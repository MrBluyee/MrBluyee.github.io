<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Little Kernel 02 | Mr Bluyee's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '3dbaf3043b34b1c894c4cd063629b6a9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Little Kernel 02</h1><a id="logo" href="/.">Mr Bluyee's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Little Kernel 02</h1><div class="post-meta">2018-11-13<span> | </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">学习笔记——嵌入式开发</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#LK-kernel-thread"><span class="toc-number">1.</span> <span class="toc-text">LK kernel thread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-init"><span class="toc-number">1.1.</span> <span class="toc-text">thread_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-create"><span class="toc-number">1.2.</span> <span class="toc-text">thread_create</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#arch-thread-initialize-t"><span class="toc-number">1.2.1.</span> <span class="toc-text">arch_thread_initialize(t)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-resume"><span class="toc-number">1.3.</span> <span class="toc-text">thread_resume</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#insert-in-run-queue-head"><span class="toc-number">1.3.1.</span> <span class="toc-text">insert_in_run_queue_head</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-yield"><span class="toc-number">1.4.</span> <span class="toc-text">thread_yield</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#thread-resched"><span class="toc-number">1.4.1.</span> <span class="toc-text">thread_resched</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h3 id="LK-kernel-thread"><a href="#LK-kernel-thread" class="headerlink" title="LK kernel thread"></a>LK kernel thread</h3><p>Warning: many of the functions in here are for internal use of the kernel.</p>
<span id="more"></span>

<p>There are 32 priority levels. DEFAULT_PRIORITY is appropriate for typical threads. LOW_PRIORITY and HIGH_PRIORITY are relative to default priority. Threads that are set to real time will not be preempted by other threads of the same or lower priority when they are running. Use with caution.</p>
<p>Threads do not begin running until thread_resume() is called on them. Typically calls to thread_create() are followed immediately by thread_resume(). Threads that exit will wait, consuming resources like stack space until thread_join() is called to obtain their exit status, unless thread_detach() is called on them prior to exit (in which case they will silently exit and clean up). Threads may give up their quantum voluntarily by calling thread_yield().</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a_thread_start_routine(void *arg);</span><br></pre></td></tr></table></figure>

<p>Functions to create, start, and obtain exit status from a thread:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread_t *thread_create(const char *name, thread_start_routine entry, void *arg, int priority, size_t stack_size);</span><br><span class="line">status_t thread_resume(thread_t *);</span><br><span class="line">status_t thread_detach(thread_t *t);</span><br><span class="line">status_t thread_detach_and_resume(thread_t *t);</span><br><span class="line">status_t thread_join(thread_t *t, int *retcode, lk_time_t timeout);</span><br></pre></td></tr></table></figure>

<p>Functions to temporarily or permanently stop executing a thread:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void thread_yield(void);</span><br><span class="line">void thread_sleep(lk_time_t delay);</span><br><span class="line">void thread_exit(int retcode);</span><br></pre></td></tr></table></figure>

<p>Functions for a thread to modify its state:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void thread_set_name(const char *name);</span><br><span class="line">void thread_set_priority(int priority);</span><br><span class="line">status_t thread_set_real_time(thread_t *t);</span><br></pre></td></tr></table></figure>

<h4 id="thread-init"><a href="#thread-init" class="headerlink" title="thread_init"></a>thread_init</h4><p>thread_init 函数位于 kernel&#x2F;thread.c 文件中，关于线程的初始化在 thread_init_early 中已经完成。前一篇文章中已对thread_init_early做了解析。</p>
<h4 id="thread-create"><a href="#thread-create" class="headerlink" title="thread_create"></a>thread_create</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_t *thread_create(const char *name, thread_start_routine entry, void *arg, int priority, size_t stack_size)</span><br><span class="line">&#123;</span><br><span class="line">    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_create_etc代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  Create a new thread</span><br><span class="line"> *</span><br><span class="line"> * This function creates a new thread.  The thread is initially suspended, so you</span><br><span class="line"> * need to call thread_resume() to execute it.</span><br><span class="line"> *</span><br><span class="line"> * @param  name        Name of thread</span><br><span class="line"> * @param  entry       Entry point of thread</span><br><span class="line"> * @param  arg         Arbitrary argument passed to entry()</span><br><span class="line"> * @param  priority    Execution priority for the thread.</span><br><span class="line"> * @param  stack_size  Stack size for the thread.</span><br><span class="line"> *</span><br><span class="line"> * Thread priority is an integer from 0 (lowest) to 31 (highest).  Some standard</span><br><span class="line"> * prioritys are defined in &lt;kernel/thread.h&gt;:</span><br><span class="line"> *</span><br><span class="line"> *  HIGHEST_PRIORITY</span><br><span class="line"> *  DPC_PRIORITY</span><br><span class="line"> *  HIGH_PRIORITY</span><br><span class="line"> *  DEFAULT_PRIORITY</span><br><span class="line"> *  LOW_PRIORITY</span><br><span class="line"> *  IDLE_PRIORITY</span><br><span class="line"> *  LOWEST_PRIORITY</span><br><span class="line"> *</span><br><span class="line"> * Stack size is typically set to DEFAULT_STACK_SIZE</span><br><span class="line"> *</span><br><span class="line"> * @return  Pointer to thread object, or NULL on failure.</span><br><span class="line"> */</span><br><span class="line">thread_t *thread_create_etc(thread_t *t, const char *name, thread_start_routine entry, void *arg, int priority, void *stack, size_t stack_size)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int flags = 0;</span><br><span class="line"></span><br><span class="line">    if (!t) &#123;</span><br><span class="line">        t = malloc(sizeof(thread_t));</span><br><span class="line">        if (!t)</span><br><span class="line">            return NULL;</span><br><span class="line">        flags |= THREAD_FLAG_FREE_STRUCT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_thread_struct(t, name);</span><br><span class="line"></span><br><span class="line">    t-&gt;entry = entry;</span><br><span class="line">    t-&gt;arg = arg;</span><br><span class="line">    t-&gt;priority = priority;</span><br><span class="line">    t-&gt;state = THREAD_SUSPENDED;</span><br><span class="line">    t-&gt;blocking_wait_queue = NULL;</span><br><span class="line">    t-&gt;wait_queue_block_ret = NO_ERROR;</span><br><span class="line">    thread_set_curr_cpu(t, -1);</span><br><span class="line"></span><br><span class="line">    t-&gt;retcode = 0;</span><br><span class="line">    wait_queue_init(&amp;t-&gt;retcode_wait_queue);</span><br><span class="line"></span><br><span class="line">#if WITH_KERNEL_VM</span><br><span class="line">    t-&gt;aspace = NULL;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* create the stack */</span><br><span class="line">    if (!stack) &#123;</span><br><span class="line">#if THREAD_STACK_BOUNDS_CHECK</span><br><span class="line">        stack_size += THREAD_STACK_PADDING_SIZE;</span><br><span class="line">        flags |= THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK;</span><br><span class="line">#endif</span><br><span class="line">        t-&gt;stack = malloc(stack_size);</span><br><span class="line">        if (!t-&gt;stack) &#123;</span><br><span class="line">            if (flags &amp; THREAD_FLAG_FREE_STRUCT)</span><br><span class="line">                free(t);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        flags |= THREAD_FLAG_FREE_STACK;</span><br><span class="line">#if THREAD_STACK_BOUNDS_CHECK</span><br><span class="line">        memset(t-&gt;stack, STACK_DEBUG_BYTE, THREAD_STACK_PADDING_SIZE);</span><br><span class="line">#endif</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t-&gt;stack = stack;</span><br><span class="line">    &#125;</span><br><span class="line">#if THREAD_STACK_HIGHWATER</span><br><span class="line">    if (flags &amp; THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK) &#123;</span><br><span class="line">        memset(t-&gt;stack + THREAD_STACK_PADDING_SIZE, STACK_DEBUG_BYTE,</span><br><span class="line">               stack_size - THREAD_STACK_PADDING_SIZE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        memset(t-&gt;stack, STACK_DEBUG_BYTE, stack_size);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    t-&gt;stack_size = stack_size;</span><br><span class="line"></span><br><span class="line">    /* save whether or not we need to free the thread struct and/or stack */</span><br><span class="line">    t-&gt;flags = flags;</span><br><span class="line"></span><br><span class="line">    /* inheirit thread local storage from the parent */</span><br><span class="line">    thread_t *current_thread = get_current_thread();</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i &lt; MAX_TLS_ENTRY; i++)</span><br><span class="line">        t-&gt;tls[i] = current_thread-&gt;tls[i];</span><br><span class="line"></span><br><span class="line">    /* set up the initial stack frame */</span><br><span class="line">    arch_thread_initialize(t);</span><br><span class="line"></span><br><span class="line">    /* add it to the global thread list */</span><br><span class="line">    THREAD_LOCK(state);</span><br><span class="line">    list_add_head(&amp;thread_list, &amp;t-&gt;thread_list_node);</span><br><span class="line">    THREAD_UNLOCK(state);</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_create 的逻辑比较简单，总体上来说只有 3 个步骤：<br>申请并填充 thread_t 结构体<br>初始化线程栈空间<br>添加线程到 thread_list 头部</p>
<h5 id="arch-thread-initialize-t"><a href="#arch-thread-initialize-t" class="headerlink" title="arch_thread_initialize(t)"></a>arch_thread_initialize(t)</h5><p>lk 的线程栈初始化。<br>线程栈的初始化由 arch_thread_initialize 完成，这个函数位于 arch&#x2F;arm&#x2F;thread.c 文件中，其代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct context_switch_frame &#123;</span><br><span class="line">    vaddr_t r4;</span><br><span class="line">    vaddr_t r5;</span><br><span class="line">    vaddr_t r6;</span><br><span class="line">    vaddr_t r7;</span><br><span class="line">    vaddr_t r8;</span><br><span class="line">    vaddr_t r9;</span><br><span class="line">    vaddr_t r10;</span><br><span class="line">    vaddr_t r11;</span><br><span class="line">    vaddr_t lr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void arch_thread_initialize(thread_t *t)</span><br><span class="line">&#123;</span><br><span class="line">    // create a default stack frame on the stack</span><br><span class="line">    vaddr_t stack_top = (vaddr_t)t-&gt;stack + t-&gt;stack_size;</span><br><span class="line"></span><br><span class="line">    // make sure the top of the stack is 8 byte aligned for EABI compliance</span><br><span class="line">    stack_top = ROUNDDOWN(stack_top, 8);</span><br><span class="line"></span><br><span class="line">    struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);</span><br><span class="line">    frame--;</span><br><span class="line"></span><br><span class="line">    // fill it in</span><br><span class="line">    memset(frame, 0, sizeof(*frame));</span><br><span class="line">    frame-&gt;lr = (vaddr_t)&amp;initial_thread_func;</span><br><span class="line"></span><br><span class="line">    // set the stack pointer</span><br><span class="line">    t-&gt;arch.sp = (vaddr_t)frame;</span><br><span class="line"></span><br><span class="line">#if ARM_WITH_VFP</span><br><span class="line">    arm_fpu_thread_initialize(t);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化线程栈空间其实就是在栈顶使用一块空间用于后续保存寄存器信息以方便线程切换。需要保存的寄存器信息定义在 context_switch_frame 结构体中，其中 lr 用于保存线程函数入口。 当这块内存空间设置好以后，线程栈的初始化工作基本就完成了，剩下的就是通过 thread_resume 来启动线程。</p>
<h4 id="thread-resume"><a href="#thread-resume" class="headerlink" title="thread_resume"></a>thread_resume</h4><p>thread_resume 函数位于 kernel&#x2F;thread.c 文件中，其代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  Make a suspended thread executable.</span><br><span class="line"> *</span><br><span class="line"> * This function is typically called to start a thread which has just been</span><br><span class="line"> * created with thread_create()</span><br><span class="line"> *</span><br><span class="line"> * @param t  Thread to resume</span><br><span class="line"> *</span><br><span class="line"> * @return NO_ERROR on success, ERR_NOT_SUSPENDED if thread was not suspended.</span><br><span class="line"> */</span><br><span class="line">status_t thread_resume(thread_t *t)</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG_ASSERT(t-&gt;magic == THREAD_MAGIC);</span><br><span class="line">    DEBUG_ASSERT(t-&gt;state != THREAD_DEATH);</span><br><span class="line"></span><br><span class="line">    bool resched = false;</span><br><span class="line">    bool ints_disabled = arch_ints_disabled();</span><br><span class="line">    THREAD_LOCK(state);</span><br><span class="line">    if (t-&gt;state == THREAD_SUSPENDED) &#123;</span><br><span class="line">        t-&gt;state = THREAD_READY;</span><br><span class="line">        insert_in_run_queue_head(t);</span><br><span class="line">        if (!ints_disabled) /* HACK, don&#x27;t resced into bootstrap thread before idle thread is set up */</span><br><span class="line">            resched = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp_reschedule(MP_CPU_ALL_BUT_LOCAL, 0);</span><br><span class="line"></span><br><span class="line">    THREAD_UNLOCK(state);</span><br><span class="line"></span><br><span class="line">    if (resched)</span><br><span class="line">        thread_yield();</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑简单明了，只有以下两个步骤：<br>修改 thread 的状态为 THREAD_READY, 然后添加到 run_queue 中。</p>
<h5 id="insert-in-run-queue-head"><a href="#insert-in-run-queue-head" class="headerlink" title="insert_in_run_queue_head"></a>insert_in_run_queue_head</h5><p>insert_in_run_queue_head 函数位于同一文件中，其代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void insert_in_run_queue_tail(thread_t *t)</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG_ASSERT(t-&gt;magic == THREAD_MAGIC);</span><br><span class="line">    DEBUG_ASSERT(t-&gt;state == THREAD_READY);</span><br><span class="line">    DEBUG_ASSERT(!list_in_list(&amp;t-&gt;queue_node));</span><br><span class="line">    DEBUG_ASSERT(arch_ints_disabled());</span><br><span class="line">    DEBUG_ASSERT(spin_lock_held(&amp;thread_lock));</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;run_queue[t-&gt;priority], &amp;t-&gt;queue_node);</span><br><span class="line">    run_queue_bitmap |= (1&lt;&lt;t-&gt;priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run_queue 在 thread_init_early 中已经有过了解，就是一个大小为 32 的全局链表数组，这个数组每一项对应一个线程优先级，下标越大的数组项优先级越大。比较有趣的是使用了一个uint32类型的全局变量 run_queue_bitmap 来作为优先级的索引。这个变量的每一位对应数组的每一项, 通过检查对应位的值是 0 或 1 就可以知道优先级的使用情况。</p>
<h4 id="thread-yield"><a href="#thread-yield" class="headerlink" title="thread_yield"></a>thread_yield</h4><p>调用 thread_yield 来获取 cpu 执行。thread_yield 函数位于同一文件中，主要是修改current_thread 的状态的 THREAD_READY并插入对应优先级项链表的尾部，然后调用 thread_resched 函数来切换线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Yield the cpu to another thread</span><br><span class="line"> *</span><br><span class="line"> * This function places the current thread at the end of the run queue</span><br><span class="line"> * and yields the cpu to another waiting thread (if any.)</span><br><span class="line"> *</span><br><span class="line"> * This function will return at some later time. Possibly immediately if</span><br><span class="line"> * no other threads are waiting to execute.</span><br><span class="line"> */</span><br><span class="line">void thread_yield(void)</span><br><span class="line">&#123;</span><br><span class="line">    thread_t *current_thread = get_current_thread();</span><br><span class="line"></span><br><span class="line">    DEBUG_ASSERT(current_thread-&gt;magic == THREAD_MAGIC);</span><br><span class="line">    DEBUG_ASSERT(current_thread-&gt;state == THREAD_RUNNING);</span><br><span class="line"></span><br><span class="line">    THREAD_LOCK(state);</span><br><span class="line"></span><br><span class="line">    THREAD_STATS_INC(yields);</span><br><span class="line"></span><br><span class="line">    /* we are yielding the cpu, so stick ourselves into the tail of the run queue and reschedule */</span><br><span class="line">    current_thread-&gt;state = THREAD_READY;</span><br><span class="line">    current_thread-&gt;remaining_quantum = 0;</span><br><span class="line">    if (likely(!thread_is_idle(current_thread))) &#123; /* idle thread doesn&#x27;t go in the run queue */</span><br><span class="line">        insert_in_run_queue_tail(current_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    thread_resched();</span><br><span class="line"></span><br><span class="line">    THREAD_UNLOCK(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="thread-resched"><a href="#thread-resched" class="headerlink" title="thread_resched"></a>thread_resched</h5><p>切换线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  Cause another thread to be executed.</span><br><span class="line"> *</span><br><span class="line"> * Internal reschedule routine. The current thread needs to already be in whatever</span><br><span class="line"> * state and queues it needs to be in. This routine simply picks the next thread and</span><br><span class="line"> * switches to it.</span><br><span class="line"> *</span><br><span class="line"> * This is probably not the function you&#x27;re looking for. See</span><br><span class="line"> * thread_yield() instead.</span><br><span class="line"> */</span><br><span class="line">void thread_resched(void)</span><br><span class="line">&#123;</span><br><span class="line">    thread_t *oldthread;</span><br><span class="line">    thread_t *newthread;</span><br><span class="line"></span><br><span class="line">    thread_t *current_thread = get_current_thread();</span><br><span class="line">    uint cpu = arch_curr_cpu_num();</span><br><span class="line"></span><br><span class="line">    DEBUG_ASSERT(arch_ints_disabled());</span><br><span class="line">    DEBUG_ASSERT(spin_lock_held(&amp;thread_lock));</span><br><span class="line">    DEBUG_ASSERT(current_thread-&gt;state != THREAD_RUNNING);</span><br><span class="line"></span><br><span class="line">    THREAD_STATS_INC(reschedules);</span><br><span class="line"></span><br><span class="line">    newthread = get_top_thread(cpu);</span><br><span class="line"></span><br><span class="line">    DEBUG_ASSERT(newthread);</span><br><span class="line"></span><br><span class="line">    newthread-&gt;state = THREAD_RUNNING;</span><br><span class="line"></span><br><span class="line">    oldthread = current_thread;</span><br><span class="line"></span><br><span class="line">    if (newthread == oldthread)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    /* set up quantum for the new thread if it was consumed */</span><br><span class="line">    if (newthread-&gt;remaining_quantum &lt;= 0) &#123;</span><br><span class="line">        newthread-&gt;remaining_quantum = 5; // XXX make this smarter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* mark the cpu ownership of the threads */</span><br><span class="line">    thread_set_curr_cpu(oldthread, -1);</span><br><span class="line">    thread_set_curr_cpu(newthread, cpu);</span><br><span class="line"></span><br><span class="line">#if WITH_SMP</span><br><span class="line">    if (thread_is_idle(newthread)) &#123;</span><br><span class="line">        mp_set_cpu_idle(cpu);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mp_set_cpu_busy(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (thread_is_realtime(newthread)) &#123;</span><br><span class="line">        mp_set_cpu_realtime(cpu);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mp_set_cpu_non_realtime(cpu);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if THREAD_STATS</span><br><span class="line">    THREAD_STATS_INC(context_switches);</span><br><span class="line"></span><br><span class="line">    if (thread_is_idle(oldthread)) &#123;</span><br><span class="line">        lk_bigtime_t now = current_time_hires();</span><br><span class="line">        thread_stats[cpu].idle_time += now - thread_stats[cpu].last_idle_timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    if (thread_is_idle(newthread)) &#123;</span><br><span class="line">        thread_stats[cpu].last_idle_timestamp = current_time_hires();</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    KEVLOG_THREAD_SWITCH(oldthread, newthread);</span><br><span class="line"></span><br><span class="line">#if PLATFORM_HAS_DYNAMIC_TIMER</span><br><span class="line">    if (thread_is_real_time_or_idle(newthread)) &#123;</span><br><span class="line">        if (!thread_is_real_time_or_idle(oldthread)) &#123;</span><br><span class="line">            /* if we&#x27;re switching from a non real time to a real time, cancel</span><br><span class="line">             * the preemption timer. */</span><br><span class="line">#if DEBUG_THREAD_CONTEXT_SWITCH</span><br><span class="line">            dprintf(ALWAYS, &quot;arch_context_switch: stop preempt, cpu %d, old %p (%s), new %p (%s)\n&quot;,</span><br><span class="line">                    cpu, oldthread, oldthread-&gt;name, newthread, newthread-&gt;name);</span><br><span class="line">#endif</span><br><span class="line">            timer_cancel(&amp;preempt_timer[cpu]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (thread_is_real_time_or_idle(oldthread)) &#123;</span><br><span class="line">        /* if we&#x27;re switching from a real time (or idle thread) to a regular one,</span><br><span class="line">         * set up a periodic timer to run our preemption tick. */</span><br><span class="line">#if DEBUG_THREAD_CONTEXT_SWITCH</span><br><span class="line">        dprintf(ALWAYS, &quot;arch_context_switch: start preempt, cpu %d, old %p (%s), new %p (%s)\n&quot;,</span><br><span class="line">                cpu, oldthread, oldthread-&gt;name, newthread, newthread-&gt;name);</span><br><span class="line">#endif</span><br><span class="line">        timer_set_periodic(&amp;preempt_timer[cpu], 10, (timer_callback)thread_timer_tick, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* set some optional target debug leds */</span><br><span class="line">    target_set_debug_led(0, !thread_is_idle(newthread));</span><br><span class="line"></span><br><span class="line">    /* do the switch */</span><br><span class="line">    set_current_thread(newthread);</span><br><span class="line"></span><br><span class="line">#if DEBUG_THREAD_CONTEXT_SWITCH</span><br><span class="line">    dprintf(ALWAYS, &quot;arch_context_switch: cpu %d, old %p (%s, pri %d, flags 0x%x), new %p (%s, pri %d, flags 0x%x)\n&quot;,</span><br><span class="line">            cpu, oldthread, oldthread-&gt;name, oldthread-&gt;priority,</span><br><span class="line">            oldthread-&gt;flags, newthread, newthread-&gt;name,</span><br><span class="line">            newthread-&gt;priority, newthread-&gt;flags);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if THREAD_STACK_BOUNDS_CHECK</span><br><span class="line">    /* check that the old thread has not blown its stack just before pushing its context */</span><br><span class="line">    if (oldthread-&gt;flags &amp; THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK) &#123;</span><br><span class="line">        STATIC_ASSERT((THREAD_STACK_PADDING_SIZE % sizeof(uint32_t)) == 0);</span><br><span class="line">        uint32_t *s = (uint32_t *)oldthread-&gt;stack;</span><br><span class="line">        for (size_t i = 0; i &lt; THREAD_STACK_PADDING_SIZE / sizeof(uint32_t); i++) &#123;</span><br><span class="line">            if (unlikely(s[i] != STACK_DEBUG_WORD)) &#123;</span><br><span class="line">                /* NOTE: will probably blow the stack harder here, but hopefully enough</span><br><span class="line">                 * state exists to at least get some sort of debugging done.</span><br><span class="line">                 */</span><br><span class="line">                panic(&quot;stack overrun at %p: thread %p (%s), stack %p\n&quot;, &amp;s[i],</span><br><span class="line">                      oldthread, oldthread-&gt;name, oldthread-&gt;stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef WITH_LIB_UTHREAD</span><br><span class="line">    uthread_context_switch(oldthread, newthread);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if WITH_KERNEL_VM</span><br><span class="line">    /* see if we need to swap mmu context */</span><br><span class="line">    if (newthread-&gt;aspace != oldthread-&gt;aspace) &#123;</span><br><span class="line">        vmm_context_switch(oldthread-&gt;aspace, newthread-&gt;aspace);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* do the low level context switch */</span><br><span class="line">    arch_context_switch(oldthread, newthread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体流程如下：</p>
<p>通过get_top_thread(cpu)函数从 run_queue_bitmap 中获取优先级最高的线程。<br>设置线程状态为 THREAD_RUNNING, 如果新线程不等于老线程则调用 arch_context_switch 切换线程。arch_context_switch 函数位于 arch&#x2F;arm&#x2F;thread.c 文件中，只是作为转接 arm_context_switch 的媒介。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void arch_context_switch(thread_t *oldthread, thread_t *newthread)</span><br><span class="line">&#123;</span><br><span class="line">//  TRACEF(&quot;arch_context_switch: cpu %u old %p (%s), new %p (%s)\n&quot;, arch_curr_cpu_num(), oldthread, oldthread-&gt;name, newthread, newthread-&gt;name);</span><br><span class="line">#if ARM_WITH_VFP</span><br><span class="line">    arm_fpu_thread_swap(oldthread, newthread);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    arm_context_switch(&amp;oldthread-&gt;arch.sp, newthread-&gt;arch.sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arm_context_switch 函数位于 arch&#x2F;arm&#x2F;asm.S 文件中，是汇编代码，其代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    /* context switch frame is as follows:</span><br><span class="line">     * lr</span><br><span class="line">     * r11</span><br><span class="line">     * r10</span><br><span class="line">     * r9</span><br><span class="line">     * r8</span><br><span class="line">     * r7</span><br><span class="line">     * r6</span><br><span class="line">     * r5</span><br><span class="line">     * r4</span><br><span class="line">     */</span><br><span class="line">/* arm_context_switch(addr_t *old_sp, addr_t new_sp) */</span><br><span class="line">FUNCTION(arm_context_switch)</span><br><span class="line">    /* save non callee trashed supervisor registers */</span><br><span class="line">    /* spsr and user mode registers are saved and restored in the iframe by exceptions.S */</span><br><span class="line">    push    &#123; r4-r11, lr &#125;</span><br><span class="line"></span><br><span class="line">    /* save old sp */</span><br><span class="line">    str     sp, [r0]</span><br><span class="line"></span><br><span class="line">    /* clear any exlusive locks that the old thread holds */</span><br><span class="line">#if ARM_ARCH_LEVEL &gt;= 7</span><br><span class="line">    /* can clear it directly */</span><br><span class="line">    clrex</span><br><span class="line">#elif ARM_ARCH_LEVEL == 6</span><br><span class="line">    /* have to do a fake strex to clear it */</span><br><span class="line">    ldr     r0, =strex_spot</span><br><span class="line">    strex   r3, r2, [r0]</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* load new regs */</span><br><span class="line">    mov     sp, r1</span><br><span class="line">    pop     &#123; r4-r11, lr &#125;</span><br><span class="line">    bx      lr</span><br></pre></td></tr></table></figure>
<p>函数的功能很简单，保存 old_thread 的寄存器环境到内存，从内存加载 new_thread 的寄存器环境，跳转到线程入口,到这里新的线程就会执行起来。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>Little Kernel 02</p><p><span>文章作者：</span>Mr Bluyee</p><p><span>发布时间：</span>2018-11-13</p><p><span>最后更新：</span>2019-07-15</p><p><span>原始链接：</span><a href="/2018/11/13/Little-Kernel-02/">https://www.mrbluyee.com/2018/11/13/Little-Kernel-02/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://www.mrbluyee.com/2018/11/13/Little-Kernel-02/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" rel="tag">嵌入式开发</a></li></ul></div><div class="post-nav"><a class="pre" href="/2018/11/13/Little-Kernel-03/">Little Kernel 03</a><a class="next" href="/2018/11/03/Little-Kernel-01/">Little Kernel 01</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zOTYxNS8xNjE0Mg"><script>(function(d, s) {
  var j, e = d.getElementsByTagName(s)[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Enjoy life / Hope for future</p><a class="info-icon" href="mr.bluyee@hotmail.com" title="mr.bluyee@hotmail.com" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/MrBluyee" title="https://github.com/MrBluyee" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C-%E7%AE%97%E6%B3%95/">学习笔记——C 算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">学习笔记——C数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Python/">学习笔记——Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94android/">学习笔记——android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94data-compression/">学习笔记——data compression</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94expert-c-programming/">学习笔记——expert c programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94linux/">学习笔记——linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94opencv/">学习笔记——opencv</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/">学习笔记——代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%8E%E5%8A%9F%E8%80%97%E6%8A%80%E6%9C%AF/">学习笔记——低功耗技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">学习笔记——嵌入式开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">学习笔记——机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%89%A9%E8%81%94%E7%BD%91/">学习笔记——物联网</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">学习笔记——网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">学习笔记——计算机系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">计算机系统</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 15px;">网络协议</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" style="font-size: 15px;">嵌入式开发</a> <a href="/tags/data-compression/" style="font-size: 15px;">data compression</a> <a href="/tags/opencv/" style="font-size: 15px;">opencv</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/03/25/zlib-and-gzip-format/">zlib and gzip format</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/23/deflate%20format/">deflate format</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/23/IPsec/">IPsec</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/%E6%95%B0%E7%9A%84%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/">数的素性测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/20/%E6%89%A9%E5%B1%95%E7%9A%84%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/">扩展的欧几里得算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/">欧几里得算法-求最大公因数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F/">常用路由方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/19/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91WSN%E6%A6%82%E8%BF%B0/">无线传感网WSN概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/">无线模块休眠与激活机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/16/SOC%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/">SOC的低功耗设计</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Mr Bluyee's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>