<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>gcc程序编译的静态链接和动态链接 | Mr Bluyee's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '3dbaf3043b34b1c894c4cd063629b6a9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">gcc程序编译的静态链接和动态链接</h1><a id="logo" href="/.">Mr Bluyee's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">gcc程序编译的静态链接和动态链接</h1><div class="post-meta">2018-07-31<span> | </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94expert-c-programming/">学习笔记——expert c programming</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 21</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">静态链接与动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">动态链接的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E5%B0%86helloworld%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%BC%80%E6%9D%A5%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">首先将helloworld代码拆分开来：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86helloworld-c%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">将helloworld.c生成动态链接库：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91main%E6%97%B6%E5%8A%A0%E5%85%A5libhelloworld-so%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">编译main时加入libhelloworld.so：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cmain%EF%BC%8C%E5%87%BA%E9%94%99%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">运行main，出错：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86helloworld-c%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">将helloworld.c生成静态链接库：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91main%E6%97%B6%E5%8A%A0%E5%85%A5libhelloworld-a%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">编译main时加入libhelloworld.a：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4libhelloworld-a%E5%90%8E%E8%BF%90%E8%A1%8Cmain-static%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">删除libhelloworld.a后运行main_static：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81-%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">多个文件生成动态&#x2F;静态库的用法：</span></a></li></ol></div></div><div class="post-content"><p>在链接阶段中，所有对应于源文件的.o文件、”-l”选项指定的库文件、无法识别的文件名（包括指定的.o目标文件和.a库文件）按命令行中的顺序传递给链接器。</p>
<span id="more"></span>

<p>下面看一下，链接的过程是怎样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gcc -v -o helloworld helloworld.o</span><br><span class="line"></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-6.3.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --with-gmp=/mingw --with-mpfr --with-mpc=/mingw --with-isl=/mingw --prefix=/mingw --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-pkgversion=&#x27;MinGW.org GCC-6.3.0-1&#x27; --enable-static --enable-shared --enable-threads --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --enable-libgomp --disable-libvtv --enable-nls</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 6.3.0 (MinGW.org GCC-6.3.0-1) </span><br><span class="line">COMPILER_PATH=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../libexec/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/</span><br><span class="line">LIBRARY_PATH=d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../lib/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br><span class="line"> d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/collect2.exe -plugin d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/liblto_plugin-0.dll -plugin-opt=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe -plugin-opt=-fresolution=C:\Users\MrBlu\AppData\Local\Temp\cceFgn0y.res -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -plugin-opt=-pass-through=-ladvapi32 -plugin-opt=-pass-through=-lshell32 -plugin-opt=-pass-through=-luser32 -plugin-opt=-pass-through=-lkernel32 -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -Bdynamic -o helloworld.exe d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../crt2.o d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/crtbegin.o -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0 -Ld:/software/mingw/bin/../lib/gcc -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../.. helloworld.o -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt -ladvapi32 -lshell32 -luser32 -lkernel32 -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/crtend.o</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br></pre></td></tr></table></figure>
<p>crt2.o 、crtbegin.o、crtend.o是gcc加入的系统标准启动文件，对于一般应用程序，这些启动是必须的。<br>-Ldir：在库文件的搜索路径列表中添加dir目录。<br>-lname：添加链接库文件。</p>
<h4 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h4><p>库有两种：静态库（.a、.lib）和动态库（.so、.dll）。<br>window上对应的是.lib、.dll。<br>linux上对应的是.a、.so</p>
<p>如果函数库的一份拷贝是可执行文件的物理组成部分，称之为静态链接。静态链接当链接程序时，需要使用的每个库函数的一份拷贝被加入到可执行文件中。静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大（即使是在静态链接中，整个库文件也并没有全部装入到可执行文件中，所装入的只是需要的函数）。</p>
<p>如果可执行文件只是包含了文件名，让载入器在运行时能够寻找程序所需要的函数库，称之为动态链接。动态链接允许系统提供一个庞大的函数库集合，可以提供许多有用的服务，程序在运行时寻找它们。动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。</p>
<p>收集模块准备执行的三个阶段的规范名称是链接-编辑（link-editing）、载入（loading）和运行时链接（runtime linking）。静态链接的模块被链接编辑时载入，以便运行。动态链接的模块被链接编辑后载入，并在运行时进行链接以便运行。</p>
<p>程序执行时，在main函数被调用之前，运行时载入器把共享的数据对象载入到进程的地址空间。外部函数被真正调用之前，运行时载入器并不解析它们。所以动态链接即使链接了函数库，如果没有实际调用，也不会带来额外开销。</p>
<p>gcc编译器默认使用动态链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o helloworld_shared helloworld.o</span><br></pre></td></tr></table></figure>
<p>gcc编译器使用静态链接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -o helloworld_static helloworld.o</span><br></pre></td></tr></table></figure>
<p>在windows平台上使用mingw编译发现这两种方式生成的exe文件的大小都一样，为40kb，怀疑mingw的编译的库是静态库。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-d754fc6ed9f6553c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="捕获1.JPG"><br>下面看一下linux平台上使用gcc两种编译方式的文件大小区别：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-a8db81edf848c424.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot1png"><br>可以看到helloworld_shared的大小为8344，而helloworld_static的大小达到844792。</p>
<p>-nostartfiles：<br>不链接系统标准启动文件，而标准库文件仍然正常使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gcc -v -nostartfiles -o helloworld helloworld.o</span><br><span class="line"></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-6.3.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --with-gmp=/mingw --with-mpfr --with-mpc=/mingw --with-isl=/mingw --prefix=/mingw --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-pkgversion=&#x27;MinGW.org GCC-6.3.0-1&#x27; --enable-static --enable-shared --enable-threads --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --enable-libgomp --disable-libvtv --enable-nls</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 6.3.0 (MinGW.org GCC-6.3.0-1) </span><br><span class="line">COMPILER_PATH=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../libexec/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/</span><br><span class="line">LIBRARY_PATH=d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../lib/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-nostartfiles&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br><span class="line"> d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/collect2.exe -plugin d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/liblto_plugin-0.dll -plugin-opt=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe -plugin-opt=-fresolution=C:\Users\MrBlu\AppData\Local\Temp\ccZxAfxD.res -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -plugin-opt=-pass-through=-ladvapi32 -plugin-opt=-pass-through=-lshell32 -plugin-opt=-pass-through=-luser32 -plugin-opt=-pass-through=-lkernel32 -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -Bdynamic -o helloworld.exe -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0 -Ld:/software/mingw/bin/../lib/gcc -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../.. helloworld.o -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt -ladvapi32 -lshell32 -luser32 -lkernel32 -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt</span><br><span class="line">ertr000001.o:(.rdata+0x0): undefined reference to `_pei386_runtime_relocator&#x27;</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>-nostdlib<br>不链接系统标准启动文件和标准库文件，会提示因为没有链接系统标准启动文件和标准库文件，而链接失败。<br>该选项常用于裸机&#x2F;bootloader、linux内核等程序，因为它们不需要启动文件、标准库文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gcc -v -nostdlib -o helloworld helloworld.o</span><br><span class="line"></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-6.3.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --with-gmp=/mingw --with-mpfr --with-mpc=/mingw --with-isl=/mingw --prefix=/mingw --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-pkgversion=&#x27;MinGW.org GCC-6.3.0-1&#x27; --enable-static --enable-shared --enable-threads --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --enable-libgomp --disable-libvtv --enable-nls</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 6.3.0 (MinGW.org GCC-6.3.0-1) </span><br><span class="line">COMPILER_PATH=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../libexec/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/</span><br><span class="line">LIBRARY_PATH=d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../lib/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-nostdlib&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br><span class="line"> d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/collect2.exe -plugin d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/liblto_plugin-0.dll -plugin-opt=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe -plugin-opt=-fresolution=C:\Users\MrBlu\AppData\Local\Temp\ccRAu2K4.res -Bdynamic -o helloworld.exe -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0 -Ld:/software/mingw/bin/../lib/gcc -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../.. helloworld.o</span><br><span class="line">helloworld.o:helloworld.c:(.text+0xa): undefined reference to `__main&#x27;</span><br><span class="line">helloworld.o:helloworld.c:(.text+0x25): undefined reference to `puts&#x27;</span><br><span class="line">helloworld.o:helloworld.c:(.text+0x3b): undefined reference to `printf&#x27;</span><br><span class="line">helloworld.o:helloworld.c:(.text+0x47): undefined reference to `puts&#x27;</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<h4 id="动态链接的优点"><a href="#动态链接的优点" class="headerlink" title="动态链接的优点"></a>动态链接的优点</h4><p>动态链接的优点是可执行文件的体积可以非常小。虽然运行速度稍慢一些，但动态链接能够更加有效的利用磁盘空间，而且链接-编辑阶段的时间也会缩短（因为链接器的有些工作被推迟到载入时）。</p>
<p>动态链接的主要目的是把程序与它们使用的特定的函数库版本中分离开来。取而代之的是，我们约定由系统向程序提供一个接口，该接口保持稳定，不随时间和操作系统的后续版本发生变化。</p>
<p>程序可以调用接口所承诺的服务，而不必担心这些功能是怎样提供的或者它们的底层实现是否改变。由于它是介于应用程序和函数库二进制可执行文件所提供的服务之间的接口，所以称它为应用程序二进制接口（Application Binary Interface，ABI）。</p>
<p>尽管单个可执行文件的启动速度稍受影响，但动态链接可以从两个方面提高性能：<br>1.动态链接可执行文件比功能相同的静态链接可执行文件的体积小。它能够节省磁盘空间和虚拟内存，因为函数库只有在需要时才被映射到进程中。<br>2.所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库的一个单独拷贝。操作系统内核保证映射到内存中的函数库可以被所有使用它们的进程共享。这就提供了更好的I&#x2F;O和交换空间利用率，节省了物理内存，从而提高了系统的整体性能。如果可执行文件是静态链接的，每个文件都将拥有一份函数库的拷贝，显然极为浪费。</p>
<p>动态链接使得函数库的版本升级更为容易。新的函数库可以随时发布，只要安装到系统中，旧的程序就能够自动获得新版本函数库的优点而无需重新链接。动态链接允许用户在运行时选择需要执行的函数库。这就使为了提高速度或提高内存使用效率或包含额外的调试信息而创建新版本的函数库是完全可能的，用户可以根据自己的喜好，在程序执行时用一个库文件取代另一个库文件。</p>
<p>动态链接是一种“just-in-time（JIT）”链接，这意味着程序在运行时必须能够找到它们所需要的函数库。链接器通过把库文件名或路径名植入可执行文件中来做到这一点。这意味着，函数库的路径不能随意移动。如果把程序链接到&#x2F;usr&#x2F;lib&#x2F;libthread.so库，那么就不能把该函数库移动到其他目录，除非在链接器中进行特别说明。否则，当程序调用该函数库的函数时，就会在运行时导致失败。当在一台机器上编译完程序后，把它拿到另一台不同的机器上运行时，也可能出现这种情况。执行程序的机器必须具有该程序需要链接的函数库，而且这些函数库必须位于在链接器中所说明的目录。对于标准系统函数库而言，这并不成问题。</p>
<p>任何人都可以创建静态或动态的函数库。只需简单的编译一些不包含main函数的代码，并把编译所生的.o用正确的工具进行处理。<br>使用<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/00ee0ec582a1">gcc程序编译的过程</a>中的示例代码在Ubuntu下使用gcc创建静态和动态库：</p>
<h4 id="首先将helloworld代码拆分开来："><a href="#首先将helloworld代码拆分开来：" class="headerlink" title="首先将helloworld代码拆分开来："></a>首先将helloworld代码拆分开来：</h4><p>分别为“helloworld.c”、“helloworld.h”、“main.c”,<br>helloworld.c内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0 </span><br><span class="line"></span><br><span class="line">#define DEBUG_ENABLE</span><br><span class="line"></span><br><span class="line">void helloworld(void)&#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        if(i == TRUE)&#123;</span><br><span class="line">                printf(&quot;hello\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">#ifdef DEBUG_ENABLE</span><br><span class="line">                printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">#endif</span><br><span class="line">                printf(&quot;hello world\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>helloworld.h内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HELLO_WORLD_H </span><br><span class="line">#define HELLO_WORLD_H </span><br><span class="line">    void helloworld(void);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>main.c内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include  &quot;helloworld.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"> &#123;</span><br><span class="line">     helloworld();</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="将helloworld-c生成动态链接库："><a href="#将helloworld-c生成动态链接库：" class="headerlink" title="将helloworld.c生成动态链接库："></a>将helloworld.c生成动态链接库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared helloworld.c -o libhelloworld.so</span><br></pre></td></tr></table></figure>
<p> -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。 与位置无关的代码表示用这种方法产生的代码保证对于任何全局数据的访问都是通过额外的间接方法完成的。这使它很容易对数据进行重新定位，只要简单的修改全局偏移量表的其中一个值就可以了。类似的，每个函数调用的产生就像是通过过程链接表的某个间接地址所产生的一样。这样，文本可以很容易的重新定位到任何地方，只要修改一下偏移量表就可以了。所以当代码在运行时被映射进来时，运行时链接器可以直接把它们放在任何空闲的地方，而代码本身并不需要修改。</p>
<p>在缺省情况下，编译器并不产生与位置无关的代码，因为额外的指针解除引用操作将使程序在运行时稍慢。然而，如果不使用与位置无关的代码，所产生的代码就会被对应到固定的地址，这对于可执行文件来说确实很好，但对于共享库，速度却要慢一点，因为现在每个全局引用就不得不在运行时通过修改页面安排到固定的位置，这使得页面无法共享。</p>
<p>运行时链接器总能够安排对页面的引用。但是，使用位置无关代码，任务被极大的简化了。当然需要权衡一下，位置无关代码与由运行时链接器安排代码相比，速度是快了还是慢了。根据经验，对于函数库应该始终使用与位置无关代码。对于共享库，与位置无关的代码显得格外有用，因为每个使用共享库的进程一般都会把它映射到不同的虚拟地址（尽管共享库同一份物理拷贝）。</p>
<p>一个相关的术语是“纯代码（pure code）”。纯可执行文件是只包含代码（无静态或初始化过的数据）的文件。它之所以称为“纯”是因为它不必进行修改就能被其他特定的进程执行。它从堆栈或者其他（非纯）段引用数据。纯代码可以被共享。如果生成与位置无关代码（意味着共享），你通常也希望它是纯代码。</p>
<h4 id="编译main时加入libhelloworld-so："><a href="#编译main时加入libhelloworld-so：" class="headerlink" title="编译main时加入libhelloworld.so："></a>编译main时加入libhelloworld.so：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.h main.c -L. -lhelloworld -o main</span><br></pre></td></tr></table></figure>
<p>-L. : 标记告诉gcc函数库可能位于当前目录。<br>-l ：后面加上动态链接库，动态链接库的名字前的lib不用加上去。传给C编译器的命令行参数里并没有提到函数库的完整路径名。它甚至没有提到在函数库目录中该文件的完整名字。实际上，编译器被告知根据选项-lname链接到相应的函数库，函数库的名字是libname.so——换句话说，“lib”部分和文件扩展名被省略掉了，但在前面加了一个“l”。</p>
<h4 id="运行main，出错："><a href="#运行main，出错：" class="headerlink" title="运行main，出错："></a>运行main，出错：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main: error while loading shared libraries: libhelloworld.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>程序在运行时，会查找需要的动态库文件，若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。有多种方法可以解决：</p>
<p>a.将文件 libhelloworld.so复制到目录&#x2F;usr&#x2F;lib中，再执行则没有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ sudo mv libhelloworld.so /usr/lib</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main</span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>b.既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们可以将这个环境变量设置成当前目录： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ export LD_LIBRARY_PATH=$(pwd)</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main</span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>c.ldconfig命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ sudo ldconfig ~/mypro/C</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main</span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>当用户在某个目录下面创建或拷贝了一个动态链接库,若想使其被系统共享,可以执行一下”ldconfig 目录名”这个命令。此命令的功能在于让ldconfig将指定目录下的动态链接库被系统共享起来,意即:在缓存文件&#x2F;etc&#x2F;ld.so.cache中追加进指定目录下的共享库。上述指令让系统共享了~&#x2F;mypro&#x2F;C目录下的动态链接库。</p>
<p>可以查看程序执行时调用动态库的过程： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ldd main</span><br><span class="line">    linux-vdso.so.1 (0x00007ffd56fa4000)</span><br><span class="line">    libhelloworld.so =&gt; /home/mrbluyee/mypro/C/libhelloworld.so (0x00007fcec730f000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcec6f1e000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007fcec7713000)</span><br></pre></td></tr></table></figure>
<h4 id="将helloworld-c生成静态链接库："><a href="#将helloworld-c生成静态链接库：" class="headerlink" title="将helloworld.c生成静态链接库："></a>将helloworld.c生成静态链接库：</h4><p>a.先将helloworld.c编译生成.o文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o helloworld.o helloworld.c</span><br></pre></td></tr></table></figure>
<p>b.通过ar工具将目标文件打包成.a静态库文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rc libhelloworld.a helloworld.o</span><br></pre></td></tr></table></figure>
<p>注意：静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o&#x2F;.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。故ar工具里打包的一定是.o的文件，否则当运行连接了该静态库的可执行程序会报错。</p>
<h4 id="编译main时加入libhelloworld-a："><a href="#编译main时加入libhelloworld-a：" class="headerlink" title="编译main时加入libhelloworld.a："></a>编译main时加入libhelloworld.a：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.h main.c -static -L. -lhelloworld -o main_static </span><br></pre></td></tr></table></figure>
<p>可以看到，使用动态链接库生成的mian与静态链接库生成的main_static的大小区别：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-5700c0fbe7393588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot2.png"><br>动态链接库生成的mian大小为8288，而静态链接库生成的main_static的大小为844856。</p>
<h4 id="删除libhelloworld-a后运行main-static："><a href="#删除libhelloworld-a后运行main-static：" class="headerlink" title="删除libhelloworld.a后运行main_static："></a>删除libhelloworld.a后运行main_static：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ rm libhelloworld.a</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main_static </span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>程序照常运行，静态库中的helloworld函数已经链接到main_static文件中了。</p>
<h4 id="多个文件生成动态-静态库的用法："><a href="#多个文件生成动态-静态库的用法：" class="headerlink" title="多个文件生成动态&#x2F;静态库的用法："></a>多个文件生成动态&#x2F;静态库的用法：</h4><p>动态库:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.gcc -fPIC -shared xxx1.c xxx2.c xxx3.c -o libxxx.so </span><br><span class="line">2.gcc -fPIC -shared xxx1.o xxx2.o xxx3.o -o libxxx.so </span><br></pre></td></tr></table></figure>
<p>静态库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rc libxxx.a xxx1.o xxx2.o xxx3.o</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>gcc程序编译的静态链接和动态链接</p><p><span>文章作者：</span>Mr Bluyee</p><p><span>发布时间：</span>2018-07-31</p><p><span>最后更新：</span>2019-07-15</p><p><span>原始链接：</span><a href="/2018/07/31/gcc程序编译的静态链接和动态链接/">https://www.mrbluyee.com/2018/07/31/gcc%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://www.mrbluyee.com/2018/07/31/gcc%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul></div><div class="post-nav"><a class="pre" href="/2018/07/31/Linux%E4%B8%8B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">Linux下的静态库和动态库</a><a class="next" href="/2018/07/31/gcc%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B/">gcc程序编译的过程</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zOTYxNS8xNjE0Mg"><script>(function(d, s) {
  var j, e = d.getElementsByTagName(s)[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Enjoy life / Hope for future</p><a class="info-icon" href="mr.bluyee@hotmail.com" title="mr.bluyee@hotmail.com" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/MrBluyee" title="https://github.com/MrBluyee" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C-%E7%AE%97%E6%B3%95/">学习笔记——C 算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">学习笔记——C数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Python/">学习笔记——Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94android/">学习笔记——android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94data-compression/">学习笔记——data compression</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94expert-c-programming/">学习笔记——expert c programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94linux/">学习笔记——linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94opencv/">学习笔记——opencv</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/">学习笔记——代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%8E%E5%8A%9F%E8%80%97%E6%8A%80%E6%9C%AF/">学习笔记——低功耗技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">学习笔记——嵌入式开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">学习笔记——机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%89%A9%E8%81%94%E7%BD%91/">学习笔记——物联网</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">学习笔记——网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">学习笔记——计算机系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">计算机系统</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 15px;">网络协议</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" style="font-size: 15px;">嵌入式开发</a> <a href="/tags/data-compression/" style="font-size: 15px;">data compression</a> <a href="/tags/opencv/" style="font-size: 15px;">opencv</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/03/23/deflate%20format/">deflate format</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/23/IPsec/">IPsec</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/%E6%95%B0%E7%9A%84%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/">数的素性测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/20/%E6%89%A9%E5%B1%95%E7%9A%84%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/">扩展的欧几里得算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/">欧几里得算法-求最大公因数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/04/%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F/">常用路由方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/19/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91WSN%E6%A6%82%E8%BF%B0/">无线传感网WSN概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/18/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/">无线模块休眠与激活机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/16/SOC%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/">SOC的低功耗设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/03/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97/">电源管理的低功耗</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Mr Bluyee's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>