<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>anything LLM with ollama - a private document chatbot</title>
      <link href="/2024/04/02/anything-LLM-with-ollama-a-private-document-chatbot/"/>
      <url>/2024/04/02/anything-LLM-with-ollama-a-private-document-chatbot/</url>
      
        <content type="html"><![CDATA[<p>AnythingLLM is a full-stack application that enables you to turn any document, resource, or piece of content into context that any LLM can use as references during chatting. This application allows you to pick and choose which LLM or Vector Database you want to use as well as supporting multi-user management and permissions.</p><h3 id="deploy-with-docker"><a href="#deploy-with-docker" class="headerlink" title="deploy with docker"></a>deploy with docker</h3><p>Pull in the latest image from docker:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mintplexlabs/anythingllm</span><br></pre></td></tr></table></figure><p>on linux:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export STORAGE_LOCATION=$HOME/anythingllm &amp;&amp; \</span><br><span class="line">mkdir -p $STORAGE_LOCATION &amp;&amp; \</span><br><span class="line">touch &quot;$STORAGE_LOCATION/.env&quot; &amp;&amp; \</span><br><span class="line">docker run -d -p 3001:3001 \</span><br><span class="line">--cap-add SYS_ADMIN \</span><br><span class="line">-v $&#123;STORAGE_LOCATION&#125;:/app/server/storage \</span><br><span class="line">-v $&#123;STORAGE_LOCATION&#125;/.env:/app/server/.env \</span><br><span class="line">-e STORAGE_DIR=&quot;/app/server/storage&quot; \</span><br><span class="line">mintplexlabs/anythingllm</span><br></pre></td></tr></table></figure><p>on windows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Run this in powershell terminal</span><br><span class="line">$env:STORAGE_LOCATION=&quot;$HOME\Documents\anythingllm&quot;; `</span><br><span class="line">If(!(Test-Path $env:STORAGE_LOCATION)) &#123;New-Item $env:STORAGE_LOCATION -ItemType Directory&#125;; `</span><br><span class="line">If(!(Test-Path &quot;$env:STORAGE_LOCATION\.env&quot;)) &#123;New-Item &quot;$env:STORAGE_LOCATION\.env&quot; -ItemType File&#125;; `</span><br><span class="line">docker run -d -p 3001:3001 `</span><br><span class="line">--cap-add SYS_ADMIN `</span><br><span class="line">-v &quot;$env:STORAGE_LOCATION`:/app/server/storage&quot; `</span><br><span class="line">-v &quot;$env:STORAGE_LOCATION\.env:/app/server/.env&quot; `</span><br><span class="line">-e STORAGE_DIR=&quot;/app/server/storage&quot; `</span><br><span class="line">mintplexlabs/anythingllm;</span><br></pre></td></tr></table></figure><p>To access the full application, visit <a href="http://localhost:3001/">http://localhost:3001</a> in your browser.</p><p><img src="/images/anythingllm/anythingllm_get_started.png" alt="anything llm get started"></p><p><img src="/images/anythingllm/anythingllm_preference.png" alt="anything llm preference"></p><p><img src="/images/anythingllm/anythingllm_config_ollama.png" alt="anything llm config ollama"><br>Base URL:<br><a href="http://host.docker.internal:11434/">http://host.docker.internal:11434</a></p><p>Note:<br>On linux <a href="http://host.docker.internal:11434/">http://host.docker.internal:11434</a> does not work.<br>Use <a href="http://172.17.0.1:11434/">http://172.17.0.1:11434</a> instead to emulate this functionality.</p><p><img src="/images/anythingllm/anythingllm_embedding_preference.png" alt="anythingllm embedding preference"></p><p>We could select the default one: AnythingLLM Native Embedder<br>It will use the ONNX all-MiniLM-L6-v2 model built by Xenova on HuggingFace.co.<br>This model is a quantized and WASM version of the popular all-MiniLM-L6-v2 which produces a 384-dimension vector.</p><p>For the text generation, it recommends at least using a 4-bit or 5-bit quantized model of the used LLM.<br>Lower quantization models tend to just output unreadable garbage. For more detailed info, please see:<br><a href="https://github.com/Mintplex-Labs/anything-llm/blob/master/server/storage/models/README.md">https://github.com/Mintplex-Labs/anything-llm/blob/master/server/storage/models/README.md</a></p><p><img src="/images/anythingllm/anythingllm_vector_database.png" alt="anythingllm vector database"><br>For the vector database, we could also select the default one: LanceDB<br>For more detailed info, please see: <a href="https://github.com/lancedb/lancedb">https://github.com/lancedb/lancedb</a></p><p><img src="/images/anythingllm/anythingllm_data_handling.png" alt="anythingllm data handling"></p><p><img src="/images/anythingllm/anythingllm_new.png" alt="anythingllm new workspace"></p><p><img src="/images/anythingllm/anythingllm_test.png" alt="anythingllm test workspace"></p><p><img src="/images/anythingllm/anythingllm_settings1.png" alt="anythingllm test workspace general settings"></p><p><img src="/images/anythingllm/anythingllm_chat_setting.png" alt="anythingllm test workspace chat setting"></p><p><img src="/images/anythingllm/anythingllm_vectordb_setting.png" alt="anythingllm test workspace vector database setting"></p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://github.com/Mintplex-Labs/anything-llm">https://github.com/Mintplex-Labs/anything-llm</a><br><a href="https://github.com/Mintplex-Labs/anything-llm/blob/master/docker/HOW_TO_USE_DOCKER.md">https://github.com/Mintplex-Labs/anything-llm/blob/master/docker/HOW_TO_USE_DOCKER.md</a> </p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>open-webui with ollama - ChatGPT like interface</title>
      <link href="/2024/04/02/open-webui-with-ollama-ChatGPT-like-interface/"/>
      <url>/2024/04/02/open-webui-with-ollama-ChatGPT-like-interface/</url>
      
        <content type="html"><![CDATA[<h2 id="Open-WebUI-Formerly-Ollama-WebUI"><a href="#Open-WebUI-Formerly-Ollama-WebUI" class="headerlink" title="Open WebUI (Formerly Ollama WebUI)"></a>Open WebUI (Formerly Ollama WebUI)</h2><p>The Open WebUI is designed to interact with the Ollama API through a specific route. When a request is made from the WebUI to Ollama, it is not directly sent to the Ollama API. Initially, the request is sent to the Open WebUI backend via &#x2F;ollama route. From there, the backend is responsible for forwarding the request to the Ollama API. This forwarding is accomplished by using the route specified in the OLLAMA_BASE_URL environment variable. Therefore, a request made to &#x2F;ollama in the WebUI is effectively the same as making a request to OLLAMA_BASE_URL in the backend. For instance, a request to &#x2F;ollama&#x2F;api&#x2F;tags in the WebUI is equivalent to OLLAMA_BASE_URL&#x2F;api&#x2F;tags in the backend.</p><h3 id="setup-on-Windows"><a href="#setup-on-Windows" class="headerlink" title="setup on Windows"></a>setup on Windows</h3><p>Download the Docker desktop and install:<br><a href="https://docs.docker.com/desktop/install/windows-install/">https://docs.docker.com/desktop/install/windows-install/</a></p><p>If Ollama is on your computer, use this command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure><p>If Ollama is on a Different Server, use this command:<br>To connect to Ollama on another server, change the OLLAMA_BASE_URL to the server’s URL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:8080 -e OLLAMA_BASE_URL=https://example.com -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure><p>Server Connection Error<br>If you’re experiencing connection issues, it’s often due to the WebUI docker container not being able to reach the Ollama server at 127.0.0.1:11434 (host.docker.internal:11434) inside the container. Use the –network&#x3D;host flag in your docker command to resolve this. Note that the port changes from 3000 to 8080, resulting in the link: <a href="http://localhost:8080/">http://localhost:8080</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network=host -v open-webui:/app/backend/data -e OLLAMA_BASE_URL=http://127.0.0.1:11434 --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure><p><img src="/images/openwebui/openwebui_dockercmd.png" alt="open-webui docker install cmd"></p><p><img src="/images/openwebui/docker_desktop.png" alt="docker desktop"></p><p>After installation, you can access Open WebUI at <a href="http://localhost:3000/">http://localhost:3000</a>.<br><img src="/images/openwebui/openwebui_signin.png" alt="open-webui sign in"></p><p>Sign up an account:<br><img src="/images/openwebui/openwebui-signup.png" alt="open-webui sign up"></p><p>Log in with the tester account:<br><img src="/images/openwebui/openwebui.png" alt="open-webui"></p><p>A simple example:<br><img src="/images/openwebui/openwebui_example.png" alt="example"></p><p>Check the settings:<br><img src="/images/openwebui/openwebui_settings.png" alt="open-webui Settings"></p><h3 id="Addtional-features"><a href="#Addtional-features" class="headerlink" title="Addtional features"></a>Addtional features</h3><p>Retrieval Augmented Generation (RAG):<br><a href="https://docs.openwebui.com/tutorial/rag">https://docs.openwebui.com/tutorial/rag</a><br><a href="https://github.com/open-webui/open-webui/blob/main/backend/apps/rag/main.py">https://github.com/open-webui/open-webui/blob/main/backend/apps/rag/main.py</a></p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://github.com/open-webui/open-webui">https://github.com/open-webui/open-webui</a><br><a href="https://docs.openwebui.com/">https://docs.openwebui.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ollama - run large language models locally</title>
      <link href="/2024/04/02/ollama-run-large-language-models-locally/"/>
      <url>/2024/04/02/ollama-run-large-language-models-locally/</url>
      
        <content type="html"><![CDATA[<h2 id="LLM-runner-Ollama"><a href="#LLM-runner-Ollama" class="headerlink" title="LLM runner - Ollama"></a>LLM runner - Ollama</h2><p>Ollama is an open source project for running and managing large language models locally. It bundles model weights, configuration, and data into a single package, defined by a Modelfile. Ollama provides a set of simple and easy-to-use APIs for creating, running, and managing various language models. A series of pre-built large language models are available on the <a href="https://ollama.com/library">https://ollama.com/library</a>, they can be downloaded and run directly. Whether you want to use top-of-the-line modles like Llama 2, Mistral, or want to quickly deploy and test your own models, Ollama offers easy support.</p><h3 id="setup-on-Windows"><a href="#setup-on-Windows" class="headerlink" title="setup on Windows"></a>setup on Windows</h3><p>Download the application and install:<br><a href="https://ollama.com/download/OllamaSetup.exe">https://ollama.com/download/OllamaSetup.exe</a></p><p>After installed, a shell window open automatically<br><img src="/images/ollama/setup_on_win.png" alt="Ollama inital"></p><p>Check the ollama help info:<br><img src="/images/ollama/ollama_help.png" alt="Ollama help info"></p><p>ollama run llama2:<br><img src="/images/ollama/ollama_run_llama2.png" alt="ollama run llama2"></p><p>The models are get stored at below path:<br>C:\Users&lt;user name&gt;\.ollama\models</p><h3 id="setup-on-Linux"><a href="#setup-on-Linux" class="headerlink" title="setup on Linux"></a>setup on Linux</h3><p>Manual install:<br><a href="https://github.com/ollama/ollama/blob/main/docs/linux.md">https://github.com/ollama/ollama/blob/main/docs/linux.md</a></p><p>Docker:<br><a href="https://hub.docker.com/r/ollama/ollama">https://hub.docker.com/r/ollama/ollama</a></p><h3 id="CLI-reference"><a href="#CLI-reference" class="headerlink" title="CLI reference"></a>CLI reference</h3><p><em>Create a model</em><br>ollama create is used to create a model from a Modelfile.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama create mymodel -f ./Modelfile</span><br></pre></td></tr></table></figure><p><em>Pull a model</em><br>This command can also be used to update a local model. Only the diff will be pulled.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama pull llama2</span><br></pre></td></tr></table></figure><p><em>Remove a model</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama rm llama2</span><br></pre></td></tr></table></figure><p><em>Copy a model</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama cp llama2 my-llama2</span><br></pre></td></tr></table></figure><p><em>List models</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama list</span><br></pre></td></tr></table></figure><p><em>Start Ollama</em><br>Used when you want to start ollama without running the desktop application.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama serve</span><br></pre></td></tr></table></figure><p><em>Pass in prompt as arguments</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run llama2 &quot;prompt&quot;</span><br></pre></td></tr></table></figure><h3 id="Customize-a-prompt"><a href="#Customize-a-prompt" class="headerlink" title="Customize a prompt"></a>Customize a prompt</h3><p>Check the models:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Windows\System32&gt; ollama list</span><br><span class="line">NAME            ID              SIZE    MODIFIED</span><br><span class="line">llama2:latest   78e26419b446    3.8 GB  28 minutes ago</span><br></pre></td></tr></table></figure><p>Create a Modelfile save it as a file, example in the Modelfile as below:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM llama2</span><br><span class="line"></span><br><span class="line"># set the temperature to 1 [higher is more creative, lower is more coherent]</span><br><span class="line">PARAMETER temperature 1</span><br><span class="line"></span><br><span class="line"># set the system message</span><br><span class="line">SYSTEM &quot;&quot;&quot;</span><br><span class="line">You are Mario from Super Mario Bros. Answer as Mario, the assistant, only.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>more param details, see <a href="https://github.com/ollama/ollama/blob/main/docs/modelfile.md">https://github.com/ollama/ollama/blob/main/docs/modelfile.md</a></p><p>Create and run the model</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ollama create choose-a-model-name -f &lt;location of the file e.g. ./Modelfile&gt;&#x27;</span><br><span class="line">ollama run choose-a-model-name</span><br></pre></td></tr></table></figure><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://ollama.com/blog">https://ollama.com/blog</a><br><a href="https://github.com/ollama/ollama">https://github.com/ollama/ollama</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>huffman coding in deflate</title>
      <link href="/2024/03/28/huffman-coding-in-deflate/"/>
      <url>/2024/03/28/huffman-coding-in-deflate/</url>
      
        <content type="html"><![CDATA[<p>In deflate dynamic huffman blocks, the huffman tree is stored with the canonical type.</p><h2 id="Canonical-Huffman-code"><a href="#Canonical-Huffman-code" class="headerlink" title="Canonical Huffman code"></a>Canonical Huffman code</h2><p>a canonical Huffman code is a particular type of Huffman code with unique properties which allow it to be described in a very compact manner. Rather than storing the structure of the code tree explicitly, canonical Huffman codes are ordered in such a way that it suffices to only store the lengths of the codewords, which reduces the overhead of the codebook.</p><h3 id="Translate-a-normal-huffman-coding-to-the-canonical-huffman-code"><a href="#Translate-a-normal-huffman-coding-to-the-canonical-huffman-code" class="headerlink" title="Translate a normal huffman coding to the canonical huffman code"></a>Translate a normal huffman coding to the canonical huffman code</h3><p>Suppose we have the following non-canonical codebook:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = 11</span><br><span class="line">B = 0</span><br><span class="line">C = 101</span><br><span class="line">D = 100</span><br></pre></td></tr></table></figure><p>Here the letter A has been assigned 2 bits, B has 1 bit, and C and D both have 3 bits. To make the code a canonical Huffman code, the codes are renumbered. The bit lengths stay the same with the code book being sorted first by codeword length and secondly by alphabetical value of the letter:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B = 0</span><br><span class="line">A = 11</span><br><span class="line">C = 101</span><br><span class="line">D = 100</span><br></pre></td></tr></table></figure><p>Each of the existing codes are replaced with a new one of the same length, using the following algorithm:</p><ul><li>The first symbol in the list gets assigned a codeword which is the same length as the symbol’s original codeword but all zeros. This will often be a single zero (‘0’).</li><li>Each subsequent symbol is assigned the next binary number in sequence, ensuring that following codes are always higher in value.</li><li>When you reach a longer codeword, then after incrementing, append zeros until the length of the new codeword is equal to the length of the old codeword. This can be thought of as a left shift.</li></ul><p>By following these three rules, the canonical version of the code book produced will be:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B = 0</span><br><span class="line">A = 10</span><br><span class="line">C = 110</span><br><span class="line">D = 111</span><br></pre></td></tr></table></figure><h3 id="store-canonical-huffman-code-efficiently"><a href="#store-canonical-huffman-code-efficiently" class="headerlink" title="store canonical huffman code efficiently"></a>store canonical huffman code efficiently</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = 10    (code value: 2 decimal, bits: 2)</span><br><span class="line">B = 0     (code value: 0 decimal, bits: 1)</span><br><span class="line">C = 110   (code value: 6 decimal, bits: 3)</span><br><span class="line">D = 111   (code value: 7 decimal, bits: 3)</span><br></pre></td></tr></table></figure><p>Assume the alphabets are start from A,B,C,D, …<br>This alphabets should be the predefined, and be known from both compression and decompression side. Thus, only the below info need to be stored:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Used symbol length： 4</span><br><span class="line">Number of bits for each symbol: 2, 1, 3, 3</span><br></pre></td></tr></table></figure><h3 id="get-the-canonical-huffman-code-from-the-stored-info"><a href="#get-the-canonical-huffman-code-from-the-stored-info" class="headerlink" title="get the canonical huffman code from the stored info"></a>get the canonical huffman code from the stored info</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Used symbol length： 4</span><br><span class="line">Number of bits for each symbol: 2, 1, 3, 3</span><br><span class="line"></span><br><span class="line">Get the used symbol info and the correspond bit length:</span><br><span class="line">(&#x27;A&#x27;,2), (&#x27;B&#x27;,1), (&#x27;C&#x27;,3), (&#x27;D&#x27;,3)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Sort it with bit length:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bit length: [1, 2, 3, 3]</span><br><span class="line">used symbol: [B, A, C, D]</span><br></pre></td></tr></table></figure><p>Pseudocode to get the canonical huffman code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">code := 0</span><br><span class="line">while more symbols do</span><br><span class="line">    print symbol = code</span><br><span class="line">    code := (code + 1) &lt;&lt; ((bit length of the next symbol) − (current bit length))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">B = 0</span><br><span class="line">A = 10</span><br><span class="line">C = 110</span><br><span class="line">D = 111</span><br></pre></td></tr></table></figure><h3 id="decompression-with-the-canonical-huffman-code"><a href="#decompression-with-the-canonical-huffman-code" class="headerlink" title="decompression with the canonical huffman code"></a>decompression with the canonical huffman code</h3><p>For the decompression, we do not need to create the codes or the tree in order to decode canonical codes. All we need is the list of symbols in order and the count of symbols in each code length.</p><p>Since the canonical codes within a code length are sequential binary integers, you can simply do integer comparisons to see if the bits you have fall within that code range, and if it is, an integer subtraction to determine which symbol it is.</p><p>example code from <a href="https://github.com/madler/zlib/blob/master/contrib/puff/puff.c">https://github.com/madler/zlib/blob/master/contrib/puff/puff.c</a> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#define MAXBITS 15              /* maximum bits in a code */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of</span><br><span class="line"> * each length, which for a canonical code are stepped through in order.</span><br><span class="line"> * symbol[] are the symbol values in canonical order, where the number of</span><br><span class="line"> * entries is the sum of the counts in count[].  The decoding process can be</span><br><span class="line"> * seen in the function decode() below.</span><br><span class="line"> */</span><br><span class="line">struct huffman &#123;</span><br><span class="line">    short *count;       /* number of symbols of each length */</span><br><span class="line">    short *symbol;      /* canonically ordered symbols */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Decode a code from the stream s using huffman table h.  Return the symbol or</span><br><span class="line"> * a negative value if there is an error.  If all of the lengths are zero, i.e.</span><br><span class="line"> * an empty code, or if the code is incomplete and an invalid code is received,</span><br><span class="line"> * then -10 is returned after reading MAXBITS bits.</span><br><span class="line"> *</span><br><span class="line"> * Format notes:</span><br><span class="line"> *</span><br><span class="line"> * - The codes as stored in the compressed data are bit-reversed relative to</span><br><span class="line"> *   a simple integer ordering of codes of the same lengths.  Hence below the</span><br><span class="line"> *   bits are pulled from the compressed data one at a time and used to</span><br><span class="line"> *   build the code value reversed from what is in the stream in order to</span><br><span class="line"> *   permit simple integer comparisons for decoding.  A table-based decoding</span><br><span class="line"> *   scheme (as used in zlib) does not need to do this reversal.</span><br><span class="line"> *</span><br><span class="line"> * - The first code for the shortest length is all zeros.  Subsequent codes of</span><br><span class="line"> *   the same length are simply integer increments of the previous code.  When</span><br><span class="line"> *   moving up a length, a zero bit is appended to the code.  For a complete</span><br><span class="line"> *   code, the last code of the longest length will be all ones.</span><br><span class="line"> *</span><br><span class="line"> * - Incomplete codes are handled by this decoder, since they are permitted</span><br><span class="line"> *   in the deflate format.  See the format notes for fixed() and dynamic().</span><br><span class="line"> */</span><br><span class="line">local int decode(struct state *s, const struct huffman *h)</span><br><span class="line">&#123;</span><br><span class="line">    int len;            /* current number of bits in code */</span><br><span class="line">    int code;           /* len bits being decoded */</span><br><span class="line">    int first;          /* first code of length len */</span><br><span class="line">    int count;          /* number of codes of length len */</span><br><span class="line">    int index;          /* index of first code of length len in symbol table */</span><br><span class="line"></span><br><span class="line">    code = first = index = 0;</span><br><span class="line">    for (len = 1; len &lt;= MAXBITS; len++) &#123;</span><br><span class="line">        code |= bits(s, 1);             /* get next bit */</span><br><span class="line">        count = h-&gt;count[len];</span><br><span class="line">        if (code - count &lt; first)       /* if length len, return symbol */</span><br><span class="line">            return h-&gt;symbol[index + (code - first)];</span><br><span class="line">        index += count;                 /* else update for next length */</span><br><span class="line">        first += count;</span><br><span class="line">        first &lt;&lt;= 1;</span><br><span class="line">        code &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -10;                         /* ran out of codes */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Follow with the previous example, we will have:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">B = 0</span><br><span class="line">A = 10</span><br><span class="line">C = 110</span><br><span class="line">D = 111</span><br><span class="line"></span><br><span class="line">bit length: [1, 2, 3, 3]</span><br><span class="line">used symbol: [B, A, C, D]</span><br><span class="line"></span><br><span class="line">MAXBITS = 3</span><br><span class="line">h-&gt;count[MAXBITS + 1] = [0, 1, 1, 2]  (number of symbols of each length)</span><br><span class="line">h-&gt;symbol = [B, A, C, D]</span><br><span class="line"></span><br><span class="line">Assume the bit stream is:</span><br><span class="line"></span><br><span class="line">A    B   C     D</span><br><span class="line">b&#x27;10 b&#x27;0 b&#x27;110 b&#x27;111</span><br><span class="line"></span><br><span class="line">code = first = index = 0</span><br><span class="line">loop 1:</span><br><span class="line">code = 0 | bits(s, 1) //code = 1</span><br><span class="line">count = h-&gt;count[1] //count = 1</span><br><span class="line">code - count = 0 // code - count == first</span><br><span class="line">index += count //index = 1</span><br><span class="line">first += count //first = 1</span><br><span class="line">first &lt;&lt;= 1 //first = b&#x27;10</span><br><span class="line">code &lt;&lt;= 1 //code = b&#x27;10</span><br><span class="line"></span><br><span class="line">loop 2:</span><br><span class="line">code = b&#x27;10 | bits(s, 1) //code = b&#x27;10</span><br><span class="line">count = h-&gt;count[2] //count = 1</span><br><span class="line">code - count = 1 //code - count &lt; first</span><br><span class="line">index + (code - first) //1 + 2 - 2 = 1</span><br><span class="line">return h-&gt;symbol[1] //return A</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="generate-the-dynamic-huffman-code"><a href="#generate-the-dynamic-huffman-code" class="headerlink" title="generate the dynamic huffman code"></a>generate the dynamic huffman code</h3><p>analysis code from:<br><a href="https://github.com/madler/zlib/blob/master/trees.c#L1093">https://github.com/madler/zlib/blob/master/trees.c#L1093</a><br><a href="https://github.com/madler/zlib/blob/develop/deflate.h#L333">https://github.com/madler/zlib/blob/develop/deflate.h#L333</a> </p><p>There are 2 huffman table for the deflate dynamic huffman blocks,<br>one is the literal&#x2F;length table, another is the distance table.</p><p>And we know that the LZ77 processed data will have the below format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">literal symbol (0-255),</span><br><span class="line">.. , </span><br><span class="line">length (3-258), distance (1-32768),</span><br><span class="line">.. ,</span><br><span class="line">end of block symbol (256).</span><br></pre></td></tr></table></figure><p>So, there has 2 kind of tally functions to calculate the symbol frequency when parsing each symbol within the block.</p><p>Related data structures and define:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#define LENGTH_CODES 29</span><br><span class="line">/* number of length codes, not counting the special END_BLOCK code */</span><br><span class="line"></span><br><span class="line">#define LITERALS  256</span><br><span class="line">/* number of literal bytes 0..255 */</span><br><span class="line"></span><br><span class="line">#define L_CODES (LITERALS+1+LENGTH_CODES)</span><br><span class="line">/* number of Literal or Length codes, including the END_BLOCK code */</span><br><span class="line"></span><br><span class="line">#define D_CODES   30</span><br><span class="line">/* number of distance codes */</span><br><span class="line"></span><br><span class="line">#define BL_CODES  19</span><br><span class="line">/* number of codes used to transfer the bit lengths */</span><br><span class="line"></span><br><span class="line">#define HEAP_SIZE (2*L_CODES+1)</span><br><span class="line">/* maximum heap size */</span><br><span class="line"></span><br><span class="line">/* Data structure describing a single value and its code string. */</span><br><span class="line">typedef struct ct_data_s &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        ush  freq;       /* frequency count */</span><br><span class="line">        ush  code;       /* bit string */</span><br><span class="line">    &#125; fc;</span><br><span class="line">    union &#123;</span><br><span class="line">        ush  dad;        /* father node in Huffman tree */</span><br><span class="line">        ush  len;        /* length of bit string */</span><br><span class="line">    &#125; dl;</span><br><span class="line">&#125; FAR ct_data;</span><br><span class="line"></span><br><span class="line">#define Freq fc.freq</span><br><span class="line">#define Code fc.code</span><br><span class="line">#define Dad  dl.dad</span><br><span class="line">#define Len  dl.len</span><br><span class="line"></span><br><span class="line">struct static_tree_desc_s &#123;</span><br><span class="line">    const ct_data *static_tree;  /* static tree or NULL */</span><br><span class="line">    const intf *extra_bits;      /* extra bits for each code or NULL */</span><br><span class="line">    int     extra_base;          /* base index for extra_bits */</span><br><span class="line">    int     elems;               /* max number of elements in the tree */</span><br><span class="line">    int     max_length;          /* max bit length for the codes */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct tree_desc_s &#123;</span><br><span class="line">    ct_data *dyn_tree;           /* the dynamic tree */</span><br><span class="line">    int     max_code;            /* largest code with non zero frequency */</span><br><span class="line">    const static_tree_desc *stat_desc;  /* the corresponding static tree */</span><br><span class="line">&#125; FAR tree_desc;</span><br><span class="line"></span><br><span class="line">typedef struct internal_state &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */</span><br><span class="line">    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */</span><br><span class="line">    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */</span><br><span class="line">    /* dyn_ltree is used for store the generated literal and length tree,</span><br><span class="line">    * The elements in dyn_ltree[:L_CODES] are leaves, middle nodes get stored</span><br><span class="line">    * after it. same as the dyn_dtree and bl_tree.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    struct tree_desc_s l_desc;               /* desc. for literal tree */</span><br><span class="line">    struct tree_desc_s d_desc;               /* desc. for distance tree */</span><br><span class="line">    struct tree_desc_s bl_desc;              /* desc. for bit length tree */</span><br><span class="line"></span><br><span class="line">    ush bl_count[MAX_BITS+1];</span><br><span class="line">    /* number of codes at each bit length for an optimal tree */</span><br><span class="line"></span><br><span class="line">    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */</span><br><span class="line">    int heap_len;               /* number of elements in the heap */</span><br><span class="line">    int heap_max;               /* element of largest frequency */</span><br><span class="line">    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.</span><br><span class="line">     * The same heap array is used to build all trees.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    uch depth[2*L_CODES+1];</span><br><span class="line">    /* Depth of each subtree used as tie breaker for trees of equal frequency</span><br><span class="line">     */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2 tally functions:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//if it is a literal symbol (0-255, 256):</span><br><span class="line"></span><br><span class="line">_tr_tally_lit(s, c, flush)</span><br><span class="line">     s-&gt;dyn_ltree[cc].Freq++;</span><br><span class="line"></span><br><span class="line">//if it is a length &amp; distance pair:</span><br><span class="line"></span><br><span class="line">_tr_tally_dist(s, distance, length, flush)</span><br><span class="line">    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++;</span><br><span class="line">    s-&gt;dyn_dtree[d_code(dist)].Freq++; </span><br></pre></td></tr></table></figure><p>Assume, we have A,B,C,D four symbols, and the frequency shown as below:</p><table><thead><tr><th>symbol index</th><th>symbol</th><th>frequency</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>4</td></tr><tr><td>1</td><td>B</td><td>5</td></tr><tr><td>2</td><td>C</td><td>1</td></tr><tr><td>3</td><td>D</td><td>2</td></tr></tbody></table><p>The huffman table is created by the build_tree() function：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* ===========================================================================</span><br><span class="line"> * Construct one Huffman tree and assigns the code bit strings and lengths.</span><br><span class="line"> * Update the total bit length for the current block.</span><br><span class="line"> * IN assertion: the field freq is set for all tree elements.</span><br><span class="line"> * OUT assertions: the fields len and code are set to the optimal bit length</span><br><span class="line"> *     and corresponding code. The length opt_len is updated; static_len is</span><br><span class="line"> *     also updated if stree is not null. The field max_code is set.</span><br><span class="line"> */</span><br><span class="line">local void build_tree(deflate_state *s, tree_desc *desc)</span><br><span class="line"></span><br><span class="line">    ct_data *tree         = desc-&gt;dyn_tree;</span><br><span class="line">    const ct_data *stree  = desc-&gt;stat_desc-&gt;static_tree;</span><br><span class="line">    int elems             = desc-&gt;stat_desc-&gt;elems;</span><br><span class="line">    int n, m;          /* iterate over heap elements */</span><br><span class="line">    int max_code = -1; /* largest code with non zero frequency */</span><br><span class="line">    int node;          /* new node being created */</span><br><span class="line"></span><br><span class="line">    /* Construct the initial heap, with least frequent element in heap[SMALLEST].</span><br><span class="line">     * The sons of heap[n] are heap[2*n] and heap[2*n + 1].</span><br><span class="line">     * heap[0] is not used.</span><br><span class="line">     * HEAP_SIZE = (2*L_CODES+1)</span><br><span class="line">     */</span><br><span class="line">    s-&gt;heap_len = 0, s-&gt;heap_max = HEAP_SIZE;</span><br><span class="line"></span><br><span class="line">    /* Initial the heap, put all the elems which Freq is not 0 to the heap.</span><br><span class="line">    * The elems with 0 Freq will be set the 0 to the Len.</span><br><span class="line">    * The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree.</span><br><span class="line">    * for l_tree, elems = L_CODES = (256 + 1 + 29) = 286</span><br><span class="line">    * for d_tree, elems = D_CODES = 30</span><br><span class="line">    * for bl_tree, elems = BL_CODES = 19</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    for (n = 0; n &lt; elems; n++) &#123;</span><br><span class="line">        if (tree[n].Freq != 0) &#123;</span><br><span class="line">            s-&gt;heap[++(s-&gt;heap_len)] = max_code = n;</span><br><span class="line">            s-&gt;depth[n] = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tree[n].Len = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>For the A, B, C, D four symbols, the heap size should be 2 * 4 + 1 &#x3D; 9, elems &#x3D; 4.<br>So, at the initial heap stage, we will get:</p><table><thead><tr><th>heap index</th><th>symbol</th><th>symbol frequency</th><th>symbol depth</th></tr></thead><tbody><tr><td>0</td><td>not used</td><td>-</td><td>-</td></tr><tr><td>1</td><td>A</td><td>4</td><td>0</td></tr><tr><td>2</td><td>B</td><td>5</td><td>0</td></tr><tr><td>3</td><td>C</td><td>1</td><td>0</td></tr><tr><td>4</td><td>D</td><td>2</td><td>0</td></tr></tbody></table><p>heap_len &#x3D; 4<br>max_code &#x3D; 3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,</span><br><span class="line"> * establish sub-heaps of increasing lengths:</span><br><span class="line"> */</span><br><span class="line">for (n = s-&gt;heap_len/2; n &gt;= 1; n--) pqdownheap(s, tree, n);</span><br><span class="line"></span><br><span class="line">/* pqdownheap(deflate_state *s, ct_data *tree, int k) is used to </span><br><span class="line"> * restore the heap property by moving down the tree starting at node k,</span><br><span class="line"> * exchanging a node with the smallest of its two sons if necessary, stopping</span><br><span class="line"> * when the heap property is re-established (each father smaller than its</span><br><span class="line"> * two sons).</span><br></pre></td></tr></table></figure><p>We can build a tree with the initial heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C(1)<br>&nbsp;&nbsp;&#x2F;<br>D(2)</p><p>So, the elements heap[3 (4 &#x2F; 2 + 1)] &#x3D; C, heap[4] &#x3D; D are leaves of the tree.<br>And the for loop will do pqdownheap() for the heap[2] &#x3D; B, heap[1] &#x3D; A:</p><p><em>loop 1:</em><br>pqdownheap(s, tree, B):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;D(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C(1)<br>&nbsp;&nbsp;&#x2F;<br>B(5)</p><p><em>loop 2:</em><br>pqdownheap(s, tree, A):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;D(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&#x2F;<br>B(5)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* Construct the Huffman tree by repeatedly combining the least two</span><br><span class="line"> * frequent nodes.</span><br><span class="line"> */</span><br><span class="line">node = elems;              /* next internal node of the tree */</span><br><span class="line">do &#123;</span><br><span class="line">    pqremove(s, tree, n);  /* n = node of least frequency */</span><br><span class="line">    /*</span><br><span class="line">     * Remove the smallest element from the heap and recreate the heap with</span><br><span class="line">     * one less element. Updates heap and heap_len.         </span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    m = s-&gt;heap[SMALLEST]; /* m = node of next least frequency (SMALLEST = 1) */</span><br><span class="line"></span><br><span class="line">    s-&gt;heap[--(s-&gt;heap_max)] = n; /* keep the nodes sorted by frequency */</span><br><span class="line">    s-&gt;heap[--(s-&gt;heap_max)] = m;</span><br><span class="line"></span><br><span class="line">    /* Create a new node father of n and m */</span><br><span class="line">    tree[node].Freq = tree[n].Freq + tree[m].Freq;</span><br><span class="line">    s-&gt;depth[node] = (uch)((s-&gt;depth[n] &gt;= s-&gt;depth[m] ?</span><br><span class="line">                            s-&gt;depth[n] : s-&gt;depth[m]) + 1);</span><br><span class="line">    tree[n].Dad = tree[m].Dad = (ush)node;</span><br><span class="line"></span><br><span class="line">    /* and insert the new node in the heap */</span><br><span class="line">    s-&gt;heap[SMALLEST] = node++;</span><br><span class="line">    pqdownheap(s, tree, SMALLEST);</span><br><span class="line"></span><br><span class="line">&#125; while (s-&gt;heap_len &gt;= 2);</span><br></pre></td></tr></table></figure><p>heap_len &#x3D; 4<br>SMALLEST &#x3D; 1<br>node &#x3D; elems &#x3D; 4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define pqremove(s, tree, top) \</span><br><span class="line">&#123;\</span><br><span class="line">    top = s-&gt;heap[SMALLEST]; \</span><br><span class="line">    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \</span><br><span class="line">    pqdownheap(s, tree, SMALLEST); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>loop 1:</em><br>pqremove() step 1:<br>n &#x3D; C</p><p>pqremove() step 2:<br>s-&gt;heap_len &#x3D; 3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B(5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;D(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p><p>pqremove() step 3:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D(2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p><p>m &#x3D; D<br>heap[8] &#x3D; C<br>heap[7] &#x3D; D</p><p>Create a new node father of n and m:<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[4] &#x3D; C.freq + D.freq &#x3D; 1 + 2 &#x3D; 3</p><p>insert the new node in the heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p><p>pqdownheap(s, tree, SMALLEST):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p><table><thead><tr><th>heap index</th><th>symbol</th><th>symbol frequency</th><th>symbol dad</th></tr></thead><tbody><tr><td>0</td><td>not used</td><td>-</td><td>-</td></tr><tr><td>1</td><td>(3)</td><td>3</td><td>-</td></tr><tr><td>2</td><td>B</td><td>5</td><td>-</td></tr><tr><td>3</td><td>A</td><td>4</td><td>-</td></tr><tr><td>4</td><td>-</td><td>-</td><td>-</td></tr><tr><td>5</td><td>-</td><td>-</td><td>-</td></tr><tr><td>6</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>D</td><td>2</td><td>(3)</td></tr><tr><td>8</td><td>C</td><td>1</td><td>(3)</td></tr></tbody></table><p><em>loop 2:</em><br>pqremove() step 1:<br>n &#x3D; (3)</p><p>pqremove() step 2:<br>s-&gt;heap_len &#x3D; 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)</p><p>pqremove() step 3:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)</p><p>m &#x3D; A<br>heap[6] &#x3D; (3)<br>heap[5] &#x3D; A</p><p>Create a new node father of n and m:<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[5] &#x3D; (3).freq + A.freq &#x3D; 3 + 4 &#x3D; 7</p><p>insert the new node in the heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)</p><p>pqdownheap(s, tree, SMALLEST):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B(5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;(7)</p><table><thead><tr><th>heap index</th><th>symbol</th><th>symbol frequency</th><th>symbol dad</th></tr></thead><tbody><tr><td>0</td><td>not used</td><td>-</td><td>-</td></tr><tr><td>1</td><td>B</td><td>5</td><td>-</td></tr><tr><td>2</td><td>(7)</td><td>7</td><td>-</td></tr><tr><td>3</td><td>-</td><td>-</td><td>-</td></tr><tr><td>4</td><td>-</td><td>-</td><td>-</td></tr><tr><td>5</td><td>A</td><td>4</td><td>(7)</td></tr><tr><td>6</td><td>(3)</td><td>3</td><td>(7)</td></tr><tr><td>7</td><td>D</td><td>2</td><td>(3)</td></tr><tr><td>8</td><td>C</td><td>1</td><td>(3)</td></tr></tbody></table><p><em>loop 3:</em><br>pqremove() step 1:<br>n &#x3D; B</p><p>pqremove() step 2:<br>s-&gt;heap_len &#x3D; 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)</p><p>pqremove() step 3:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)</p><p>m &#x3D; (7)<br>heap[4] &#x3D; B<br>heap[3] &#x3D; (7)</p><p>Create a new node father of n and m:<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[6] &#x3D; (7).freq + B.freq &#x3D; 7 + 5 &#x3D; 12</p><p>insert the new node in the heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(12)</p><p>pqdownheap(s, tree, SMALLEST):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(12)</p><table><thead><tr><th>heap index</th><th>symbol</th><th>symbol frequency</th><th>symbol dad</th></tr></thead><tbody><tr><td>0</td><td>not used</td><td>-</td><td>-</td></tr><tr><td>1</td><td>(12)</td><td>12</td><td>-</td></tr><tr><td>2</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>(7)</td><td>7</td><td>(12)</td></tr><tr><td>4</td><td>B</td><td>5</td><td>(12)</td></tr><tr><td>5</td><td>A</td><td>4</td><td>(7)</td></tr><tr><td>6</td><td>(3)</td><td>3</td><td>(7)</td></tr><tr><td>7</td><td>D</td><td>2</td><td>(3)</td></tr><tr><td>8</td><td>C</td><td>1</td><td>(3)</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;heap[--(s-&gt;heap_max)] = s-&gt;heap[SMALLEST];</span><br></pre></td></tr></table></figure><p>heap_max &#x3D; 2</p><p>for now, we have the elements in heap:</p><table><thead><tr><th>heap index</th><th>symbol</th><th>symbol frequency</th><th>symbol dad</th></tr></thead><tbody><tr><td>0</td><td>not used</td><td>-</td><td>-</td></tr><tr><td>1</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>(12)</td><td>12</td><td>-</td></tr><tr><td>3</td><td>(7)</td><td>7</td><td>(12)</td></tr><tr><td>4</td><td>B</td><td>5</td><td>(12)</td></tr><tr><td>5</td><td>A</td><td>4</td><td>(7)</td></tr><tr><td>6</td><td>(3)</td><td>3</td><td>(7)</td></tr><tr><td>7</td><td>D</td><td>2</td><td>(3)</td></tr><tr><td>8</td><td>C</td><td>1</td><td>(3)</td></tr></tbody></table><p>for now, we have the elements in tree:</p><table><thead><tr><th>tree index</th><th>symbol</th><th>symbol frequency</th><th>symbol dad</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>4</td><td>(7)</td></tr><tr><td>1</td><td>B</td><td>5</td><td>(12)</td></tr><tr><td>2</td><td>C</td><td>1</td><td>(3)</td></tr><tr><td>3</td><td>D</td><td>2</td><td>(3)</td></tr><tr><td>4</td><td>(3)</td><td>3</td><td>(7)</td></tr><tr><td>5</td><td>(7)</td><td>7</td><td>(12)</td></tr><tr><td>6</td><td>(12)</td><td>12</td><td>-</td></tr><tr><td>7</td><td></td><td></td><td></td></tr><tr><td>8</td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* At this point, the fields freq and dad are set. We can now</span><br><span class="line"> * generate the bit lengths.</span><br><span class="line"> */</span><br><span class="line">gen_bitlen(s, (tree_desc *)desc);</span><br></pre></td></tr></table></figure><p>The symbol bit length is generated by the gen_bitlen() function：<br>(below function not considered the overflow case, if overflow happened, adjust and recalculate)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* In a first pass, compute the optimal bit lengths (which may</span><br><span class="line"> * overflow in the case of the bit length tree).</span><br><span class="line"> */</span><br><span class="line">tree[s-&gt;heap[s-&gt;heap_max]].Len = 0; /* root of the heap */</span><br><span class="line"></span><br><span class="line">for (h = s-&gt;heap_max + 1; h &lt; HEAP_SIZE; h++) &#123;</span><br><span class="line">    n = s-&gt;heap[h];</span><br><span class="line">    bits = tree[tree[n].Dad].Len + 1;</span><br><span class="line">    if (bits &gt; max_length) bits = max_length, overflow++;</span><br><span class="line">    tree[n].Len = (ush)bits;</span><br><span class="line">    /* We overwrite tree[n].Dad which is no longer needed */</span><br><span class="line"></span><br><span class="line">    if (n &gt; max_code) continue; /* not a leaf node */</span><br><span class="line"></span><br><span class="line">    s-&gt;bl_count[bits]++;</span><br><span class="line">    xbits = 0;</span><br><span class="line">    if (n &gt;= base) xbits = extra[n - base];</span><br><span class="line">    f = tree[n].Freq;</span><br><span class="line">    s-&gt;opt_len += (ulg)f * (unsigned)(bits + xbits);</span><br><span class="line">    if (stree) s-&gt;static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>tree index</th><th>symbol</th><th>symbol frequency</th><th>symbol dad</th><th>symbol len</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>4</td><td>(7)</td><td>2</td></tr><tr><td>1</td><td>B</td><td>5</td><td>(12)</td><td>1</td></tr><tr><td>2</td><td>C</td><td>1</td><td>(3)</td><td>3</td></tr><tr><td>3</td><td>D</td><td>2</td><td>(3)</td><td>3</td></tr><tr><td>4</td><td>(3)</td><td>3</td><td>(7)</td><td>2</td></tr><tr><td>5</td><td>(7)</td><td>7</td><td>(12)</td><td>1</td></tr><tr><td>6</td><td>(12)</td><td>12</td><td>-</td><td>0</td></tr><tr><td>7</td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>bl_count: (only calculate the leaves)</p><table><thead><tr><th>bit length</th><th>symbol count</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>2</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* The field len is now set, we can generate the bit codes */</span><br><span class="line">gen_codes ((ct_data *)tree, max_code, s-&gt;bl_count):</span><br><span class="line">    unsigned code = 0;  </span><br><span class="line">    for (bits = 1; bits &lt;= MAX_BITS; bits++) &#123;</span><br><span class="line">        code = (code + bl_count[bits - 1]) &lt;&lt; 1;</span><br><span class="line">        next_code[bits] = (ush)code;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>bit length</th><th>symbol count</th><th>code</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>b’0</td></tr><tr><td>2</td><td>1</td><td>b’10</td></tr><tr><td>3</td><td>2</td><td>b’110</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (n = 0;  n &lt;= max_code; n++) &#123;</span><br><span class="line">    int len = tree[n].Len;</span><br><span class="line">    if (len == 0) continue;</span><br><span class="line">    /* Now reverse the bits */</span><br><span class="line">    tree[n].Code = (ush)bi_reverse(next_code[len]++, len);</span><br><span class="line"></span><br><span class="line">    Tracecv(tree != static_ltree, (stderr,&quot;\nn %3d %c l %2d c %4x (%x) &quot;,</span><br><span class="line">        n, (isgraph(n) ? n : &#x27; &#x27;), len, tree[n].Code, next_code[len] - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally we get:</p><table><thead><tr><th>tree index</th><th>symbol</th><th>symbol frequency</th><th>symbol len</th><th>symbol code</th><th>reversed code</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>4</td><td>2</td><td>b’10</td><td>b’01</td></tr><tr><td>1</td><td>B</td><td>5</td><td>1</td><td>b’0</td><td>b’0</td></tr><tr><td>2</td><td>C</td><td>1</td><td>3</td><td>b’110</td><td>b’011</td></tr><tr><td>3</td><td>D</td><td>2</td><td>3</td><td>b’111</td><td>b’111</td></tr></tbody></table><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://en.wikipedia.org/wiki/Canonical_Huffman_code">https://en.wikipedia.org/wiki/Canonical_Huffman_code</a><br><a href="https://github.com/madler/zlib/blob/master/contrib/puff/puff.c">https://github.com/madler/zlib/blob/master/contrib/puff/puff.c</a><br><a href="https://github.com/madler/zlib/blob/develop/trees.c">https://github.com/madler/zlib/blob/develop/trees.c</a><br><a href="https://stackoverflow.com/questions/29575309/decoding-huffman-file-from-canonical-form">https://stackoverflow.com/questions/29575309/decoding-huffman-file-from-canonical-form</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——data compression </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data compression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zlib and gzip format</title>
      <link href="/2024/03/25/zlib-and-gzip-format/"/>
      <url>/2024/03/25/zlib-and-gzip-format/</url>
      
        <content type="html"><![CDATA[<p>Raw DEFLATE compressed data (RFC 1951) are typically written with a zlib or gzip wrapper encapsulating the data, by adding a header and footer. This provides stream identification and error detection that are not provided by the raw DEFLATE data.</p><h2 id="ZLIB"><a href="#ZLIB" class="headerlink" title="ZLIB"></a>ZLIB</h2><h3 id="ZLIB-header"><a href="#ZLIB-header" class="headerlink" title="ZLIB header"></a>ZLIB header</h3><table><thead><tr><th>header fields</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>Compression method (CM)</td><td>4 bits</td><td>CM &#x3D; 8 (deflate with 32K window) <br>CM &#x3D; 15 (reserved)</td></tr><tr><td>Compression information (CINFO)</td><td>4 bits</td><td>CINFO&#x3D;7 window size: 32K <br>Window &#x3D; 1 &lt;&lt; (CINFO + 8)</td></tr><tr><td>Flags (FLG)</td><td>8 bits</td><td>flags, details see below</td></tr><tr><td>Dictionary identifier (DICTID)</td><td>32 bits</td><td>optional, if FLG.FDICT set. <br>DICTID &#x3D; Alder32(Dictionary)</td></tr><tr><td>Dictionary</td><td>size could be checked by the DICTID</td><td>optional, if FLG.FDICT set.</td></tr></tbody></table><p>Flags (FLG)</p><table><thead><tr><th>bit fields</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>check bits (FCHECK)</td><td>5 bits</td><td>check bits for CMF and FLG</td></tr><tr><td>preset dictionary (FDICT)</td><td>1 bit</td><td>preset dictionary flag</td></tr><tr><td>compression level (FLEVEL)</td><td>2 bits</td><td>compression level</td></tr></tbody></table><p>check bits(FCHECK) value must be such that CMF(CM + CINFO) and FLG, when viewed as a 16-bit unsigned integer stored in MSB order (CMF*256 + FLG), is a multiple of 31.<br>Simply, it should satisfy: (CMF*256 + FLG) mod 31 &#x3D;&#x3D; 0</p><p>preset dictionary(FDICT) if set, a DICT dictionary identifier is present immediately after the FLG byte. The dictionary is a sequence of bytes which are initially fed to the compressor without producing any compressed output. DICT is the Adler-32 checksum of this sequence of bytes.</p><p>Compression level (FLEVEL) <em>(for CM &#x3D; 8)</em></p><table><thead><tr><th>value</th><th>description</th></tr></thead><tbody><tr><td>0</td><td>compressor used fastest algorithm</td></tr><tr><td>1</td><td>compressor used fast algorithm</td></tr><tr><td>2</td><td>compressor used default algorithm</td></tr><tr><td>3</td><td>compressor used maximum compression, slowest algorithm</td></tr></tbody></table><h3 id="Compressed-Data"><a href="#Compressed-Data" class="headerlink" title="Compressed Data"></a>Compressed Data</h3><p>For compression method 8, the compressed data is stored in the deflate compressed data format. For raw deflate format, please see <a href="https://www.mrbluyee.com/2024/03/23/deflate%20format/">deflate format</a></p><h3 id="ZLIB-footer"><a href="#ZLIB-footer" class="headerlink" title="ZLIB footer"></a>ZLIB footer</h3><table><thead><tr><th>footer fields</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>Adler-32 Checksum</td><td>32 bits</td><td>checksum value of the uncompressed data <br> (excluding any dictionary data)</td></tr></tbody></table><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.rfc-editor.org/rfc/rfc1950">https://www.rfc-editor.org/rfc/rfc1950</a><br><a href="https://en.wikipedia.org/wiki/Zlib">https://en.wikipedia.org/wiki/Zlib</a><br><a href="https://github.com/madler/zlib">https://github.com/madler/zlib</a></p><h2 id="GZIP"><a href="#GZIP" class="headerlink" title="GZIP"></a>GZIP</h2><h3 id="GZIP-header"><a href="#GZIP-header" class="headerlink" title="GZIP header"></a>GZIP header</h3><table><thead><tr><th>header fields</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>IDentification 1 (ID1)</td><td>8 bits</td><td>fixed value ID1 &#x3D; 31 (0x1f, \037)</td></tr><tr><td>IDentification 2 (ID2)</td><td>8 bits</td><td>fixed value ID2 &#x3D; 139 (0x8b, \213)</td></tr><tr><td>Compression method (CM)</td><td>8 bits</td><td>CM &#x3D; 0-7 (reserved), CM &#x3D; 8 (deflate)</td></tr><tr><td>Flags (FLG)</td><td>8 bits</td><td>flags, details see below</td></tr><tr><td>Modification TIME (MTIME)</td><td>32 bits</td><td>Unix format of the most recent modification time</td></tr><tr><td>Extra Flags (XFL)</td><td>8 bits</td><td>Extra flags, details see below</td></tr><tr><td>Operating System (OS)</td><td>8 bits</td><td>Operating System</td></tr><tr><td>XLEN</td><td>16 bits</td><td>optional, if FLG.FEXTRA set. Extra field byte length</td></tr><tr><td>Extra field</td><td>XLEN bytes</td><td>optional, if FLG.FEXTRA set.</td></tr><tr><td>Original file name</td><td>zero-terminated</td><td>optional, if FLG.FNAME set.</td></tr><tr><td>File comment</td><td>zero-terminated</td><td>optional, if FLG.FCOMMENT set.</td></tr><tr><td>Header CRC16</td><td>16 bits</td><td>optional, if FLG.FHCRC set.</td></tr></tbody></table><p>Flags (FLG)</p><table><thead><tr><th>fields</th><th>bit</th><th>description</th></tr></thead><tbody><tr><td>FTEXT</td><td>bit 0</td><td>If FTEXT is set, the file is probably ASCII text.</td></tr><tr><td>FHCRC</td><td>bit 1</td><td>If FHCRC is set, a CRC16 for the gzip header is present.</td></tr><tr><td>FEXTRA</td><td>bit 2</td><td>If FEXTRA is set, optional extra fields are present.</td></tr><tr><td>FNAME</td><td>bit 3</td><td>If FNAME is set, a zero-terminated original file name is present.</td></tr><tr><td>FCOMMENT</td><td>bit 4</td><td>If FCOMMENT is set, a zero-terminated file comment is present.</td></tr><tr><td>reserved</td><td>bit 5-7</td><td>Reserved FLG bits must be zero.</td></tr></tbody></table><p>Extra Flags (XFL) <em>(for CM &#x3D; 8)</em></p><table><thead><tr><th>value</th><th>description</th></tr></thead><tbody><tr><td>XFL &#x3D; 2</td><td>compressor used maximum compression, slowest algorithm.</td></tr><tr><td>XFL &#x3D; 4</td><td>compressor used fastest algorithm.</td></tr></tbody></table><p>Operating System (OS)</p><table><thead><tr><th>value</th><th>description</th></tr></thead><tbody><tr><td>0</td><td>FAT filesystem (MS-DOS, OS&#x2F;2, NT&#x2F;Win32)</td></tr><tr><td>1</td><td>Amiga</td></tr><tr><td>2</td><td>VMS (or OpenVMS)</td></tr><tr><td>3</td><td>Unix</td></tr><tr><td>4</td><td>VM&#x2F;CMS</td></tr><tr><td>5</td><td>Atari TOS</td></tr><tr><td>6</td><td>HPFS filesystem (OS&#x2F;2, NT)</td></tr><tr><td>7</td><td>Macintosh</td></tr><tr><td>8</td><td>Z-System</td></tr><tr><td>9</td><td>CP&#x2F;M</td></tr><tr><td>10</td><td>TOPS-20</td></tr><tr><td>11</td><td>NTFS filesystem (NT)</td></tr><tr><td>12</td><td>QDOS</td></tr><tr><td>13</td><td>Acorn RISCOS</td></tr><tr><td>255</td><td>unknown</td></tr></tbody></table><h3 id="Compressed-Data-1"><a href="#Compressed-Data-1" class="headerlink" title="Compressed Data"></a>Compressed Data</h3><p>For compression method 8, the compressed data is stored in the deflate compressed data format. For raw deflate format, please see <a href="https://www.mrbluyee.com/2024/03/23/deflate%20format/">deflate format</a></p><h3 id="GZIP-footer"><a href="#GZIP-footer" class="headerlink" title="GZIP footer"></a>GZIP footer</h3><table><thead><tr><th>footer fields</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>CRC-32 Checksum (CRC32)</td><td>32 bits</td><td>checksum value of the uncompressed data.</td></tr><tr><td>Input Size (ISIZE)</td><td>32 bits</td><td>size of the uncompressed input data modulo 2^32.</td></tr></tbody></table><h3 id="reference-1"><a href="#reference-1" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.ietf.org/rfc/rfc1952.txt">https://www.ietf.org/rfc/rfc1952.txt</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——data compression </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data compression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deflate format</title>
      <link href="/2024/03/23/deflate%20format/"/>
      <url>/2024/03/23/deflate%20format/</url>
      
        <content type="html"><![CDATA[<p>DEFLATE is a lossless data compression algorithm, it’s a combination of the LZ77 algorithm and Huffman coding.</p><h2 id="deflate-blocks"><a href="#deflate-blocks" class="headerlink" title="deflate blocks"></a>deflate blocks</h2><p>deflate compressed data format consists a series of blocks.<br>Each block has a 3 bit header, they are independent with each other:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>bit 0</td><td>BFINAL</td></tr><tr><td>bit 1-2</td><td>BTYPE</td></tr></tbody></table><p>Note that the header bits do not necessarily begin on a byte boundary,<br>since a block does not necessarily occupy an integral number of bytes.</p><p>BFINAL is set if and only if this is the last block of the data set.</p><p>BTYPE specifies the block type:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>b’00</td><td>no compression</td></tr><tr><td>b’01</td><td>compressed with fixed Huffman codes</td></tr><tr><td>b’10</td><td>compressed with dynamic Huffman codes</td></tr><tr><td>b’11</td><td>reserved (error)</td></tr></tbody></table><h3 id="no-compression-block-aka-stored-block"><a href="#no-compression-block-aka-stored-block" class="headerlink" title="no compression block (aka stored block)"></a>no compression block (aka stored block)</h3><p>no compression block contains the uncompressed original literal data.</p><table><thead><tr><th>type</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>BFINAL</td><td>1 bit</td><td>b’* (0 or 1)</td></tr><tr><td>BTYPE</td><td>2 bits</td><td>b’00</td></tr><tr><td>Reserved bits</td><td>&lt; 8 bits</td><td>make sure the offset of LEN is byte aligned</td></tr><tr><td>LEN</td><td>2 bytes</td><td>number of data bytes in the block</td></tr><tr><td>NLEN</td><td>2 bytes</td><td>NLEN &#x3D; 65535 - LEN, used for the number validation</td></tr><tr><td>Literal data</td><td>LEN in bytes</td><td>uncompressed data</td></tr></tbody></table><p>no compression block has the limited block sise, due to the maxium value of LEN is 65535.</p><h3 id="dynamic-Huffman-block"><a href="#dynamic-Huffman-block" class="headerlink" title="dynamic Huffman block"></a>dynamic Huffman block</h3><p>Dynamic Huffman block is compressed using a combination of the LZ77 algorithm and Huffman coding.<br>And the Huffman coding tree is dynamically generated at the compression stage, it’s stored within the block.</p><table><thead><tr><th>type</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>BFINAL</td><td>1 bit</td><td>b’* (0 or 1)</td></tr><tr><td>BTYPE</td><td>2 bits</td><td>b’10</td></tr><tr><td>HLIT</td><td>5 bits</td><td>number of Literal&#x2F;Length codes - 257 (257 - 286)</td></tr><tr><td>HDIST</td><td>5 bits</td><td>number of Distance codes - 1 (1 - 32)</td></tr><tr><td>HCLEN</td><td>4 bits</td><td>number of Code Length codes - 4 (4 - 19)</td></tr><tr><td>Code Length codes</td><td>3 bits * (HCLEN + 4)</td><td>code lengths for the code length table</td></tr><tr><td>literal&#x2F;length distance table</td><td>* bits (related to the HLIT, HDIST and the code length table)</td><td>2 huffman tree stored</td></tr><tr><td>huffman encoded bit stream</td><td>* bits</td><td>end with EOB symbol (256)</td></tr></tbody></table><p>Note: The huffman encoded bit stream has different bit order compared to other fields. (In the literal&#x2F;length distance table, it is also the huffman encoded bit stream but for the literal&#x2F;length distance code length info)</p><p>In the huffman encoded bit stream, it consist of sequences of symbols drawn from three conceptually distinct alphabets: either literal bytes, from the alphabet of byte values (0..255), or (length, backward distance) pairs.</p><p>The representation used in this bit stream limits distances to 32K bytes and lengths to 258 bytes, but does not limit the size of the block,<br>thus, the length is drawn from (3..258) and the distance is drawn from (1..32,768).</p><p>In fact, the literal and length alphabets are merged into a single alphabet (0..285),<br>where values 0..255 represent literal bytes, the value 256 indicates end-of-block.<br>And values 257..285 represent length codes (possibly in conjunction with extra bits following the symbol code) as follows:</p><table><thead><tr><th>code</th><th>extra bits</th><th>length</th><th>code</th><th>extra bits</th><th>length</th><th>code</th><th>extra bits</th><th>length</th></tr></thead><tbody><tr><td>257</td><td>0</td><td>3</td><td>267</td><td>1</td><td>15,16</td><td>277</td><td>4</td><td>67-82</td></tr><tr><td>258</td><td>0</td><td>4</td><td>268</td><td>1</td><td>17,18</td><td>278</td><td>4</td><td>83-98</td></tr><tr><td>259</td><td>0</td><td>5</td><td>269</td><td>2</td><td>19-22</td><td>279</td><td>4</td><td>99-114</td></tr><tr><td>260</td><td>0</td><td>6</td><td>270</td><td>2</td><td>23-26</td><td>280</td><td>4</td><td>115-130</td></tr><tr><td>261</td><td>0</td><td>7</td><td>271</td><td>2</td><td>27-30</td><td>281</td><td>5</td><td>131-162</td></tr><tr><td>262</td><td>0</td><td>8</td><td>272</td><td>2</td><td>31-34</td><td>282</td><td>5</td><td>163-194</td></tr><tr><td>263</td><td>0</td><td>9</td><td>273</td><td>3</td><td>35-42</td><td>283</td><td>5</td><td>195-226</td></tr><tr><td>264</td><td>0</td><td>10</td><td>274</td><td>3</td><td>43-50</td><td>284</td><td>5</td><td>227-257</td></tr><tr><td>265</td><td>1</td><td>11,12</td><td>275</td><td>3</td><td>51-58</td><td>285</td><td>0</td><td>258</td></tr><tr><td>266</td><td>1</td><td>13,14</td><td>276</td><td>3</td><td>59-66</td><td></td><td></td><td></td></tr></tbody></table><p>The distance code has another alphabet, the value is from 0 to 29:</p><table><thead><tr><th>code</th><th>extra bits</th><th>distance</th><th>code</th><th>extra bits</th><th>distance</th><th>code</th><th>extra bits</th><th>distance</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>10</td><td>4</td><td>33-48</td><td>20</td><td>9</td><td>1025-1536</td></tr><tr><td>1</td><td>0</td><td>2</td><td>11</td><td>4</td><td>49-64</td><td>21</td><td>9</td><td>1537-2048</td></tr><tr><td>2</td><td>0</td><td>3</td><td>12</td><td>5</td><td>65-96</td><td>22</td><td>10</td><td>2049-3072</td></tr><tr><td>3</td><td>0</td><td>4</td><td>13</td><td>5</td><td>97-128</td><td>23</td><td>10</td><td>3073-4096</td></tr><tr><td>4</td><td>1</td><td>5,6</td><td>14</td><td>6</td><td>129-192</td><td>24</td><td>11</td><td>4097-6144</td></tr><tr><td>5</td><td>1</td><td>7,8</td><td>15</td><td>6</td><td>193-256</td><td>25</td><td>11</td><td>6145-8192</td></tr><tr><td>6</td><td>2</td><td>9-12</td><td>16</td><td>7</td><td>257-384</td><td>26</td><td>12</td><td>8193-12288</td></tr><tr><td>7</td><td>2</td><td>13-16</td><td>17</td><td>7</td><td>385-512</td><td>27</td><td>12</td><td>12289-16384</td></tr><tr><td>8</td><td>3</td><td>17-24</td><td>18</td><td>8</td><td>513-768</td><td>28</td><td>13</td><td>16385-24576</td></tr><tr><td>9</td><td>3</td><td>25-32</td><td>19</td><td>8</td><td>769-1024</td><td>29</td><td>13</td><td>24577-32768</td></tr></tbody></table><p>Generally, the data in the huffman encoded bit stream has the below format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">literal huffman code,</span><br><span class="line">.. , </span><br><span class="line">length huffman code, (extra bits), distance huffman code, (extra bits),</span><br><span class="line">.. ,</span><br><span class="line">end of block huffman code.</span><br></pre></td></tr></table></figure><p>And after the huffman decode, it translate to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">literal symbol (0-255),</span><br><span class="line">.. , </span><br><span class="line">length symbol (257-285), (extra bits), distance symbol (0-29), (extra bits),</span><br><span class="line">.. ,</span><br><span class="line">end of block symbol (256).</span><br></pre></td></tr></table></figure><p>Due to there has 2 alphabets: literal and length shared the same alphabet, distance used another alphabet.<br>There has 2 huffman coding trees, one is for the literal and length code, another is for the distance code. But they don’t get stored into the block directly.</p><p><em>Below steps show how to get these 2 huffman tables from the info stored within the block:</em></p><p>First thing is deflate also pre-defined a code length table:</p><table><thead><tr><th>index</th><th>code length</th><th>description</th></tr></thead><tbody><tr><td>0</td><td>16</td><td>repeat last length for (3 + extra: 3-6) times, follow with extra info (2 bits)</td></tr><tr><td>1</td><td>17</td><td>repeat zero for (3 + extra: 3-10) times, follow with extra info (3 bits)</td></tr><tr><td>2</td><td>18</td><td>repeat zero for (11 + extra: 11-138) times, follow with extra info (7 bits)</td></tr><tr><td>3</td><td>0</td><td>literal&#x2F;length &amp; distance code length encoded to 0 bit</td></tr><tr><td>4</td><td>8</td><td>literal&#x2F;length &amp; distance code length encoded to 8 bits</td></tr><tr><td>5</td><td>7</td><td>literal&#x2F;length &amp; distance code length encoded to 7 bits</td></tr><tr><td>6</td><td>9</td><td>literal&#x2F;length &amp; distance code length encoded to 9 bits</td></tr><tr><td>7</td><td>6</td><td>literal&#x2F;length &amp; distance code length encoded to 6 bits</td></tr><tr><td>8</td><td>10</td><td>literal&#x2F;length &amp; distance code length encoded to 10 bits</td></tr><tr><td>9</td><td>5</td><td>literal&#x2F;length &amp; distance code length encoded to 5 bits</td></tr><tr><td>10</td><td>11</td><td>literal&#x2F;length &amp; distance code length encoded to 11 bits</td></tr><tr><td>11</td><td>4</td><td>literal&#x2F;length &amp; distance code length encoded to 4 bits</td></tr><tr><td>12</td><td>12</td><td>literal&#x2F;length &amp; distance code length encoded to 12 bits</td></tr><tr><td>13</td><td>3</td><td>literal&#x2F;length &amp; distance code length encoded to 3 bits</td></tr><tr><td>14</td><td>13</td><td>literal&#x2F;length &amp; distance code length encoded to 13 bits</td></tr><tr><td>15</td><td>2</td><td>literal&#x2F;length &amp; distance code length encoded to 2 bits</td></tr><tr><td>16</td><td>14</td><td>literal&#x2F;length &amp; distance code length encoded to 14 bits</td></tr><tr><td>17</td><td>1</td><td>literal&#x2F;length &amp; distance code length encoded to 1 bit</td></tr><tr><td>18</td><td>15</td><td>literal&#x2F;length &amp; distance code length encoded to 15 bits</td></tr></tbody></table><p>4 bits HCLEN shows that the size of the stored code length info, the value is from 0 to 15,<br>and it indicates the number of the stored code length info, from 4 to 19.</p><p>For example, if HCLEN&#x3D;12, then the first 16 code length info get stored with the block with 3-bit size each.<br>And from the index 16 to index 18, these code length info are just not stored, it means they are not used.<br>Also, if there has the 0 value with the 3-bits, that means the correspond code length is not used.</p><p>Let’s assume, these 16 code length info has the listed 3-bits value: [1,0,5,5,3,0,5,0,4,0,0,4,0,5,0,3]<br>Then, it tells us:</p><table><thead><tr><th>index</th><th>code length</th><th>description</th></tr></thead><tbody><tr><td>0</td><td>16</td><td>code length code 16 huffman encoded length: 1 bit</td></tr><tr><td>1</td><td>17</td><td>code length code 17 not used</td></tr><tr><td>2</td><td>18</td><td>code length code 18 huffman encoded length: 5 bits</td></tr><tr><td>3</td><td>0</td><td>code length code 0 huffman encoded length: 5 bits</td></tr><tr><td>4</td><td>8</td><td>code length code 8 huffman encoded length: 3 bits</td></tr><tr><td>5</td><td>7</td><td>code length code 7 not used</td></tr><tr><td>6</td><td>9</td><td>code length code 9 huffman encoded length: 5 bits</td></tr><tr><td>7</td><td>6</td><td>code length code 6 not used</td></tr><tr><td>8</td><td>10</td><td>code length code 10 huffman encoded length: 4 bits</td></tr><tr><td>9</td><td>5</td><td>code length code 5 not used</td></tr><tr><td>10</td><td>11</td><td>code length code 11 not used</td></tr><tr><td>11</td><td>4</td><td>code length code 4 huffman encoded length: 4 bits</td></tr><tr><td>12</td><td>12</td><td>code length code 12 not used</td></tr><tr><td>13</td><td>3</td><td>code length code 3 huffman encoded length: 5 bits</td></tr><tr><td>14</td><td>13</td><td>code length code 13 not used</td></tr><tr><td>15</td><td>2</td><td>code length code 2 huffman encoded length: 3 bits</td></tr><tr><td>16</td><td>14</td><td>code length code 14 not used, value not stored</td></tr><tr><td>17</td><td>1</td><td>code length code 1 not used, value not stored</td></tr><tr><td>18</td><td>15</td><td>code length code 15 not used, value not stored</td></tr></tbody></table><p>we can define the Huffman code for an alphabet just by giving the bit lengths of the codes for each symbol of the alphabet in order; this is sufficient to determine the actual codes. </p><p>For this example, let’s sort it as:</p><table><thead><tr><th>code length symbol</th><th>encoded length</th></tr></thead><tbody><tr><td>16</td><td>1 bit</td></tr><tr><td>2</td><td>3 bit</td></tr><tr><td>8</td><td>3 bit</td></tr><tr><td>4</td><td>4 bit</td></tr><tr><td>10</td><td>4 bit</td></tr><tr><td>0</td><td>5 bit</td></tr><tr><td>3</td><td>5 bit</td></tr><tr><td>9</td><td>5 bit</td></tr><tr><td>18</td><td>5 bit</td></tr></tbody></table><p>Step 1: Count the number of codes for each code length.<br>Let bl_count[N] be the number of codes of length N, N &gt;&#x3D; 1.</p><table><thead><tr><th>code length symbol</th><th>encoded length</th><th>number of code of length</th></tr></thead><tbody><tr><td>16</td><td>1 bit</td><td>1 symbol encoded to 1 bit</td></tr><tr><td>2</td><td>3 bit</td><td>2 symbol encoded to 3 bits</td></tr><tr><td>8</td><td>3 bit</td><td>-</td></tr><tr><td>4</td><td>4 bit</td><td>2 symbol encoded to 4 bits</td></tr><tr><td>10</td><td>4 bit</td><td>-</td></tr><tr><td>0</td><td>5 bit</td><td>4 symbol encoded to 5 bits</td></tr><tr><td>3</td><td>5 bit</td><td>-</td></tr><tr><td>9</td><td>5 bit</td><td>-</td></tr><tr><td>18</td><td>5 bit</td><td>-</td></tr></tbody></table><p>So, the bl_count has value [0, 1, 0, 2, 2, 4]</p><p>Step 2: Find the numerical value of the smallest code for each code length:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">code = 0;</span><br><span class="line">bl_count[0] = 0;</span><br><span class="line">for (bits = 1; bits &lt;= MAX_BITS; bits++) &#123;</span><br><span class="line">    code = (code + bl_count[bits-1]) &lt;&lt; 1;</span><br><span class="line">    next_code[bits] = code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>code length symbol</th><th>encoded length</th><th>number of code of length</th><th>encoded code</th></tr></thead><tbody><tr><td>16</td><td>1 bit</td><td>bl_count[1] &#x3D; 1</td><td>0 (b’0)</td></tr><tr><td>2</td><td>3 bit</td><td>bl_count[3] &#x3D; 2</td><td>4 (b’100)</td></tr><tr><td>8</td><td>3 bit</td><td>-</td><td></td></tr><tr><td>4</td><td>4 bit</td><td>bl_count[4] &#x3D; 2</td><td>12 (b’1100)</td></tr><tr><td>10</td><td>4 bit</td><td>-</td><td></td></tr><tr><td>0</td><td>5 bit</td><td>bl_count[5] &#x3D; 4</td><td>28 (b’11100)</td></tr><tr><td>3</td><td>5 bit</td><td>-</td><td></td></tr><tr><td>9</td><td>5 bit</td><td>-</td><td></td></tr><tr><td>18</td><td>5 bit</td><td>-</td><td></td></tr></tbody></table><p>Step 3: Assign numerical values to all codes, using consecutive values for all codes of the same length with the base values determined at step 2. </p><table><thead><tr><th>code length symbol</th><th>encoded length</th><th>number of code of length</th><th>encoded code</th></tr></thead><tbody><tr><td>16</td><td>1 bit</td><td>bl_count[1] &#x3D; 1</td><td>0 (b’0)</td></tr><tr><td>2</td><td>3 bit</td><td>bl_count[3] &#x3D; 2</td><td>4 (b’100)</td></tr><tr><td>8</td><td>3 bit</td><td>-</td><td>5 (b’101)</td></tr><tr><td>4</td><td>4 bit</td><td>bl_count[4] &#x3D; 2</td><td>12 (b’1100)</td></tr><tr><td>10</td><td>4 bit</td><td>-</td><td>13 (b’1101)</td></tr><tr><td>0</td><td>5 bit</td><td>bl_count[5] &#x3D; 4</td><td>28 (b’11100)</td></tr><tr><td>3</td><td>5 bit</td><td>-</td><td>29 (b’11101)</td></tr><tr><td>9</td><td>5 bit</td><td>-</td><td>30 (b’11110)</td></tr><tr><td>18</td><td>5 bit</td><td>-</td><td>31 (b’11111)</td></tr></tbody></table><p>for now, we have constructed the code length huffman tree as shown in below:</p><table><thead><tr><th>index</th><th>code length</th><th>description</th></tr></thead><tbody><tr><td>0</td><td>16</td><td>code length code 16 encoded to 0 (b’0)</td></tr><tr><td>1</td><td>17</td><td>-</td></tr><tr><td>2</td><td>18</td><td>code length code 18 encoded to 31 (b’11111)</td></tr><tr><td>3</td><td>0</td><td>code length code 0 encoded to 28 (b’11100)</td></tr><tr><td>4</td><td>8</td><td>code length code 8 encoded to 5 (b’101)</td></tr><tr><td>5</td><td>7</td><td>-</td></tr><tr><td>6</td><td>9</td><td>code length code 9 encoded to 30 (b’11110)</td></tr><tr><td>7</td><td>6</td><td>-</td></tr><tr><td>8</td><td>10</td><td>code length code 10 encoded to 13 (b’1101)</td></tr><tr><td>9</td><td>5</td><td>-</td></tr><tr><td>10</td><td>11</td><td>-</td></tr><tr><td>11</td><td>4</td><td>code length code 4 encoded to 12 (b’1100)</td></tr><tr><td>12</td><td>12</td><td>-</td></tr><tr><td>13</td><td>3</td><td>code length code 3 encoded to 29 (b’11101)</td></tr><tr><td>14</td><td>13</td><td>-</td></tr><tr><td>15</td><td>2</td><td>code length code 2 encoded to 4 (b’100)</td></tr><tr><td>16</td><td>14</td><td>-</td></tr><tr><td>17</td><td>1</td><td>-</td></tr><tr><td>18</td><td>15</td><td>-</td></tr></tbody></table><p>Note: Codes that are never used (which have a bit length of zero) must not be assigned a value.</p><p>This code length huffman tree is used to decode the following literal&#x2F;length distance table.<br>And from this table, we will construct the literal&#x2F;length huffman tree and the distance huffman tree.</p><p>We know that there has 0-285 value in the literal&#x2F;length alphabet, and 0-29 value in the distance alphabet.<br>But not all of them may get used in the current dynamic huffman block, thus, we have the stored value 5 bits HLIT and the 5 bits HDIST to show the symbol usage info.</p><p>For example, if the HLIT value is 1, that means the first (1 + 257) value in the literal&#x2F;length alphabet are get stored in the literal&#x2F;length distance table, and the value 258 to 285 are not in the literal&#x2F;length distance table. (for sure, they are not get used within the current block.)</p><p>If the HDIST value is 23, that means the first (23 + 1) value in the distance alphabet are get stored in the literal&#x2F;length distance table. (after the stored literal&#x2F;length symbol value), and the value 24 to 29 are not in the literal&#x2F;length distance table. (for sure, they are not get used within the current block.)</p><p>Previously, we have construct the code length huffman tree, and it can be used to decode the literal&#x2F;length distance table. Assume, below value is huffman decoded from the literal&#x2F;length distance table:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5, </span><br><span class="line">0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3),</span><br><span class="line">0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3),</span><br><span class="line">5, 30, 5, 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3), 0, (3),</span><br><span class="line">13, 13, 31, (6), 12, 12, 28, 4, 4, 4, 29</span><br></pre></td></tr></table></figure><p>According this decoded value, we can get the below table:</p><table><thead><tr><th>index</th><th>value from literal&#x2F;length distance table</th><th>symbol code length</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>8 bits</td></tr><tr><td>1-6</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>7-12</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>13-18</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>19-25</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>31-37</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>43-48</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>49-54</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>55-60</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>61-66</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>67-72</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>73-78</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>79-84</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>85-90</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>91-96</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>97-102</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>103-108</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>109-114</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>115-120</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>121-126</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>127-132</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>133-138</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>139-144</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>145-150</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>151-156</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>157-162</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>163-167</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>169-174</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>175-180</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>181-186</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>187-182</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>193-198</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>199-204</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>205</td><td>5</td><td>8 bits</td></tr><tr><td>206</td><td>30</td><td>9 bits</td></tr><tr><td>207</td><td>5</td><td>8 bits</td></tr><tr><td>208-213</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>214-219</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>220-225</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>226-231</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>232-237</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>238-243</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>244-249</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>250-255</td><td>0, (3)</td><td>16, repeat previous length code 8 for 6 times</td></tr><tr><td>256</td><td>13</td><td>10 bits</td></tr><tr><td>257</td><td>13</td><td>10 bits</td></tr></tbody></table><table><thead><tr><th>index</th><th>value from literal&#x2F;length distance table</th><th>symbol code length</th></tr></thead><tbody><tr><td>0-16</td><td>31, (6)</td><td>18, repeat length code 0 for 17 times</td></tr><tr><td>17</td><td>12</td><td>4 bits</td></tr><tr><td>18</td><td>12</td><td>4 bits</td></tr><tr><td>19</td><td>28</td><td>0 bits</td></tr><tr><td>20</td><td>4</td><td>2 bits</td></tr><tr><td>21</td><td>4</td><td>2 bits</td></tr><tr><td>22</td><td>4</td><td>2 bits</td></tr><tr><td>23</td><td>29</td><td>3 bits</td></tr></tbody></table><p>With the same method of the construct of the code length huffman tree, we can construct the literal&#x2F;length huffman tree and distance huffman tree.</p><h3 id="fixed-Huffman-block"><a href="#fixed-Huffman-block" class="headerlink" title="fixed Huffman block"></a>fixed Huffman block</h3><p>For the fixed Huffman block, the Huffman codes for the two alphabets are fixed, and are not represented explicitly in the data:</p><table><thead><tr><th>type</th><th>size</th><th>description</th></tr></thead><tbody><tr><td>BFINAL</td><td>1 bit</td><td>b’* (0 or 1)</td></tr><tr><td>BTYPE</td><td>2 bits</td><td>b’01</td></tr><tr><td>huffman encoded bit stream</td><td>* bits</td><td>end with EOB symbol (256)</td></tr></tbody></table><p>The Huffman code lengths for the literal&#x2F;length alphabet are:</p><table><thead><tr><th>index</th><th>code length</th></tr></thead><tbody><tr><td>0-143</td><td>8 bits</td></tr><tr><td>144-255</td><td>9 bits</td></tr><tr><td>256-279</td><td>7 bits</td></tr><tr><td>280-285</td><td>8 bits</td></tr></tbody></table><p>The Huffman code lengths for the distance alphabet are:</p><table><thead><tr><th>index</th><th>code length</th></tr></thead><tbody><tr><td>0-29</td><td>5 bits</td></tr></tbody></table><p>With these info, we can easily construct the 2 huffman trees.</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://datatracker.ietf.org/doc/html/rfc1951">https://datatracker.ietf.org/doc/html/rfc1951</a> </p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——data compression </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data compression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPsec</title>
      <link href="/2019/09/23/IPsec/"/>
      <url>/2019/09/23/IPsec/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>IPsec是IP Security的简称。IPsec不是具体指哪个协议，而是一组开放的基于网络层的，应用密码学的安全通信协议族，它是IETF制定的，在IP层对IP报文提供安全服务，目标是为IP提供高安全性的特性。<br>IPsec本身定义了如何在IP数据中增加字段来保证IP包的完整性、私有性和真实性。</p><span id="more"></span><h5 id="IPsec协议族"><a href="#IPsec协议族" class="headerlink" title="IPsec协议族"></a>IPsec协议族</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/IPsec%E5%8D%8F%E8%AE%AE%E6%97%8F.JPG" alt="IPsec协议族"></p><p>IPsec协议族相关的RFC</p><table><thead><tr><th>RFC</th><th>内容</th></tr></thead><tbody><tr><td><a href="https://tools.ietf.org/html/rfc2401">2401</a></td><td>IPsect体系结构</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2402">2402</a></td><td>AH(Authentication Header)协议</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2403">2403</a></td><td>HMAC-MD5-96在AH和ESP中的应用</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2404">2404</a></td><td>HMAC-SHA-1-96在AH和ESP中的应用</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2405">2405</a></td><td>DES-CBC在ESP中的应用</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2406">2406</a></td><td>ESP(Encapsulating Security Payload)协议</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2407">2407</a></td><td>IPsec DOI</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2408">2408</a></td><td>ISAKMP协议</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2409">2409</a></td><td>IKE(Internet Key Exchange)协议</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2410">2410</a></td><td>NULL加密算法及在IPsec中的应用</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2411">2411</a></td><td>IPsec文档路线图</td></tr><tr><td><a href="https://tools.ietf.org/html/rfc2412">2412</a></td><td>OAKLEY协议</td></tr></tbody></table><h5 id="IPsec安全体系框架"><a href="#IPsec安全体系框架" class="headerlink" title="IPsec安全体系框架"></a>IPsec安全体系框架</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/IPsec%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E6%A1%86%E6%9E%B6.JPG" alt="IPsec安全体系框架"></p><h5 id="IPsec的安全特性"><a href="#IPsec的安全特性" class="headerlink" title="IPsec的安全特性"></a>IPsec的安全特性</h5><p>1.无连接数据完整性(Data Integrity)<br>IPsec接收方对发送方发送来的包进行认证，以确保数据在传输过程中没有被篡改。</p><p>2.数据源认证(Data Authentication)<br>IPsec接收方对IPsec包的源地址进行认证。这项服务基于数据完整性服务。</p><p>3.抗重放服务(Anti-Replay)<br>IPsec接收方可检测并拒绝接收过时或重复的报文。</p><p>4.数据机密性(Confidentiality)<br>IPsec发送方在通过网络传输包前对包进行加密。</p><p>5.有限的数据流保护(Limited Traffic-flow Confidentiality)</p><p>AH和ESP的对比：</p><table><thead><tr><th>安全性</th><th>AH</th><th>ESP</th></tr></thead><tbody><tr><td>协议号</td><td>50</td><td>51</td></tr><tr><td>数据完整性校验</td><td>支持</td><td>支持(不验证IP头)</td></tr><tr><td>数据源验证</td><td>支持</td><td>支持</td></tr><tr><td>数据加解密</td><td>不支持</td><td>支持</td></tr><tr><td>抗重放服务</td><td>支持</td><td>支持</td></tr><tr><td>有限的数据流保护</td><td>不支持</td><td>支持</td></tr><tr><td>NAT-T(NAT穿越)</td><td>不支持</td><td>支持</td></tr></tbody></table><h5 id="IPsec-×××"><a href="#IPsec-×××" class="headerlink" title="IPsec ×××"></a>IPsec ×××</h5><p>是基于IPsec协议族构建的在IP层实现的安全虚拟专用网。通过在数据包中插入一个预定义头部的方式，<br>来保证OSI上层协议的安全，主要用于保护TCP、UDP、ICMP和隧道的IP数据包。</p><p>VPN是IPsec的一种应用方式，IPsec VPN的应用场景分为3种：<br><strong>1.Site-to-Site（站点到站点或者网关到网关）</strong><br>企业内网（若干PC）之间的数据通过这些网关建立的IPSec隧道实现安全互联。</p><p><strong>2.End-to-End（端到端或者PC到PC）</strong><br>两个PC之间的通信由两个PC之间的IPSec会话保护。</p><p><strong>3.End-to-Site（端到站点或者PC到网关）</strong><br>两个PC之间的通信由网关和异地PC之间的IPSec进行保护。</p><h4 id="AH协议-使用较少"><a href="#AH协议-使用较少" class="headerlink" title="AH协议 (使用较少)"></a>AH协议 (使用较少)</h4><p>AH为报文验证头协议（协议号51），可以同时提供数据完整性确认、数据来源确认、防重放等安全特性。<br>AH插到标准IP包头后面，它保证数据包的完整性和真实性，防止黑客截断数据包或向网络中插入伪造的数据包。<br>AH常用摘要算法（单向hash函数）MD5和SHA1实现该特性。<br><strong>为什么AH使用较少？</strong><br>1.AH无法提供数据加密，所有数据在传输时以明文传输，而ESP提供数据加密。<br>2.AH因为提供数据来源确认（源IP地址一旦改变，AH校验失败），所以无法穿越NAT。</p><h5 id="AH协议工作在传输模式"><a href="#AH协议工作在传输模式" class="headerlink" title="AH协议工作在传输模式"></a>AH协议工作在传输模式</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/AH%E5%8D%8F%E8%AE%AE%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F.JPG" alt="AH协议工作在传输模式"></p><h5 id="AH协议工作在隧道模式"><a href="#AH协议工作在隧道模式" class="headerlink" title="AH协议工作在隧道模式"></a>AH协议工作在隧道模式</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/AH%E5%8D%8F%E8%AE%AE%E9%9A%A7%E9%81%93%E6%A8%A1%E5%BC%8F.JPG" alt="AH协议工作在隧道模式"></p><h5 id="AH头结构"><a href="#AH头结构" class="headerlink" title="AH头结构"></a>AH头结构</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/AH%E5%A4%B4%E7%BB%93%E6%9E%84.JPG" alt="AH头结构"><br><strong>Next Header 下一头部 (8 bits)</strong><br>标识认证头后面的下一个载荷类型（标识被传送数据所属的协议）。<br><strong>Payload Len 载荷长度 (8 bits)</strong><br>表示认证头包的大小，以32bit为单位的AH头部长度-2，default&#x3D;4<br><strong>Reserved 保留 (16 bits)</strong><br>为将来的应用保留（当前都置为0）。<br><strong>Security Parameters Index (SPI) 安全参数索引 (32 bits)</strong><br>与IP地址一同用来标识安全参数，用于表示有相同IP地址和相同安全协议的不同SA。由SA的创建者定义，只有逻辑意义。<br><strong>Sequence Number 序列号 (32 bits)</strong><br>一个单向递增的计数器，用于防止重放攻击，SA建立之初初始化为0，序列号不允许重复。<br><strong>Integrity Check Value (ICV) 完整性校验值  (multiple of 32 bits)</strong><br>认证数据（包含了认证当前包所必须的数据），由SA初始化时指定的算法来计算。</p><h4 id="ESP协议-使用广泛"><a href="#ESP协议-使用广泛" class="headerlink" title="ESP协议 (使用广泛)"></a>ESP协议 (使用广泛)</h4><p>ESP为报文安全封装协议（协议号50），它将需要保护的用户数据进行加密后再封装到IP包中，保证数据的完整性、真实性和私有性。<br>ESP可以同时提供数据完整性确认、数据加密、防重放等安全特性。<br>ESP通常使用DES、3DES、AES等加密算法实现数据加密，使用MD5或SHA1来实现数据完整性。</p><h5 id="ESP协议工作在传输模式"><a href="#ESP协议工作在传输模式" class="headerlink" title="ESP协议工作在传输模式"></a>ESP协议工作在传输模式</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/ESP%E5%8D%8F%E8%AE%AE%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F.JPG" alt="ESP协议工作在传输模式"></p><h5 id="ESP协议工作在隧道模式"><a href="#ESP协议工作在隧道模式" class="headerlink" title="ESP协议工作在隧道模式"></a>ESP协议工作在隧道模式</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/ESP%E5%8D%8F%E8%AE%AE%E9%9A%A7%E9%81%93%E6%A8%A1%E5%BC%8F.JPG" alt="ESP协议工作在隧道模式"></p><h5 id="ESP包结构"><a href="#ESP包结构" class="headerlink" title="ESP包结构"></a>ESP包结构</h5><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/ESP%E5%8C%85%E7%BB%93%E6%9E%84.JPG" alt="ESP包结构"><br><strong>Security Parameters Index (SPI) 安全参数索引 (32 bits)</strong><br>与IP地址一同用来标识安全参数，用于表示有相同IP地址和相同安全协议的不同SA。由SA的创建者定义，只有逻辑意义。<br><strong>Sequence Number 序列号 (32 bits)</strong><br>一个单向递增的计数器，用于防止重放攻击，SA建立之初初始化为0，序列号不允许重复。<br><strong>Payload data 载荷数据 (variable)</strong><br>包含由下一个头部字段给出的变长数据<br><strong>Padding 填充字段 (0-255 octets)</strong><br>大多数加密算法要求输入数据包含整数个分组，因此需要填充。<br><strong>Pad Length 填充长度 (8 bits)</strong><br>给出前面填充字段的长度，置0时表示没有填充。<br><strong>Next Header 下一头部 (8 bits)</strong><br>标识认证头后面的下一个载荷类型（标识被传送数据所属的协议）。<br><strong>Integrity Check Value (ICV) 完整性校验值  (multiple of 32 bits)</strong><br>认证数据（包含了认证当前包所必须的数据），由SA初始化时指定的算法来计算。</p><h4 id="IPsec的两种模式比较"><a href="#IPsec的两种模式比较" class="headerlink" title="IPsec的两种模式比较"></a>IPsec的两种模式比较</h4><p><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/IPsec%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.jpg" alt="IPsec的两种模式应用场景"><br>隧道模式可以适用于任何场景.传输模式只能适合PC到PC的场景。<br>隧道模式虽然可以适用于任何场景，但是隧道模式需要多一层IP头（通常为20字节长度）开销，所以在PC到PC的场景，建议还是使用传输模式。<br><strong>传输模式：</strong><br>传输模式在AH、ESP处理前后IP头部保持不变，主要用于End-to-End的应用场景。<br><strong>隧道模式:</strong><br>隧道模式在AH、ESP处理之后再封装了一个外网IP头，主要用于Site-to-site的应用场景。</p><p><strong>为什么在Site-to-Site场景中只能使用隧道模式：</strong><br><img src="/images/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/IPsec/S2S%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.jpg" alt="Site-to-Site场景分析"><br>1.IPSec会话建立在发起方、响应方两个网关之间。<br>2.由于使用传输模式，所以IP头部并不会有任何变化，IP源地址是192.168.1.2，目的地址是10.1.1.2。<br>3.因为源、目的地址都是私有地址，Internet中不会维护企业自己网络的路由，该数据包在Internet中大概率被丢弃。<br>4.假设数据包成功穿越了Internet，因为目的地址不是响应方网关(2.17.1.2),所以响应方直接将包转发给内网PC。<br>5.最后响应方内网PC收到数据包，因为没有参与IPsec协商，没有对应的SA,所以密文数据无法解密而被PC丢弃。</p><p><strong>在Site-to-Site情况下使用传输模式的充要条件：</strong><br>兴趣流必须完全在发起方、响应方IP地址范围内的流量，协议可以是任意的。<br>比如发起方IP地址为6.24.1.2，响应方IP地址为2.17.1.2，那么兴趣流可以是源6.24.1.2&#x2F;32、目的是2.17.1.2&#x2F;32。<br>若数据包的源、目的IP地址不同，则应使用隧道模式。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数的素性测试</title>
      <link href="/2019/07/21/%E6%95%B0%E7%9A%84%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/07/21/%E6%95%B0%E7%9A%84%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="数的素性测试"><a href="#数的素性测试" class="headerlink" title="数的素性测试"></a>数的素性测试</h3><p>概念：整数p(p&gt;1)是素数,当且仅当其公因数只有1与其本身。<br><a href="https://github.com/MrBluyee/arithmetic_c/tree/master/greast_common_divisor">github源码</a></p><span id="more"></span><h4 id="相关定理"><a href="#相关定理" class="headerlink" title="相关定理"></a>相关定理</h4><p>1.任意整数a&gt;1都可以唯一的因式分解为：<br>$a &#x3D; p_{1}^{a_{1}} \times p_{2}^{a_{2}} \times … \times p_{n}^{a_{n}}$<br>其中$p_{1},p_{2},…,p_{n}$都是素数($p_{1} \lt p_{2} \lt … \lt p_{n}$)，<br>所有的$a_{i}$都是正整数。<br>例如$12 &#x3D; 2^{2} \times 3^{1}$ </p><p>另一种表示方法：<br>设P是所有素数的集合，则任意正整数a可唯一的表示为<br>$a &#x3D; \prod p^{a_{p}}, {p \in P} ,a_{p} \ge 0$<br>对于任意的a，其大多数指数$a_{p}$为0，那么可根据上面的公式，以所有非零指数来唯一的表示一个正整数。<br>例如，整数12可用{$a_{2}&#x3D;2,a_{3}&#x3D;1$}来表示。</p><p>我们知道，$a^{b} \times a^{c} &#x3D; a^{b+c}$,<br>设$k&#x3D;ab$，<br>$a&#x3D; \prod p^{a_{p}},b&#x3D; \prod p^{b_{p}},k&#x3D; \prod p^{k_{p}}$<br>则对于所有的$p \in P$,有$k_{p} &#x3D; a_{p} + b_{p}$成立。</p><p>从素因子的角度看，a整除b意味着，对于任意的$p \in P$，有$a_{p} \le b_{p}$。</p><p>若将整数以上述公式表示，则很容易确定两个正整数的最大公约数。<br>例如：<br>$300 &#x3D; 2^{2} \times 3^{1} \times 5^{2}$<br>$18 &#x3D; 2^{1} \times 3^{2}$<br>则$gcd(18,300) &#x3D; 2^{1} \times 3^{1} &#x3D; 6$ </p><p>即如果$d&#x3D;gcd(a, b)$,则有$d_{p}&#x3D;min(a_{p},b_{p})$</p><p>2.费马定理<br>第一种表述：<br>若p是素数，a是正整数且不能被p整除，则：<br>$$a^{p-1} \ mod \ p &#x3D; 1 \ mod \ p$$<br>例：<br>a&#x3D;7,p&#x3D;19<br>$a^{p-1}&#x3D;7^{18}$<br>$7^{18} \ mod \ 19 &#x3D; 1 \ mod \ 19$</p><p>第二种表述：<br>若p是素数，a是任意正整数，则：<br>$$a^{p} \ mod \ p &#x3D; a \ mod \ p$$<br>例：<br>a&#x3D;3,p&#x3D;5<br>$a^{p}&#x3D;3^{5}$<br>$3^{5} \ mod \ 5 &#x3D; 3 \ mod \ 5$</p><p>3.欧拉定理</p><p>3.a 欧拉函数$\phi (n)$<br>$\phi (n)$为小于n且与n互素的正整数的个数。<br>$\phi (1) &#x3D; 1$</p><p>欧拉函数$\phi (n)$前30项的值：</p><table><thead><tr><th>n</th><th>$\phi (n)$</th><th>n</th><th>$\phi (n)$</th><th>n</th><th>$\phi (n)$</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>11</td><td>10</td><td>21</td><td>12</td></tr><tr><td>2</td><td>1</td><td>12</td><td>4</td><td>22</td><td>10</td></tr><tr><td>3</td><td>2</td><td>13</td><td>12</td><td>23</td><td>22</td></tr><tr><td>4</td><td>2</td><td>14</td><td>6</td><td>24</td><td>8</td></tr><tr><td>5</td><td>4</td><td>15</td><td>8</td><td>25</td><td>20</td></tr><tr><td>6</td><td>2</td><td>16</td><td>8</td><td>26</td><td>12</td></tr><tr><td>7</td><td>6</td><td>17</td><td>16</td><td>27</td><td>18</td></tr><tr><td>8</td><td>4</td><td>18</td><td>6</td><td>28</td><td>12</td></tr><tr><td>9</td><td>6</td><td>19</td><td>18</td><td>29</td><td>28</td></tr><tr><td>10</td><td>4</td><td>20</td><td>8</td><td>30</td><td>8</td></tr></tbody></table><p>显然，对于素数p有<br>$\phi (p) &#x3D; p-1$</p><p>3.b 欧拉定理<br>第一种表述：<br>对任意互素的正整数a和n，有：<br>$$ a^{\phi (n)} \ mod \ n &#x3D; 1 \ mod \ n $$<br>例：<br>a&#x3D;3,n&#x3D;10<br>$\phi (10) &#x3D; 4$<br>$a^{\phi (n)}&#x3D;3^{\phi (10)}&#x3D;3^{4}$<br>$3^{4} \ mod \ 10 &#x3D; 1 \ mod \ 10$</p><p>第二种表述：<br>对任意的正整数a，n，有：<br>$$ a^{\phi (n)+1} \ mod \ n &#x3D; a \ mod \ n $$<br>例：<br>a&#x3D;3,n&#x3D;6<br>$\phi (n)+1 &#x3D; \phi (6) + 1 &#x3D; 3$<br>$a^{\phi (n)+1} &#x3D; 3^{3}$<br>$3^{3} \ mod \ 6 &#x3D; 3 \ mod \ 6$</p><h4 id="素性测试"><a href="#素性测试" class="headerlink" title="素性测试"></a>素性测试</h4><p>许多密码算法需要随机选择一个或多个非常大的素数，因此需要确定一个给定的大数是否为素数。</p><p><strong>Miller-Rabin算法</strong><br>Miller和Rabin提出的这一算法是典型的大数素性测试算法</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展的欧几里得算法</title>
      <link href="/2019/07/20/%E6%89%A9%E5%B1%95%E7%9A%84%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
      <url>/2019/07/20/%E6%89%A9%E5%B1%95%E7%9A%84%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="扩展的欧几里得算法-Extended-Euclidean-algorithm"><a href="#扩展的欧几里得算法-Extended-Euclidean-algorithm" class="headerlink" title="扩展的欧几里得算法(Extended Euclidean algorithm)"></a>扩展的欧几里得算法(Extended Euclidean algorithm)</h3><p>扩展的欧几里得算法是欧几里得算法的扩展，除了计算a，b两个数的最大公因数，还能找到整数x,y，<br>使得ax + by &#x3D; d &#x3D; gcd(a, b)。它对于有限域中的计算以及RSA等密码算法非常重要。<br><a href="https://github.com/MrBluyee/arithmetic_c/tree/master/greast_common_divisor">github源码</a></p><span id="more"></span><p>推理（推理过程与上一章类似）：<br>设：<br>$a &#x3D; q_{1}b + r_{1} , r_{1} &#x3D; ax_{1} + by_{1}$<br>$b &#x3D; q_{2}r_{1} + r_{2}  , r_{2} &#x3D; ax_{2} + by_{2}$<br>$r_{1} &#x3D; q_{3}r_{2} + r_{3} , r_{3} &#x3D; ax_{3} + by_{3}%$<br>…<br>$r_{i-2} &#x3D; q_{i}r_{i-1} + r_{i} , r_{i} &#x3D; ax_{i} + by_{i}$<br>…<br>$r_{n-2} &#x3D; q_{n}r_{n-1} + r_{n} , r_{n} &#x3D; ax_{n} + by_{n}$<br>$r_{n-1} &#x3D; q_{n+1}r_{n} + 0$</p><p>则：<br>$r_{i} &#x3D; r_{i-2} -q_{i}r_{i-1}$<br>因：<br>$r_{i-2} &#x3D; ax_{i-2} + by_{i-2}$<br>$r_{i-1} &#x3D; ax_{i-1} + by_{i-1}$<br>$r_{i}   &#x3D; ax_{i}   + by_{i}$<br>代入，得：<br>$ax_{i} + by_{i} &#x3D; (ax_{i-2} + by_{i-2}) - q_{i}(ax_{i-1} + by_{i-1})$<br>          $&#x3D; a(x_{i-2} - q_{i}x_{i-1}) + b(y_{i-2} -q_{i}y_{i-1})$<br>即：<br>$x_{i} &#x3D; x_{i-2} - q_{i}x_{i-1}$<br>$y_{i} &#x3D; y_{i-2} - q_{i}y_{i-1}$</p><p>由$r_{i} &#x3D; r_{i-2} -q_{i}r_{i-1}$可知，<br>新余数$r_{i}$的计算基于前面两个计算的余数$r_{i-1}$和$r_{i-2}$，<br>那么若按此方式计算，在开始时需要知道$r_{0}$和$r_{-1}$的值，令$r_{-1}&#x3D;a$，$r_{0} &#x3D; b$,则有：</p><table><thead><tr><th>计算</th><th>满足</th><th>计算</th><th>满足</th></tr></thead><tbody><tr><td>$r_{-1}&#x3D;a$</td><td></td><td>$x_{-1}&#x3D;1$<br>$y_{-1}&#x3D;0$</td><td>$a&#x3D;ax_{-1}+by_{-1}$</td></tr><tr><td>$r_{0}&#x3D;b$</td><td></td><td>$x_{0}&#x3D;0$<br>$y_{0}&#x3D;1$</td><td>$b&#x3D;ax_{0}+by_{0}$</td></tr><tr><td>$r_{1}$ &#x3D; a mod b<br>$q_{1} &#x3D; a &#x2F; b$</td><td>$a &#x3D; q_{1}b+r_{1}$</td><td>$x_{1}&#x3D;x_{-1}-q_{1}x_{0}&#x3D;1$<br>$y_{1}&#x3D;y_{-1}-q_{1}y_{0}&#x3D;-q_{1}$</td><td>$r_{1}&#x3D;ax_{1}+by_{1}$</td></tr><tr><td>$r_{2}$ &#x3D; b mod $r_{1}$<br>$q_{2} &#x3D; b &#x2F; r_{1}$</td><td>$b &#x3D; q_{2}r_{1}+r_{2}$</td><td>$x_{2}&#x3D;x_{0}-q_{2}x_{1}$<br>$y_{2}&#x3D;y_{0}-q_{2}y_{1}$</td><td>$r_{2}&#x3D;ax_{2}+by_{2}$</td></tr><tr><td>$r_{3} &#x3D; r_{1}$ mod $r_{2}$<br>$q_{3} &#x3D; r_{1} &#x2F; r_{2}$</td><td>$r_{1} &#x3D; q_{3}r_{2}+r_{3}$</td><td>$x_{3}&#x3D;x_{1}-q_{3}x_{2}$<br>$y_{3}&#x3D;y_{1}-q_{3}y_{2}$</td><td>$r_{3}&#x3D;ax_{3}+by_{3}$</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>$r_{n} &#x3D; r_{n-2}$ mod $r_{n-1}$<br>$q_{n} &#x3D; r_{n-2} &#x2F; r_{n-1}$</td><td>$r_{n-2} &#x3D; q_{n}r_{n-1}+r_{n}$</td><td>$x_{n}&#x3D;x_{n-2}-q_{n}x_{n-1}$<br>$y_{n}&#x3D;y_{n-2}-q_{n}y_{n-1}$</td><td>$r_{n}&#x3D;ax_{n}+by_{n}$</td></tr><tr><td>$r_{n+1} &#x3D; r_{n-1}$ mod $r_{n} &#x3D; 0$<br>$q_{n+1} &#x3D; r_{n-1} &#x2F; r_{n}$</td><td>$r_{n-1} &#x3D; q_{n+1}r_{n} + 0$</td><td></td><td>$d&#x3D;gcd(a, b)&#x3D;r_{n}$<br>$x &#x3D; x_{n};y &#x3D; y_{n}$</td></tr></tbody></table><h4 id="C实现"><a href="#C实现" class="headerlink" title="C实现"></a>C实现</h4><p>循环方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">// Extended Euclidean Algorithm</span><br><span class="line">// d = gcd(a, b) = ax + by</span><br><span class="line">// input a,b</span><br><span class="line">// output x,y</span><br><span class="line">// return d</span><br><span class="line">int gcd_ex(int a, int b, int *x, int *y)&#123;</span><br><span class="line">    int a_temp;</span><br><span class="line">    int b_temp;</span><br><span class="line"></span><br><span class="line">    int a_negative_flag = 0;</span><br><span class="line">    int b_negative_flag = 0;</span><br><span class="line">    int a_b_swap_flag = 0;</span><br><span class="line"></span><br><span class="line">    int x1 = 1; //init value</span><br><span class="line">    int y1 = 0; //x(-1) = 1, y(-1) = 0;</span><br><span class="line">    int x2 = 0;</span><br><span class="line">    int y2 = 1; //x(0) = 0, y(0) = 1;</span><br><span class="line"></span><br><span class="line">    int q; // q = a_temp / b_temp;</span><br><span class="line">    int r; // r = a_temp % b_temp;</span><br><span class="line"></span><br><span class="line">    if(a &lt; 0)&#123;</span><br><span class="line">        a_temp = -a;</span><br><span class="line">        a_negative_flag = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        a_temp = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(b &lt; 0)&#123;</span><br><span class="line">        b_temp = -b;</span><br><span class="line">        b_negative_flag = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        b_temp = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(b_temp &gt; a_temp)&#123;</span><br><span class="line">        r = a_temp;</span><br><span class="line">        a_temp = b_temp;</span><br><span class="line">        b_temp = r;</span><br><span class="line">        a_b_swap_flag = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(b_temp == 0)&#123;</span><br><span class="line">        *x = 1;</span><br><span class="line">        *y = 0;</span><br><span class="line">        if(a_b_swap_flag)&#123;</span><br><span class="line">            *x = 0;</span><br><span class="line">            *y = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a_negative_flag)&#123;</span><br><span class="line">            *x = -*x;</span><br><span class="line">        &#125;</span><br><span class="line">        if(b_negative_flag)&#123;</span><br><span class="line">            *y = -*y;</span><br><span class="line">        &#125;</span><br><span class="line">        return a_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = a_temp % b_temp;</span><br><span class="line">    q = a_temp / b_temp;</span><br><span class="line"></span><br><span class="line">    if(r == 0)&#123;</span><br><span class="line">        *x = 0;</span><br><span class="line">        *y = 1;</span><br><span class="line">        if(a_b_swap_flag)&#123;</span><br><span class="line">            *x = 1;</span><br><span class="line">            *y = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a_negative_flag)&#123;</span><br><span class="line">            *x = -*x;</span><br><span class="line">        &#125;</span><br><span class="line">        if(b_negative_flag)&#123;</span><br><span class="line">            *y = -*y;</span><br><span class="line">        &#125;</span><br><span class="line">        return b_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(r != 0)&#123;</span><br><span class="line">        *x = x1 - (q * x2);</span><br><span class="line">        *y = y1 - (q * y2);</span><br><span class="line">        x1 = x2;</span><br><span class="line">        y1 = y2;</span><br><span class="line">        x2 = *x;</span><br><span class="line">        y2 = *y;</span><br><span class="line">        a_temp = b_temp;</span><br><span class="line">        b_temp = r;</span><br><span class="line">        r = a_temp % b_temp;</span><br><span class="line">        q = a_temp / b_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(a_b_swap_flag)&#123;</span><br><span class="line">        r = *x;</span><br><span class="line">        *x = *y;</span><br><span class="line">        *y = r;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a_negative_flag)&#123;</span><br><span class="line">        *x = -*x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b_negative_flag)&#123;</span><br><span class="line">        *y = -*y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return b_temp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧几里得算法-求最大公因数</title>
      <link href="/2019/07/17/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/"/>
      <url>/2019/07/17/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="欧几里得算法-Euclidean-algorithm"><a href="#欧几里得算法-Euclidean-algorithm" class="headerlink" title="欧几里得算法(Euclidean algorithm)"></a>欧几里得算法(Euclidean algorithm)</h3><p>欧几里德算法又称辗转相除法，用于计算两个正整数a，b的最大公因数。<br><a href="https://github.com/MrBluyee/arithmetic_c/tree/master/greast_common_divisor">github源码</a></p><span id="more"></span><h4 id="最大公因数-Greast-Common-Divisor"><a href="#最大公因数-Greast-Common-Divisor" class="headerlink" title="最大公因数(Greast Common Divisor)"></a>最大公因数(Greast Common Divisor)</h4><p><strong>定义：</strong> 对于整数a,b,其最大公因数是能同时整除a和b的最大整数，用gcd(a,b)来表示。</p><!-- more --><p>由于最大公因数必须是正数，所以有gcd(a,b) &#x3D; gcd(a,-b) &#x3D; gcd(-a,b) &#x3D; gcd(-a,-b)。</p><p><strong>互素：整数a,b互素，当且仅当它们只有一个正整数公因子1，即gcd(a,b) &#x3D; 1</strong></p><p>推理：</p><p>设:<br>$a \ge b \gt 0$<br>$a &#x3D; q_{1}b + r_{1} ,(0 \le r_{1} \lt b)$<br>$d &#x3D; gcd(a, b)$</p><p>则:<br>情形1： $r_{1} &#x3D; 0$<br>则b整除a，即$d &#x3D; gcd(a, b) &#x3D; b$</p><p>情形2： $r_{1} \neq 0$<br>则d一定能够整除$r_{1}$，证明：<br>$d &#x3D; gcd(a,b)$<br>则<br>a mod d &#x3D; 0  -&gt; $a &#x3D; k_{1}d$<br>b mod d &#x3D; 0  -&gt; $b &#x3D; k_{2}d$<br>$r_{1} &#x3D; a - q_{1}b &#x3D; k_{1}d - q_{1}k_{2}d &#x3D; d(k_{1} - q_{1}k_{2})$<br>即<br>$r_{1}$ mod d &#x3D; 0</p><p>对任意一个b和$r_{1}$的公因数c，有：<br>b  mod c &#x3D; 0  -&gt; $b &#x3D; k_{3}c$<br>$r_{1}$ mod c &#x3D; 0  -&gt; $r_{1} &#x3D; k_{4}c$<br>则 $a &#x3D; q_{1}b + r_{1} &#x3D; q_{1}k_{3}c + k_{4}c &#x3D; c(q_{1}k_{3} + k_{4})$,即<br>a mod c &#x3D; 0<br>则 c 是整数a,b的公因数，$c \le d$,<br>那么 $d &#x3D; gcd(b,r_{1})$<br>即将求整数a,b的最大公因数转换为了求b,$r_{1}$的最大公因数。</p><p>求$gcd(b,r_{1})$同样可设$b &#x3D; q_{2}r_{1} + r_{2} ,(0 \le r_{2} \lt r1)$<br>若$r_{2} &#x3D; 0$, 则$d &#x3D; r_{1}$, 若$r_{2} \neq 0$，则 $d &#x3D; gcd(r_{1},r_{2})$。</p><p>依此循环，余数会一直递减，当余数为0时，循环停止，求得d。</p><p>展开如下:<br>$a  &#x3D; q_{1}b + r_{1} ,(0&lt; r_{1} &lt; b)$<br>$b  &#x3D; q_{2}r_{1} + r_{2} ,(0&lt; r_{2} &lt; r_{1})$<br>$r_{1} &#x3D; q_{3}r_{2} + r_{3} ,(0&lt; r_{3} &lt; r_{2})$<br>…</p><p>$r_{n-2} &#x3D; q_{n}r_{n-1} + r_{n} ,(0&lt; r_{n} &lt; r_{n-1})$<br>$r_{n-1} &#x3D; q_{n+1}r_{n} + 0$<br>$d &#x3D; gcd(a,b) &#x3D; r_{n}$</p><p>该算法称为欧几里得算法。</p><h4 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Euclid(a, b)&#123;</span><br><span class="line">if(b == 0)&#123;</span><br><span class="line">return a;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return Euclid(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C实现"><a href="#C实现" class="headerlink" title="C实现"></a>C实现</h4><p>递归方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int gcd1(int a, int b)&#123;</span><br><span class="line">    int a_temp;</span><br><span class="line">    int b_temp;</span><br><span class="line">    int r;</span><br><span class="line">    if(a &lt; 0)&#123;</span><br><span class="line">        a_temp = -a;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        a_temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b &lt; 0)&#123;</span><br><span class="line">        b_temp = -b;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        b_temp = b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b_temp &gt; a_temp)&#123;</span><br><span class="line">        r = a_temp;</span><br><span class="line">        a_temp = b_temp;</span><br><span class="line">        b_temp = r;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b_temp == 0)&#123;</span><br><span class="line">        return a_temp;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return gcd1(b_temp,a_temp % b_temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>循环方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int gcd2(int a, int b)&#123;</span><br><span class="line">    int a_temp;</span><br><span class="line">    int b_temp;</span><br><span class="line">    int r;</span><br><span class="line">    if(a &lt; 0)&#123;</span><br><span class="line">        a_temp = -a;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        a_temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b &lt; 0)&#123;</span><br><span class="line">        b_temp = -b;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        b_temp = b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b_temp &gt; a_temp)&#123;</span><br><span class="line">        r = a_temp;</span><br><span class="line">        a_temp = b_temp;</span><br><span class="line">        b_temp = r;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b_temp == 0) return a_temp;</span><br><span class="line">    r = a_temp % b_temp;</span><br><span class="line">    while(r != 0)&#123;</span><br><span class="line">        a_temp = b_temp;</span><br><span class="line">        b_temp = r;</span><br><span class="line">        r = a_temp % b_temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return b_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用路由方式</title>
      <link href="/2019/03/04/%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/03/04/%E5%B8%B8%E7%94%A8%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="常用路由方式"><a href="#常用路由方式" class="headerlink" title="常用路由方式"></a>常用路由方式</h3><p>在组建网络时，选择路由方法是不可避免的问题。一般所说的路由就是为消息的传输选择一条路径，使得要传输的数据沿着这条路径从源节点发送到目的节点。</p><span id="more"></span><h4 id="路由协议分类"><a href="#路由协议分类" class="headerlink" title="路由协议分类"></a>路由协议分类</h4><table><thead><tr><th>分类依据</th><th>路由类型</th><th>特点</th><th>优点</th><th>缺点</th><th>典型路由算法</th></tr></thead><tbody><tr><td>根据路由发现策略</td><td>主动路由</td><td>维护路由表，包含邻居节点探测和路由广播</td><td>查表寻径，所需时间较少</td><td>开销较大，路由协议不收敛</td><td>OSPF等</td></tr><tr><td></td><td>被动路由</td><td>在有需求时会按需进行路由发现</td><td>不需周期性的路由信息广播，节省网络资源</td><td>路由发现时存在延时</td><td>DSR、IP、IPX、APPLE TALK</td></tr><tr><td>根据网络管理的逻辑结构</td><td>平面路由</td><td>网络中所有的节点在路由功能上地位相同</td><td>无特殊节点，流量分布均匀，算法易于实现</td><td>扩展性弱，没有对通信资源的管理</td><td>洪泛、SAR、定向扩散</td></tr><tr><td></td><td>分层路由</td><td>采用簇的概念对网络节点进行层次划分</td><td>满足无线网络的扩展性，延长网络的生命周期</td><td>在分簇的过程中会消耗能量</td><td>LEACH、TEEN、多层类聚算法</td></tr></tbody></table><h4 id="洪泛路由算法"><a href="#洪泛路由算法" class="headerlink" title="洪泛路由算法"></a>洪泛路由算法</h4><p>本算法最初应用于交换机和网桥之间的数据传递，即某台设备接收到数据之后再次将此数据发送给除此设备之外的所有设备，类似于洪水流动。采用洪泛路由进行数据传输时，消息会沿着不同的路径进行路由，网络中的所有设备均会收到消息并进行中继，直到消息到达目的设备。</p><p>洪泛路由协议方便实现且简单有效，同时还具有较高的鲁棒性。网络中不存在特定的集中式路由器，且网络中的路由状态信息无需维护。网络中所传输的消息在到达其目的地之前有多条路径可以选择。然而，在实现过程中，传统的洪泛路由算法也存在其固有的缺点。进行洪泛广播时，网络中所有的节点都会对接收到的消息进行中继，这种中继方式很容易产生大量的消息导致广播风暴，同时网络中消息数量的增多还有可能导致消息碰撞。</p><h4 id="连接状态路由协议"><a href="#连接状态路由协议" class="headerlink" title="连接状态路由协议"></a>连接状态路由协议</h4><p>连接状态选路协议（Link State Routing Protocol）为整个拓扑结构保持了一张路由表（routing table），通过这张表来找到拥有最少连接消耗的路径。所有的节点使用 flooding technique定期地发送连接消耗的信息。每一个节点使用收集的新的连接消耗信息来更新自己的路由表。由于拓扑结构的动态行为或无线媒介，连接消耗信息可能是不一致的，例如突如其来的不正确的传播时延。这可能造成在连接更新时发生短暂的路由循环。</p><h4 id="距离向量路由协议"><a href="#距离向量路由协议" class="headerlink" title="距离向量路由协议"></a>距离向量路由协议</h4><p>距离向量路由协议（Distance Vector Routing Protocol）通过使得每个节点i保持一张含有距离或耗费集合{dij(x)}的表来进行操作，其中节点j是节点i的相邻节点。在将数据包发给目的节点x时，如果节点i的相邻节点k是i的所有相邻节点中的最小值，则将节点k当做是节点i的下一跳。这张路由表给出了每个目的节点的最佳距离以及哪个路由可以到达。为了保持最新的距离结合，每个路由器与它所有的相邻节点定期交换信息。如果交换结束后，一个节点 到任何一个相邻节点的最短距离将发生变化，这个过程经一直重复知道所有的节点完成路由表的更新。但是，由于旧的的信息，在更新路由表时，DV路由算法可能引起短暂的或长期的循环。</p><h4 id="OSPF协议与链路状态算法"><a href="#OSPF协议与链路状态算法" class="headerlink" title="OSPF协议与链路状态算法"></a>OSPF协议与链路状态算法</h4><p>OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。著名的迪克斯加算法（Dijkstra）被用来计算最短路径树。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议。</p><p>链路状态算法（也称最短路径优先算法）用于更新路由表。其基本思想是互联网上的每个路由器周期性的向其他路由器广播自己与相邻路由器的连接关系，以使各个路由器都可以画出一张互联网拓扑结构图。利用这张图和最短路径优先算法，路由器就可以计算出自己到达各个网络之间的最短路径。适用于大型网络。收敛速度快。</p><h4 id="DSR路由协议"><a href="#DSR路由协议" class="headerlink" title="DSR路由协议"></a>DSR路由协议</h4><p>动态源路由协议(Dynamic Source Routing, DSR)是在移动自组网(MANET)中使用的一种路由协议。它工作在TCP&#x2F;IP协议族的网络层。</p><p>DSR路由协议是属于按需路由协议的一种，基础为源路由寻径机制，网络中的节点可以动态的发现从源节点到目的节点之间完整的路由信息。在每个分组的头部都具备<br>包含整条路由的信息，在进行分组转发时，路由器首先会获取分组头部的缓存记录，之后按照缓存记录来转发分组。源节点在进行数据发送之前，会先将源节点到目的节点之间的完整路由信息放入需要发送的数据包中，数据包在被转发时免去了路由表查询过程，只需从数据包中取得下一跳节点进行转发即可，同时所有经过的中间节点都不需要为转发数据储存所需的路由消息，这在一定程度上减少了网络的开销。</p><p><strong>1.产生路由请求</strong><br>当源节点需要与某目的节点进行通信时，它首先在本节点维护的路由缓存中查找是否有到达该目的节点的路由。若路由缓存中已包含了到达该目的节点的有效路由，则立即使用此路由发送数据分组，否则它将向所有邻居广播RREQ(Route Request)分组，以启动一个路由发现过程来找到一条到达该目的节点的可用路由。</p><p><strong>2.节点对路由请求的处理</strong></p><ul><li>1.如果接收RREQ的节点是该路由请求的目的节点，则向发起RREQ的源节点返回RREP分组。将收到的RREQ分组的源节点地址、RREQ分组中携带的源路由节点地址列表和本节点的地址按顺序排列作为源路由封装在RREP(Route Reply)分组中发送给源节点，并将处理后的RREQ分组删除。 </li><li>2.收到RREQ的节点检查自己是否已经包含在RREQ携带的源路由节点列表中，如果是则将RREQ分组丢弃。</li><li>3.如果协议要求使用双向链路，节点要检查前一节点是否在自己的通信范围内，如果不在则丢弃该RREQ包；如果不确定则向前一节点发送一TTL值为“1”的RREQ分组，如果收到前一节点回复的RREP这表示两节点之间是双向链路，继续处理RREQ分组，否则表示两节点之间为单向链路则将RREQ分组丢弃。</li><li>4.接收RREQ的节点必须要查找当地的路由请求表看有无发起此RREQ的源节点所对应的路由请求表入口。如果有则在当地缓存中查看有无与(此RREQ路由请求号，此RREQ目的节点IP地址)对相对应的入口，如有则将现在收到的RREQ分组丢弃。</li><li>5.如果接受RREQ的节点的路由请求表中没有和此RREQ对应的表项，说明以前没收接受过此RREQ，则按以下步骤处理该RREQ请求分组：利用此RREQ的(路由请求序号，目的节点IP地址)值，为此RREQ分组在节点的路由请求表中创建一入口；对此RREQ分组做一个完整的拷贝；将节点自己的IP地址追加到RREQ分组的源路由节点列表中；节点在自己的路由缓存中查找到RREQ分组中目的节点的路由，有则向发起RREQ的源节点回复一RREP分组，称为“缓存路径回复(cached Route Reply)”；如果节点在自己的路由缓存中没有找到通往RREQ目的节点的路径，则将新改好的RREQ拷贝广播发送出去。</li></ul><p><strong>3.中间节点回复RREP分组</strong><br> 在2中讲到如果接收RREQ的中间节点在自己的路由缓存中找到通往RREQ分组目的节点的路径则要向源节点回复一cached Route Reply分组。这种机制可以大大减小网络中因为路由发现过程所造成的开销，因为这种机制可以大大减少路由发现过程中的RREQ广播报文。</p><p>下面详细叙述向源节点回复cached Route Reply的过程:</p><ul><li>1.中间节点在回复RREP之前首先要检查被回复的源路由中不会出现节点重复出现的情况。即查看由RREQ原节点地址、RREQ中已经积累的节点IP地址列表、本节点路由缓存中找到的路径中的IP地址顺序排列下来的地址列表中有无重复出现的IP地址，如果有则不能继续进行缓存路径回复，而转到2中步骤5的最后一步继续执行。如不存在重复出现的IP地址就向下执行。</li><li>2.中间节点将从自己路由缓存中得到的路径cached-route追加到RREQ分组头中的源路由地址列表中，这样就得到要发给RREQ源节点的完整路由：&lt;源节点IP地址、RREQ分组头携带的节点的IP地址列表、cached-route&gt;。此中间节点的IP地址已经在RREQ分组头中，不需再追加。将得到的源路由封装在RREP包中发送给发起RREQ的源节点。</li><li>3.中间节点发送完路由缓存回复后，就不再继续广播RREQ分组了。此时如果RREQ数据分组头中除了已经处理过的RREQ选项外不再含有其他任何选项，并DSR选项头后面也不含有其他数据负载(TCP或UDP数据)，则中间节点可将此RREQ分组丢弃。否则作如下处理：将RREQ DSR选项头中的目的节点IP地址作为RREQ IP分组的目的IP地址，即置换掉RREQ分组的广播地址；将RREQ分组中的路由请求选项移除；将从中间接点路由缓存中得到地路径作为源路由添加到新的RREQ分组头中；将重新创建的RREQ数据分组按分组头中的源路由转发出去。</li></ul><p><strong>4.处理并转发路由回复</strong><br>目的节点收到RREQ分组得到完整的源节点到目的节点的路由后，将此路由封装在RREP分组中，然后发送给源节点。RREP分组可以封装成一个单独的IP分组传递给源节点，或封装在其他有数据要传输给源节点的IP分组中被捎带回源节点。 目的节点将自己的IP地址追加到RREQ携带的节点的IP地址列表中，将得到的IP地址列表作为返回给源节点的完整路由封装在RREP分组中。RREP数据分组的源IP地址设为发送RREP分组的节点的IP地址，目的IP地址设为发起RREQ的源节点的IP地址。如果使用的底层MAC协议支持双向路由，RREP数据分组可沿RREP选项中携带的源路由的逆向路由依次传输，否则目的节点为此RREP选项发起新的路由发现过程，且要将RREP选项封装在新产生的RREQ数据分组中以防止出现路由发现过程的反复进行。</p><h4 id="DSDV路由协议"><a href="#DSDV路由协议" class="headerlink" title="DSDV路由协议"></a>DSDV路由协议</h4><p>DSDV （Destination sequenced distance vector routing,目的节点序列距离矢量）路由协议可以用于Ad hoc网络。Ad hoc网络是从传统网络演变而来的，它的不同之处在于相互连接的动态拓扑结构以及设置网络的自动管理。从图论的角度来看，ad hoc网络是由一个节点集合N，一个边的集合E(t)构成的图G(N, E(t))。E(t)中的每条边由两个节点构成，并在一定服务范围之内，它既可以是单向的也可以是双向的。当可移动节点在ad hoc网络中自由移动时，E(t)随着时间发生变化。同时，ad hoc的拓扑结构在任意时间是不定的。由于ad hoc网络拓扑结构的变化性，网络中的节点不得不总是自动更新它们的路由信息。</p><p>以往，分组交换网络中的路由协议使用的是DV（distance-vector）或LS（link-state）路由算法。它们都允许一个主机通过“最短路径”到达目的节点时的下一跳。它们最短路径的形式可能是跳数、延迟时间（以ms为单位）、路径中排队的包的数量或其他类似的信息。这种最短路径协议在许多动态的分组交换网络中被成功应用。原则上，任何一个这样的协议也可以被用于ad hoc网络。而DV和LS协议的主要不足之处在于，他们花费了太长的时间去会聚，以及高度复杂的信息。而由于ad hoc网络中无线连接的带宽限制，信息的复杂性一定要被控制在一个较低的程度。另外，快速变化的拓扑结构需要路由协议快速找到相应的路由器。因此，新的路由协议需要满足这样一个基本的哲学体系。DSDV协议是对传统的BF路由协议的变形，它专注于ad hoc网络，解决了传统的DV路由协议中长期存在的循环和无限技术的问题。</p><p>DSDV路由协议基于 Bellman-ford 算法实现，为了防止产生路由环路和死锁等问题，该路由协议采用序列号来进行路由新旧的区分。网络中的每个节点都具备一张路由表，而且需要对其进行管理更新，该路由表包含目的节点、下一跳节点、路由计量标准及该路由序列号等信息。当网络中的每个节点都要管理更新一张包含大量信息的路由表时，势必会增大网络的整体开销，所以为了避免该缺点，DSDV 路由协议采用了周期更新和触发更新两种更新方式。</p><p>在DSDV中，ad hoc网络中的每个可移动节点保持着一张路由表，它列出了所有有效的目的节点，metric值、到达目的节点的下一跳节点以及由目的节点产生的一个序列号码。利用这样一张存储在每一个可移动节点中的路由表，数据包得以在ad hoc网络的节点之间传送。Ad hoc网络中的每个节点利用定期的广播或当新的重要的信息有效时更新各自的路由表，来保持动态变化的拓扑结构下路由表的一致性。</p><p>当检测到网络拓扑变化时，每个移动节点定期或立即使用广播或多播路由表更新包发布路由信息。更新包从metric为1的直连相邻节点开始发送。接收到更新包后，相邻节点更新路由表，将metric增加1，并将更新包重新发送到本节点的相邻节点。这个过程将重复进行，直到ad hoc网络中的所有节点都收到具有相应metric的更新包。更新包还将保留一段时间，以等待本节点与每个特定目标节点的最佳路由包数据到达，然后更新其路由表并重新传输更新包。如果一个节点在等待时间内接收到同一目的地的多个更新数据包，则通常首选序列号较近的路由作为数据包转发决策的基础，但如果仅更改了序列号，则不必立即公布路由信息。如果更新包具有具有相同节点的相同序列号，则将使用具有最小metric的更新包，并将丢弃现有路由或将其存储为不太可取的路由。在这种情况下，更新包将与序列号一起传播到ad hoc网络中的所有移动节点。路由变化的广播可能会被延迟，直到找到最优路径为止。延迟可能不稳定路径的广播可以抑制路由表的波动，减少可能到达的具有相同序列号的路由条目的重复数。</p><p>每个移动节点的路由表中的元素都是动态变化的，以保持与ad hoc网拓扑动态变化的一致性。为了达到这种一致性，路由信息广播必须足够频繁或快速，以确保每个移动节点几乎总是能够定位到动态的ad hoc网中的所有其他移动节点。在更新路由信息后，每个节点必须根据动态创建的ad hoc网中的请求将数据包中继到其他节点。</p><h4 id="ZigBee路由协议分析"><a href="#ZigBee路由协议分析" class="headerlink" title="ZigBee路由协议分析"></a>ZigBee路由协议分析</h4><p>ZigBee协议采用以下两种算法的结合体作为自身的路由算法。</p><ul><li>AODV：Ad-Hoc On-Demand Distance Vector（按需距离矢量路由）</li><li>Cluster-Tree algorithm（树型网络结构路由）</li></ul><p>其中AODV路由协议是一种按需路由协议，利用扩展环搜索的办法来限制搜索发现过的目的节点的范围，支持组播，可以实现在ZigBee节点间动态的，自发的路由，使节点很快的获得通向所需目的的的路由。这也是ZigBee路由协议的核心。针对自身的特点，ZigBee网络中使用一种简化版本的AODV协议（AODV Junior，AODVjr）。</p><p>Cluster-Tree算法包括地址的分配（configuration of addresses）与寻址路由两部分（addresses routing）。包括子节点的16位网络短地址的分配，以及根据目的节点的网络地址来计算下一跳的算法。</p><p>作为两种算法的结合体，ZigBee网络中，节点可以按照网络树状结构的父子关系使用Cluster-Tree算法选择路径。即每一个节点都会试图将收到的信息包转发给自己的后代节点，如果通过计算发现目的地址不是自己的一个后代节点，则将这个数据包转发给自身上一级的父节点，由父节点进行类似的判断处理，直到找到目的节点。Cluster-Tree算法的特点在于使不具有路由功能的节点间通过与各自的父节点间的通信仍然可以发送数据分组和控制分组，但它的缺点是效率不高。为了提高效率，ZigBee中允许具有路由功能的节点使用AODVjr算法去发现路由，让具有路由功能的节点可以不按照父子关系而直接发送信息到其通信范围内的其他节点。</p><h4 id="AODVjr路由算法"><a href="#AODVjr路由算法" class="headerlink" title="AODVjr路由算法"></a>AODVjr路由算法</h4><p>AODVjr路由时一种按需分配的路由协议，只有在路由节点接收到网络数据包，并且网络数据包的目的地址不在节点的路由表中时才会进行路由发现过程。也就是说，路由表的内容是按照需要建立的，而且它可能仅仅是整个网络拓扑结构的一部分。</p><p>AODVjr的优点是，相对于有线网络的路由协议而言，它不需要周期性的路由信息广播，节省了一定的网络资源，并降低了网络功耗。缺点是在需要时才发起路由寻找过程，会增加数据到达目的地址的时间。由于ZigBee网络中对数据的实时性要求不大，而更重视对网络能量的节省，因此AODVjr非常适合应用在ZigBee网络中。</p><p>一次路由建立由以下三个步骤组成：</p><ul><li>1.路由发现</li><li>2.反向路由建立</li><li>3.正向路由的建立</li></ul><p>经过这三个步骤，即可建立起一条路由节点到目的节点的有效传输路径。在这个路由建立过程中，AODVjr使用3种消息作为控制信息：</p><ul><li>1.Route Request(RREQ)，路由请求</li><li>2.Route Replies(RREP)，路由回复</li><li>3.Route Error(RERR)，路由错误</li></ul><p>以下将对路由建立的三个过程进行详细描述。</p><p><strong>(1)路由发现过程</strong></p><p>对于一个具有路由能力的节点，当接收到一个从网络层的更高层发出的发送数据帧的请求，且路由表中没有和目的节点对应的条目时，它就会发起路由发现过程。源节点首先创建一个路由请求分组(RREQ)，并使用多播(Multi．Broadcast)的方式向周围节点进行广播。</p><p>如果一个节点发起了路由发现过程，它就应该建立相应的路由表条目和路由发现表条目，状态设置为路由发现中。任何一个节点都可能从不同的邻居节点处接收到广播的RREQ。接收到后节点将进行如下分析：</p><ul><li>1.如果是第一次接收到这个RREQ消息，且消息的目的地址不是自己，则节点会保留这个RREQ分组的信息用于建立反向路径，然后将这个RREQ消息广播出去。</li><li>2.如果之前已经接受过这个RREQ消息，表明这是由于网络内多个节点频繁广播产生的多余消息，对路由建立过程没有任何作用，则节点将丢弃这个消息。</li></ul><p><strong>(2)反向路由建立过程</strong></p><p>当RREQ消息从一个源节点转发到不同的目的地时，沿途所经过的节点都要自动建立到源节点的反向路由。也就是记录当前接收到的RREQ消息是由哪一个节点转发而来的的。通过记录收到的第一个RREQ消息的邻居地址来建立反向路由，这些反向路由将会维持一定时间，该段时间足够RREQ消息在网内转发以及产生的RREP消息返回源节点。</p><p>当RREQ消息最终到达了目的节点，节点验证RREQ中的目的地址为自己的地址之后，目的节点就会产生RREP消息，作为一个对RREQ消息的应答。由于之前已经建立了明确的反向路由，因此RREP无需进行广播，只需按照反向路由的指导，采取单播的方式即可把RREP消息传送给源节点。</p><p><strong>(3)正向路由建立过程</strong></p><p>在RREP以单播方式转发回源节点的过程中，沿着这条路径上的每一个节点都会根据PREP的指导建立到目的节点的路由，也就是说确定到目的地址节点的下一跳(next-hop)。方法就是记录RREP是从哪一个节点传播而来．然后将该邻居节点写入路由表中的路由表项。一直到RREP传送到源节点。至此．一次路由建立过程完毕。源节点与目标节点之间可以开始数据传输。可以看出，AODV是按照需求驱动的、使用RREQ．RREP控制实现的、先广播，后单播的路由的路由建立过程。</p><p>附：<br><strong>动态路由中选择最佳路由的几种常见metric</strong></p><p>当到达一个网络有多条路径的时候，路由器会根据甚么来选择最优路径，一般来讲路由器会根据以下几种度量值来选择最佳路由。</p><ul><li>1、跳数<br>它可以简单的记录经过路由器的个数。例如，数据从路由器A发出，经过路由器B到达其他网络，那么其跳数为1，如果经过C到达其他网络，它经过的路由器为2，那么其跳数为2.在RIP中，跳数是衡量路径的主要标准，其最大跳数16，超过16即为不可达。</li><li>2、带宽<br>一般会选择带宽高的路径，但是不是主要标准，如果在T1线路上，链路带宽占用过多，那么它就可能不会选择这个链路了。</li><li>3、负载<br>负载反映了沿途链路的流量大小。最优路径应该是负载最低的路径。负载不会像带宽或者跳数那样，路径上的负载变化，那么度量也会跟着变化。这里需要当心，如果度量变化过于频繁，那么会引起路由振荡，路由振荡会对路由器的CPU、数据链路的带宽和拳王稳定性产生负面影响。</li><li>4、时延<br>时延是报文经过链路经过的时间，使用时延作为度量的路由协议会使用时延较低的链路最为最佳路径。有多种方法可以计算时延，时延不仅要考虑链路时延，而且还要考虑路由器的处理时延和队列时延等因素。另一方面，路由的时延可能根本无法度量。因此，时延可能是沿路各个接口所定义的静态时延的总和。</li><li>5、可靠性<br>此独联是用以度量链路在某种情况下发生故障的可能性。可靠性是可以变化的或者固定的。可靠性高的链路将被优先选择。</li><li>6、花费<br>此度量有管理员设置，可以反映路由的登记。通过任何策略或者链路特性对链路的cost进行定义。同时，花费也可以反映出网络管理员的主观意识。</li></ul><p>一般以上几种度量不是单独使用，一般是综合使用，通过某种算法来计算最佳路径。</p><p>参考内容：<br><a href="https://blog.csdn.net/u013078669/article/details/49780185">OSPF路由协议分析</a><br><a href="https://blog.csdn.net/zcj331/article/details/23438761">OSPF协议与链路状态算法</a><br><a href="https://blog.csdn.net/qq_16811963/article/details/52136320">距离矢量路由协议和链路状态路由协议</a><br><a href="https://blog.csdn.net/candycat1992/article/details/8087255/">目的节点序列距离矢量（DSDV)协议</a><br><a href="https://blog.csdn.net/candycat1992/article/details/8100146">DSDV协议</a><br><a href="https://product.pconline.com.cn/itbk/wlbg/wlsbjc/1703/8998852.html">动态路由中选择最佳路由的几种常见metric</a><br><a href="http://www.cnblogs.com/NL34/p/3597494.html?utm_source=tuicool&utm_medium=referral">ZigBee路由协议分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线传感网WSN概述</title>
      <link href="/2019/02/19/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91WSN%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/02/19/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91WSN%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="无线传感网"><a href="#无线传感网" class="headerlink" title="无线传感网"></a>无线传感网</h3><p>无线传感网（Wireless Sensor Network, WSN）: 具有感知、计算和无线网络通信能力的传感器及由其构成的无线传感器网络。</p><span id="more"></span><p>WSN由随机分布的集成有传感器、数据处理单元和通信模块的微小节点通过自组织的方式构成网络，借助于节点中形式多样的内置传感器，相互协作，实时感知和采集周边环境中的物理信息，并对这些信息进行处理，可以使人们在任何时间、绝大多数地点和多种环境条件下获取大量翔实而可靠的信息。</p><p>与传统传感器技术相比，无线传感器网络是由低成本、密集型、随机分布的节点组成的，自组织性和容错能力使其不会因为某些节点损坏而导致整个系统的崩溃，无线连接使其部署几乎不受监测对象的影响，维护成本非常低。</p><p>在无线传感器网络的研究与应用中，由于与传统无线网络及移动自组网络（Mobile Self-organizing Networks）的差异，在基础理论和工程技术层面出现了一系列挑战性问题，其中最核心的是能耗问题。</p><p>传统无线网络通常侧重如何满足用户的QoS要求，虽然也要考虑电能消耗，但是传统网络节点的电能可以补充，电能不是制约其应用的主要问题。而无线传感器网络中由于网络布置环境及节点规模等特点，节点电能一般由电池供应，在很多场合下由于条件限制，维护人员难以接近，电池更换非常困难，甚至不可能更换，但是却要求网络的生存时间尽可能的长，节点电能受限成为其最大制约因素。</p><p>可以通过两种途径去解决上述问题：一是利用可以再生的环境能源，使传感器节点实现自供电；二是采用低功耗电路设计方法和高效的电源管理方法，降低传感器节点的功耗，或通过网络级功耗管理技术、功率控制技术等多种技术相结合的方式实现网络电能利用率的提高，从而降低网络的整体能耗。在实际的应用中由于节点受成本的限制，往往较多采用后者的技术途径去实现网络的能耗降低，从而延长网络生存期。</p><h3 id="无线传感器网络的特点"><a href="#无线传感器网络的特点" class="headerlink" title="无线传感器网络的特点"></a>无线传感器网络的特点</h3><p><strong>自组织网络，抗毁性强</strong><br>无线传感器网络中没有严格的控制中心，网络的布设无需依赖于任何预设的基础设施。节点通过分布式算法协调各自的行为，开机后就可以快速、自动的组成一个独立的网络。任何节点失效或新节点加入都不会影响整个网络的运行，具有很强的可扩展性和抗毁性。<br><strong>多跳路由模式</strong><br>传感器节点通信距离有限，一般在几十到几百米范围内。要访问通信范围以外的节点，需要通过中间节点进行多跳路由。固定网络的多跳路由使用网关和路由器来实现，而无线传感器网络没有专门的路由设备，多跳路由是由传感器节点完成的，每个节点既是信息的发起者，也可以是信息的转发者。<br><strong>传感节点数量大，分布密度高</strong><br>为了获取精确信息，以及利用节点之间高度连接性来保证系统的容错性和抗毁性，传感器网络的节点数量和分布密度都要比一般无线网络高几个数量级。这会带来一系列问题，如信号冲突、信息无法有效传送、路由选择困难、大量节点之间如何协同工作等。<br><strong>网络动态性强</strong><br>传感器网络工作在比较恶劣的环境中，经常有新节点加入或已有节点失效，且网络中的传感器、感知对象和观察者这三要素都可能具有移动性，网络的拓扑结构和数据传输路径也随之变化。因此传感器网络必须具有可重构和自调整性。<br><strong>以数据为中心</strong><br>对无线传感器网络的用户而言，传感器网络的核心是感知数据，而不是网络硬件。以数据为中心的特点要求传感器网络能够快速有效的组织起各个节点的信息，并提取有用信息直接传送给用户。<br><strong>与应用相关</strong><br>无线传感器网络应用广泛，不同的应用对系统的要求必然会有很大差别，所以传感器网络不能像Internet那样有统一的通信协议平台。针对每一个具体应用来研究传感器网络技术，这是传感器网络不同于传统网络的显著特征。只有让系统更贴近应用，才能做出最高效的目标系统。<br><strong>电池电能是网络寿命的关键</strong><br>传感器节点一般由电池供电，电池电能极其有限，且传感器网络通常运行在人无法接近甚至危险的远程环境中，不能给电池充电或更换电池。一旦电池电能用完，这个节点也就失去了作用。因此节能是无线传感器网络设计要考虑的首要因素。<br><strong>传感器节点体积小，计算和存储能力有限</strong><br>无线传感器网络是在MEMS技术、数字电路技术基础上发展起来的，传感器节点各部分集成度很高，因此具有体积小的优点。同时由于体积、成本及电能的限制，嵌入式处理器的计算能力十分有限，存储器的容量也较小。传统网络上成熟的协议和算法对传感器网络而言开销太大，难以使用，必须重新设计简单有效的协议及算法。<br><strong>通信半径小，带宽较低</strong><br>随着通信距离的增加，无线通信的能耗将急剧增加，因此无线传感器网络的通信半径一般较小。和传统无线网络不同，传感器网络中传输的数据大部分是经过节点处理过的数据，因此流量较小。</p><h3 id="无线传感网协议栈模型"><a href="#无线传感网协议栈模型" class="headerlink" title="无线传感网协议栈模型"></a>无线传感网协议栈模型</h3><p>随着应用和体系结构的不同，无线传感网络的通信协议栈也不尽相同，协议栈模型如下图所示：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91WSN%E6%A6%82%E8%BF%B0/%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%A8%A1%E5%9E%8B.jpg" alt="无线传感网通信协议栈模型"><br>该模型既参考了现有通用网络的模型架构，同时又包含了传感器网络特有的电源管理、移动管理及任务管理。</p><ul><li>应用层为不同的应用提供一个相对统一的高层接口。</li><li>如有需要，传输层可为传感网络保持数据流或保证与Internet连接。</li><li>网络层主要关心数据的路由。</li><li>数据链路层协调无线媒质的访问，尽量减少相邻节点广播时的冲突。</li><li>物理层为系统提供一个简单、稳定的调制、传输和接收系统。</li><li>电源管理、移动管理和任务管理负责传感器由节点能量、移动和任务分配的监测，帮助传感器节点协调感测任务，尽量减小整个系统的功耗。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——低功耗技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无线模块休眠与激活机制</title>
      <link href="/2019/02/18/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/18/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>如何降低无线模块的总体功耗？</p><span id="more"></span><p>显然，只降低发射机的发射功率，或者只降低接收机的电流消耗是不现实的。这种方法的效果不但不明显，而且会带来通信质量下降的恶劣后果。</p><p>只有采用空闲时无线模块休眠的方式，才能大大的降低通信设备的平均功耗。对于由两个以上无线收发设备组成的任何结构、任何协议的半双工无线通信系统，其中的某一个设备真正工作于发射或接收状态的时间是很少的。当通信设备不工作于发射和接收状态时，使其进入休眠状态，可大大降低平均功耗。因为休眠状态的模块电流只有微安级。而无线通信设备发射时的电流是数十毫安以上，接收电流也在十几到数十毫安之间。因此，引入休眠机制的通信系统，休眠时间越长，则平均能耗越低。</p><h3 id="无线模块的休眠模式"><a href="#无线模块的休眠模式" class="headerlink" title="无线模块的休眠模式"></a>无线模块的休眠模式</h3><p>无线模块休眠一般有同步休眠模式、异步休眠模式和混合休眠模式。</p><p>同步休眠模式不需要休眠唤醒过程，最大限度的节省了电量的消耗。<br>混合休眠模式可以提高网络的健壮性，有些节点在受到干扰情况下不能进行同步休眠时，会自动进入异步休眠模式，最大限度的减小无谓的功耗消耗。</p><h4 id="同步休眠"><a href="#同步休眠" class="headerlink" title="同步休眠"></a>同步休眠</h4><p>同步模式下节点的休眠时间片和工作时间片由休眠广播报文实现同步，相邻节点之间的时间片误差小于1ms。同步休眠广播报文由网关在每个工作时间片的结束时刻向全网逐级广播，该报文指定本次同步休眠时间片的长度。</p><p>工作时间片的长度没有限制，可以根据数据传输需要自动动态调整，网络在没有数据传输时可以立即休眠而不需要等待某个预定的工作时间片结束，在有数据传输时会自动等待数据传输结束再进行休眠。</p><p>同步休眠模式下相邻节点间的时间片的误差很小，可以在工作时间片起始时刻立即进行数据传输，不需要进行无线唤醒或其他同步操作。</p><p>同步休眠示意图如下所示：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E5%90%8C%E6%AD%A5%E4%BC%91%E7%9C%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="同步休眠示意图"></p><p>工作时间片（work time slice）和休眠时间片（sleep time slice）根据需要由网关自动动态调整，在上图中，工作时间片和休眠时间片的时间长度是不同的。</p><p>在某工作时间片内网关模块有数据传出时，会在数据传输结束后等到信道静默超时后自动向网络发送同步休眠广播报文；在某工作时间片内网关模块没有数据传输时，会在工作时间片的开始时刻立即向网络发送同步休眠广播报文。</p><p>对于传感网络来说，数据传输就是对传感节点的数据采集，整个工作时间片的工作过程大致描述如下：</p><ul><li>网关模块在工作时间片的开始时刻向网络中的传感器节点发送读数据的指令，根据目的地址可以采用广播、多播和单播的方式。</li><li>传感节点模块在收到读数据指令后，如果地址匹配则唤醒传感器&#x2F;外设，同时还会向远处的传感器节点中继转发收到的读数据命令，转发次数可以设置。</li><li>为了保证传感器&#x2F;外设数据的有效性，传感节点模块在唤醒传感器&#x2F;外设后会等待一段时间才向传感器&#x2F;外设发送读数据的指令，然后等待传感器&#x2F;外设的响应。</li><li>在收到传感器&#x2F;外设的响应数据报文或等待超时后，传感节点模块通知传感器&#x2F;外设进行休眠。</li><li>如果收到传感器&#x2F;外设的响应数据报文，传感节点模块会将该数据报文向网关发送。</li><li>传感节点模块在上行数据报文缓冲区空闲时可以向网关方向中继转发远处传感节点的数据。</li><li>对于网关来说，在向网络发送读数据指令后，就可以陆续接收到网络中传感节点的响应数据报文，可以对网络中所有、部分、和指定传感节点进行数据采集。</li><li>网关模块在一定时间内不再收到传感节点的数据，认为数据采集过程已经完成，会向网络广播同步休眠报文，该报文指定当前休眠时间片的长度。</li><li>传感节点模块接收到广播同步休眠报文后，会向网络中继广播发送同步休眠报文，为了提高该报文的接收成功率，会多次重复发送。</li><li>传感节点模块完成同步休眠报文的发送次数后会进入休眠状态，直到休眠时间片结束为止。一次完整的同步数据采集过程结束。</li></ul><h4 id="异步休眠"><a href="#异步休眠" class="headerlink" title="异步休眠"></a>异步休眠</h4><p>异步休眠模式下无线节点模块会在网络空闲后主动按照预设的“睡醒比”进行间歇式休眠，睡醒比是“监听时间片”和“异步休眠时间片“长度的比值。睡醒比越大，模块的待机功耗就越小，但同样意味着异步唤醒休眠需要的时间更长、模块的响应速度越慢、每个报文的平均发送时间越长。因此”睡醒比“参数的设置需要综合考虑实际网络的工作情况，使得实际使用平均功耗最低。</p><p>“监听时间片”和RF的速率有关，一般只有毫秒级。如果无线节点在”监听时间片”内监听到网络中有数据需要收发就会自动进入正常工作模式。“睡醒比”可以灵活设置，该参数决定了无线节点待机电流的大小。假设无线节点模块的休眠电流为0.5uA，接收电流为22mA，异步休眠模式周期电流如下图所示：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E5%BC%82%E6%AD%A5%E4%BC%91%E7%9C%A0%E5%8A%9F%E8%80%97%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="异步休眠功耗示意图"></p><p>在没有外界干扰的情况下，异步唤醒的成功率为100%。</p><h4 id="混合休眠"><a href="#混合休眠" class="headerlink" title="混合休眠"></a>混合休眠</h4><p>采用同步休眠模式的低功耗无线网络，在同步休眠报文受到干扰或网关节点掉电时，节点模块由于得不到正确的休眠命令，并不会主动进入休眠状态，会造成节点功耗的上升，从而缩短电池的使用寿命。</p><p>为了克服上述情况，增强网络的抗干扰能力，可以采用以同步休眠为主、异步休眠为辅的混合休眠模式。混合休眠模式下，没有收到同步休眠命令的节点可以自动进入异步休眠模式，以保持较低的功耗。混合休眠模式可以看作在异步休眠模式的基础上叠加了同步休眠模式。</p><p>相对于同步休眠模式，混合休眠模式在工作时间片的一开始并不能立即进行数据传输，需要先进行全网或路由节点唤醒。在唤醒过程结束后，基本可以保证所有相邻的节点都可以被可靠唤醒。在唤醒阶段被遗漏的节点也会被后续的数据传输节点继续唤醒。</p><p>混合模式相对于同步休眠模式在工作时间片内增加了全网唤醒的处理过程，导致每个工作时间片的时间变长，也就增加了无线节点模块的功耗。</p><p>混合休眠示意图如下：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E6%B7%B7%E5%90%88%E4%BC%91%E7%9C%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="混合休眠示意图"></p><h3 id="无线模块的唤醒方式"><a href="#无线模块的唤醒方式" class="headerlink" title="无线模块的唤醒方式"></a>无线模块的唤醒方式</h3><p>当某个无线模块处于休眠状态时，其不接收也不发射数据，处于非工作状态，当其他模块需要与其进行通信时，通信是不会成功的。因此，就需要一套流程，把处于休眠状态的无线通信设备唤醒。</p><h4 id="定时唤醒"><a href="#定时唤醒" class="headerlink" title="定时唤醒"></a>定时唤醒</h4><p>定时唤醒通信中，参与通信的所有无线通信设备，按照一定的定时周期，或每次通信时约定下次通信的定时时间，定时时间一到参与通信的多个设备同时从休眠状态进入工作状态，完成通信后再进入休眠状态。其工作时序图如下图所示：</p><p><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%92.jpg" alt="定时唤醒"></p><p>上图中的T可以是常数，也可以是变量。当T是变量时，每次通信，所有参与通信的设备必须约定下次通信的时间间隔T。t是工作时间，在这个工作时间内的某一时刻，只能有一个设备处于发射状态，其他设备处于接收状态。很显然，T&#x2F;t的比值越大，平均功耗就越小。</p><p>定时唤醒通信的缺点有：</p><ul><li>参与通信的所有无线通信设备必须在时间上同步，则对时钟的要求较高。</li><li>初始同步需要较长的时间和复杂的流程。</li><li>不同无线通信设备的时钟，由于存在误差，会产生漂移，需要一套校准机制进行校准。</li><li>休眠时间越长，时钟漂移越大，一旦漂移过大或其他原因导致设备脱离同步，重新同步需要花费很大的代价。</li><li>通信实时性和灵活性不强，如果某设备有突发的通信需要，而其他设备仍在休眠，则不能在短时间内完成通信，只能等待定时时间到。</li></ul><h4 id="信号强度唤醒"><a href="#信号强度唤醒" class="headerlink" title="信号强度唤醒"></a>信号强度唤醒</h4><p>信号强度唤醒是利用接收机在某一时刻收到的信号强度RSSI，通过设定的门限，判断系统在某一时间段内是否产生通信需求，如果是，则设备从休眠状态进入工作状态。</p><p>使用信号强度唤醒法的系统中，设备有主从之分，发起通信的设备是主设备（只能有一个），其他设备是从设备（一个或多个）。在大部分应用中，主从设备是固定的。但在一些比较复杂的系统中，主从设备可以是动态的，某个设备在某一时刻，可能是主设备，也可能是从设备。</p><p>主设备工作流程如下：</p><p>主设备在有通信需求时，首先发送持续时间为Ts的唤醒信号，该信号可以是载波，也可以是调制信号。Ts&gt;&#x3D;T+t。主设备发送完唤醒信号后，其他从设备都被唤醒，马上进入正常通信状态，和从设备进行数据交换，持续时间为Tc。数据交换完毕，从设备进入休眠状态。对于通信失败的从设备，主设备需要启动差错处理机制进行处理。</p><p>从设备工作流程如下：</p><p>按照固定的周期T+t，交替工作于休眠&#x2F;接收状态。在时间T内，从设备是休眠的。在时间t内，从设备处于接收状态，但不接收数据，只测量RSSI的值。t是信号强度唤醒的监听窗口，不同的设备由于没有同步，其窗口的相位是不同的。</p><p>如果RSSI测量值低于预置的门限，则表示没有任何通信请求，从设备进入休眠状态。如果RSSI测量值高于或等于预置的门限值，则表示有主设备发出通信请求，从设备暂时不进入休眠状态，继续处于接收状态，等待时间为Tw。不同从设备的Tw值是不一样的。在Tw期间，从设备处于接收状态，但不能正常通信，这期间的能量是浪费掉的。</p><p>Tw等待期过后，从设备收到主设备的命令或数据并完成既定的收发流程TA后，又进入休眠状态。如果因为干扰等原因没有收到主设备发来的命令或数据，则表示本次通信失败，从设备在等待时间Tout后又进入休眠。</p><p>信号强度唤醒方法时序图：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E5%94%A4%E9%86%92.jpg" alt="信号强度唤醒"></p><p>信号强度唤醒法的优点是t可以取比较小的值，但其缺点很多，主要有：</p><ul><li>抗干扰能力差，尤其是同频和邻频干扰对其影响是致命的，持续的干扰会对从设备产生连续的误唤醒，从而导致能量的消耗。</li><li>不能区分信号发送者的身份，所以会轻易的被其他系统无意或恶意唤醒，导致能量消耗，系统的可靠性下降。</li><li>缩短通信距离，当RSSI信号比较弱时，从设备的接收机测试RSSI信号时，干扰和噪声能量会占比较大的比重，导致RSSI测量值的可信度下降，所以必须设置较高的门限才能减少误唤醒，提高可靠性。设置高门限则会导致通信距离缩短，如接收机的灵敏度为-120dBm，但门限必须设置为-112dBm，则通信距离相应缩短。突发干扰和噪声产生的误唤醒随环境不同而不同，随时间不同也不同，从而找到一个合理的门限值比较困难，计算和评估误唤醒消耗的能量也非常困难。</li></ul><h4 id="最短数据包唤醒"><a href="#最短数据包唤醒" class="headerlink" title="最短数据包唤醒"></a>最短数据包唤醒</h4><p>系统中某无线收发设备有通信要求时，先重复发送若干个最短数据包，接收机在定时探测时，只有正确收到其中一包数据，才认为此时有通信请求，暂时不进入休眠状态，等待进入下一步的通信流程，这种方法就是最短数据包唤醒法。</p><p>该方法中的通信设备也有主从之分，反复发送最短数据包的是主设备，被最短数据包唤醒的是从设备。</p><p>通常，无线数据通信中，数据包一般由位同步、帧同步、数据和结束符四部分组成。</p><p>在NRZ编码系统中，位同步码取值为10101010…，其作用主要是让接收机的位同步提取电路能可靠锁定，然后对后续的码元产生同步。</p><p>帧同步的作用是，让接收机通过扫描比较帧同步，找到数据部分的起始位置。接收机有一个若干位的移位寄存器，每收到1比特的数据就移位一次，并将新收到的数据放到最低位，然后与一个固定的帧同步常数比较，相等则表示已经同步上，否则继续接收下一个比特并比较。</p><p>数据是通信传输的有效部分，由多字节数据组成，数据中还包含数据长度、CRC校验等信息，如果采取FEC纠错算法，数据中还包含FEC的冗余部分。</p><p>结束符代表一包数据的结束。</p><p>最短数据包唤醒方法时序图：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E6%9C%80%E7%9F%AD%E6%95%B0%E6%8D%AE%E5%8C%85%E5%94%A4%E9%86%92.jpg" alt="最短数据包唤醒"></p><p>最短数据包就是在保证可靠通信的情况下总长度最短的数据包。其中位同步的长度是由硬件决定的，不同的硬件电路或不同的集成电路要求发送的位同步个数也不同，一般在4<del>16字节之间，这里假设8字节。帧同步一般为16、24、32比特，越长则误同步的概率越低，一般取32比特。数据部分可以是0字节，也可以是1</del>3字节。如果没有数据（0字节），则无法分组唤醒或携带一些唤醒参数或命令，一般情况下，数据部分最好有1字节。结束符在最短数据包中可以不存在，也可以取1字节或2字节。</p><p>采用最短数据包唤醒法的系统，工作流程和信号强度唤醒法基本一致，从设备也工作于休眠&#x2F;接收的交替状态，但其接收的持续时间必须两倍于最短数据包的发送时间，即大于等于2t。2t是最短数据包唤醒法的窗口。休眠时间T越长平均功耗越小。  </p><p>最短数据包唤醒法已经克服了信号强度唤醒法的大部分缺点。如果最短数据包中再携带一定的信息，则也可以在Tw期间让从设备处于休眠状态，从而更进一步降低功耗。</p><p>最短数据包唤醒法的缺点是，窗口时长必须在2t以上才能保证设备被可靠唤醒。</p><p>针对上述参与通信的所有无线通信设备必须在时间上同步、抗干扰能力差、接收窗口时间长从而使功耗大的缺陷，CC1101提供了检测同步字的方案。CC1101的一帧数据包由前导码、同步字、地址、数据和校验构成。当CC1101从休眠状态切换到监听状态时，在监听时间片内，若收到匹配的同步字，则进行正常的接收状态，接收完一帧数据；若在监听时间片内没有收到匹配的同步字，则重新回到休眠模式。对于这种方式，不仅可以设置不同的同步字对多个模块进行区分，避免误唤醒，此外唤醒监听的窗口也可以设置的很短，从而进一步降低平均功耗。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——低功耗技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SOC的低功耗设计</title>
      <link href="/2019/02/16/SOC%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/02/16/SOC%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>影响SOC系统功耗的参数调整主要从系统级到物理级来进行。</p><span id="more"></span><h3 id="软硬件划分"><a href="#软硬件划分" class="headerlink" title="软硬件划分"></a>软硬件划分</h3><p>软硬件划分是从系统功能的抽象描述着手，把系统功能分解为硬件和软件来实现。通过比较采用硬件方式和软件方式实现系统功能的功耗，得出一个比较合理的低功耗实现方案。由于软硬件划分处于设计的起始阶段，所以能为降低功耗带来更大的可能。</p><h3 id="功耗管理"><a href="#功耗管理" class="headerlink" title="功耗管理"></a>功耗管理</h3><p>功耗管理的核心思想是设计并区分不同的工作模式。其管理方式可分为动态功耗管理和静态功耗管理两种。动态功耗管理的思想就是有选择的将不被调用的模块挂起，从而降低功耗。静态功耗管理是对待机工作模式的功耗进行管理，它所要监测的是整个系统的工作状态，而不是只针对某个模块。如果系统在一段时间内一直处于空闲状态，则静态功耗管理就会把整个芯片挂起，系统进入睡眠状态，以减少功耗。</p><h3 id="系统硬件架构低功耗设计"><a href="#系统硬件架构低功耗设计" class="headerlink" title="系统硬件架构低功耗设计"></a>系统硬件架构低功耗设计</h3><h4 id="并行结构"><a href="#并行结构" class="headerlink" title="并行结构"></a>并行结构</h4><p>并行结构是将一条数据通路的工作分解到两条通路上完成。并行结构降低功耗的主要原因是在其获得与参考结构相同计算速度的前提下，其工作频率可以降低为原来的1&#x2F;2，同时电源电压也可降低。并行电路结构是以牺牲芯片的面积来降低功耗。高性能处理器及高速应用的设计一般都要求在给定的时间内完成指定数量的计算操作。就架构来说，在大多数情况下，对于高吞吐量的芯片，并行结构一般是首选。</p><h4 id="流水结构"><a href="#流水结构" class="headerlink" title="流水结构"></a>流水结构</h4><p>电路流水就是采用插入寄存器的办法降低组合路径的长度，达到降低功耗的目的。在先相加再比较的电路中间插入流水线寄存器的流水结构，加法器和选择器处在两条不同的组合路径上，电路的工作频率没有改变，但每一级的电路减少，使电源电压可以降低。流水结构是另外一种形式的并行操作方式，可以降低能量损耗。</p><p>流水线不同于硬件复制，并行性是由流水线的寄存器插入，将一个处理器划分为N个流水线级。在这样的实现中，如果要保持相同的数据吞吐量，就要保持相同的时钟频率f。忽略流水线造成的寄存器的开销，负载电容C还是会保持在原来的水平上。这种配置方式的优点在于大大减少了寄存器级之间计算电路的要求。</p><p>流水结构和并行化处理获得了相同的功耗目标。与并行化处理相同的是，虽然不多，但是还是带来了一些设计开销。这些寄存器开销付出了功耗和面积的代价。首先，这些寄存器都需要时钟来驱动，增加了时钟网络的电容负载，随着流水线深度的增加，原先可以忽略的开销也不得不重视，因为这一点，流水线式的并行处理技术的吸引力也相对减小。但是，相对于硬件复制并行技术来说，该技术还是有相当大的优点的，使其成为功耗优化的有效方法之一。</p><p>在实际的设计中，并不是所有的电路都适合采用流水线结构的电路。而对于流水结构电路来说，主要有两个需要注意的地方，即分支转移冒险和数据冒险。</p><h4 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h4><p>一般可采用一位热码（One-Hot码）、格雷码和总线反转码降低片上系统总线的功耗。</p><p>One-Hot码在一个二进制数中只允许1个数位不同于其他各数位的值。<br>格雷码对于任何两个连续的数字其对应的二进制码中只有1位的数值不同。</p><p>由于在访问相邻的两个地址的内容时，其跳变次数比较少，从而有效的降低了总线功耗。</p><p>除了这几种编码外，还有一些更为复杂的低功耗编码，如窄总线编码、部分总线反转编码和自适应编码等，这些编码方式的最终目的就是通过改变编码来减少不同数据切换时的平均翻转次数。在采用这些编码时，设计者应综合考虑它们带来的其他代价，如增加的编解码电路等。</p><h3 id="寄存器级低功耗设计"><a href="#寄存器级低功耗设计" class="headerlink" title="寄存器级低功耗设计"></a>寄存器级低功耗设计</h3><h4 id="门控时钟"><a href="#门控时钟" class="headerlink" title="门控时钟"></a>门控时钟</h4><p>门控时钟有两种：门控到达逻辑模块的时钟和门控到达每个触发器的时钟。但不管是哪一种，都能起到降低功耗的作用。中心模块提供给模块A和模块B不同的门控时钟，当模块不工作时，可以关闭该模块，从而达到降低功耗的目的。门控时钟作为一个低功耗最基本的优化方法，其应用已经非常广泛。在非常复杂但功耗受限的系统中，将没有任何操作的系统部分的时钟关闭是最常见的使用形式。对于何时关闭时钟，是由设计者自己来决定的。一般来说，从时钟门控技术获益最多的大多是低吞吐量的数据通路。</p><h4 id="存储分区访问"><a href="#存储分区访问" class="headerlink" title="存储分区访问"></a>存储分区访问</h4><p>存储分区访问就是将一个大的存储模块分成不同的小存储模块，通过译码器输出的高位地址来区分不同的存储模块。工作中，只有被访问的存储器才工作，其他存储器不工作。</p><h4 id="预计算"><a href="#预计算" class="headerlink" title="预计算"></a>预计算</h4><p>预计算就是提前进行位宽较小的计算工作，如果这些操作得到的信息可以代表实际的运算结果，就可以避免再进行位宽较大的计算工作，降低电路的有效翻转率，从而达到降低功耗的目的。</p><h3 id="高集成度的单片化设计"><a href="#高集成度的单片化设计" class="headerlink" title="高集成度的单片化设计"></a>高集成度的单片化设计</h3><p>将很多外围硬件集成到CPU芯片中，增大硬件冗余；内部以低功耗、低电压的原则设计，可为嵌入式处理器的低功耗设计提供很强的动力。在实际使用中，不用的硬件接口电路可以通过相关的指令关闭，以节省功耗。</p><h4 id="IP集成"><a href="#IP集成" class="headerlink" title="IP集成"></a>IP集成</h4><p>IP集成已经成为SOC的主要设计方法。不仅IP设计本身要实现低功耗设计，连接IP的总线结构也是低功耗设计的重点，集成在SOC内部的电源管理IP通过对系统功耗模式提供硬件支持来降低功耗。动态缩放技术进一步通过降低工作电压和时钟频率来减少大量功耗。</p><p>SOC面向的应用非常广泛，且有专用化的趋势，参数化设计方法可以在集成时根据应用来裁剪IP，并利用该机制结合软硬件仿真平台对参数进行邻域搜索优化。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——低功耗技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电源管理的低功耗</title>
      <link href="/2019/02/03/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97/"/>
      <url>/2019/02/03/%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97/</url>
      
        <content type="html"><![CDATA[<h3 id="电源管理方案"><a href="#电源管理方案" class="headerlink" title="电源管理方案"></a>电源管理方案</h3><span id="more"></span><h4 id="单电源、低电压供电"><a href="#单电源、低电压供电" class="headerlink" title="单电源、低电压供电"></a>单电源、低电压供电</h4><p>模拟电路的工作电压范围宽，电路正常工作的动态范围大。在允许牺牲电路增益的条件下，降低电源电压，压缩电路动态范围，可大大减小电路的工作电流，从而降低设备的功耗。</p><h4 id="分区-分时供电"><a href="#分区-分时供电" class="headerlink" title="分区&#x2F;分时供电"></a>分区&#x2F;分时供电</h4><p>一个嵌入式系统的所有组成部分并非时刻在工作，可采用分区&#x2F;分时供电技术。原理是利用开关控制电源供电单元，在某一部分电路处于休眠状态时，关闭其供电电源，仅保留工作部分电路的电源。</p><h4 id="电源管理设计"><a href="#电源管理设计" class="headerlink" title="电源管理设计"></a>电源管理设计</h4><p>系统根据不同的使用环境对CPU的运行速率进行合理调整。如过系统使用外接电源，CPU将按照正常的主频率及电压运行；当检测到系统为电池供电时，自动切换CPU的主频率及电压至较低状态运行。</p><h3 id="动态电源管理"><a href="#动态电源管理" class="headerlink" title="动态电源管理"></a>动态电源管理</h3><p>动态电源管理（Dynamic Power Management，DPM）技术有选择的把闲置的系统模块关闭或者置于低能耗状态，从而有效的利用电能。DPM基于下面的假设：</p><ul><li>系统各个部分的工作负载不同</li><li>系统在每个工作时刻的负载不同</li><li>工作负载可以预测</li></ul><p>一个电源管理系统包含一个电源管理者，它能够基于对工作负载的观察来完成控制策略。例如，简单的策略可以是某一部分不工作时，关闭供电或置成省电状态。该策略可采用不同的方法来实现，如计时器、硬件控制或软件控制。</p><p>一个电源管理系统可以用一个电源状态机来模拟，电源状态机的每种状态都代表着电源消耗情况及相应的系统性能。状态之间的转换需要一定的能量及延迟。一般来说，如果在一种状态下耗能低，系统性能也较低，转换的延迟时间也较长。如硬盘系统可以表示为3种状态：活动态，此时硬盘可被读写；闲置态，可立即转换到活动态；睡眠态。</p><p>预测性策略利用以前的工作负载情况来预测将来的闲置周期。最简单的预测技术设定策略，其缺点在于当系统模块等待超时设定期满的过程也会消耗电能。有些预测性的停止策略对超时设定进行了改进，即当一个新闲置周期开始时就把系统模块转换到低耗能状态。为了处理非静态工作负载，一些适应性技术相继出现。这些技术主要通过启发式的方法来调整超时时间。预测性及适应性策略均是启发性的。基于随机性模型的策略可取得最佳结果，结果的质量取决于所做的假设。测量结果表明这种方法可大大降低电能的消耗量。</p><h3 id="动态电压缩放"><a href="#动态电压缩放" class="headerlink" title="动态电压缩放"></a>动态电压缩放</h3><p>动态电压缩放（Dynamic Voltage Scale，DVS）基于器件工作电压越高则功耗越高的原理。系统的动态功耗和电压的平方成正比，降低供电电压可以降低系统的动态功耗。它允许在运行时改变CPU的工作电压，一般可以设置几个离散电压值，软件首先分析系统状态，然后可以根据需求在几个电压值之间进行动态调整。</p><p>动态电压缩放可以在系统不同层次上实现，在硬件上是针对处理器的设计；在操作系统中是在调度模块实现缩放电压的算法；还有是在编译器中和应用程序中实现。</p><h4 id="动态电压缩放算法"><a href="#动态电压缩放算法" class="headerlink" title="动态电压缩放算法"></a>动态电压缩放算法</h4><p>操作系统级的动态电压缩放算法的基本原理是操作系统的调度模块根据工作负载的需求来给每个任务分配不同的电压值，同时调节处理器的电压和频率，以达到降低能耗的目的。针对操作系统的动态电压缩放算法可分为两大类：一类是基于间隔方法（Interval-Based approach）的算法，另一类是基于任务方法（Task-based approach）的算法。</p><h5 id="基于间隔方法算法"><a href="#基于间隔方法算法" class="headerlink" title="基于间隔方法算法"></a>基于间隔方法算法</h5><p>这种方法的原理是系统将时间分割成固定长度的间隔，根据以前间隔中CPU的使用率对每个间隔的时钟速度进行调节。这类算法可分为两大流程，第一步是根据系统过去的行为来预测系统以后的工作负载；第二步就是根据预测的系统负载来缩放电压和时钟频率。这两步通常被称作预测和设置时钟速度。</p><p>比较经典的基于间隔的动态电压缩放算法主要有：FLAT，PEAK，PAST，AVGn。</p><h5 id="基于任务方法算法"><a href="#基于任务方法算法" class="headerlink" title="基于任务方法算法"></a>基于任务方法算法</h5><p>这种方法是考虑系统的工作由具有CPU需求和时限的任务组成，系统尽快的运行CPU以合理的概率来满足时限要求。它的基本原理就是以调度策略为基础，比如最早时限优先（EDF）或速率单调（RM）调度策略，根据每个任务的具体情况来决定供电电压。</p><p>比较有代表性的基于任务算法有：针对间发任务的动态电压缩放算法，间发任务调度STS算法和针对非周期任务的动态电压缩放算法。</p><h5 id="任务内动态电压缩放方法算法"><a href="#任务内动态电压缩放方法算法" class="headerlink" title="任务内动态电压缩放方法算法"></a>任务内动态电压缩放方法算法</h5><p>因为基于任务的动态电压缩放方法存在浪费松弛时间的问题，因此提出了针对编译级的任务内动态电压缩放方法。这种方法的基本原理是在编译时作出电压缩放的决定，确定缩放电压的代码插入哪个位置，这样就将一个任务划分成一个一个的时间片，在执行任务时电压就可以动态的在每个时间片中变化。</p><p>它可以分为两类：基于路径的任务内算法和随机任务内算法。这两者的差别在于怎样估计松弛时间和调节速度。</p><p>部分内容整理自百度百科：<br><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%94%B5%E5%8E%8B%E8%B0%83%E8%8A%82/13345771?fr=aladdin">动态电压调节</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——低功耗技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SOC的低功耗应用</title>
      <link href="/2019/02/02/SOC%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E5%BA%94%E7%94%A8/"/>
      <url>/2019/02/02/SOC%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="SOC的功耗"><a href="#SOC的功耗" class="headerlink" title="SOC的功耗"></a>SOC的功耗</h3><p>从SOC的应用层面来说，功耗主要取决于以下几个方面：</p><span id="more"></span><ul><li>芯片规格：尺寸、工艺、晶体管数量、使用的模拟与外设功能。</li><li>供电电压：电压越高，功耗越大。</li><li>时钟频率：频率越高，功耗越大。</li><li>使用的外设：使用外设越多，功耗越大。</li><li>运行模式：MCU不同的运行模式具有不同的功率消耗。</li></ul><h4 id="芯片功耗指标"><a href="#芯片功耗指标" class="headerlink" title="芯片功耗指标"></a>芯片功耗指标</h4><p>从设计角度来说，在满足系统性能需求的情况下，尽可能选择能耗较低的低功耗芯片，即在CPU的性能和功耗方面进行比较和选择。通常一个参考指标是每执行1M次指令所消耗的能量，即Watt&#x2F;MIPS。但是，实际上各个CPU的体系结构相差很大，衡量性能的方式也不尽相同。所以，我们还应该进一步分析一些细节。CPU的功率消耗分为两大部分：内核功耗PCORE和外设功耗PI&#x2F;O，总的功耗等于两者之和，即：<br>P&#x3D;P_CORE+P_(I&#x2F;O)<br>对于PCORE，关键在于其供电电源电压和时钟频率的高低；对于PI&#x2F;O来讲，除了留意各个外设的功耗外，还必须关注时钟单元与数据通路。</p><h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>动态功耗与供电电压的平方成正比，因此降低供电电压能够有效降低功耗。能够使用低电压电源供电的SOC往往都具有较好的功耗表现，而且一些SOC支持较宽的电源电压范围，在这种情况下，从降低功耗考虑，应尽可能使用较低的电源电压供电。</p><p>需要注意的是，降低供电电压会导致芯片电路信号延迟加大，执行时间变长，这是低功耗芯片设计时需要考虑的，而且在应用中，过低的供电电压可能使得SOC的部分功能或者外设无法使用，这需要结合具体应用情况而定。一些SOC内部也自带调压器，调压器输出合适的电压给SOC的core使用。内部使用调压器使得SOC的core功耗在不同电源电压下时基本固定。有些支持低功耗的SOC内部可能不止一个调压器，除了主调压器之外还有专用于低功耗模式的调压器。相比于主调压器，低功耗调压器带负载能力会弱很多，但是其调压器本身的功耗也会小很多。</p><p>此外，通过动态电压调节技术，使得SOC在不同的运行模式下，工作电源可以自动调整，从而在保证性能的基础上降低功耗。</p><h4 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h4><p>大部分SOC都不止一个时钟源可以用，而支持低功耗的SOC，其时钟单元也相对复杂，包含时钟发生器、驱动、时钟树和时钟负载等，也是芯片中功耗较高的单元。</p><p>时钟源通常分为外部时钟源和内部时钟源。外部时钟源往往使用晶体振荡器，精度高，功耗高；内部时钟源为RC振荡器，精度低，功耗相对较低。低功耗SOC通常支持外部高速时钟源、外部低速时钟源、内部高速时钟源和内部低速时钟源。很多SOC的时钟树也支持分频器和倍频器，系统时钟可以选择多个时钟源，各个外设也支持独立的时钟开关和选择多个时钟源。</p><p>选择时钟的类型和速度对SOC的功耗有很大影响。首先，动态功耗与时钟的速度成正比，时钟速度越快，功耗越大。所以，当实际使用中不需要CPU高速工作时，适当降低时钟频率可以有效降低系统功耗。虽然降低时钟速度可以直接降低功耗，但是这在很多情况下不是理想的解决方案，因为时钟速度降低后，CPU执行指令所需的时间变长，其性能会减弱。如果我们考虑平均功耗，使用最快的时钟速度让CPU执行任务，然后在剩下的时间内使CPU工作在低功耗模式才是一个较好的选择。这就是后面会分析的SOC的低功耗运行模式。</p><h4 id="外设与GPIO"><a href="#外设与GPIO" class="headerlink" title="外设与GPIO"></a>外设与GPIO</h4><p>SOC通常具有很丰富的外设以适应各种应用场景。支持低功耗模式的SOC其每个外设应可以独立的开启和关闭。实际低功耗应用中SOC用不到的外设应该全部失能，而且其对应的各个外设时钟也应该关闭掉，这样可以节省由未使用的外设消耗的部分功耗。</p><p>很多SOC上电复位后，其GPIO默认模式为浮空输入。因为噪声的影响，设置为浮空输入时，GPIO内部的施密特触发器可能会因为噪声的波动而检测为IO电平的翻转，这也会导致GPIO一定的功率消耗。所以在低功耗应用中，未使用的GPIO应当配置到一个合适的状态以节省这部分功耗，例如配置为上拉输入或者高&#x2F;低电平输出。</p><p>此外，很多SOC的应用方案里都会使用到按键来做人机交互。不建议按键使用额外的电阻上拉到外部电源或者下拉到地，因为按键按下时外电路会增加不必要的电流消耗。通常的做法是按键一端直接连接GPIO，一端到地，GPIO配置为上拉输入模式。因为SOC的GPIO内的上拉输入一般为弱上拉，按键按下时内部电源通过GPIO输出的电流相对小很多。</p><p>此外，为了进一步降低按键按下时消耗的电流，我们可以在程序中动态的配置按键GPIO的输入状态：当按键按下时，程序进入外部中断的中断服务程序里，此时先将GPIO配置为浮空输入模式，然后再执行相应的任务代码。在按键释放后或者任务代码执行完成后，应再将GPIO重新配置回上拉输入模式。动态配置上拉输入的好处在于，在按键按下的时间里，GPIO大部分的时间处于浮空输入状态，比上拉输入状态的消耗更小。</p><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><p>系统功耗也取决于SOC的运行模式。如果SOC使用电池供电，那么选择合适的运行模式就十分重要。为了确保电池的使用时长，在设计时就必须考虑系统的平均功耗，使其低于一个目标值。一般情况是，SOC在一个周期内很短的时间片内执行任务，然后在剩下的时间内工作在低功耗模式，从而使其平均电流消耗小于目标值。</p><p>概括来说，低功耗SOC支持以下三种运行模式：</p><ul><li>运行模式（Run Mode）</li><li>待机模式（Wait Mode）</li><li>休眠模式（Sleep Mode）</li></ul><p>运行模式指的是SOC没有使用休眠策略，CPU与外设正常工作的模式。在持续供电且不用考虑功耗的情况下，系统往往采用运行模式。</p><p>在待机模式下，系统的core以低速保持工作，部分组件进入休眠状态，等待一个外部或内部的中断事件来唤醒。</p><p>在休眠模式下，系统绝大部分组件包括core都关断，以大幅度的节省能耗。同时，系统能够被唤醒的手段相对于待机模式也会少很多，往往可能只支持外部中断唤醒。</p><p>待机模式和休眠模式都属于低功耗模式，两种又有着一些区别：休眠模式的唤醒反应时间比待机模式长一些，因为在休眠模式下，片上存储器断电、core关断、大部分外设与时钟关闭，而这些恢复正常工作都需要时间。也正因为这些特性，休眠模式的功耗比待机模式的功耗也小很多。</p><h4 id="其他低功耗手段"><a href="#其他低功耗手段" class="headerlink" title="其他低功耗手段"></a>其他低功耗手段</h4><p><strong>1.尽量减少CPU的计算量。</strong><br>减少CPU运算的工作可以从很多方面入手：</p><ul><li>将一些运算的结果预先计算好，放在Flash中，用查表的方法替代实时的计算，减小CPU的运算工作量，可以有效降低CPU的功耗。</li><li>不可避免的实时计算，算到精度够了就结束，避免“过度”计算。</li><li>尽量使用短的数据类型，如尽量使用字符型的8位数据替代16位的整型数据。</li></ul><p><strong>2.软件代码优化。</strong><br>软件代码的功耗优化主要包括：</p><ul><li>a.在确定算法时，对所需算法的复杂性、并发性进行分析，尽可能利用算法的规整性和可重用性，减少所需的运算操作和运算资源。</li><li>b.把算法转化为可执行代码时，尽可能针对特定的硬件体系结构进行优化，如由于访问寄存器比访问内存需要更少的功耗，所以，可以通过合理有效的利用寄存器来减少对内存的访问。</li><li>c.在操作系统中充分利用硬件提供的节点模式，随着动态电压调整技术的出现，操作系统可以通过合理的设置工作状态来减少功耗。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——低功耗技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无线网络的低功耗软件方案</title>
      <link href="/2019/02/01/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%A1%88/"/>
      <url>/2019/02/01/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="无线网络低功耗"><a href="#无线网络低功耗" class="headerlink" title="无线网络低功耗"></a>无线网络低功耗</h3><p>无线网络降低功耗的主要软件机制有拓扑控制、功率控制、数据融合和基于移动节点的节能机制。</p><span id="more"></span><h3 id="拓扑控制"><a href="#拓扑控制" class="headerlink" title="拓扑控制"></a>拓扑控制</h3><p>拓扑控制指网络拓扑随着一个或多个参数的变化而变化，这些参数包括节点的移动性、节点位置、信道、发射功率、天线方向等。通过拓扑控制能够在保证网络的覆盖率和连通性的前提下，降低通信所造成的干扰、提高MAC协议和路由协议的效率，为数据融合提供优化的拓扑结构，从而提高网络的吞吐量、可靠性、可扩展性等其他性能。</p><p>拓扑的形成受各种因素的影响，其中包括可控因素和非可控因素。</p><ul><li>非可控因素<br>节点移动性<br>天气<br>噪声等</li><li>可控因素<br>节点的传输功率<br>天线方向<br>信道分配等</li></ul><p>研究无线Mesh网络的拓扑控制问题，就是在维持拓扑的某些全局性质的前提下，通过删除或关闭某些产生冲突可能性比较大的边，或通过调整节点的发送功率来降低或避免通信时节点之间的冲突问题，以降低网络干扰，进而提高网络吞吐量。</p><p>Mesh网络是一个动态性网络体系模型，其网络拓扑结构会因动态因素激发产生随机变化。<br>因此研究无线Mesh网络的拓扑控制问题，需要重点考虑以下因素：</p><ul><li>环境因素或能量耗尽导致部分节点出现故障或失效。</li><li>恶劣的外部环境条件引发无线通信链路带宽发生变化或出现通信中断状态。</li><li>自组织网络涉及节点实时进入和移出，其网络的扩展和收缩导致了网络的动态可重构性。</li></ul><p>目前对拓扑控制的研究可以分为两大类：</p><ul><li>一类是计算几何方法，以某些几何结构为基础构建网络的拓扑，以满足某些性质。</li><li>另一类是概率分析方法，在节点按照某种概率密度分布的情况下，计算使拓扑以大概率满足某些性质时节点所需要的最小传输功率和最小邻近节点个数。</li></ul><p>无线Mesh网络现有拓扑控制策略有两种方式：</p><ul><li>基于位置驱动<br>1.以节点位置为依据的分簇算法(Geographical Adaptive Fidelity,GAF)是一种典型的基于位置驱动的拓扑控制方法。<br>2.基于位置驱动的拓扑控制方法还有GRF(Geographic Random Forwarding),利用节点位置和网络冗余来达到拓扑控制的目的。</li><li>基于连接驱动<br>基于连接驱动的拓扑控制方式有Span、ASCENT、Naps、DDEMA四种。</li></ul><p>近年来拓扑控制策略已经成为无线自组网的研究热点，但是目前在这个领域中尚存在着一些迫切需要解决的问题：</p><p>首先，<strong>对于节点分布的假设过于理想化。</strong><br>目前很多研究都假定节点是均匀分布的。虽然在某些情况下这种假设是合理的，但是在大多数情况下这样的假设都是过于理想化的。</p><p>其次，<strong>当前理论研究与仿真实验所基于的无线信道模型和能量衰减模型相对过于简单与理想化。</strong><br>实际的WMN网络环境往往相差较大，从而导致理论研究结论在实际网络环境中并不适用。因此，为了获得更加符合实际的量化结果，理论研究需要在模型的精准度和复杂度之间选取恰当的折衷点。</p><p>最后，<strong>当前关于拓扑控制的理论研究与算法设计通常基于二维平面网络的前提假设，这样的假设也是过于理想化的。</strong>因为在网络中节点的部署有很强的随机性和地域限制，因此三维立体空间更贴切无线Mesh网络的实际部署环境。</p><h3 id="功率控制"><a href="#功率控制" class="headerlink" title="功率控制"></a>功率控制</h3><p>目前功率控制机制主要利用休眠唤醒协议和MAC协议来实现功率控制的目的（目前功率控制措施主要是在MAC层采用侦听&#x2F;睡眠交替的无线信道侦听机制）。</p><h4 id="休眠唤醒协议"><a href="#休眠唤醒协议" class="headerlink" title="休眠唤醒协议"></a>休眠唤醒协议</h4><p>休眠唤醒机制即节点在不工作的时候，关掉通信模块，交替进行休眠和唤醒。</p><p>休眠唤醒协议分为非层次型和层次型两种。</p><p>非层次型的拓扑控制算法：<br>每个节点根据自己所能获取的信息，独立的控制自己在工作状态和睡眠状态之间的转换。</p><p>层次型的拓扑控制算法：<br>采用周期性选择簇头节点的做法使网络中的节点能量消耗均衡。</p><p>休眠唤醒机制有三种方案：按需、预定回合和同步。</p><ul><li>按需的典型方法有：STEM(Sparse Topology Management)、STEM-T、STEM-B、PTW(Pipelined Tone Wakeup)。</li><li>预定回合方案需要所有的邻近节点在同一时间唤醒。</li><li>同步机制在保证邻近节点活跃状态有重叠的基础上，允许每个节点独立唤醒。此后在同步唤醒机制的基础上设计了异步唤醒机制。</li></ul><h4 id="MAC协议"><a href="#MAC协议" class="headerlink" title="MAC协议"></a>MAC协议</h4><p>睡眠唤醒机制可以运行在MAC层之上，也可以集成到MAC协议之中。很多MAC协议中都具有低占空比的特点。基于TDMA的MAC协议有TRAMA、FLAMA（Flow-Ware Medium Access）和LMAC（Light-weight Medium Access）。基于竞争的MAC协议有B-MAC（Berkeley MAC）、S-MAC（Sensor MAC）、T-MAC（Timeout MAC）、D-MAC，混合MAC协议最重要的是Z-MAC。</p><p>目前MAC层功率控制技术的主要目标是降低功耗，在降低功耗的同时提高信道的空间复用度。降低功耗是第一目标，MAC层功率控制优化工作主要包括两个方面：</p><p><strong>1.冲突退避机制</strong><br>改进冲突避免接入机制，更好的解决功率控制技术带来的链路不对称等问题。</p><p>最初功率控制机制采用最大的发送功率发起RTS、CTS帧交互，而以较低的功率完成数据帧的传输和应答，从而降低数据帧的发送功率，节省节点的能耗。</p><p>有文献将此类功率控制机制称为<strong>基本功率控制机制</strong>，该机制的实现较为简单，不需要引入新的控制帧，并能与现有的DCF协议兼容。</p><p>但文献中的分析指出，该类功率控制机制不但会引起网络平均吞吐量下降，而且在某些情况下，还可能导致节点能耗的增加。</p><p>因此在基本功率控制机制的基础上提出了<strong>PCMA协议</strong>，该协议在数据帧发送期间周期性的增大发送功率，从而避免冲突。</p><p>PCMA协议没能通过功率控制机制提高频率的空间复用度，因而无法提高网络的平均吞吐量。在PCMA协议引入了一种基于双信道的功率控制机制，该机制规定，接收节点在数据信道上接收数据帧的同时，还在忙音信道上发送忙音信号。忙音信号的功率等于该节点正确接收数据帧所允许的最大噪声功率，其他发送节点能通过监听忙音信号来调整发送功率，从而避免冲突。</p><p>与DCF协议相比，PCMA协议能获得更高的网络吞吐量，但监听忙音信号仅能避免节点在接收数据帧时发生冲突，无法保证发送节点正确接收ACK应答帧。</p><p>在PCDC协议中，冲突避免信息被插入到CTS报文中并在RTS&#x2F;CTS子控制信道以最大功率发送，此时的CTS的功能不是禁止覆盖范围内的节点进行发送，而是在保证不影响其数据报文的正确接收前提下，告知邻近节点可以一定的功率上限进行功率发送，因此增大了共享信道通信的并行数目，增大了信道利用率和网络吞吐量。</p><p>冲突避免机制的设计关系到信道的空间复用问题，好的冲突避免机制有利于传输的并发，对全网性能的提高有非常重要的意义。</p><p><strong>2.发送功率选取</strong><br>通过一定策略选取最佳的发送功率。在选取发送功率级别的过程中，通常有几种方法。</p><ul><li>通过节点与周围节点的连接特性作为标准（如节点的度，连接集的定义）来确定发送的功率大小，如基于锥区域的方案来维持网络的连接性，即每个节点逐渐的增大传输功率，直到在每个方向的某个角度范围内至少能发现一个邻近节点。</li><li>根据信道质量决定节点的发送功率（如设定接收端的信噪比、QoS保证、丢包率、ACK回应的阈值），如使用闭环的循环计算方法，迭代计算出理想的传输功率，其迭代的过程就是通过递减功率发送探测包，直至不能收到ACK为止，此时的功率为迭代阶段选定的功率；转入功率维护阶段，设定连续成功接收或连续失败接收ACK数量的阈值，当超过阈值时则提升或降低功率级别。</li><li>根据路由层的反馈决定功率大小（如依次放大功率级别，直到路由成功），如在路由发现阶段设定两级功率，先用低能级进行路由发现，如果失败，则提高能级继续进行路由发现。</li><li>根据博弈论、遗传算法等数学工具计算最优功率，如采用不合作的博弈论方法提出一种新的定价机制，此定价与信干比SIR呈线性关系，通过选定不同的比列常数可以达到不同的网络优化目标，如流量均衡、吞吐率优化等。</li></ul><p>发射功率的选取对于保持网络的连通性很重要，节点选取发送功率时，不但要考虑数据的可达性，还要考虑对邻近节点造成的干扰。</p><p>通常，网络层功率控制技术所关心的是如何通过改变发射功率来动态调整网络的拓扑结构（拓扑控制，Topology Control）和路由选择，使网络的性能到达最优。</p><p>网络层确定了最大功率后，通过MAC层的功率控制在此最大发射功率前提下，根据下一跳节点的距离和信道质量等条件动态调整发射功率。网络层的功率控制依赖于MAC层的功率控制技术，和网络层的功率控制相比，MAC层的功率控制是一种经常性的调整，每发送一个数据帧都可能要进行功率控制，而网络层的功率控制则在较长的时间内进行一次调整，调整频率较低。因此，MAC层功率控制粒度更细，可更高效的调节功率以实现性能的优化。</p><p>而独立节点级的功率控制技术根据获知的情况，为每次传输挑选独立的功率进行数据发送，避免网络级功率控制使用统一功率所引起的不必要的相互干扰和网络性能的下降，更具灵活性。</p><p>传统的分层协议栈结构是网络设计中最基础、最有影响力的结构，协议栈中各层隐蔽该层及其以下层次的复杂性，为上层提供服务，分层结构逻辑清晰、扩展性强、鲁棒性高，便于实现。</p><p>然而，在严格分层协议栈网络中，整个网络系统被分割成若干个独立的层，相邻层与层之间的交互严格的通过层间的静态接口来实现，非相邻层之间不允许直接交互，因此，层与层之间的信息难以共享，增加了信息的冗余及对等层间的通信开销。合理利用跨层设计思想，联合MAC层和物理层，结合多速率和调度技术为WMN设计功率控制机制将会更加高效。</p><h3 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h3><p>根据处理的事件不同，以减少传输给终端节点的数据量为目标，数据融合方式分为两类：</p><ul><li>数据整合机制，主要是减少不必要的数据，通过网络内部处理、数据压缩、数据预测三种方式减少不必要的数据。</li><li>减少传感器模块的能量消耗，主要通过自适应采样、分层或分级采样和基于模型的主动采样三种方式。</li></ul><h3 id="基于移动节点的节能机制"><a href="#基于移动节点的节能机制" class="headerlink" title="基于移动节点的节能机制"></a>基于移动节点的节能机制</h3><p>在静态的无线网络中，一般来说，越靠近终端节点的节点能耗越大。通过一些节点（包括终端节点）的移动，可以避免这种情况的发生，从而提高WSN整体的生命周期，使无线Mesh网络中的动态和静态实现最优的配置。这种最优配置主要依赖于两个节点的位置和数据量的发送，在数据密集型无线传感器网络中制定出最佳的移动路径，达到移动节点无线传输的总能量消耗最小的目的。</p><p>由于无线Mesh网络的能量供应主要以不可补充的电池为基础，在此基础上，为了有效延长网络生存的时间，除了在节点设计时选用低功耗器件，在网络构建与控制协议设计中除了采用节点冗余技术、优化介质访问控制（MAC）技术、节能路由协议与数据融合技术、功率控制技术以外，还可以采用动态能耗管理（DPM）、动态电压调节（DVS）和动态频率调节技术（DFS）等节能策略，达到对有限能量资源的最大化利用，最大限度延长网络生存时间。</p><p>本文内容整理自《无线通信网络超低功耗技术》，如有侵权，请告知：<a href="mailto:&#x6d;&#x72;&#x2e;&#98;&#x6c;&#117;&#121;&#101;&#101;&#x40;&#104;&#x6f;&#x74;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;">&#x6d;&#x72;&#x2e;&#98;&#x6c;&#117;&#121;&#101;&#101;&#x40;&#104;&#x6f;&#x74;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——低功耗技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMOS电路的功耗</title>
      <link href="/2019/01/24/CMOS%E7%94%B5%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%80%97/"/>
      <url>/2019/01/24/CMOS%E7%94%B5%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%80%97/</url>
      
        <content type="html"><![CDATA[<h3 id="CMOS电路"><a href="#CMOS电路" class="headerlink" title="CMOS电路"></a>CMOS电路</h3><p>CMOS电路是目前应用最广泛的数字电路，具有面积小、功耗低且易于集成等特点，其基本原理同样适用于其他形式的数字电路。CMOS电路在理想状态下两管不同时导通，具有良好的功耗特性。CMOS集成电路功耗主要分为两个部分：静态功耗和动态功耗。</p><span id="more"></span><ul><li>静态功耗<br>栅极氧化层的隧穿电流<br>反偏二极管的漏电流<br>电路竞争电流<br>MOS晶体管的亚阈导通电流等</li><li>动态功耗<br>负载电容充放电引起的开关功耗<br>PMOS与NMOS同时导通时产生的短路电流功耗</li></ul><p>动态功耗占据电路总功耗的主要部分，动态功耗主要由电路中的信号翻转引起，静态功耗主要是漏电流功耗，与信号跳变频率无关。随着集成电路规模和集成度的增加，器件尺寸减小，栅极氧化层厚度减小，器件总漏电流增大，静态功耗增加。</p><h4 id="动态功耗"><a href="#动态功耗" class="headerlink" title="动态功耗"></a>动态功耗</h4><p>动态功耗是电路运行过程中信号翻转所引起的能量消耗，主要是指电容充放电引起的功耗，即开关功耗。同时，动态功耗还包括PMOS和NMOS网络同时导通时引起的短路功耗及由于延迟引起的竞争冒险功耗等。<br><strong>1.开关功耗</strong><br>开关功耗约占CMOS电路总功耗的70%~90%，是CMOS电路低功耗设计的关键。计算公式如下：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/CMOS%E7%94%B5%E8%B7%AF%E7%9A%84%E5%8A%9F%E8%80%97/1.JPG" alt="开关功耗"></p><ul><li>CL<br>CL包含：<br>自载电容（包括源漏结电容、栅极覆盖电容）<br>栅电容和布线之间的逻辑门扇出电容<br>互容产生的寄生电容<br>下一级电路的输入门电容<br>互连电容<br>反相器源漏区的电容</li><li>VDD<br>供电电压</li><li>f<br>时钟频率</li><li>α<br>电路活动因子。<br>实际情况下，CMOS电路翻转的频率不会与时钟频率一致，即不是时钟信号每次翻转都伴随输出的翻转，α是平均时间内单个节点在单位时钟周期之内翻转的概率。</li></ul><p>由上面的式子可以知道，开关功耗与负载电容、电源电压、工作频率及电路活动因子共同决定，减小负载电容、供电电压、工作频率和电路活动因子都可以减小动态功耗。</p><p><strong>2.短路功耗</strong><br>短路功耗约占CMOS电路总功耗的10%~30%。<br>对于理想的CMOS电路来说，晶体管工作状态瞬间翻转，没有延时，不存在从电源到地之间的电流通路。现实中的CMOS电路输入信号的上升&#x2F;下降时间大于0，上拉网络和下拉网络在很短的时间内同时导通，存在从电源到地之间的短路电流脉冲，产生短路功耗。短路电流与CMOS管的尺寸有关。<br>当VDD低于PMOS和NMOS晶体管的开启电压之和时，PMOS和NMOS不满足同时导通条件，不可能同时导通，没有短路电流，但与此同时，电路的处理速率降低。</p><h4 id="静态功耗"><a href="#静态功耗" class="headerlink" title="静态功耗"></a>静态功耗</h4><p>静态功耗主要是MOS管中的漏电流引起的功耗，占总功耗的比列不足1%。<br>漏电流主要与器件的工艺有关，一般由以下几个方面组成：</p><ul><li>亚阈值漏电流（subthreshold leakage）</li><li>PN结反偏电流</li><li>栅电流</li><li>栅极感应漏电流</li><li>沟道隧穿电流</li></ul><p>在CMOS电路中，阈值电压非常重要。阈值电压即为形成沟道（增强型）时所对应的VGS。<br>电路延时与阈值电压的大小成正比，降低阈值电压可以减小电路延时。但若减小阈值电压，亚阈值电流会增大，引起漏电流功耗增加。因此在低功耗CMOS电路设计时应充分考虑阈值电压的影响，合理选择工作电压和阈值电压。漏电流功耗在总的动态功耗中所占比重较小，若选择工艺阈值电压高、栅极氧化层厚度大的晶体管，则静态功耗可以有效降低。</p><p>目前，功耗的优化方法越来越多，也越来越具有针对性，但其思想都是通过降低工作电压、工作频率、减少计算量等方法实现集成电路的功耗优化。</p><h3 id="CMOS电路低功耗"><a href="#CMOS电路低功耗" class="headerlink" title="CMOS电路低功耗"></a>CMOS电路低功耗</h3><p>使用CMOS电路应注意的几点：</p><p><strong>1.CMOS电路的逻辑电平。</strong><br>CMOS电路的逻辑电平与TTL电平有所区别，CMOS电路的驱动电压范围较宽，而TTL电路的驱动电压范围较窄。通常情况下，CMOS电路之间可以互相驱动，CMOS可以驱动TTL电路，而TTL并不能驱动所有的CMOS电路。</p><p><strong>2.未用引脚的处理。</strong><br>a.未用引脚不能悬空。由于CMOS电路是电压控制器件，其输入阻抗很高，如果输入引脚悬空，会带来以下问题：</p><ul><li>在输入引脚上很容易积累电荷，产生较大的感应电动势。</li><li>输入端电平不稳定，电路来回翻转而增大系统功耗。</li><li>虽然CMOS器件有保护电路，不至于损坏器件，但未用引脚悬空会使输入引脚电位位于过渡区，使电路中的P沟道和N沟道都处于导通状态，致使功耗增大。</li></ul><p>b.输出为高原则。为降低功耗，多余的门电路引脚应遵循使输出为高电平的使用原则。</p><p><strong>3.CMOS器件的带负载能力。</strong><br>CMOS电路因输入阻抗高，所以输入漏电流很小，基本可以不考虑总线带负载的能力，接口芯片可以直接挂在总线上；而TTL器件的漏电流较大，需要考虑芯片的扇出数。</p><p><strong>4.尽量选择高速低频工作方式。</strong><br>虽然CMOS器件的静态功耗几乎为零，但在逻辑电平翻转时会有电流流过，器件的动态功耗和逻辑电平翻转频率成正比。需要注意的是，选用高速低频器件会带来电磁兼容性方面的问题，因为高速器件会产生大量的谐波，产生电磁辐射。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——低功耗技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>物联网万物皆文件特性的思考</title>
      <link href="/2018/12/23/%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/12/23/%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6%E7%89%B9%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h4 id="从一个WiFi模块谈起"><a href="#从一个WiFi模块谈起" class="headerlink" title="从一个WiFi模块谈起"></a>从一个WiFi模块谈起</h4><p>WiFi模块可以说是在目前物联网产品中使用较多的模块。这篇文章从一个小小的WiFi模块开始，去一步一步摸索物联网的万物皆文件的特性，是我对前面一篇文章的进一步思考。本文展示的是一种思路，思路是清晰的，但可能表达的不是很好，有待于后续的整理与补充。</p><span id="more"></span><p>WiFi模块目前发挥的作用：<br>目前WiFi模块内部主要是MCU，微控制器，价格比较低廉，比较知名的有乐鑫的esp8266。这种MCU为主控的注定了模块一般不会去做处理器的重活，而且一般MCU我们主要侧重点是control（驱动、外设）、connect。MCU不是DSP，一般也没有NPU等核，频率也不高，存储容量也不大，算法全放在MCU上跑是比较吃力的，而且容易达到其上限。</p><p>对于WiFi模块，我们主要关注的是control、data transfer。而且目前可以看到的是，很多WiFi模块在项目中起到的作用还是串口数据透传，没有充分挖掘WiFi模块能够提供的能力。</p><p>一般WiFi模块的使用：<br>control：<br>in - sensor<br>out - controller<br>in&#x2F;out - 其他device</p><p>data transfer:<br>could service: wifi -&gt; internet -&gt; webservice<br>webservice: 一些拿mcu wifi模块自己做的云、开放的物联网平台等。</p><p>wireless data transfer:<br>other device.</p><p>对于我们个人开发者来说，除了利用WiFi模块完成项目里所需要的功能后，往往还会考虑一个问题：WiFi模块还可以用来做什么？</p><p>思考：<br>wifi模块可以用来做什么？<br>绝大部分是硬件处理后的数据传输，交互。</p><p>如果像windows电脑的设备管理器一样，WiFi模块能够管理所有局域网内的设备？<br>what if device tree managered by wireless connect?</p><h4 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h4><p>1.从头开始：<br>第一阶段：<br>moblie app：<br>第一小步：<br>移动版的串口调试助手<br>uart data transfer through wifi or bt,<br>like uart asistant on pc.<br>（基本功能）<br>串口收发数据，ascii、hex<br>receive and send uart data.<br>用途：<br>发送指令，send control code<br>获取传感器信息, get sensor status<br>甚至解析摄像头传过来的图像数据，<br>或者调试系统，系统的console：协议、图像、指令<br>特点:<br>移动端上功能全面，性能出色，使用方便的调试助手。</p><p>第二小步：<br>增强链接，传感器增强：<br>1.移动端可以使用指令调用板子上的传感器资源，以及控制设备。<br>2.模块端可以使用指令调用移动端上的资源，比如手机上的传感器：陀螺仪、gps等，手机摄像头拍照，数据网，短信，电话等。<br>用途：<br>1.移动端可以方便的获取板子传感器数据以及控制板子上设备的功能。<br>2.以一个便宜的WiFi&#x2F;蓝牙模块就可以调用手机上丰富的功能，极具性价比。</p><p>第三小步：<br>直接远程输入执行脚本（lua）<br>在node mcu中本身就可以通过串口执行各种脚本。<br>两个方式：<br>1.WiFi接收的数据透传到uart，让接着串口的系统可以执行脚本运行程序（本身串口调试助手就可以）<br>2.在node mcu的基础做支持WiFi远程执行lua脚本的功能。<br>调用比第二小步中的指令执行更加灵活。实际上串口传输的是字符串，然后本地解释器解释执行。不会有函数返回结果，相当于远程console。</p><p>第四小步：<br>Over-the-Air Upgrade (OTAU)<br>The OTAU bootloader is able to load an application image, which has been received by the application over the air and saved in an external memory device, and program it into the internal flash memory.<br>level 1：<br>application：script code (lua、python)<br>level 2：<br>firmware,中间件，协议栈更新<br>level 3：<br>系统更新<br>system image update</p><p>第五小步：<br>RPC 是远程过程调用<br>Remote Procedure Call<br>RPC 是指计算机 A 上的进程，调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。而这一过程，对于开发人员来说是透明的。<br>在移动端上运行的程序的函数是调用WiFi模块的，通过远程过程调用进行无缝调用。</p><p>2.设备文件系统雏形<br>第二阶段：<br>第一小步：<br>WiFi模块只要连接接到手机，或者与手机在同一个局域网下。手机端可以视WiFi模块为一个设备文件系统。<br>WiFi模块里所有可用资源，如外部传感器、接口、io、控制器、甚至自己的文件系统、自定义的数据处理、加解密的算法、功能、与控制逻辑等，都以文件的形式可被手机访问到。只要手机有合适的权限，那么像访问文件一样，只要挂载上，就可以远程调用任何支持的资源。（WiFi模块对于手机的查看就相当于window的设备管理器）<br>比如,一个WiFi网络内的一个模块的设备树:<br>根：192.168.1.10&#x2F;esp_wifi_device<br>硬件层：<br>.&#x2F;esp_wifi_device&#x2F;hardware&#x2F;sensor1<br>.&#x2F;esp_wifi_device&#x2F;hardware&#x2F;sensor2<br>.&#x2F;esp_wifi_device&#x2F;hardware&#x2F;control1<br>.&#x2F;esp_wifi_device&#x2F;hardware&#x2F;control2<br>.&#x2F;esp_wifi_device&#x2F;hardware&#x2F;uart1<br>.&#x2F;esp_wifi_device&#x2F;hardware&#x2F;spi<br>系统层：<br>.&#x2F;esp_wifi_device&#x2F;system&#x2F;http<br>.&#x2F;esp_wifi_device&#x2F;system&#x2F;wifi<br>.&#x2F;esp_wifi_device&#x2F;system&#x2F;encrypt<br>.&#x2F;esp_wifi_device&#x2F;system&#x2F;embeded function1<br>.&#x2F;esp_wifi_device&#x2F;system&#x2F;embeded function2<br>.&#x2F;esp_wifi_device&#x2F;system&#x2F;status<br>应用层：<br>.&#x2F;esp_wifi_device&#x2F;app&#x2F;application1<br>.&#x2F;esp_wifi_device&#x2F;app&#x2F;application2</p><p>lua脚本，可远程调用函数执行。</p><p>第二小步：<br>wifi模块同样可以视手机为一个设备文件系统，只要有合适的权限，可以使用手机设备文件抽象出的各种功能：<br>例如：一个wifi网络内的手机的设备树：<br>根：192.168.1.11&#x2F;android_phone<br>硬件层：<br>.&#x2F;android_phone&#x2F;gps<br>.&#x2F;android_phone&#x2F;sms<br>.&#x2F;android_phone&#x2F;sensor1<br>.&#x2F;android_phone&#x2F;sensor2<br>.&#x2F;android_phone&#x2F;camera1<br>.&#x2F;android_phone&#x2F;camera2<br>.&#x2F;android_phone&#x2F;bluetooth<br>.&#x2F;android_phone&#x2F;wifi<br>.&#x2F;android_phone&#x2F;mobiledata<br>.&#x2F;android_phone&#x2F;nfc<br>…<br>系统层：<br>.&#x2F;android_phone&#x2F;console<br>.&#x2F;android_phone&#x2F;adb<br>.&#x2F;android_phone&#x2F;system_app1<br>…<br>框架（库）层：<br>.&#x2F;android_phone&#x2F;python<br>.&#x2F;android_phone&#x2F;opencv<br>.&#x2F;android_phone&#x2F;tensor_flow<br>…<br>软件层：<br>.&#x2F;android_phone&#x2F;app1<br>.&#x2F;android_phone&#x2F;app2<br>.&#x2F;android_phone&#x2F;app3</p><p>最终效果：<br>包括计算机在内的一系列设备，甚至一些专用仪器都可以使用这套框架。该框架可以集成在IOT系统中作为一个基础设施存在，同时对于目前已有的物联网云来说，整个结构都需要重新设计，以适应这种面向文件操控而不是数据操控的访问方式。<br>最终实现万物皆文件，最廉价的底性能设备也可以有能力去操控高性能的设备。</p><p>以智能音箱为例，廉价的小音箱在上述设计的firmware与protocol的基础上，可以以一个低成本的解决方案去控制、管理网络下的各种设备，设备联系更加紧密，使用更加人性化。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——物联网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对物联网的一些思考</title>
      <link href="/2018/12/23/%E5%AF%B9%E7%89%A9%E8%81%94%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2018/12/23/%E5%AF%B9%E7%89%A9%E8%81%94%E7%BD%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h3 id="物联网该是什么样子"><a href="#物联网该是什么样子" class="headerlink" title="物联网该是什么样子"></a>物联网该是什么样子</h3><p>这是16年在知乎上发的一篇关于物联网的思考的文章，现在翻出来转到自己博客上。现在看看还是觉得当时自己还是太年轻，技术上的积累太少，有些东西考虑的不到位，甚至有些天真了。最近又思考了一番，深化了一些细节内容，会在下一篇文章给出。</p><span id="more"></span><p>原文链接：<br><a href="https://zhuanlan.zhihu.com/p/21526343">关于物联网下一步发展的思考</a></p><p>物联网是一个非常大的、高度复杂的东西，从目前国内发展的状况来看，还是处于玩概念阶段。从智能家居到智能工厂到其他产业智能化再到智能城市，从智能再到智慧，这需要一系列强有力的基础作为支撑，而且也是一个循序渐进，潜移默化的过程。像目前的智能家居就是一个初端，但是现在的这个初端，总是觉得少了什么。</p><p>关键词： <strong>平台、安全、服务</strong></p><h4 id="构建平台"><a href="#构建平台" class="headerlink" title="构建平台"></a>构建平台</h4><p>目前国内好几家大公司都开发了自己的物联网平台，好多企业也在研发自己的产品。个人觉得，目前小米算是做的不错的，它就把握住了很多关键的点，但是我觉得它做的还是不够。小米现在有很多智能家居的产品。但是在这方面应该争做产业链上游，卖技术为主，现在物联网刚刚起步，我们还是有很多机会的。在智能家居这块，无线路由器是家居产品连网的绝佳切入点，小米抓住了这个点，在智能路由器中加入它的产品的远程监控。想做成一个大家都能接受的平台不容易，这种庞大而又复杂的东西，需要各大企业合作，全社会协作进行。对于这样一个平台，应该打造成安卓系统这种类型，这样做有利于其自身的推广与发展。</p><p>个人觉得未来将是嵌入式的黄金二、三十年，可以与各行各业进行深层次的结合，有非常多的机会和非常大的潜力，能够极大的推动社会的发展，十年之后的生活会是怎样，可能我们现在都无法去预测，一切皆有可能。现在的嵌入式系统的发展只能算是一个开端，很多东西我们还处于学习的阶段，离应用还是有些距离。很多人一想到嵌入式，就想到linux，Android，QT，arm处理器等等，仿佛做这些就是代表的嵌入式，但是这不全是。嵌入式的精髓在于 <strong>灵活</strong>，对不同的对象有合适的处理方法，这些应该理解为嵌入式的高级应用，适用于处理复杂的事情，然而很多东西它不需要复杂的控制，它要考虑成本，51能做的事情为什么要用arm cortex A9的处理器呢，所以对不同的控制对象应该采用合适的方案。从硬件底层来说，这就意味着合格的物联网平台应该具有包容性，全面支持各种层次、架构的MCU与处理器。</p><p>物联网和嵌入式有很多相似的特性，两者并驾齐驱可以达到相辅相成的结果。所以，对于打造一个平台，从终端底层系统来说，物联网应与嵌入式系统相结合，源码开源，不同层次全面覆盖，MCU以FreeRTOS为支撑，支持8位，16位，32位的所有单片机，x86架构和arm系列的处理器可以以linux为支撑，或者直接开发出属于我们自己的物联网专用SOC和操作系统。开发手机操作系统已经很难赶上目前主流手机系统了，而这是一次可以在这方面走在前面的机会。底层系统支持多种传输介质接入网络技术，比如有线的以太网，各种总线，无线的蓝牙、wifi、ZigBee和其他频段电磁波，红外、可见光传输，甚至声波传输，比如超声波，这些自由的数据传输最终转换为以太网、wifi或者移动数据网络接入Internet。支持这些可以非常灵活，自由，因地制宜、量体裁衣的设计物联网设备，为开发者提供无限可能的开发方案。</p><p>然后就是加大宣传力度，提供论坛交流，对主流的单片机、处理器提供开发板，对各个层次的单片机、处理器提供丰富详细的系统移植教程，各种应用例程，开发方案，与高校课程实践、课程设计，甚至于专业比赛相结合。（比较郁闷的是为什么有些公司开发的系统不对外公开，好不好也无法评估，我觉得物联网系统是需要众多的参与者的，因为这个系统要包含的内容、对象非常的多而且复杂，公司自己可能也无法考虑应用的那么全面）目前32位的arm cortex mx内核的单片机中，我觉得做的最成功的是意法半导体的STM32，为什么用户非常的多，因为服务到位，网上一搜，stm32的开发资料非常的多，众多的开发资料使得它简单，易用，因而用户也多。就比如说开发板，用户在购买开发板进行学习时，肯定考虑资料多不多，够不够全面。想要将物联网开发系统变成一个平台，就必须做好这些前期工作，资料全面易得到，简单易上手，开发者用户多。之所以要开源是因为物联网是一个非常庞大而又复杂的东西，光靠企业自身的力量是不行的，这需要全社会的投入，合作。推出开源的系统后，可以利用众多第三方企业，或者个人的开发者来推动系统的优化升级，bug修复，以及系统的推广。</p><h4 id="保障安全"><a href="#保障安全" class="headerlink" title="保障安全"></a>保障安全</h4><p>物联网核心是网络。在开发的操作系统里应有包含云服务和局域网控制的物联网服务框架，代码也应多种编程语言版本，全部开源。对于在MCU里使用的C语言框架应该尽可能的简单，易移植性要强，最好能够做出那种类似于FatFS文件系统的性质的物联网服务框架，简单易用，可远程、局域网使用，不用上系统（简单的while结构）都能运行最好不过。或者学习TI的CC系列单片机的源码结构（比如源码包含了zigbee协议的CC2530），以那样的一种形式提供给开发者。开源的物联网服务框架意味着想要安全使用的话，需要超强的加密以及安全保护机制。至于安全保护机制，非常的重要，用户的账号保护，数据的网络传输，云服务器的安全是重中之重，而这样整个的一个平台单靠一个企业来做是很困难的，单是设计物联网协议就已经是足够头疼的问题了。以个人的看法，腾讯的强力的用户账号保护机制，360优秀的保障网络安全能力，阿里出色的云服务、大数据处理、云安全能力，百度强大的数据分析能力，华为卓越的研发能力，小米在这方面探索的可行方法与经验，如果能够携手合作，结合各方的优势，打造出成功的平台是一点问题也没有的。而且这样的平台用起来，人们对于各种物联网产品的使用会放心的多。</p><h4 id="拓展服务"><a href="#拓展服务" class="headerlink" title="拓展服务"></a>拓展服务</h4><p>目前的智能家居产品的服务主要就是提供用户远程监控服务，一些公司只是对用户数据无意义的收集，云处理往往是一个噱头。除了提供用户远程监控服务外，这些数据经过处理分析后能产生一些价值。比如统计大量的用户数据，推测出人们常用的控制策略以及生活习性，并据此提供用户各种适合习惯的控制策略，或者云托管，做真正的云管家。比如可以根据不同地区人们使用的设备数量与种类，可以估算出不同地区的发展水平，不同地区人们对于生活质量的不同追求，消费习惯，以及间接反应地区的环境质量，比如如果A地区的空气净化机使用较多，说明A地区的空气质量肯定是存在问题的，甚至可以根据用户使用的空气质量检测传感器上传的空气质量数据来更精确的分析出地区的空气质量水平，以此来找出污染源，再比如根据用户使用的温湿度传感器上传的数据，精确分析各地区的温度变化，以及变化规律，分析冷暖气流的移动方向，甚至提前做出天气预报，向用户预警。单在智能家居这块，里面有非常多的有价值数据可以挖掘，并反过来为各方提供有价值的服务。</p><p>最后一个问题就是如何盈利，短期的话应该看不到盈利，而且需要大量的投入，从长远来看是非常可观。所以这些东西小公司是无法做成的，得有能力的公司来做，把这些东西都做了之后，不仅是成为产业链上游企业，更可能成为行业标准制定者。上游企业的盈利方式主要应该是云服务，以及物联网操作系统对第三方企业的授权，以及认证，类似于谷歌的安卓。对于利用平台研发自身产品的企业可以对其收授权、认证和云服务费用，对于个人一定服务范围内免费。比如teamviewer的远程连接服务，对企业收费，对个人免费。授权很好理解，认证即是在云服务里向用户提供该公司产品专用的各项服务。只要个人注册了云服务账号，购买第三方的产品后，使用该产品也应该是免费的。云服务费就是根据第三方企业的产品在云服务上的用户使用量来对第三方企业收取一定的费用。个人开发者也应该可以直接免费使用基于系统框架的云服务，而出于安全性的考虑，个人开发者想用自己开发的产品来使用云服务时应该实名制，防止出现使用于非法活动的情况。</p><h3 id="对物联网系统的特性的思考"><a href="#对物联网系统的特性的思考" class="headerlink" title="对物联网系统的特性的思考:"></a>对物联网系统的特性的思考:</h3><h4 id="非常强大的包容性"><a href="#非常强大的包容性" class="headerlink" title="非常强大的包容性"></a>非常强大的包容性</h4><p>全面支持多种平台，终端系统支持多种MCU，处理器（系统分层次，分版本，有简单有复杂），非常强的易移植性。</p><h4 id="非常灵活的联网方案"><a href="#非常灵活的联网方案" class="headerlink" title="非常灵活的联网方案"></a>非常灵活的联网方案</h4><p>支持众多的通信方案，从有线到无线，从光到声。并不是这些功能都要包含在预移植系统中，而是系统提供各种方案的接口，提供完善的协议，以及软硬件解决方案。单一的通信方式，特别是无线，信道的容量是一定的，要充分考虑设备过多，过于密集的情况，采用灵活的联网方案就可以有灵活的拓扑结构（比如混合使用），进而实现理想的通信效果。</p><h4 id="自由的云服务框架"><a href="#自由的云服务框架" class="headerlink" title="自由的云服务框架"></a>自由的云服务框架</h4><p>要求是使用简单，自由。</p><h4 id="严格而又智能的云管理"><a href="#严格而又智能的云管理" class="headerlink" title="严格而又智能的云管理"></a>严格而又智能的云管理</h4><p>分权限管理，加强安全操作机制。比如云平台只有在获得用户的对应许可后才可以查看具体数据信息，在获取用户许可后才可以主动控制用户的设备。</p><h4 id="强有力的安全保护机制"><a href="#强有力的安全保护机制" class="headerlink" title="强有力的安全保护机制"></a>强有力的安全保护机制</h4><p>通信加密，网络防护，用户账户保护，云防护、紧急情况智能处理等都是必须有的安全保护机制。</p><h4 id="万物皆文件"><a href="#万物皆文件" class="headerlink" title="万物皆文件"></a>万物皆文件</h4><p>个人觉得这是系统的核心问题。这个意思是学习linux的“一切皆文件”，不管是局域网内还是云访问各种各样的物联网设备时，对设备的操作全部转化为对文件的操作。这样做在整个系统里有非常多的好处，解决了很多潜在的难点，比如权限管理、设备标识、设备多样化。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——物联网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git命令速记</title>
      <link href="/2018/12/20/git%E5%91%BD%E4%BB%A4%E9%80%9F%E8%AE%B0/"/>
      <url>/2018/12/20/git%E5%91%BD%E4%BB%A4%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h3><p>GIT （分布式版本控制系统）<br>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><span id="more"></span><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>命令行输入git先看系统有没有已经安装。<br>linux：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>windows<br>下载可执行文件<br><a href="https://git-scm.com/downloads">官网下载地址</a></p><p>安装好后设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>初始化一个Git仓库：<br>git init </p><p>添加文件到Git仓库，分两步：<br>1.把文件修改添加到暂存区：<br>git add filename<br>2.暂存区的所有内容提交到当前分支：<br>git commit -m “message”</p><p>查看仓库当前的状态:<br>git status</p><p>查看具体修改了的内容：<br>git diff filename</p><p>查看版本记录：<br>详细：<br>git log<br>简略：<br>git log –pretty&#x3D;oneline<br>SHA1计算出来的一串数字是commit id（版本号）</p><p>版本回退：<br>git reset<br>在Git中，用HEAD表示当前版本。<br>上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100<br>回退到上一个版本：<br>git reset –hard HEAD^<br>回退到指定版本：<br>git reset –hard commit_id（没必要写全，前几位）</p><p>查看命令记录：<br>git reflog<br>（可用于找commit id）</p><p>撤回修改：<br>1.文件已修改，未add到暂存区:<br>git checkout – filename<br>2.文件已修改，并add到暂存区，未commit：<br>git reset HEAD filename<br>git checkout – filename<br>或<br>git reset –hard HEAD</p><p>从版本库中删除文件:<br>git rm filename（不仅删除了文件，而且还添加到了暂存区）<br>git commit -m “message”</p><p>本地删错文件了，恢复：<br>git checkout – filename<br>（git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除）</p><p>在本地关联远程库：<br>git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;</a>:xxx&#x2F;xxx.git<br>添加后，远程库的名字就是origin</p><p>把本地库的内容推送到远程:<br>git push</p><p>git push -u origin master<br>远程库如果是空的，我们第一次推送master分支，加上-u参数，<br>Git不但会把本地的master分支内容推送的远程新的master分支，<br>还会把本地的master分支和远程的master分支关联起来，<br>在以后的推送或者拉取时就可以简化命令：<br>git push origin master</p><p>从远程库拉取最新的内容：<br>git pull</p><p>从远程库克隆：<br>git clone <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>:xxx&#x2F;xxx.git</p><p>查看分支:<br>git branch</p><p>创建分支：<br>git branch branchname</p><p>切换分支：<br>git checkout branchname</p><p>创建+切换分支：<br>git checkout -b branchname</p><p>在本地创建和远程分支对应的分支：<br>git checkout -b branchname origin&#x2F;branchname</p><p>建立本地分支和远程分支的关联：<br>git branch –set-upstream-to origin&#x2F;branchname branchname</p><p>合并某分支到当前分支：<br>git merge branchname<br>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>–no-ff： 强制禁用Fast forward模式，<br>Git就会在merge时生成一个新的commit，<br>从分支历史上就可以看出分支信息。<br>git merge –no-ff -m “message” branchname。</p><p>删除分支：<br>git branch -d branchname<br>删除本地分支后，同步到远程：<br>git push origin branchname 删除远程分支branchname</p><p>解决冲突：<br>把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>工作做到一半要去做别的分支，保存现场：<br>git stash<br>然后，用git status查看工作区，就是干净的（除非有没有被Git管理的文件）。</p><p>恢复现场：<br>查看：<br>git stash list<br>恢复方法一：<br>git stash apply（恢复后，stash内容并不删除）<br>git stash apply stash@{0} （恢复指定stash）<br>git stash drop （删除）<br>恢复方法二：<br>git stash pop （同时删除drop）</p><p>丢弃一个没有被合并过的分支：<br>git branch -D branchname</p><p>查看远程库<br>git remote<br>git remote -v （详细信息）</p><p>把本地未push的分叉提交历史整理成直线：<br>（目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比）<br>git rebase</p><p>查看标签：<br>git tag  查看所有标签<br>git show tagname  查看标签信息等具体内容</p><p>新建标签：<br>（标签基于commit，创建的标签都只存储在本地，不会自动推送到远程。）<br>git tag tagname   用于新建一个标签，默认commit为HEAD。<br>git tag -a tagname -m “message”   可以指定标签信息，默认commit为HEAD。<br>git tag tagname commit_id  给对应commit打标签</p><p>删除标签：<br>git tag -d tagname</p><p>推送标签到远程：<br>git push origin tagname  推送指定标签<br>git push origin –tags   推送所有标签</p><p>删除远程标签：<br>1.git tag -d tagname  先删除本地标签<br>2.git push origin :refs&#x2F;tags&#x2F;tagname  删除远程标签</p><p>忽略特殊文件：<br>编写.gitignore文件<br><a href="https://github.com/github/gitignore">example</a><br>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——代码管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Linux系统之Linux文件系统</title>
      <link href="/2018/12/16/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E4%B9%8BLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/12/16/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E4%B9%8BLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><p>在Unix业界有一句话叫做“一切皆文件”，这是对Linux文件系统的一个很好抽象。<br>我们说“Linux中一切皆文件”直观的可以这样理解：所有的东西，设备、内存都模拟成文件。</p><span id="more"></span><p>而Windows中，我们则可以极端的认为“一切皆设备”。</p><h3 id="常用的文件系统"><a href="#常用的文件系统" class="headerlink" title="常用的文件系统"></a>常用的文件系统</h3><h4 id="第二代扩展文件系统（EXT2）"><a href="#第二代扩展文件系统（EXT2）" class="headerlink" title="第二代扩展文件系统（EXT2）"></a>第二代扩展文件系统（EXT2）</h4><p>ext2fs由Rey Card设计，其目标是为Linux提供一个强大的可扩展文件系统。</p><ul><li>支持标准unix文件类型</li><li>管理大的分区，达4TB</li><li>支持长文件名，255字符</li><li>为超级用户保留5%数据块</li></ul><h4 id="基于FLASH的文件系统"><a href="#基于FLASH的文件系统" class="headerlink" title="基于FLASH的文件系统"></a>基于FLASH的文件系统</h4><p>FLASH（闪存）作为嵌入式系统的主要存储媒介，有其自身的特性。FLASH的写入操作只能把对应位置的1修改为0，而不能把0修改为1（擦除FLASH就是把对应存储块的内容恢复为1），因此，一般情况下，向FLASH写入内容时，需要先擦除对应的存储区间，这种擦除是以块（block）为单位进行的。在往 Flash 擦除块写数据(Write)之前必须将擦除块 （Erase Block）先进行擦除(Erase)操作。Flash 擦除操作的最小单位是擦除块（Erase Block）, 写操作的最小单位是page。</p><p>正是因为Flash这样的特点，为Flash 存储器设计的文件系统需要实现“不在原地更新”（Out-Of-Place update)。<br>如果擦除块很小，而且可以快速的擦除，那样的话擦除块就可以被视为块设备的 disk sectors，但是事实往往并非如此。读取一个擦除块中的数据，擦除这个擦除块，然后再将更新的数据写回这个擦除块往往比简单的直接将更新的数据写到另外一个已经被擦除过的擦除块多花费100倍的时间。也就是说，在原地更新数据（In-Place updates）往往比“不在原地更新”（Out-Of-Place Update）多用100倍的时间。</p><p>当然，Out-Of-Place update 也随之引入了其他的要求– 垃圾回收（Garbage Collection）。 正是因为更新数据采用的Out-Of-Place， 擦除块就会既包含有效数据也包含被废弃的无效数据（有效数据已经被更新到其他地方）。 这样，最后文件系统会用光所有的擦除块，而一个擦除块将是有效数据和无效数据的结合体。 识别一个擦除块中含有很多废弃数据，并将其中的有效数据转移到另外的擦除块的过程被称为垃圾回收（Garbage Collection）。</p><p>垃圾回收得益于文件系统的节点结构（Node structure）。文件系统的垃圾回收器如果想回收一个擦除块，这个文件系统必须能够识别存在擦除块上的数据。这正是文件系统面临的查找索引的反向问题。文件系统往往通过文件名开始查找所有属于这个文件的数据。垃圾回收正好相反，垃圾回收是以数据作为起始线索，查找它所属于的文件（如果有的话）。解决这一问题的一种方式是把元数据(meta data)和文件数据(file data)一起存储。这种文件数据和数据的组合体称之为节点（node）。每个Node记录了这个node 中的元数据隶属于哪个文件（更确切的说是inode number），以及在文件中的offset 以及数据长度等。 JFFS2 和 UBIFS 文件系统都遵循了节点结构（node-structured）的设计模式,这使得它们的垃圾收集器可以直接读取擦除块就能可以知道哪些数据需要移动，哪些数据可以丢弃，并一一更新它们的索引。</p><p>闪存主要有NOR和NAND两种技术。<br>NAND和NOR的区别:</p><ul><li>都属于闪存，操作单位是字节，而不是扇区；</li><li>NOR，更适合存储程序代码，容量一般比较小（比如32M），可擦写次数几十万次；</li><li>NAND，适合存储数据，容量比较大，与NOR相比，NAND不是很可靠，出厂时会有一定比例的坏块，对数据的存取不是通过地址映射，而是通过寄存器操作，串行读取数据，可擦写次数数百万；</li><li>JFFS与YAFFS比较,两者各有长处. 一般来说,对于容量较小的NOR Flash,可以选用JFFS;对于容量较大的NAND Flash，比如超过64MBytes,用YAFFS比较合适。</li></ul><p>FLASH的擦写次数是有限的，NAND闪存还有特殊的硬件接口和读写时序。因此，必须针对Flash的硬件特性设计符合应用要求的文件系统；传统的文件系统如ext2等，用作Flash的文件系统会有诸多弊端。</p><p>在嵌入式Linux下，MTD(Memory Technology Device,存储技术设备)为底层硬件（闪存）和上层（文件系统）之间提供一个统一的抽象接口，即Flash的文件系统都是基于MTD驱动层的。使用MTD驱动程序的主要优点在于，它是专门针对各种非易失性存储器（以闪存为主）而设计的，因而它对Flash有更好的支持、管理和基于扇区的擦除、读写操作接口。</p><h4 id="JFFS2"><a href="#JFFS2" class="headerlink" title="JFFS2"></a>JFFS2</h4><p>日志闪存文件系统版本2（Journalling Flash File System v2）</p><p>JFFS最早是由瑞典Axis Communications公司基于Linux2.0的内核为嵌入式系统开发的文件系统。<br>JFFS2是RedHat公司基于JFFS开发的闪存文件系统，最初是针对RedHat公司的嵌入式产品eCos开发的嵌入式文件系统，所以JFFS2也可以用在Linux，uclinux中。</p><p><strong>JFFS2 Overview</strong><br>JFFS2, the Journalling Flash File System version 2 is widely used in the embedded systems world. JFFS2 was originally designed for small NOR flashes (less then about 32MB) and the first device with JFFS2 file system was a small bar-code scanner. Later,when NAND flashes became widely used, NAND support was added to JFFS2. The firstNAND flashes were also small enough, but grew in size very quickly and are currently much larger then 32MB.JFFS2 has log-structured design, which basically means, that the whole file system may be regarded as one large log. Any file system modification (i.e., file change, directory<br>creation, changing files attributes, etc) is appended to the log. The log is the only data structure on the flash media. Modifications are encapsulated into small data structures called nodes.So, JFFS2 is roughly a log, the log consists of nodes, each node contains a file system modification. And this is basically all JFFS2 file system is. It is very simple from the physical layouts standpoint. </p><p>The index is a crucial part of any file system as it is used to keep track of everything that is stored in the file system. For example, the index may help to quickly locate the addresses of physical blocks which correspond to the specified file at the specified offset,or it helps to quickly find all the directory entries in a specified directory and so on.For example, in case of ext2, the inode table, the bitmap and the set of direct, indirect,doubly indirect and triply indirect pointers may be considered the index. In case of the FAT file system, the File Allocation Table may be considered as the index, etc.In traditional file systems the index is usually kept and maintained on the media, but unfortunately, this is not the case for JFFS2. In JFFS2, the index is maintained in RAM,not on the flash media. And this is the root of all the JFFS2 scalability problems.Of course, as the index in kept in RAM, JFFS2 achieves extremely high throughput,just because it does not need to update the index on flash after something has been changed in the file system. And this works very well for relatively small flashes, for which JFFS2 was originally designed. But as soon as one tries to use JFFS2 on large flashes (starting from about 128MB), many problems come up.At first, it is obvious that JFFS2 needs to build the index in RAM when it mounts the file system. For this reason, it needs to scan the entire flash partition in order to locate all the nodes which are present there. So, the larger is JFFS2 partition, the more<br>nodes it has, the longer it takes to mount it.</p><p>The second, it is evidently that the index consumes some RAM. And the larger is the JFFS2 file system, the more nodes it has, the more memory is consumed.<br>To put it differently, if S is the size of the JFFS3 flash partition,</p><ul><li>JFFS2 mount time scales as O(S) (linearly);</li><li>JFFS2 memory consumption scales as O(S) (linearly).</li></ul><p>JFFS2 has many advantages, for example:</p><ul><li>very economical flash usage. data usually take as much flash space as it actuallyneed, without wasting a lot space as in case of traditional file systems for block devices;</li><li>admitting of on-flight compression which allows to fit a great deal of data to the flash; note, there are few file systems which support compression;</li><li>very good file system write throughput (no need to update any on-flash indexing information as it simply does not exist there);</li><li>unclean reboots robustness;</li><li>good enough wear-leveling.</li></ul><p>It is also worth noting here that there is a patch which is usually referred to as the summary patch, that was implemented by Ferenc Havasi and was recently committed to the JFFS2 CVS. This patch speeds up the JFFS2 mount greatly, especially in case of NAND flashes. What the patch basically does is that it puts a small summary node at the end of each flash erasable block. This node, roughly speaking, contains the copy of headers of all the nodes in this eraseblocks. So, when JFFS2 mounts the file system,it needs to glance to the end of each eraseblock and read the summary node. This results in that JFFS2 only needs to read one or few NAND pages from the end of each eraseblock. Instead, when there is no summary, JFFS2 reads almost every NAND page in each eraseblock, because node headers are spread more or less evenly over eraseblocks.Although the patch helps a lot, it is still a not scalable solution and it only relaxes the coefficient of the JFFS2 mount time liner dependency. Let alone that it does not lessen JFFS2 memory consumption.</p><p><strong>JFFS2主要用于NOR型闪存</strong>，<br>基于MTD驱动层，特点是：<br>1.可读写的、<br>2.支持数据压缩的、<br>3.基于哈希表的日志型文件系统<br>4.提供崩溃&#x2F;掉电安全保护<br>5.提供“写平衡”支持等。<br>缺点是：<br>当文件系统已满或接近满时，因为垃圾收集的关系而使jffs2的运行速度大大放慢。<br>jffsx不适合用于NAND闪存主要是因为NAND闪存的容量一般较大，这样导致jffs为维护日志节点所占用的内存空间迅速增大，另外，jffsx文件系统在挂载时需要扫描整个FLASH的内容，以找出所有的日志节点，建立文件结构，对于大容量的NAND闪存会耗费大量时间。</p><p>jffs系列文件系统的使用详细文档，可参考MTD补丁包中mtd-jffs-HOWTO.txt</p><p><strong>JFFS3</strong><br>The main idea how to fix in JFFS2 to make it scalable is to move the index from RAM to flash. Unfortunately, this requires complete JFFS2 redesign and re-implementation and the design of JFFS3 is largely different to the design of JFFS2. </p><p>Indexing problem:</p><p>There is a large difference between block devices and flash devices in how they allow to update the contents of a sector. Block devices admit of so-called in-place updates, i.e.the update may be written straight to the sector. Flash devices do not allow this unless the whole eraseblock has been erased before.Obviously, it is unacceptable to erase the whole eraseblock each time a sector is updated. Instead, so-called out-of-place updates technique is usually used. This simply means that no attempts to update sectors in-place are made but instead, updates are written to some other sector and the contents of the previous sector is afterwords regarded as garbage.</p><p>This out-of-place writes property of flash devices assumes that JFFS3 also has<br>log-structured design as in JFFS3 any update is written out-of-place. And it seems that this is natural for any flash file system to have log-structured design.It is interesting to notice that in log-structured file systems for block devices not any update is out-of-place. There are always some fixed-position sectors present. These sectors usually refer the file system index, admit of quick file system mount and they are updated in-place.<br>But flash devices have limited number of erase cycles for each eraseblock and it is impossible to guaranty good wear-levelling if some eraseblocks are reserved for similar purposes. So, it is important that in JFFS3 there are no in-place updates as good wear-levelling is one of the main requirements to JFFS3.</p><p>wear-leveling这项技术在flash设备的微控制器上使用了一种算法，来跟踪flash上存储空间的使用情况。这使得数据每次能够重写到flash中的不同地方，而不是一直写入到同一个位置。在理想状态下，wear-leveling可以保证在重新使用空间之前，所有的物理flash存储空间都已经被使用过。使用这种方式，最大限度的使用了flash存储单元，而尽量减少了损耗的程度，所以可以保证flash设备的最长使用期限。但如果最终达到了最大使用次数，整个flash还是将会损坏。</p><p>The out-of-place updates property makes it difficult to maintain the index on the flash media. </p><h4 id="YAFFS"><a href="#YAFFS" class="headerlink" title="YAFFS"></a>YAFFS</h4><p>Yet Another Flash File System<br>yaffs&#x2F;yaffs2是专为嵌入式系统使用NAND型闪存而设计的一种日志型文件系统，提供磨损平衡和掉电恢复的健壮性。它还为大容量的Flash 芯片做了很好的调整，针对启动时间和RAM 的使用做了优化。与jffs2相比，它减少了一些功能(例如不支持数据压缩)，所以速度更快，挂载时间很短，对内存的占用较小。另外，它还是跨平台的文件系统，除了Linux和eCos，还支持WinCE, pSOS和ThreadX等。</p><p>yaffs&#x2F;yaffs2自带NAND芯片的驱动，并且为嵌入式系统提供了直接访问文件系统的API，用户可以不使用Linux中的MTD与VFS，直接对文件系统操作。当然，yaffs也可与MTD驱动程序配合使用。</p><p>YAFFS中，文件是以固定大小的数据块进行存储的，块的大小可以是512字节、1 024字节或者2 048字节。这种实现依赖于它能够将一个数据块头和每个数据块关联起来。每个文件（包括目录）都有一个数据块头与之相对应，数据块头中保存了ECC(Error Correction Code)和文件系统的组织信息，用于错误检测和坏块处理。充分考虑了NAND Flash的特点，YAFFS把这个数据块头存储在Flash的16字节备用空间中。当文件系统被挂载时，只须扫描存储器的备用空间就能将文件系统信息读入内存，并且驻留在内存中，不仅加快了文件系统的加载速度，也提高了文件的访问速度，但是增加了内存的消耗。</p><p>为了在节省内存的同时提高文件数据块的查找速度，YAFFS利用更高效的映射结构把文件位置映射到物理位置。文件的数据段被组织成树型结构，这个树型结构具有32字节的节点，每个内部节点都包括8个指向其他节点的指针，叶节点包括16个2字节的指向物理地址的指针。YAFFS在文件进行改写时总是先写入新的数据块，然后将旧的数据块从文件中删除。这样即使在修改文件时意外掉电，丢失的也只是这一次修改数据的最小写入单位，从而实现了掉电保护，保证了数据完整性。</p><p>结合贪心算法的高效性和随机选择的平均性，YAFFS实现了兼顾损耗平均和减小系统开销的目的。当满足特定的小概率条件时，就会尝试随机选择一个可回收的页面；而在其他情况下，则使用贪心算法来回收最“脏”的块。</p><p>yaffs与yaffs2的主要区别在于，前者仅支持小页(512 Bytes) NAND闪存，后者则可支持大页(2KB) NAND闪存。同时，yaffs2在内存空间占用、垃圾回收速度、读&#x2F;写速度等方面均有大幅提升。</p><h4 id="CRAMFS"><a href="#CRAMFS" class="headerlink" title="CRAMFS"></a>CRAMFS</h4><p>由Linux Torvalds参与开发的小型只读压缩文件系统。</p><ul><li>Inode、文件名称和目录信息不压缩</li><li>单个文件最大为16MB</li><li>数据压缩存放</li><li>适合不需要写、且体积较大的文件系统，如&#x2F;lib，&#x2F;opt等</li><li>与JFFS2、Cloop相比，读取速度快</li><li>压缩率可以超过50%</li><li>读取文件时，每次读取4k内容，解压缩到cache中</li><li>Linux内核已提供了对cramfs的支持，只要编译时选中</li></ul><p>创建文件系统（生成image文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkcramfs /lib lib.cramfs</span><br><span class="line">mkcramfs /usr usr.cramfs</span><br></pre></td></tr></table></figure><p>挂载文件系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t cramfs lib.cramfs /lib -o loop</span><br><span class="line">mount -t cramfs usr.cramfs /usr -o loop</span><br></pre></td></tr></table></figure><h4 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h4><p>&#x2F;proc：一个虚拟文件系统，只存在于内存中，通过它可以查询、设置系统的运行情况及各种系统参数。</p><ul><li>系统中的很多应用都依赖于proc文件系统，如命令lsmod等同于cat &#x2F;proc&#x2F;modules。</li><li>文件的大小为0</li><li>很多文件名体现了内核的相应参数，可以通过这个文件名修改参数值。如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 2048 &gt; /proc/sys/shmmni</span><br><span class="line">修改共享内存段的限制</span><br></pre></td></tr></table></figure></li><li>&#x2F;proc下的“数字目录”指代了相应pid的进程，如目录“1”下的内容就是1进程的各种信息。</li></ul><h3 id="Linux根文件系统"><a href="#Linux根文件系统" class="headerlink" title="Linux根文件系统"></a>Linux根文件系统</h3><p>首先要明白的是“什么是文件系统”，文件系统是对一个存储设备上的数据和元数据进行组织的机制。这种机制有利于用户和操作系统的交互。</p><p>在Linux没有文件系统的话，用户和操作系统的交互也就断开了。</p><p>根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储文件的功能，但是相对于普通的文件系统，它的特殊之处在于，它是内核启动时所mount的第一个文件系统。Linux内核在系统启动期间进行的最后操作之一就是安装根文件系统。根文件系统一直是所有类UNIX系统不可或缺的组件。</p><h4 id="根文件系统的基本结构"><a href="#根文件系统的基本结构" class="headerlink" title="根文件系统的基本结构"></a>根文件系统的基本结构</h4><ul><li>bin 必要的用户命令（二进制文件）</li><li>boot 引导加载程序使用的静态文件</li><li>dev 设备文件及其他特殊文件</li><li>etc 系统配置文件</li><li>home 用户主目录</li><li>lib 必要的链接库，例如：C链接库、内核模块</li><li>mnt 临时挂载的文件系统的挂载点</li></ul><h4 id="BusyBox简介"><a href="#BusyBox简介" class="headerlink" title="BusyBox简介"></a>BusyBox简介</h4><p>BusyBox是很多标准Linux工具的一个单个可执行实现。BusyBox包含了一些简单的工具，例如cat和echo，还包含了一些更大、更复杂的工具，例如grep、find、mount以及telnet；有些人将BusyBox称为Linux工具里的“瑞士军刀”。可以使用Busybox制作根文件系统。</p><p>文章部分内容整理自：<br><a href="http://www.cie-eec.org/">www.cie-eec.org</a> 相关文档</p><p><a href="https://www.xuebuyuan.com/835415.html">JFFS3 design issues</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Linux系统之Linux内核</title>
      <link href="/2018/12/15/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E4%B9%8BLinux%E5%86%85%E6%A0%B8/"/>
      <url>/2018/12/15/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E4%B9%8BLinux%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><p>内核是所有Linux系统的中心软件组件。嵌入式领域所说的Linux，一般是指linux内核。移植也是指的移植linux内核到目标平台。</p><span id="more"></span><p>linux内核的版本号说明：<br>例，2.6.24<br>其中，2是主版本号，6是次版本号，24是修订版本号。<br>如果次版本号是偶数，说明是稳定版本。<br>如果次版本号是奇数，则是开发版本。</p><h4 id="Linux内核源码目录结构"><a href="#Linux内核源码目录结构" class="headerlink" title="Linux内核源码目录结构"></a>Linux内核源码目录结构</h4><ul><li>arch<br>包含和硬件体系结构相关的代码，每种平台占一个相应的目录。如arm、avr32、blackfin、mips等。arch目录在系统移植过程中是需要重点修改的部分。</li><li>block<br>块设备驱动程序的IO调度。</li><li>crypto<br>常用的加密和离散算法，还有一些压缩和CRC校验算法。</li><li>drivers<br>drivers目录中是系统中所有的设备驱动程序。它又进一步划分成几类设备驱动，如block、char、mtd、net、usb、video等待，每一种有对应的子目录，如声卡的驱动对应于drivers&#x2F;sound。该目录占用了整个内核发行版本代码的一半以上，其中有些驱动程序是与硬件平台相关的，有些是与硬件平台无关，例如字符设备、块设备、串口、USB以及LCD显示驱动等。</li><li>Documentation<br>内核说明文档。</li><li>fs<br>该目录下列出了linux支持的所有文件系统。<br>目前Linux已经支持包括JFFS2、YAFFS、ext3和NFS在内的多种文件系统，<br>其中JFFS2常用于嵌入式系统NOR Flash中的文件系统，<br>YAFFS常用于NAND Flash中的文件系统，<br>ext3常用于台式PC机的Linux操作系统中的文件系统。<br>还有一些伪文件系统，例如proc文件系统，可以以伪文件的形式提供其他信息<br>（例如，在proc的情况下是提供内核的内部变量和数据结构）。虽然在底层并没有实际的存储设备与这些文件系统相对应，但是进程可以像有实际存储设备一样处理。</li><li>include<br>头文件。与系统相关的头文件放在include&#x2F;linux下，与arm体系结构相关的头文件放在include&#x2F;asm-arm下。</li><li>init<br>内核初始化代码。init目录包含核心的初始化代码（不是系统的引导代码），有main.c和version.c两个文件。这是研究核心如何工作的好起点。</li><li>ipc<br>进程间通信代码。</li><li>kernel<br>内核的核心代码，包括进程调度、定时器等。和arm平台相关的核心代码在arch&#x2F;arm&#x2F;kernel目录下。</li><li>lib<br>lib目录包含了核心的库代码，不过与处理器结构相关的库代码被放在arch&#x2F;lib目录下。Lib&#x2F;inflate.c中的函数能够在系统启动时展开经过压缩的内核。Lib目录下剩余的其他文件实现一个标准C库的有用子集，主要集中在字符串和内存操作的函数（strlen、memcpy和其他类似的函数）及有关sprintf和atoi的系列函数上。</li><li>mm<br>内存管理代码，和arm平台相关的内存管理代码在arch&#x2F;arm&#x2F;mm目录下。</li><li>net<br>网络相关的代码，实现了各种常见的网络协议。例如TCP&#x2F;IP、IPX等。</li><li>scripts<br>scripts目录下没有代码，包含用于配置核心的脚本文件。当运行make menuconfig或make xconfig之类的命令配置内核时，用户就是和位于这个目录下的脚本进行交互的。</li><li>sound<br>音频设备驱动的通用代码和硬件驱动代码都在这个文件下面。</li></ul><h4 id="Linux内核启动方案"><a href="#Linux内核启动方案" class="headerlink" title="Linux内核启动方案"></a>Linux内核启动方案</h4><p>Linux内核有两种映像：</p><ul><li>非压缩内核Image</li><li>压缩内核zImage</li></ul><p>嵌入式系统存储容量有限，因此通常选择压缩内核zImage。要使用压缩内核zImage，需要在映像开头加入解压缩代码，将zImage解压后，才可以执行。</p><p>内核编译完成后，会在arch&#x2F;arm&#x2F;boot目录下生成zImage文件。</p><p>zImgae文件的组成：</p><ul><li>pggy.o  : 压缩后的内核文件</li><li>head.o  : 系统初级初始化代码文件</li><li>misc.o  : 解压缩代码文件</li></ul><h4 id="Linux内核的配置"><a href="#Linux内核的配置" class="headerlink" title="Linux内核的配置"></a>Linux内核的配置</h4><ul><li>.config文件<br>这是linux编译时所依赖的文件。我们在配置内核时所做的任何修改，最终都会在这个文件中体现出来。它是Makefile对内核进行处理的重要依据。<br>一般来说，内核提供了芯片公司demo板的.config文件，我们一般找一个近似的进行修改。如S3C2410平台上可以选择s3c2410_deconfig这个文件。</li></ul><p><strong>三种配置方式</strong></p><ul><li>make config<br>基于文本对话的配置方式，比较细致，但是浪费时间。对专业的内核开发人员比较合适。</li><li>make xconfig<br>基于图形界面的配置方式。非常直观，但是需要特殊的软件支持，一般不推荐。</li><li>make menuconfig<br>推荐的内核配置方式，采用目录的方式，直观，容易使用。</li></ul><p><strong>关于Kconfig</strong><br>在进行make menuconfig时，目录的生成依赖于Kconfig文件。一般来说，每个源代码目录下都有一个Kconfig文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config DM9000</span><br><span class="line">tristate &quot;DM9000 support&quot;</span><br><span class="line">depends on ARM||BLACKFIN||MIPS</span><br><span class="line">select CRC32</span><br><span class="line">select MII</span><br><span class="line">--help--</span><br><span class="line">Support for DM9000 chipset</span><br><span class="line">To compile this driver as a module, choose M here.</span><br><span class="line">The module will be called dm9000.</span><br></pre></td></tr></table></figure><p>Kconfig对.config文件的影响：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_DM9000=y</span><br></pre></td></tr></table></figure><p>make menuconfig对内核配置所做出的修改最终反应在.config文件中。如上所示，在.config文件中CONFIG_DM9000&#x3D;y被定义为y。<br>CONFIG_DM9000是tristate类型，有三个可能取值：<br>y:编译进内核<br>m:编译成模块<br>n:不进行编译<br>若是bool类型，则只有两种可能，y或者n。</p><p>Kconfig对Makefile的影响：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_DM9000) += dm9000.o</span><br></pre></td></tr></table></figure><p><strong>关于Makefile</strong><br>linux内核源码的每个目录下都有一个Makefile，由该Makefile对源代码的编译、链接等操作进行控制。</p><p>编译完成后，每个源代码目录下都会生成一个名叫built-in.o的文件。<br>这个文件由源代码目录下的所有源文件编译后的目标文件链接而成；<br>而不同的built-in.o又被上层目录中的Makefile链接成更大的builtin.o，直到最后链接成为一个内核vmlinux.o</p><h4 id="内核镜像的制作"><a href="#内核镜像的制作" class="headerlink" title="内核镜像的制作"></a>内核镜像的制作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkimage -A arm -T kernel -C none -O linux -a 0x30008000 -e 0x30008040 -d zImage -n &#x27;linux-2.6.24&#x27; uImage</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>-A arm</td><td>目标平台是ARM架构的</td></tr><tr><td>-T kernel</td><td>要处理的是内核</td></tr><tr><td>-C none</td><td>不采用任何压缩方式</td></tr><tr><td>-O linux</td><td>要处理的Linux内核</td></tr><tr><td>-a 0x30008000</td><td>加载地址，包括mkimage工具给内核添加的头信息</td></tr><tr><td>-e 0x30008040</td><td>真正的内核入口地址，除掉mkimage添加的0x40长度的头信息</td></tr><tr><td>-d zImage</td><td>使用的源文件是编译Linux内核得到的zImage</td></tr><tr><td>-n ‘linux-2.6.24’</td><td>生成的内核镜像的名字</td></tr><tr><td>uImage</td><td>生成的供U-Boot启动的二进制内核镜像</td></tr></tbody></table><h4 id="用U-Boot启动Linux内核"><a href="#用U-Boot启动Linux内核" class="headerlink" title="用U-Boot启动Linux内核"></a>用U-Boot启动Linux内核</h4><p>1.下载u-boot.bin到SDRAM的0x30008000处<br>tftp 0x30008000 uImage<br>2.启动内核<br>bootm 0x30008000</p><p>文章内容整理自：<br><a href="http://www.cie-eec.org/">www.cie-eec.org</a> 相关文档</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包python为可执行文件</title>
      <link href="/2018/12/12/%E6%89%93%E5%8C%85python%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
      <url>/2018/12/12/%E6%89%93%E5%8C%85python%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><span id="more"></span><p>PyInstaller is a program that freezes (packages) Python programs into stand-alone executables, under Windows, Linux, Mac OS X, FreeBSD, Solaris and AIX. </p><p>Its main advantages over similar tools are that PyInstaller works with Python 2.7 and 3.4—3.7, it builds smaller executables thanks to transparent compression, it is fully multi-platform, and use the OS support to load the dynamic libraries, thus ensuring full compatibility.</p><p>1.install</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure><p>2.Go to your program’s directory and run</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller myscript.py</span><br></pre></td></tr></table></figure><p>This will generate the bundle in a subdirectory called dist.<br>PyInstaller analyzes myscript.py and:</p><ul><li>Writes myscript.spec in the same folder as the script.</li><li>Creates a folder build in the same folder as the script if it does not exist.</li><li>Writes some log files and working files in the build folder.</li><li>Creates a folder dist in the same folder as the script if it does not exist.</li><li>Writes the myscript executable folder in the dist folder.</li></ul><p>In the dist folder you find the bundled app you distribute to your users.</p><p>What to generate:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-D </span><br><span class="line">Create a one-folder bundle containing an executable (default)</span><br><span class="line"></span><br><span class="line">-F</span><br><span class="line">Create a one-file bundled executable.</span><br><span class="line"></span><br><span class="line">-n NAME</span><br><span class="line">Name to assign to the bundled app and spec file (default: first script’s basename)</span><br></pre></td></tr></table></figure><p>more info:<br><a href="https://pyinstaller.readthedocs.io/en/stable/usage.html#">pyinstaller manual</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Linux系统之Bootloader</title>
      <link href="/2018/12/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E4%B9%8BBootloader/"/>
      <url>/2018/12/08/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E4%B9%8BBootloader/</url>
      
        <content type="html"><![CDATA[<h3 id="Bootloader的概念"><a href="#Bootloader的概念" class="headerlink" title="Bootloader的概念"></a>Bootloader的概念</h3><p>Bootloader就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。bootloader完成的主要功能是将可执行文件（一般是操作系统）搬移到内存中，然后将控制权交给这段可执行文件（操作哦系统）。</p><span id="more"></span><p>通常，Boot Loader是严重的依赖于硬件而实现的，特别是在嵌入式世界。因此，在嵌入式世界里建立一个通用的Boot Loader几乎是不可能的。尽管如此，我们仍然可以对Boot Loader归纳出一些通用的概念来，以指导用户特定的Boot Loader设计与实现。</p><h3 id="Bootloader的工作模式"><a href="#Bootloader的工作模式" class="headerlink" title="Bootloader的工作模式"></a>Bootloader的工作模式</h3><h4 id="下载模式"><a href="#下载模式" class="headerlink" title="下载模式"></a>下载模式</h4><p>对研发人员来说，Bootloader一般需要工作在这种模式下，特别是调试内核或者Bootloader本身的时候。<br>通过串口终端与Bootloader进行交互，可以操作系统硬件。比如通过网口或者串口下载内核，烧写Flash等等。</p><h4 id="启动加载模式"><a href="#启动加载模式" class="headerlink" title="启动加载模式"></a>启动加载模式</h4><p>嵌入式产品发布的时候，Bootloader必须工作在该模式下。<br>这种情况下，Bootloader必须完成硬件自检、配置，并从Flash中将内核拷贝到SDRAM中，并跳转到内核入口，实现自启动，而不需要人为的干预。</p><h3 id="Bootloader的安装媒介"><a href="#Bootloader的安装媒介" class="headerlink" title="Bootloader的安装媒介"></a>Bootloader的安装媒介</h3><p>系统上电时或复位以后，都从芯片厂商预先安排的一个地址处取第一条指令执行。</p><p>由于上电或复位需要运行的第一段程序就是Bootloader，故必须把Bootloader放入该地址。将Bootloader写入固态存储设备，永久保存，系统上电后将自动执行Bootloader。</p><h3 id="Bootloader的烧写"><a href="#Bootloader的烧写" class="headerlink" title="Bootloader的烧写"></a>Bootloader的烧写</h3><p>Bootloader可以配置系统。<br>没有Bootloader,系统就不能启动。<br>Bootloader可以实现自烧写。系统中还没有Bootloader的时候，可以从JTAG烧写。<br>典型的Flash存储空间分配：</p><ul><li>boot loader</li><li>启动参数</li><li>内核</li><li>根文件系统</li></ul><h3 id="嵌入式系统中常见的boot-loader"><a href="#嵌入式系统中常见的boot-loader" class="headerlink" title="嵌入式系统中常见的boot loader"></a>嵌入式系统中常见的boot loader</h3><ul><li>Vivi</li><li>Blob</li><li>Redboot</li><li>U-Boot(armboot、ppcboot整合)</li></ul><h3 id="U-Boot简介"><a href="#U-Boot简介" class="headerlink" title="U-Boot简介"></a>U-Boot简介</h3><p>1999年由德国DENX软件工程中心的Wolfgang Denk发起，全称Universal Bootloader。<br>特点：</p><ul><li>支持多种硬件架构：包括ARM、X86、ppc、mips、m68k、NIOS、Blackfin</li><li>支持多种操作系统：包括Linux、VxWorks、NETBSD、QNX、RTEMS、ARTOS、LynxOS</li><li>支持多达216种以上的开发板</li><li>开放源码、遵循GPL条款</li><li>易于移植、调试</li></ul><p><a href="www.denx.de/wiki/U-Boot/WebHome">官方网站</a></p><h3 id="U-Boot目录结构"><a href="#U-Boot目录结构" class="headerlink" title="U-Boot目录结构"></a>U-Boot目录结构</h3><ul><li>board 目标板相关文件，主要包含硬件初始化、SDRAM初始化</li><li>common 独立于处理器体系结构的通用代码</li><li>cpu 与处理器相关的文件，包含cpu初始化、串口初始化、中断初始化等代码。</li><li>doc U-Boot的说明文档</li><li>drivers 设备驱动代码，如Flash驱动、网卡驱动、串口驱动等</li><li>fs U-Boot支持的文件系统的实现，如cramfs、fat、ext2、jffs2等</li><li>include U-Boot使用的头文件，包括不同硬件架构的头文件</li><li>lib_xxx 处理器相关文件，如我们要使用lib_arm，与arm体系结构相关的文件。</li><li>net 网络功能的上层文件，实现各种协议，如nfs、tftp、arp等</li></ul><h3 id="U-Boot启动流程"><a href="#U-Boot启动流程" class="headerlink" title="U-Boot启动流程"></a>U-Boot启动流程</h3><p>和大多数的Boot loader一样，U-Boot的启动分为两个阶段：</p><ul><li>阶段1：依赖于CPU体系结构的代码，主要用汇编来实现。</li><li>阶段2：通常用C语言来实现，这样可以实现复杂的功能，而且具有更好的可读性和可移植性。</li></ul><h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><p>第一阶段的代码位于cpu&#x2F;arm920&#x2F;start.S中，依次完成以下功能：</p><ul><li>1.系统上电，进入svc模式</li><li>2.关闭看门狗，禁止所有中断</li><li>3.进行初级硬件初始化</li><li>4.将自身代码拷贝到SDRAM中</li><li>5.设置堆栈</li><li>6.清空bss段</li><li>7.跳转到C语言实现的stage2中</li></ul><h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><ul><li>1.初始化本阶段要使用到的硬件设备</li><li>2.检测系统内存映射（memory map）</li><li>3.将内核映像和根文件系统映像从Flash上读到RAM空间中。</li><li>4.为内核设置启动参数</li><li>5.调用内核</li></ul><h3 id="U-Boot的使用"><a href="#U-Boot的使用" class="headerlink" title="U-Boot的使用"></a>U-Boot的使用</h3><p>1.printenv<br>打印环境变量<br>打印U-Boot的环境变量，包括串口波特率、ip地址、mac地址、内核启动参数、服务器ip地址等等。</p><p>2.setenv<br>设置环境变量<br>对环境变量的值进行设置，保存在SDRAM中，但不写入Flash。这样系统掉电<br>以后设置的环境变量就不存在了。</p><p>3.saveenv<br>保存环境变量<br>将环境变量写入Flash，永久保存。掉电以后不消失。</p><p>4.ping<br>测试网络命令<br>ping命令用于测试目标板的网络是否通畅<br>格式：ping + ip addr</p><p>5.tftp<br>通过tftp协议下载文件至SDRAM<br>将tftp服务器上的文件下载到指定的地址，速度快。<br>格式：tftp + 存放地址 + 文件名</p><p>6.loadb<br>通过串口下载二进制文件<br>在目标板不具备网路功能的时候，可以配合超级终端下载二进制文件至内存中。缺点是速度很慢。<br>格式：loadb + 存放地址</p><p>7.bootm<br>引导内核<br>先将内核下载到SDRAM中（通过tftp命令或者loadb命令），然后执行bootm命令引导内核。<br>格式：bootm + 内核地址</p><p>8.help或者？<br>查看U-Boot支持的命令及其作用。</p><p>文章内容整理自：<br><a href="http://www.cie-eec.org/">www.cie-eec.org</a> 相关文档</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA与ECDSA的签名分析</title>
      <link href="/2018/12/06/RSA%E4%B8%8EECDSA%E7%9A%84%E7%AD%BE%E5%90%8D%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/06/RSA%E4%B8%8EECDSA%E7%9A%84%E7%AD%BE%E5%90%8D%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="BER编码"><a href="#BER编码" class="headerlink" title="BER编码"></a>BER编码</h3><p>RSA与ECDSA的签名都采用了BER编码。<br>BER(Basic Encoding Rule)，BER的数据都是TLV格式的。</p><span id="more"></span><p>每种TAG的定义如下：</p><table><thead><tr><th>Tag</th><th>定义</th></tr></thead><tbody><tr><td>0x01</td><td>BOOL</td></tr><tr><td>0x02</td><td>INT，整型</td></tr><tr><td>0x04</td><td>OCTSTR，字符串类型</td></tr><tr><td>0x05</td><td>NULL，空类型</td></tr><tr><td>0x06</td><td>OBJID，对象标识ObjectID（在这里就是对应的HASH算法的OID编码）</td></tr><tr><td>0x0A</td><td>ENUM</td></tr><tr><td>0x30</td><td>SEQ，Sequence组合类型</td></tr><tr><td>0x31</td><td>SETOF</td></tr><tr><td>0x40</td><td>IPADDR</td></tr><tr><td>0x41</td><td>COUNTER</td></tr><tr><td>0x42</td><td>GAUGE</td></tr><tr><td>0x43</td><td>TIMETICKS</td></tr><tr><td>0x44</td><td>OPAQUE</td></tr></tbody></table><h3 id="RSA签名"><a href="#RSA签名" class="headerlink" title="RSA签名"></a>RSA签名</h3><p>RSA私钥签名时要基于某个HASH算法，比如MD5或者SHA1等。</p><p>RSA签名过程：先对明文做HASH计算，然后对HASH后的数据进行BER编码，再用私钥直接对编码后的数据加密。</p><p>RSA验签过程：先用公钥解密，解析TLV数据从中得到HASH算法的OID和HASH值，根据OID选择相应的HASH算法对明文进行计算，最后比对HASH值。</p><p>例子：<br>公钥模：<br>89 54 E6 61 C1 52 DB ED 07 57 50 04 AD B3 D2 A7 A9 8F E8 D8 20 5B 01 B2 E5 E4 7A 7B EE 80 E3 C0 13 11 D2 F9 AD C3 CC 5F 1D 96 AC B2 AB BE 9C 14 9E 76 31 06 B2 E6 FA 01 52 A7 2E 53 C2 1D 3B 7B 9B 68 05 D2 5E 35 31 98 0E 02 93 E0 D9 0C 38 2D 3D EE 10 E6 87 53 79 DF B2 1E 12 D9 9E EF 89 6D 01 59 0D 13 94 DB 05 B7 09 34 D3 5B AB ED 7C FE 0E BE 87 EE E8 DD 01 39 3A CA 3A A7 17 B8 AA E3</p><p>公钥指数：<br>01 00 01</p><p>私钥指数：<br>01 FE B1 BA 09 CC E2 54 F7 1E 55 93 3B D2 B8 E4 A6 99 E8 8F FB 28 57 45 FA 00 EF A6 8D 38 62 16 90 30 5A 18 36 65 F9 BA 07 FC 00 56 38 18 74 BB F7 F1 4F 95 01 54 49 9D 6B 4D F2 66 55 13 87 A1 A6 95 74 72 6A D8 3A EA 34 A8 F8 40 5F 27 11 30 4F 96 3A 2E 7B E6 B6 47 3C 3B 4D 24 E8 FA 51 19 59 FB 52 E0 9B D2 24 B3 B5 8A 36 BF 34 20 E9 2A AB 5D 55 9B 60 01 D5 04 81 E8 E7 EC B2 5F 81 41</p><p>私钥P：<br>BF 36 08 66 63 74 6A 79 D0 77 64 21 73 6D 1A B9 13 BB 35 13 BE A6 73 84 C8 7D 83 67 BE C2 F5 0C 3A 7F 5F EF 6E 73 E2 BC 31 D2 0C 78 06 D7 38 85 7E F5 06 40 62 A6 1D 53 CC 97 34 30 58 EE E2 05</p><p>私钥Q：<br>B7 DD 46 99 58 B2 52 4B 87 FB E1 F1 09 44 AB 9A AD D1 93 90 9C 40 E0 2F 36 63 F4 7F 49 CB 36 E3 2C DA 85 5C 6E CE 41 AC CB 09 6C 27 B6 44 2B D8 26 5F D5 63 DF 2A C8 60 57 3B 23 13 2B 5F 65 C7</p><p>私钥DP：<br>A6 EF C4 9B A7 9E DE CA E5 2F 27 33 71 33 C3 0D EC 65 18 2C D9 D9 36 A7 A9 E6 B2 CF E3 A3 10 10 12 0E 5C B2 8C 2B 0E BC 21 7E F2 35 E4 3B 08 74 BC 67 AD 82 8E DD DA 62 EC 0E E2 98 87 3C 60 05</p><p>私钥DQ：<br>B6 A0 8B A7 75 7A 6A 53 AB D6 7D 2E 35 CE 87 C5 34 31 9F 29 5C 8A F4 22 F1 1B 87 97 87 6C DA 2F FC 35 71 91 C6 5E 08 CD E1 3E 92 B7 3F 4B A7 61 23 7C BD 30 5E 52 D8 85 19 20 1C 4E C6 1E 13 B1</p><p>私钥InvQ：<br>B4 12 D6 05 1C 2C 2B 6F B5 73 99 F3 B7 A7 08 6F A3 E8 2D 6F 33 A6 AE E5 BE 7B 89 86 7F 48 3B DD BC 4A 07 BF A4 A1 BB 96 BD 0E 46 F1 43 FA FB DE A0 1B AB 38 7D 49 59 45 EE 8C F9 3D 89 CF EB AC</p><p>明文：<br>11 22 33 44 55</p><p>签名数据：<br>56 E1 5E 29 84 D6 BC FB 87 7F 55 93 B4 E1 F3 75 2C 64 A5 BC 04 3A D7 0A DB 84 AD 8B 9C 4D D8 E6 8A 56 85 7B 2C 5E 50 E5 81 EB DC 40 D8 9A 29 64 54 19 5B F0 2B 77 D3 DB CF A2 17 BF 33 3F 19 19 B0 FF 36 53 D3 C2 36 1D 90 43 27 2C 0F 54 34 54 F7 E8 D2 09 75 E4 F1 A0 8B F5 38 EA 66 D6 53 14 E4 C5 B6 5A C7 74 52 6E 0A 16 C6 9B B7 81 0B 06 61 8A E7 41 BB 97 E6 EE 3E 6A 1C 7A E6 32 18 60</p><p>用公钥对上面的数据解密后得到：<br>30 20 30 0C 06 08 2A 86 48 86 F7 0D 02 05 05 00 04 10 28 3D 4F EA 5D DE D5 9C F8 37 D3 04 73 28 F5 AF</p><p>解析其TLV格式：<br>30 20 30 0C 06 08 2A 86 48 86 F7 0D 02 05 05 00 04 10 28 3D 4F EA 5D DE D5 9C F8 37 D3 04 73 28 F5 AF<br><strong>第一级：</strong><br>tag: 30(Sequence组合类型) 长度：20<br>内容：<br>30 0C 06 08 2A 86 48 86 F7 0D 02 05 05 00 04 10 28 3D 4F EA 5D DE D5 9C F8 37 D3 04 73 28 F5 AF </p><p><strong>第二级：</strong><br>tag: 30(Sequence组合类型) 长度：0C<br>内容：<br>06 08 2A 86 48 86 F7 0D 02 05 05 00</p><p>tag: 04(字符串类型) 长度：10<br>内容：<br>28 3D 4F EA 5D DE D5 9C F8 37 D3 04 73 28 F5 AF<br>正好就是明文数据11 22 33 44 55的MD5值。</p><p><strong>第三级：</strong><br>tag: 06(对象标识ObjectID) 长度：08<br>内容：<br>2A 86 48 86 F7 0D 02 05 </p><p>tag: 05(空类型) 长度：00<br>内容：无</p><p>RSA每次基于不同的HASH算法对不同的数据进行签名时，构造的这一段BER数据的基本格式是固定不变的，只是HASH算法的OID和哈希值会变。</p><h4 id="HASH算法的OID的编码"><a href="#HASH算法的OID的编码" class="headerlink" title="HASH算法的OID的编码"></a>HASH算法的OID的编码</h4><p>每个算法的OID都是固定的一串十进制数据，是国际权威组织定的。<br>比如MD5的OID 是 1.2.840.113549.2.5   ，<br>表示为”iso(1) member-body (2) US (840) rsadsi(113549) digestAlgorithm (2) md5 (5)”, 所以当解码程序看到这个OID时,就知道是MD5散列。</p><p>对OID的编码规则如下：<br>前两部分如果定义为x.y, 那么它们将合成一个字40*x + y, 其余部分单独作为一个字节进行编码。<br>每个字首先被分割为最少数量的没有头零数字的7位数字。</p><p>这些数字以big-endian格式进行组织,并且一个接一个地组合成字节。<br>除了编码的最后一个字节外,其他所有字节的最高位(位8)都为1。</p><p>以MD5举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.将1.2.840.113549.2.5转换成字数组 &#123;42, 840, 113549, 2, 5&#125;（因为前两部分定义为1.2，那么合成一个字40x1+2=42）</span><br><span class="line"></span><br><span class="line">2.将每个字分割为带有最高位的7位数字。</span><br><span class="line">42=42，只有一个7位数字,那么最高为0，结果为&#123;0x2A&#125;</span><br><span class="line"></span><br><span class="line">840= 6*128^1+72，除最后一个字节外,其他字节的BIT8都置1，结果为&#123;0x86,0x48&#125;</span><br><span class="line"></span><br><span class="line">113549=6*128^2+119*128^1+13，除最后一个字节外,其他字节的BIT8都置1，结果为&#123;0x86,0xF7,0x0D&#125;</span><br><span class="line"></span><br><span class="line">2=2, 只有一个7位数字,那么最高为0，结果为&#123;0x02&#125;</span><br><span class="line"></span><br><span class="line">5=5, 只有一个7位数字,那么最高为0，结果为&#123;0x05&#125;</span><br><span class="line"></span><br><span class="line">最终结果为&#123;&#123;0x2A&#125;,&#123;0x86,0x48&#125;,&#123;0x86,0xF7,0x0D&#125;,&#123;0x02&#125;,&#123;0x05&#125;&#125;</span><br><span class="line"></span><br><span class="line">3.加上TAG和LEN，得到OID编码为 0x06 08 2A 86 48 86 F7 0D 02 05</span><br></pre></td></tr></table></figure><p>常见的HASH算法在用于RSA签名时的BER数据编码格式：</p><table><thead><tr><th>hash算法</th><th>十进制数据</th><th>BER数据编码</th></tr></thead><tbody><tr><td>MD2</td><td>1.2.840.113549.2.2</td><td>30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04 10</td></tr><tr><td>MD4</td><td>1.2.840.113549.2.4</td><td>30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 04 05 00 04 10</td></tr><tr><td>MD5</td><td>1.2.840.113549.2.5</td><td>30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04 10</td></tr><tr><td>SHA1</td><td>1.3.14.3.2.26</td><td>30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14</td></tr><tr><td>SHA224</td><td>2.16.840.1.101.3.4.2.4</td><td>30 2D 30 0d 06 09 60 86 48 01 65 03 04 02 04 05 00 04 1C</td></tr><tr><td>SHA256</td><td>2.16.840.1.101.3.4.2.1</td><td>30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20</td></tr><tr><td>SHA384</td><td>2.16.840.1.101.3.4.2.2</td><td>30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30</td></tr><tr><td>SHA512</td><td>2.16.840.1.101.3.4.2.3</td><td>30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40</td></tr><tr><td>SM3</td><td>1.2.156.197.1.504</td><td>30 30 30 0c 06 08 2a 81 1C 81 45 01 83 78 05 00 04 20</td></tr></tbody></table><h3 id="ECDSA签名"><a href="#ECDSA签名" class="headerlink" title="ECDSA签名"></a>ECDSA签名</h3><p>ECDSA签名和验签过程在上一篇文章中介绍过：<br><a href="https://www.mrbluyee.com/2018/12/04/ECDSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">ECDSA非对称加密算法</a></p><p>ECDSA的签名是( r, s)两个数值，签名中直接以BER编码方式存储这两个值。<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">signature:</span><br><span class="line">[&#x27;0x30&#x27;, &#x27;0x65&#x27;, &#x27;0x2&#x27;, &#x27;0x30&#x27;, &#x27;0x33&#x27;, &#x27;0xdf&#x27;, &#x27;0xb5&#x27;, &#x27;0xb2&#x27;, &#x27;0x8a&#x27;, &#x27;0x8a&#x27;, &#x27;0xd5&#x27;, &#x27;0x49&#x27;, &#x27;0x21&#x27;, &#x27;0xe4&#x27;, &#x27;0x50&#x27;, &#x27;0xc0&#x27;, &#x27;0xf6&#x27;, &#x27;0x8a&#x27;, &#x27;0x38&#x27;, &#x27;0x58&#x27;, &#x27;0xdb&#x27;, &#x27;0xd8&#x27;, &#x27;0x92&#x27;, &#x27;0x7&#x27;, &#x27;0x80&#x27;, &#x27;0x41&#x27;, &#x27;0x8b&#x27;, &#x27;0xcc&#x27;, &#x27;0xe8&#x27;, &#x27;0xbb&#x27;, &#x27;0xa9&#x27;, &#x27;0x16&#x27;, &#x27;0xf8&#x27;, &#x27;0xf&#x27;, &#x27;0xd&#x27;, &#x27;0x32&#x27;, &#x27;0x35&#x27;, &#x27;0xa1&#x27;, &#x27;0xdf&#x27;, &#x27;0x24&#x27;, &#x27;0xcd&#x27;, &#x27;0xc8&#x27;, &#x27;0x49&#x27;, &#x27;0x86&#x27;, &#x27;0x76&#x27;, &#x27;0xad&#x27;, &#x27;0xe1&#x27;, &#x27;0x22&#x27;, &#x27;0xe&#x27;, &#x27;0xfa&#x27;, &#x27;0xfb&#x27;, &#x27;0x2&#x27;, &#x27;0x2&#x27;, &#x27;0x31&#x27;, &#x27;0x0&#x27;, &#x27;0xc9&#x27;, &#x27;0x4b&#x27;, &#x27;0xbb&#x27;, &#x27;0xa1&#x27;, &#x27;0xbe&#x27;, &#x27;0xc&#x27;, &#x27;0x2d&#x27;, &#x27;0xc9&#x27;, &#x27;0xfe&#x27;, &#x27;0xfc&#x27;, &#x27;0x6f&#x27;, &#x27;0x60&#x27;, &#x27;0xf3&#x27;, &#x27;0x64&#x27;, &#x27;0xe5&#x27;, &#x27;0x7a&#x27;, &#x27;0x2c&#x27;, &#x27;0x50&#x27;, &#x27;0x4f&#x27;, &#x27;0x1f&#x27;, &#x27;0xb0&#x27;, &#x27;0xc8&#x27;, &#x27;0x6d&#x27;, &#x27;0x76&#x27;, &#x27;0xbd&#x27;, &#x27;0x37&#x27;, &#x27;0x3b&#x27;, &#x27;0x4f&#x27;, &#x27;0xfb&#x27;, &#x27;0x97&#x27;, &#x27;0x27&#x27;, &#x27;0x19&#x27;, &#x27;0xe2&#x27;, &#x27;0x4c&#x27;, &#x27;0xf5&#x27;, &#x27;0xee&#x27;, &#x27;0xb2&#x27;, &#x27;0x21&#x27;, &#x27;0x91&#x27;, &#x27;0x79&#x27;, &#x27;0x69&#x27;, &#x27;0x51&#x27;, &#x27;0xd1&#x27;, &#x27;0x45&#x27;, &#x27;0x4f&#x27;, &#x27;0x6f&#x27;, &#x27;0xac&#x27;, &#x27;0x28&#x27;]</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">message_sign message:</span><br><span class="line">SEQ</span><br><span class="line">len: 101</span><br><span class="line">content:</span><br><span class="line">0x2,0x30,0x33,0xdf,0xb5,0xb2,0x8a,0x8a,0xd5,0x49,0x21,0xe4,0x50,0xc0,0xf6,0x8a,0x38,0x58,0xdb,0xd8,0x92,0x7,0x80,0x41,0x8b,0xcc,0xe8,0xbb,0xa9,0x16,0xf8,0xf,0xd,0x32,0x35,0xa1,0xdf,0x24,0xcd,0xc8,0x49,0x86,0x76,0xad,0xe1,0x22,0xe,0xfa,0xfb,0x2,0x2,0x31,0x0,0xc9,0x4b,0xbb,0xa1,0xbe,0xc,0x2d,0xc9,0xfe,0xfc,0x6f,0x60,0xf3,0x64,0xe5,0x7a,0x2c,0x50,0x4f,0x1f,0xb0,0xc8,0x6d,0x76,0xbd,0x37,0x3b,0x4f,0xfb,0x97,0x27,0x19,0xe2,0x4c,0xf5,0xee,0xb2,0x21,0x91,0x79,0x69,0x51,0xd1,0x45,0x4f,0x6f,0xac,0x28</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line">len: 48</span><br><span class="line">content:</span><br><span class="line">0x33,0xdf,0xb5,0xb2,0x8a,0x8a,0xd5,0x49,0x21,0xe4,0x50,0xc0,0xf6,0x8a,0x38,0x58,0xdb,0xd8,0x92,0x7,0x80,0x41,0x8b,0xcc,0xe8,0xbb,0xa9,0x16,0xf8,0xf,0xd,0x32,0x35,0xa1,0xdf,0x24,0xcd,0xc8,0x49,0x86,0x76,0xad,0xe1,0x22,0xe,0xfa,0xfb,0x2</span><br><span class="line">int val:</span><br><span class="line">7984118745046642712070940994226527427165301776521416471029518628654486337875805051425722475318955077043620618631938</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line">len: 49</span><br><span class="line">content:</span><br><span class="line">0x0,0xc9,0x4b,0xbb,0xa1,0xbe,0xc,0x2d,0xc9,0xfe,0xfc,0x6f,0x60,0xf3,0x64,0xe5,0x7a,0x2c,0x50,0x4f,0x1f,0xb0,0xc8,0x6d,0x76,0xbd,0x37,0x3b,0x4f,0xfb,0x97,0x27,0x19,0xe2,0x4c,0xf5,0xee,0xb2,0x21,0x91,0x79,0x69,0x51,0xd1,0x45,0x4f,0x6f,0xac,0x28</span><br><span class="line">int val:</span><br><span class="line">30982264106513726684219845244978923429128158159747238210412885484291235505874905425357164893263783009371945614421032</span><br></pre></td></tr></table></figure><h4 id="python-部分代码"><a href="#python-部分代码" class="headerlink" title="python 部分代码"></a>python 部分代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">解析signature到print输出:</span><br><span class="line"></span><br><span class="line">    def print_sign_message(self,signature):</span><br><span class="line">        ber_tag = BER_TAG().BER_Tag</span><br><span class="line">        bytes_index = 0</span><br><span class="line">        while bytes_index &lt; len(signature):</span><br><span class="line">            if signature[bytes_index] in ber_tag: </span><br><span class="line">                tag_index = signature[bytes_index]</span><br><span class="line">                print(ber_tag[tag_index])</span><br><span class="line">                bytes_index = bytes_index + 1</span><br><span class="line">                tag_len = int(signature[bytes_index])</span><br><span class="line">                print(&quot;len: &quot; + str(tag_len))</span><br><span class="line">                bytes_index = bytes_index + 1 </span><br><span class="line">                print(&quot;content:&quot;)</span><br><span class="line">                print(&#x27;,&#x27;.join([hex(i) for i in signature[bytes_index:bytes_index+tag_len]]))</span><br><span class="line">                if tag_index == 0x02: # INT</span><br><span class="line">                    print(&quot;int val:&quot;)</span><br><span class="line">                    print(int.from_bytes(signature[bytes_index:bytes_index+tag_len], byteorder=&#x27;big&#x27;, signed=False))</span><br><span class="line">                self.print_sign_message(signature[bytes_index:bytes_index+tag_len])</span><br><span class="line">                bytes_index = bytes_index + tag_len</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">解析signature输出[r,s]:</span><br><span class="line"></span><br><span class="line">    def __decode_signature(self,signature):</span><br><span class="line">        ber_tag = BER_TAG().BER_Tag</span><br><span class="line">        bytes_index = 0</span><br><span class="line">        while bytes_index &lt; len(signature):</span><br><span class="line">            if signature[bytes_index] in ber_tag: </span><br><span class="line">                tag_index = signature[bytes_index]</span><br><span class="line">                #print(ber_tag[tag_index])</span><br><span class="line">                bytes_index = bytes_index + 1</span><br><span class="line">                tag_len = int(signature[bytes_index])</span><br><span class="line">                #print(&quot;len: &quot; + str(tag_len))</span><br><span class="line">                bytes_index = bytes_index + 1 </span><br><span class="line">                #print(&quot;content:&quot;)</span><br><span class="line">                #print(&#x27;,&#x27;.join([hex(i) for i in signature[bytes_index:bytes_index+tag_len]]))</span><br><span class="line">                if tag_index == 0x02: # INT</span><br><span class="line">                    self.__sign_r_s.append(signature[bytes_index:bytes_index+tag_len])</span><br><span class="line">                    #print(&quot;int val:&quot;)</span><br><span class="line">                    #print(int.from_bytes(signature[bytes_index:bytes_index+tag_len], byteorder=&#x27;big&#x27;, signed=False))</span><br><span class="line">                self.__decode_signature(signature[bytes_index:bytes_index+tag_len])</span><br><span class="line">                bytes_index = bytes_index + tag_len</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    def decode_signature(self,signature):</span><br><span class="line">        self.__sign_r_s = []</span><br><span class="line">        self.__decode_signature(signature)</span><br><span class="line">        return self.__sign_r_s</span><br><span class="line"></span><br><span class="line">将[r,s]合并为signature:</span><br><span class="line"></span><br><span class="line">    def encode_to_signature(self,r_bytes,s_bytes):</span><br><span class="line">        if r_bytes[0] &amp; 0x80:</span><br><span class="line">            int_r = 0x02.to_bytes(1, byteorder= &#x27;big&#x27;) + \</span><br><span class="line">            (len(r_bytes) + 1).to_bytes(1, byteorder= &#x27;big&#x27;) + \</span><br><span class="line">            0x00.to_bytes(1, byteorder= &#x27;big&#x27;) + r_bytes</span><br><span class="line">        else:</span><br><span class="line">            int_r = 0x02.to_bytes(1, byteorder= &#x27;big&#x27;) + \</span><br><span class="line">            len(r_bytes).to_bytes(1, byteorder= &#x27;big&#x27;) + r_bytes</span><br><span class="line">        if s_bytes[0] &amp; 0x80:</span><br><span class="line">            int_s = 0x02.to_bytes(1, byteorder= &#x27;big&#x27;) + \</span><br><span class="line">            (len(s_bytes) + 1).to_bytes(1, byteorder= &#x27;big&#x27;) + \</span><br><span class="line">            0x00.to_bytes(1, byteorder= &#x27;big&#x27;) + s_bytes</span><br><span class="line">        else:</span><br><span class="line">            int_s = 0x02.to_bytes(1, byteorder= &#x27;big&#x27;) + \</span><br><span class="line">            len(s_bytes).to_bytes(1, byteorder= &#x27;big&#x27;) + s_bytes </span><br><span class="line">        int_r_s = int_r + int_s</span><br><span class="line">        return 0x30.to_bytes(1, byteorder= &#x27;big&#x27;) + len(int_r_s).to_bytes(1, byteorder= &#x27;big&#x27;) + int_r_s   </span><br><span class="line"></span><br><span class="line">BER_TAG定义：</span><br><span class="line"></span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">class BER_TAG(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for BER_TAG&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    BER_Tag = &#123;</span><br><span class="line">        0x01 : &quot;BOOL&quot;,  # BOOL</span><br><span class="line">        0x02 : &quot;INT&quot;,  # 整型</span><br><span class="line">        0x04 : &quot;OCTSTR&quot;,  # 字符串类型</span><br><span class="line">        0x05 : &quot;NULL&quot;,  # 空类型</span><br><span class="line">        0x06 : &quot;OBJID&quot;,  # 对象标识ObjectID（在这里就是对应的HASH算法的OID编码）</span><br><span class="line">        0x0A : &quot;ENUM&quot;,  # ENUM</span><br><span class="line">        0x30 : &quot;SEQ&quot;,  # Sequence组合类型</span><br><span class="line">        0x31 : &quot;SETOF&quot;,</span><br><span class="line">        0x40 : &quot;IPADDR&quot;,</span><br><span class="line">        0x41 : &quot;COUNTER&quot;,</span><br><span class="line">        0x42 : &quot;GAUGE&quot;,</span><br><span class="line">        0x43 : &quot;TIMETICKS&quot;,</span><br><span class="line">        0x44 : &quot;OPAQUE&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(BER_TAG, self).__init__()</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>附：<br>int数值的长度应等于对应的密钥参数的长度，<br>但在有些情况下，bytes最前面总会多一个0的原因：</p><p>密钥的长int型数据都是以big endian转为bytes。<br>有些值转为bytes，在bytes第一个字节，最高位上为1。<br>在有些默认处理signed的机器上，为了避免机器处理为负数，则又在前面添加了一个0，这样转换出来的数的最高位就不是1。当然，如果强制把该值处理为unsigned型，就没有这个问题。</p><p>部分内容整理自：<br><a href="https://www.cnblogs.com/jintianhu/p/5051169.html">RSA签名验签学习笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECDSA非对称加密算法</title>
      <link href="/2018/12/04/ECDSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2018/12/04/ECDSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="ECDSA-介绍"><a href="#ECDSA-介绍" class="headerlink" title="ECDSA 介绍"></a>ECDSA 介绍</h2><span id="more"></span><p><a href="https://www.8btc.com/article/63058">椭圆曲线密码学简介</a><br><a href="https://zhuanlan.zhihu.com/p/26029199">椭圆曲线密码学的简单介绍</a><br><a href="https://blog.csdn.net/u011280717/article/details/79689205">ECDSA 签名验证原理及C语言实现</a><br><a href="https://www.8btc.com/article/34080">比特币背后的数学</a></p><h3 id="基于有限域Fp的椭圆曲线域E-Fp"><a href="#基于有限域Fp的椭圆曲线域E-Fp" class="headerlink" title="基于有限域Fp的椭圆曲线域E(Fp)"></a>基于有限域Fp的椭圆曲线域E(Fp)</h3><p>椭圆曲线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y^2 ≡ x^3 + ax + b (mod p) </span><br><span class="line">当：</span><br><span class="line">a, b ∈ Fp 且满足 4a^3+27b^2 ≠ 0 (mod p)， </span><br><span class="line">x, y ∈ Fp时，</span><br><span class="line">这条曲线上的点的集合P=(x,y)就构成了一个基于有限域Fp的椭圆曲线域E(Fp)，</span><br><span class="line">元素个数记作#E(Fp)。</span><br><span class="line"></span><br><span class="line">公钥即为该曲线上的某个点Q=(x,y)的二进制输出格式。公钥可以压缩，是因为y可以根据x通过曲线函数计算出来。</span><br></pre></td></tr></table></figure><h3 id="椭圆曲线域E（Fp-的描述参数"><a href="#椭圆曲线域E（Fp-的描述参数" class="headerlink" title="椭圆曲线域E（Fp)的描述参数"></a>椭圆曲线域E（Fp)的描述参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E : y^2 ≡ x^3 + ax + b (mod p)</span><br></pre></td></tr></table></figure><p>为描述特定的椭圆曲线域，需明确六个参数：T &#x3D; (p, a, b, G, n, h)</p><ul><li>p: 代表有限域Fp的那个质数 </li><li>a,b：椭圆方程的参数 </li><li>G: 椭圆曲线上的一个基点G &#x3D; (xG, yG) </li><li>n：G在Fp中规定的序号，一个质数。 </li><li>h：余因数（cofactor），控制选取点的密度。h &#x3D; #E(Fp) &#x2F; n。</li></ul><p>secp256k1中的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F </span><br><span class="line">= 2^256 − 2^32 − 2^9 − 2^8 − 2^7 − 2^6 − 2^4 − 1</span><br><span class="line"></span><br><span class="line">a = 0， b = 7</span><br><span class="line"></span><br><span class="line">G =04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</span><br><span class="line"></span><br><span class="line">n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 </span><br><span class="line">私钥的取值范围最大不能超过n。</span><br><span class="line"></span><br><span class="line">h = 01</span><br></pre></td></tr></table></figure><h3 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h3><p>随机从[1,n-1]中选取一个数d, 计算Q &#x3D; dG。 其中，d就是私钥，而Q即为公钥。<br>有限域中的加法和乘法是有特殊规定的,dG是一个标量乘法，可以转化为加法运算。<br>基于Fp的椭圆曲线点的集合域中，加法运算是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不同的点相加： (x1, y1) ∈ E(Fp) ， (x2, y2) ∈ E(Fp)， x1 ≠x2 (x1, y1) + (x2, y2) = (x3, y3)，其中， x3 ≡ λ^2 − x1 − x2 (mod p), y3 ≡ λ(x1 − x3) − y1 (mod p), 而λ≡ （y2 − y1）/（x2 − x1）(mod p).</span><br><span class="line"></span><br><span class="line">相同点叠加： (x1, y1) ∈ E(Fp) ,  y1 ≠ 0. (x1, y1) + (x1, y1) = (x3, y3), 其中， x3 ≡ λ^2 − 2x1 (mod p), y3≡ λ(x1 − x3) − y1 (mod p), andλ≡(3x1^2+ a)/2y1(mod p).</span><br></pre></td></tr></table></figure><h3 id="ECDSA签名过程"><a href="#ECDSA签名过程" class="headerlink" title="ECDSA签名过程"></a>ECDSA签名过程</h3><p>用户的密钥对:（d, Q）；(d为私钥，Q为公钥)<br>待签名的信息：M；<br>签名：Signature(M) &#x3D; ( r, s)</p><p>签名过程：</p><ul><li>1、根据ECC算法随机生成一个密钥对(k, R), R&#x3D;(xR, yR) </li><li>2、令 r &#x3D; xR mod n，如果r &#x3D; 0，则返回步骤1 </li><li>3、计算 H &#x3D; Hash(M) </li><li>4、按照数据类型转换规则，将H转化为一个big endian的整数e </li><li>5、s &#x3D; k^-1 (e + rd) mod n，若s &#x3D; 0, 则返回步骤1 </li><li>6、输出的S &#x3D;(r,s)即为签名。</li></ul><p>验证过程：</p><ul><li>1、 计算 H &#x3D; Hash(M) </li><li>2、按照数据类型转换规则，将H转化为一个big endian的整数e </li><li>3、计算 u1 &#x3D; es^-1 mod n, u2 &#x3D; rs^-1 mod n </li><li>4、计算 R &#x3D; (xR, yR) &#x3D; u1G + u2Q, 如果R &#x3D; 零点，则验证该签名无效 </li><li>5、令 v &#x3D; xR mod n </li><li>6、若 v &#x3D;&#x3D; r，则签名有效，若 v ≠ r, 则签名无效。</li></ul><h2 id="linux-openssl-tool"><a href="#linux-openssl-tool" class="headerlink" title="linux openssl tool"></a>linux openssl tool</h2><p><a href="https://www.openssl.org/docs/man1.1.1/man1/ec.html">openssl docs -ec</a></p><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>查看支持的curves</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -list_curves</span><br><span class="line">  secp112r1 : SECG/WTLS curve over a 112 bit prime field</span><br><span class="line">  secp112r2 : SECG curve over a 112 bit prime field</span><br><span class="line">  secp128r1 : SECG curve over a 128 bit prime field</span><br><span class="line">  secp128r2 : SECG curve over a 128 bit prime field</span><br><span class="line">  secp160k1 : SECG curve over a 160 bit prime field</span><br><span class="line">  secp160r1 : SECG curve over a 160 bit prime field</span><br><span class="line">  secp160r2 : SECG/WTLS curve over a 160 bit prime field</span><br><span class="line">  secp192k1 : SECG curve over a 192 bit prime field</span><br><span class="line">  secp224k1 : SECG curve over a 224 bit prime field</span><br><span class="line">  secp224r1 : NIST/SECG curve over a 224 bit prime field</span><br><span class="line">  secp256k1 : SECG curve over a 256 bit prime field</span><br><span class="line">  secp384r1 : NIST/SECG curve over a 384 bit prime field</span><br><span class="line">  secp521r1 : NIST/SECG curve over a 521 bit prime field</span><br><span class="line">  prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field</span><br><span class="line">  prime192v2: X9.62 curve over a 192 bit prime field</span><br><span class="line">  prime192v3: X9.62 curve over a 192 bit prime field</span><br><span class="line">  prime239v1: X9.62 curve over a 239 bit prime field</span><br><span class="line">  prime239v2: X9.62 curve over a 239 bit prime field</span><br><span class="line">  prime239v3: X9.62 curve over a 239 bit prime field</span><br><span class="line">  prime256v1: X9.62/SECG curve over a 256 bit prime field</span><br><span class="line">  sect113r1 : SECG curve over a 113 bit binary field</span><br><span class="line">  sect113r2 : SECG curve over a 113 bit binary field</span><br><span class="line">  sect131r1 : SECG/WTLS curve over a 131 bit binary field</span><br><span class="line">  sect131r2 : SECG curve over a 131 bit binary field</span><br><span class="line">  sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field</span><br><span class="line">  sect163r1 : SECG curve over a 163 bit binary field</span><br><span class="line">  sect163r2 : NIST/SECG curve over a 163 bit binary field</span><br><span class="line">  sect193r1 : SECG curve over a 193 bit binary field</span><br><span class="line">  sect193r2 : SECG curve over a 193 bit binary field</span><br><span class="line">  sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field</span><br><span class="line">  sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field</span><br><span class="line">  sect239k1 : SECG curve over a 239 bit binary field</span><br><span class="line">  sect283k1 : NIST/SECG curve over a 283 bit binary field</span><br><span class="line">  sect283r1 : NIST/SECG curve over a 283 bit binary field</span><br><span class="line">  sect409k1 : NIST/SECG curve over a 409 bit binary field</span><br><span class="line">  sect409r1 : NIST/SECG curve over a 409 bit binary field</span><br><span class="line">  sect571k1 : NIST/SECG curve over a 571 bit binary field</span><br><span class="line">  sect571r1 : NIST/SECG curve over a 571 bit binary field</span><br><span class="line">  c2pnb163v1: X9.62 curve over a 163 bit binary field</span><br><span class="line">  c2pnb163v2: X9.62 curve over a 163 bit binary field</span><br><span class="line">  c2pnb163v3: X9.62 curve over a 163 bit binary field</span><br><span class="line">  c2pnb176v1: X9.62 curve over a 176 bit binary field</span><br><span class="line">  c2tnb191v1: X9.62 curve over a 191 bit binary field</span><br><span class="line">  c2tnb191v2: X9.62 curve over a 191 bit binary field</span><br><span class="line">  c2tnb191v3: X9.62 curve over a 191 bit binary field</span><br><span class="line">  c2pnb208w1: X9.62 curve over a 208 bit binary field</span><br><span class="line">  c2tnb239v1: X9.62 curve over a 239 bit binary field</span><br><span class="line">  c2tnb239v2: X9.62 curve over a 239 bit binary field</span><br><span class="line">  c2tnb239v3: X9.62 curve over a 239 bit binary field</span><br><span class="line">  c2pnb272w1: X9.62 curve over a 272 bit binary field</span><br><span class="line">  c2pnb304w1: X9.62 curve over a 304 bit binary field</span><br><span class="line">  c2tnb359v1: X9.62 curve over a 359 bit binary field</span><br><span class="line">  c2pnb368w1: X9.62 curve over a 368 bit binary field</span><br><span class="line">  c2tnb431r1: X9.62 curve over a 431 bit binary field</span><br><span class="line">  wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field</span><br><span class="line">  wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field</span><br><span class="line">  wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field</span><br><span class="line">  wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field</span><br><span class="line">  wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field</span><br><span class="line">  wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field</span><br><span class="line">  wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field</span><br><span class="line">  wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field</span><br><span class="line">  wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field</span><br><span class="line">  wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field</span><br><span class="line">  wap-wsg-idm-ecid-wtls12: WTLS curve over a 224 bit prime field</span><br><span class="line">  Oakley-EC2N-3: </span><br><span class="line">    IPSec/IKE/Oakley curve #3 over a 155 bit binary field.</span><br><span class="line">    Not suitable for ECDSA.</span><br><span class="line">    Questionable extension field!</span><br><span class="line">  Oakley-EC2N-4: </span><br><span class="line">    IPSec/IKE/Oakley curve #4 over a 185 bit binary field.</span><br><span class="line">    Not suitable for ECDSA.</span><br><span class="line">    Questionable extension field!</span><br><span class="line">  brainpoolP160r1: RFC 5639 curve over a 160 bit prime field</span><br><span class="line">  brainpoolP160t1: RFC 5639 curve over a 160 bit prime field</span><br><span class="line">  brainpoolP192r1: RFC 5639 curve over a 192 bit prime field</span><br><span class="line">  brainpoolP192t1: RFC 5639 curve over a 192 bit prime field</span><br><span class="line">  brainpoolP224r1: RFC 5639 curve over a 224 bit prime field</span><br><span class="line">  brainpoolP224t1: RFC 5639 curve over a 224 bit prime field</span><br><span class="line">  brainpoolP256r1: RFC 5639 curve over a 256 bit prime field</span><br><span class="line">  brainpoolP256t1: RFC 5639 curve over a 256 bit prime field</span><br><span class="line">  brainpoolP320r1: RFC 5639 curve over a 320 bit prime field</span><br><span class="line">  brainpoolP320t1: RFC 5639 curve over a 320 bit prime field</span><br><span class="line">  brainpoolP384r1: RFC 5639 curve over a 384 bit prime field</span><br><span class="line">  brainpoolP384t1: RFC 5639 curve over a 384 bit prime field</span><br><span class="line">  brainpoolP512r1: RFC 5639 curve over a 512 bit prime field</span><br><span class="line">  brainpoolP512t1: RFC 5639 curve over a 512 bit prime field</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选择一种curve生成private key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -name secp384r1 -genkey -out ecdsa_p384_sign.key</span><br></pre></td></tr></table></figure><p>生成密钥文件的pem内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN EC PARAMETERS-----</span><br><span class="line">context</span><br><span class="line">-----END EC PARAMETERS-----</span><br><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">context</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>查看私钥内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl ec -in ecdsa_p384_sign.key -text -noout</span><br><span class="line"></span><br><span class="line">read EC key</span><br><span class="line">Private-Key: (384 bit)</span><br><span class="line">priv:</span><br><span class="line">  content</span><br><span class="line">pub:</span><br><span class="line">  content</span><br><span class="line">ASN1 OID: secp384r1</span><br><span class="line">NIST CURVE: P-384</span><br></pre></td></tr></table></figure><p>根据私钥生成公钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ec -in ecdsa_p384_sign.key -pubout -out ecdsa_p384_verify.key</span><br></pre></td></tr></table></figure><h3 id="生成证书请求"><a href="#生成证书请求" class="headerlink" title="生成证书请求"></a>生成证书请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ecdsa_p384_sign.key -out ecdsa_p384_sign.csr</span><br><span class="line">然后输入一系列参数信息</span><br></pre></td></tr></table></figure><h3 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ecdsa_p384_sign.key -x509 -nodes -days 365 -out ecdsa_p384_cert.pem</span><br><span class="line">然后输入一系列参数信息</span><br></pre></td></tr></table></figure><h2 id="Python-ECDSA"><a href="#Python-ECDSA" class="headerlink" title="Python ECDSA"></a>Python ECDSA</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecdsa</span><br></pre></td></tr></table></figure><p><a href="https://pypi.org/project/ecdsa/">ecdsa</a></p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from ecdsa import SigningKey, NIST384p</span><br><span class="line">sk = SigningKey.generate(curve=NIST384p)</span><br><span class="line">vk = sk.get_verifying_key()</span><br><span class="line">signature = sk.sign(&quot;message&quot;)</span><br><span class="line">assert vk.verify(signature, &quot;message&quot;)</span><br></pre></td></tr></table></figure><h3 id="支持的curve"><a href="#支持的curve" class="headerlink" title="支持的curve"></a>支持的curve</h3><p>ecdsa支持NIST Curve P-192、NIST Curve P-224、NIST Curve P-256、NIST Curve P-384、NIST Curve P-521和Certicom secp256-k1<br>默认的hash为sha1，也可以自定义其他hashlib有的hashfunc，但是需要注意的是hashfunc输出的hash长度不要超过curve生成的签名长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hashfunc= should behave like hashlib.sha1 . The output length of the</span><br><span class="line">        hash (in bytes) must not be longer than the length of the curve order</span><br><span class="line">        (rounded up to the nearest byte), so using SHA256 with nist256p is</span><br><span class="line">        ok, but SHA256 with nist192p is not. (In the 2**-96ish unlikely event</span><br><span class="line">        of a hash output larger than the curve order, the hash will</span><br><span class="line">        effectively be wrapped mod n).</span><br><span class="line">        Use hashfunc=hashlib.sha1 to match openssl&#x27;s -ecdsa-with-SHA1 mode,</span><br><span class="line">        or hashfunc=hashlib.sha256 for openssl-1.0.0&#x27;s -ecdsa-with-SHA256.</span><br></pre></td></tr></table></figure><p>curve定义的参数在python-ecdsa&#x2F;src&#x2F;ecdsa&#x2F;ecdsa.py文件里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># NIST Curve P-192:</span><br><span class="line">_p = 6277101735386680763835789423207666416083908700390324961279</span><br><span class="line">_r = 6277101735386680763835789423176059013767194773182842284081</span><br><span class="line"># s = 0x3045ae6fc8422f64ed579528d38120eae12196d5L</span><br><span class="line"># c = 0x3099d2bbbfcb2538542dcd5fb078b6ef5f3d6fe2c745de65L</span><br><span class="line">_b = 0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1</span><br><span class="line">_Gx = 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012</span><br><span class="line">_Gy = 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811</span><br><span class="line"></span><br><span class="line">curve_192 = ellipticcurve.CurveFp(_p, -3, _b)</span><br><span class="line">generator_192 = ellipticcurve.Point(curve_192, _Gx, _Gy, _r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># NIST Curve P-224:</span><br><span class="line">_p = 26959946667150639794667015087019630673557916260026308143510066298881</span><br><span class="line">_r = 26959946667150639794667015087019625940457807714424391721682722368061</span><br><span class="line"># s = 0xbd71344799d5c7fcdc45b59fa3b9ab8f6a948bc5L</span><br><span class="line"># c = 0x5b056c7e11dd68f40469ee7f3c7a7d74f7d121116506d031218291fbL</span><br><span class="line">_b = 0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4</span><br><span class="line">_Gx = 0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21</span><br><span class="line">_Gy = 0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34</span><br><span class="line"></span><br><span class="line">curve_224 = ellipticcurve.CurveFp(_p, -3, _b)</span><br><span class="line">generator_224 = ellipticcurve.Point(curve_224, _Gx, _Gy, _r)</span><br><span class="line"></span><br><span class="line"># NIST Curve P-256:</span><br><span class="line">_p = 115792089210356248762697446949407573530086143415290314195533631308867097853951</span><br><span class="line">_r = 115792089210356248762697446949407573529996955224135760342422259061068512044369</span><br><span class="line"># s = 0xc49d360886e704936a6678e1139d26b7819f7e90L</span><br><span class="line"># c = 0x7efba1662985be9403cb055c75d4f7e0ce8d84a9c5114abcaf3177680104fa0dL</span><br><span class="line">_b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b</span><br><span class="line">_Gx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296</span><br><span class="line">_Gy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5</span><br><span class="line"></span><br><span class="line">curve_256 = ellipticcurve.CurveFp(_p, -3, _b)</span><br><span class="line">generator_256 = ellipticcurve.Point(curve_256, _Gx, _Gy, _r)</span><br><span class="line"></span><br><span class="line"># NIST Curve P-384:</span><br><span class="line">_p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319</span><br><span class="line">_r = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643</span><br><span class="line"># s = 0xa335926aa319a27a1d00896a6773a4827acdac73L</span><br><span class="line"># c = 0x79d1e655f868f02fff48dcdee14151ddb80643c1406d0ca10dfe6fc52009540a495e8042ea5f744f6e184667cc722483L</span><br><span class="line">_b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef</span><br><span class="line">_Gx = 0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7</span><br><span class="line">_Gy = 0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f</span><br><span class="line"></span><br><span class="line">curve_384 = ellipticcurve.CurveFp(_p, -3, _b)</span><br><span class="line">generator_384 = ellipticcurve.Point(curve_384, _Gx, _Gy, _r)</span><br><span class="line"></span><br><span class="line"># NIST Curve P-521:</span><br><span class="line">_p = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151</span><br><span class="line">_r = 6864797660130609714981900799081393217269435300143305409394463459185543183397655394245057746333217197532963996371363321113864768612440380340372808892707005449</span><br><span class="line"># s = 0xd09e8800291cb85396cc6717393284aaa0da64baL</span><br><span class="line"># c = 0x0b48bfa5f420a34949539d2bdfc264eeeeb077688e44fbf0ad8f6d0edb37bd6b533281000518e19f1b9ffbe0fe9ed8a3c2200b8f875e523868c70c1e5bf55bad637L</span><br><span class="line">_b = 0x051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00</span><br><span class="line">_Gx = 0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66</span><br><span class="line">_Gy = 0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650</span><br><span class="line"></span><br><span class="line">curve_521 = ellipticcurve.CurveFp(_p, -3, _b)</span><br><span class="line">generator_521 = ellipticcurve.Point(curve_521, _Gx, _Gy, _r)</span><br><span class="line"></span><br><span class="line"># Certicom secp256-k1</span><br><span class="line">_a = 0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">_b = 0x0000000000000000000000000000000000000000000000000000000000000007</span><br><span class="line">_p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f</span><br><span class="line">_Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</span><br><span class="line">_Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</span><br><span class="line">_r = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141</span><br><span class="line"></span><br><span class="line">curve_secp256k1 = ellipticcurve.CurveFp(_p, _a, _b)</span><br><span class="line">generator_secp256k1 = ellipticcurve.Point(curve_secp256k1, _Gx, _Gy, _r)</span><br></pre></td></tr></table></figure><h3 id="私钥操作"><a href="#私钥操作" class="headerlink" title="私钥操作"></a>私钥操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">from ecdsa import SigningKey, SECP256k1, NIST384p, NIST521p</span><br><span class="line">import hashlib</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ECDSA_Private_Key(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for ECDSA_Private_Key&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, key_filename):</span><br><span class="line">        super(ECDSA_Private_Key, self).__init__()</span><br><span class="line">        self.key_filename = key_filename</span><br><span class="line">        with open(self.key_filename,&quot;rb&quot;) as f:</span><br><span class="line">            self.private_key = SigningKey.from_pem(f.read())</span><br><span class="line">            self.privkey = self.private_key.privkey</span><br><span class="line">        </span><br><span class="line">    def print_key_message(self):</span><br><span class="line">        print(&quot;ECDSA Private Key Info:&quot;)</span><br><span class="line">        print(&quot;ECDSA private key baselen: &quot; + str(self.private_key.baselen*8) + &quot; bits&quot;)</span><br><span class="line">        print(&quot;ECDSA curve name: &quot; + self.private_key.curve.name)</span><br><span class="line">        print(&quot;ECDSA curve verifying key length: &quot; + str(self.private_key.curve.verifying_key_length))</span><br><span class="line">        print(&quot;ECDSA curve signature length: &quot; + str(self.private_key.curve.signature_length))</span><br><span class="line">        print(&quot;ECDSA curve oid:&quot;)</span><br><span class="line">        print(str(self.private_key.curve.oid))</span><br><span class="line"></span><br><span class="line">    def print_key_message_to_file(self,filename = None):</span><br><span class="line">        f_name = &#x27;&#x27;</span><br><span class="line">        if filename != None:</span><br><span class="line">            f_name = filename</span><br><span class="line">        else:</span><br><span class="line">            f_name = os.path.splitext(self.key_filename)[0] + &#x27;.txt&#x27;</span><br><span class="line">        with open(f_name,&quot;w&quot;) as f:</span><br><span class="line">            f.write(self.key_filename + &#x27;\r\n&#x27;)</span><br><span class="line">            f.write(&quot;ECDSA private key baselen: &quot; + str(self.private_key.baselen*8) + &quot; bits\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve name: &quot; + self.private_key.curve.name + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve verifying key length: &quot; + str(self.private_key.curve.verifying_key_length) + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve signature length: &quot; + str(self.private_key.curve.signature_length) + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve oid:\n&quot;)</span><br><span class="line">            f.write(str(self.private_key.curve.oid))</span><br><span class="line"></span><br><span class="line">    def sign(self,message,hash_alg=1):</span><br><span class="line">        if hash_alg == 1:</span><br><span class="line">            return self.private_key.sign(message,hashfunc=hashlib.sha256)</span><br><span class="line">        elif hash_alg == 2:</span><br><span class="line">            if self.private_key.baselen*8 == 512:</span><br><span class="line">                return self.private_key.sign(message,hashfunc=hashlib.sha512)</span><br><span class="line">            else:</span><br><span class="line">                raise RuntimeError(&#x27;hash length longer than the ecdsa length&#x27;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ecdsa_private_key = ECDSA_Private_Key(&quot;ecdsa_p384_sign.key&quot;)</span><br><span class="line">    ecdsa_private_key.print_key_message()</span><br><span class="line">    ecdsa_private_key.print_key_message_to_file()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="公钥操作"><a href="#公钥操作" class="headerlink" title="公钥操作"></a>公钥操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">from ecdsa import VerifyingKey, SECP256k1, NIST384p, NIST521p</span><br><span class="line">import hashlib</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ECDSA_Public_Key(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for ECDSA_Public_Key&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, key_filename = None, key_point = None, verify_alg = None, hash_alg = None):</span><br><span class="line">        super(ECDSA_Public_Key, self).__init__()</span><br><span class="line">        if key_filename != None:</span><br><span class="line">            self.key_filename = key_filename</span><br><span class="line">            with open(self.key_filename,&quot;rb&quot;) as f:</span><br><span class="line">                self.public_key = VerifyingKey.from_pem(f.read())</span><br><span class="line">                self.pubkey = self.public_key.pubkey</span><br><span class="line">        elif key_point != None and verify_alg != None and hash_alg != None:</span><br><span class="line">            key_hashfunc = hashlib.sha256</span><br><span class="line">            key_curve = SECP256k1</span><br><span class="line">            if hash_alg == 1:</span><br><span class="line">                key_hashfunc = hashlib.sha256</span><br><span class="line">            elif hash_alg == 2:</span><br><span class="line">                key_hashfunc = hashlib.sha512</span><br><span class="line">            if verify_alg == 0x10:</span><br><span class="line">                key_curve = SECP256k1</span><br><span class="line">            elif verify_alg == 0x11:</span><br><span class="line">                key_curve = NIST384p</span><br><span class="line">            elif verify_alg == 0x12:</span><br><span class="line">                key_curve = NIST521p</span><br><span class="line">            self.public_key = VerifyingKey.from_public_point(key_point, curve=key_curve, hashfunc=key_hashfunc)</span><br><span class="line">            self.pubkey = self.public_key.pubkey</span><br><span class="line">        </span><br><span class="line">    def print_key_message(self):</span><br><span class="line">        print(&quot;ECDSA Public Key Info:&quot;)</span><br><span class="line">        print(&quot;ECDSA public key point: &quot;)</span><br><span class="line">        print(str(self.pubkey.point))</span><br><span class="line">        print(&quot;ECDSA curve name: &quot; + self.public_key.curve.name)</span><br><span class="line">        print(&quot;ECDSA curve verifying key length: &quot; + str(self.public_key.curve.verifying_key_length))</span><br><span class="line">        print(&quot;ECDSA curve signature length: &quot; + str(self.public_key.curve.signature_length))</span><br><span class="line">        print(&quot;ECDSA curve oid:&quot;)</span><br><span class="line">        print(str(self.public_key.curve.oid))</span><br><span class="line"></span><br><span class="line">    def print_key_message_to_file(self,filename = None):</span><br><span class="line">        f_name = &#x27;&#x27;</span><br><span class="line">        if filename != None:</span><br><span class="line">            f_name = filename</span><br><span class="line">        else:</span><br><span class="line">            f_name = os.path.splitext(self.key_filename)[0] + &#x27;.txt&#x27;</span><br><span class="line">        with open(f_name,&quot;w&quot;) as f:</span><br><span class="line">            f.write(self.key_filename + &#x27;\n&#x27;)</span><br><span class="line">            f.write(&quot;ECDSA Public Key Info: \n&quot;)</span><br><span class="line">            f.write(str(self.pubkey.point))</span><br><span class="line">            f.write(&quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve name: &quot; + self.public_key.curve.name + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve verifying key length: &quot; + str(self.public_key.curve.verifying_key_length) + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve signature length: &quot; + str(self.public_key.curve.signature_length) + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA curve oid:\n&quot;)</span><br><span class="line">            f.write(str(self.public_key.curve.oid))</span><br><span class="line"></span><br><span class="line">    def verify(self,message,signature,hash_alg):</span><br><span class="line">        if hash_alg == 1:</span><br><span class="line">            return self.public_key.verify(signature, message, hashfunc=hashlib.sha256)</span><br><span class="line">        elif hash_alg == 2:</span><br><span class="line">            return self.public_key.verify(signature, message, hashfunc=hashlib.sha512)    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ecdsa_public_key = ECDSA_Public_Key(&quot;ecdsa_p384_verify.key&quot;)</span><br><span class="line">    ecdsa_public_key.print_key_message()</span><br><span class="line">    ecdsa_public_key.print_key_message_to_file()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="ECDSA-test"><a href="#ECDSA-test" class="headerlink" title="ECDSA test"></a>ECDSA test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">from ecdsa_private_key_handle import ECDSA_Private_Key</span><br><span class="line">from ecdsa_public_key_handle import ECDSA_Public_Key</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    message = &quot;hello mrbluyee.&quot;</span><br><span class="line">    ecdsa_private_key = ECDSA_Private_Key(&quot;ecdsa_p384_sign.key&quot;)</span><br><span class="line">    ecdsa_public_key = ECDSA_Public_Key(&quot;ecdsa_p384_verify.key&quot;)</span><br><span class="line">    ecdsa_public_key.print_key_message()</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line">    ecdsa_private_key.print_key_message()</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    message_sign = ecdsa_private_key.sign(message.encode(), 1)</span><br><span class="line">    print(&quot;message_sign:&quot;)</span><br><span class="line">    print(len(message_sign))</span><br><span class="line">    print([hex(i) for i in message_sign])</span><br><span class="line"></span><br><span class="line">    message_verify0 = ecdsa_public_key.verify(message.encode(), message_sign, 1)</span><br><span class="line">    print(&quot;message verify0:&quot;)</span><br><span class="line">    print(message_verify0)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行结果显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ECDSA Public Key Info:</span><br><span class="line">ECDSA public key point: </span><br><span class="line">(x,y)</span><br><span class="line">ECDSA curve name: NIST384p</span><br><span class="line">ECDSA curve verifying key length: 96</span><br><span class="line">ECDSA curve signature length: 96</span><br><span class="line">ECDSA curve oid:</span><br><span class="line">(1, 3, 132, 0, 34)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ECDSA Private Key Info:</span><br><span class="line">ECDSA private key baselen: 384 bits</span><br><span class="line">ECDSA curve name: NIST384p</span><br><span class="line">ECDSA curve verifying key length: 96</span><br><span class="line">ECDSA curve signature length: 96</span><br><span class="line">ECDSA curve oid:</span><br><span class="line">(1, 3, 132, 0, 34)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message_sign:</span><br><span class="line">96</span><br><span class="line">[&#x27;0xa2&#x27;, &#x27;0x9c&#x27;, &#x27;0xc9&#x27;, &#x27;0x5&#x27;, &#x27;0x1a&#x27;, &#x27;0x96&#x27;, &#x27;0x33&#x27;, &#x27;0x83&#x27;, &#x27;0xe9&#x27;, &#x27;0x79&#x27;, &#x27;0xb4&#x27;, &#x27;0x2b&#x27;, &#x27;0x66&#x27;, &#x27;0xa7&#x27;, &#x27;0xf7&#x27;, &#x27;0xc3&#x27;, &#x27;0x4e&#x27;, &#x27;0x4d&#x27;, &#x27;0x87&#x27;, &#x27;0xd6&#x27;, &#x27;0xb5&#x27;, &#x27;0xe&#x27;, &#x27;0xc0&#x27;, &#x27;0xe5&#x27;, &#x27;0x6a&#x27;, &#x27;0xaa&#x27;, &#x27;0x10&#x27;, &#x27;0x55&#x27;, &#x27;0xd9&#x27;, &#x27;0x58&#x27;, &#x27;0x11&#x27;, &#x27;0x17&#x27;, &#x27;0x97&#x27;, &#x27;0xc6&#x27;, &#x27;0x30&#x27;, &#x27;0x95&#x27;, &#x27;0xc9&#x27;, &#x27;0x1f&#x27;, &#x27;0x73&#x27;, &#x27;0xcc&#x27;, &#x27;0x1f&#x27;, &#x27;0x16&#x27;, &#x27;0xf7&#x27;, &#x27;0xd0&#x27;, &#x27;0x5a&#x27;, &#x27;0x92&#x27;, &#x27;0x2f&#x27;, &#x27;0x4d&#x27;, &#x27;0x26&#x27;, &#x27;0x99&#x27;, &#x27;0xc5&#x27;, &#x27;0x5&#x27;, &#x27;0xda&#x27;, &#x27;0x59&#x27;, &#x27;0x1f&#x27;, &#x27;0x69&#x27;, &#x27;0x37&#x27;, &#x27;0x86&#x27;, &#x27;0x4e&#x27;, &#x27;0x3a&#x27;, &#x27;0xe0&#x27;, &#x27;0x9f&#x27;, &#x27;0x8b&#x27;, &#x27;0xd2&#x27;, &#x27;0x85&#x27;, &#x27;0x1e&#x27;, &#x27;0xbe&#x27;, &#x27;0xfa&#x27;, &#x27;0x3f&#x27;, &#x27;0x71&#x27;, &#x27;0x37&#x27;, &#x27;0x4e&#x27;, &#x27;0x37&#x27;, &#x27;0xcc&#x27;, &#x27;0xb&#x27;, &#x27;0xc7&#x27;, &#x27;0x12&#x27;, &#x27;0x5&#x27;, &#x27;0x62&#x27;, &#x27;0x81&#x27;, &#x27;0x88&#x27;, &#x27;0x56&#x27;, &#x27;0x65&#x27;, &#x27;0x87&#x27;, &#x27;0x2d&#x27;, &#x27;0xb4&#x27;, &#x27;0xe1&#x27;, &#x27;0xf8&#x27;, &#x27;0x44&#x27;, &#x27;0xd2&#x27;, &#x27;0xe6&#x27;, &#x27;0x3f&#x27;, &#x27;0x5b&#x27;, &#x27;0xcd&#x27;, &#x27;0x14&#x27;, &#x27;0x13&#x27;]</span><br><span class="line">message verify0:</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="Python-OpenSSL"><a href="#Python-OpenSSL" class="headerlink" title="Python OpenSSL"></a>Python OpenSSL</h2><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenSSL</span><br></pre></td></tr></table></figure><h3 id="私钥操作-1"><a href="#私钥操作-1" class="headerlink" title="私钥操作"></a>私钥操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import OpenSSL</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import ec</span><br><span class="line">from cryptography.hazmat.primitives import hashes</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ECDSA_PRIVATE_KEY(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for ECDSA_PRIVATE_KEY&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, key_filename, passwd = None):</span><br><span class="line">        super(ECDSA_PRIVATE_KEY, self).__init__()</span><br><span class="line">        self.key_filename = key_filename</span><br><span class="line">        if passwd != None:</span><br><span class="line">            with open(self.key_filename,&quot;rb&quot;) as f:</span><br><span class="line">                self.private_key = serialization.load_pem_private_key( \</span><br><span class="line">                    f.read(), \</span><br><span class="line">                    password = passwd.encode(), \</span><br><span class="line">                    backend = default_backend() \</span><br><span class="line">                )</span><br><span class="line">        else:</span><br><span class="line">            with open(self.key_filename,&quot;rb&quot;) as f:</span><br><span class="line">                self.private_key = serialization.load_pem_private_key( \</span><br><span class="line">                    f.read(), \</span><br><span class="line">                    password = None, \</span><br><span class="line">                    backend = default_backend() \</span><br><span class="line">                )            </span><br><span class="line">        self.private_key_numbers = self.private_key.private_numbers()</span><br><span class="line">        self.private_value = self.private_key_numbers.private_value</span><br><span class="line">        self.private_key_numbers_public_numbers = self.private_key_numbers.public_numbers</span><br><span class="line">        self.curve = self.private_key_numbers_public_numbers.curve</span><br><span class="line">        self.point_x = self.private_key_numbers_public_numbers.x</span><br><span class="line">        self.point_y = self.private_key_numbers_public_numbers.y</span><br><span class="line">        self.encode_point = self.private_key_numbers_public_numbers.encode_point()</span><br><span class="line">     </span><br><span class="line">    def print_key_message(self):</span><br><span class="line">        print(&quot;ECDSA Private Key Info:&quot;)</span><br><span class="line">        print(&quot;key size: &quot; + str(self.private_key.key_size) + &quot; bits&quot;)</span><br><span class="line">        print(&quot;private value： &quot; + str(self.private_value))</span><br><span class="line">        print(&quot;curve: &quot; + str(self.curve.name))</span><br><span class="line">        print(&quot;point x: &quot; + str(self.point_x))</span><br><span class="line">        print(&quot;point y: &quot; + str(self.point_y))</span><br><span class="line">        print(&quot;encode point length: &quot; + str(len(self.encode_point)))</span><br><span class="line">        print(&quot;encode point: &quot;)</span><br><span class="line">        print(&#x27;,&#x27;.join([hex(i) for i in self.encode_point]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def print_key_message_to_file(self,filename = None):</span><br><span class="line">        f_name = &#x27;&#x27;</span><br><span class="line">        if filename != None:</span><br><span class="line">            f_name = filename</span><br><span class="line">        else:</span><br><span class="line">            f_name = os.path.splitext(self.key_filename)[0] + &#x27;.txt&#x27;</span><br><span class="line">        with open(f_name,&quot;w&quot;) as f:</span><br><span class="line">            f.write(self.key_filename + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA Private Key Info:\n&quot;)</span><br><span class="line">            f.write(&quot;key size: &quot; + str(self.private_key.key_size) + &quot; bits\r\n&quot;)</span><br><span class="line">            f.write(&quot;private value: &quot; + str(self.private_value) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;curve: &quot; + str(self.curve.name) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;point x: &quot; + str(self.point_x) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;point y: &quot; + str(self.point_y) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;encode point length: &quot; + str(len(self.encode_point)) + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;encode point: \n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.encode_point]))</span><br><span class="line">            f.write(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    def sign(self,message,hash_alg):</span><br><span class="line">        if hash_alg == 1:</span><br><span class="line">            return self.private_key.sign( \</span><br><span class="line">                message, \</span><br><span class="line">                ec.ECDSA(hashes.SHA256()) \</span><br><span class="line">            )</span><br><span class="line">        elif hash_alg == 2:</span><br><span class="line">            return self.private_key.sign( \</span><br><span class="line">                message, \</span><br><span class="line">                ec.ECDSA(hashes.SHA512()) \</span><br><span class="line">            )                    </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ecdsa_private_key = ECDSA_PRIVATE_KEY(&quot;ecdsa_p384_sign.key&quot;)</span><br><span class="line">    ecdsa_private_key.print_key_message()</span><br><span class="line">    ecdsa_private_key.print_key_message_to_file()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="公钥操作-1"><a href="#公钥操作-1" class="headerlink" title="公钥操作"></a>公钥操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import OpenSSL</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import padding,rsa</span><br><span class="line">from cryptography.hazmat.primitives import hashes</span><br><span class="line">from cryptography.hazmat.backends.interfaces import EllipticCurveBackend</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import ec</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicNumbers</span><br><span class="line">from ecdsa_key_content_len import ECDSA_KEY_LEN</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class ECDSA_PUBLIC_KEY(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for ECDSA_PUBLIC_KEY&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, key_filename = None, key_pem_bytes = None, key_curve = None, key_encode_point = None):</span><br><span class="line">        super(ECDSA_PUBLIC_KEY, self).__init__()</span><br><span class="line">        if key_filename != None:</span><br><span class="line">            self.key_filename = key_filename</span><br><span class="line">            with open(self.key_filename,&quot;rb&quot;) as f:</span><br><span class="line">                self.public_key = serialization.load_pem_public_key( \</span><br><span class="line">                    f.read(), \</span><br><span class="line">                    backend = default_backend() \</span><br><span class="line">                )</span><br><span class="line">            self.key_len_info = ECDSA_KEY_LEN.ECDSA_KEY[self.public_key.key_size]</span><br><span class="line">            self.public_key_numbers = self.public_key.public_numbers()</span><br><span class="line">            self.curve = self.public_key_numbers.curve</span><br><span class="line">            self.point_x = self.public_key_numbers.x</span><br><span class="line">            self.point_y = self.public_key_numbers.y</span><br><span class="line">            self.point_x_bytes = self.point_x.to_bytes(self.key_len_info[&quot;x_len&quot;], byteorder= &#x27;big&#x27;)</span><br><span class="line">            self.point_y_bytes = self.point_y.to_bytes(self.key_len_info[&quot;y_len&quot;], byteorder= &#x27;big&#x27;)</span><br><span class="line">            self.encode_point = self.public_key_numbers.encode_point()</span><br><span class="line">        elif key_pem_bytes != None:</span><br><span class="line">            self.public_key = serialization.load_pem_public_key( \</span><br><span class="line">                key_pem_bytes, \</span><br><span class="line">                backend = default_backend() \</span><br><span class="line">            )  </span><br><span class="line">            self.key_len_info = ECDSA_KEY_LEN.ECDSA_KEY[self.public_key.key_size]</span><br><span class="line">            self.public_key_numbers = self.public_key.public_numbers()</span><br><span class="line">            self.curve = self.public_key_numbers.curve</span><br><span class="line">            self.point_x = self.public_key_numbers.x</span><br><span class="line">            self.point_y = self.public_key_numbers.y  </span><br><span class="line">            self.point_x_bytes = self.point_x.to_bytes(self.key_len_info[&quot;x_len&quot;], byteorder= &#x27;big&#x27;)</span><br><span class="line">            self.point_y_bytes = self.point_y.to_bytes(self.key_len_info[&quot;y_len&quot;], byteorder= &#x27;big&#x27;)</span><br><span class="line">            self.encode_point = self.public_key_numbers.encode_point()        </span><br><span class="line">        elif key_curve != None and key_encode_point != None:</span><br><span class="line">            self.public_key_numbers = EllipticCurvePublicNumbers.from_encoded_point(key_curve, key_encode_point)</span><br><span class="line">            self.curve = self.public_key_numbers.curve</span><br><span class="line">            self.point_x = self.public_key_numbers.x</span><br><span class="line">            self.point_y = self.public_key_numbers.y</span><br><span class="line">            self.encode_point = self.public_key_numbers.encode_point()</span><br><span class="line">            backend = default_backend()</span><br><span class="line">            self.public_key = backend.load_elliptic_curve_public_numbers(self.public_key_numbers)</span><br><span class="line">            self.key_len_info = ECDSA_KEY_LEN.ECDSA_KEY[self.public_key.key_size]</span><br><span class="line">            self.point_x_bytes = self.point_x.to_bytes(self.key_len_info[&quot;x_len&quot;], byteorder= &#x27;big&#x27;)</span><br><span class="line">            self.point_y_bytes = self.point_y.to_bytes(self.key_len_info[&quot;y_len&quot;], byteorder= &#x27;big&#x27;)</span><br><span class="line"></span><br><span class="line">    def print_key_message(self): </span><br><span class="line">        print(&quot;ECDSA Private Key Info:&quot;)</span><br><span class="line">        print(&quot;key size: &quot; + str(self.public_key.key_size) + &quot; bits&quot;)</span><br><span class="line">        print(&quot;curve: &quot; + str(self.curve.name))</span><br><span class="line">        print(&quot;point x: &quot; + str(self.point_x))</span><br><span class="line">        print(&quot;point x bytes: &quot;)</span><br><span class="line">        print(&#x27;,&#x27;.join([hex(i) for i in self.point_x_bytes]))</span><br><span class="line">        print(&quot;point y: &quot; + str(self.point_y))</span><br><span class="line">        print(&quot;point y bytes: &quot;)</span><br><span class="line">        print(&#x27;,&#x27;.join([hex(i) for i in self.point_y_bytes]))</span><br><span class="line">        print(&quot;encode point length: &quot; + str(len(self.encode_point)))</span><br><span class="line">        print(&quot;encode point: &quot;)</span><br><span class="line">        print(&#x27;,&#x27;.join([hex(i) for i in self.encode_point]))</span><br><span class="line"></span><br><span class="line">    def print_key_message_to_file(self,filename = None):</span><br><span class="line">        f_name = &#x27;&#x27;</span><br><span class="line">        if filename != None:</span><br><span class="line">            f_name = filename</span><br><span class="line">        else:</span><br><span class="line">            f_name = os.path.splitext(self.key_filename)[0] + &#x27;.txt&#x27;</span><br><span class="line">        with open(f_name,&quot;w&quot;) as f:</span><br><span class="line">            f.write(self.key_filename + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;ECDSA Public Key Info:\n&quot;)</span><br><span class="line">            f.write(&quot;key size: &quot; + str(self.public_key.key_size) + &quot; bits\r\n&quot;)</span><br><span class="line">            f.write(&quot;curve: &quot; + str(self.curve.name) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;point x: &quot; + str(self.point_x) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;point x bytes: \n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.point_x_bytes]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;point y: &quot; + str(self.point_y) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;point y bytes: \n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.point_y_bytes]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;encode point length: &quot; + str(len(self.encode_point)) + &quot;\n&quot;)</span><br><span class="line">            f.write(&quot;encode point: \n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.encode_point]))</span><br><span class="line">            f.write(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    def verify(self,message,signature,hash_alg):</span><br><span class="line">        if hash_alg == 1:</span><br><span class="line">            return self.public_key.verify( \</span><br><span class="line">                signature, \</span><br><span class="line">                message, \</span><br><span class="line">                ec.ECDSA(hashes.SHA256()) \</span><br><span class="line">            )</span><br><span class="line">        elif hash_alg == 2:</span><br><span class="line">            return self.public_key.verify( \</span><br><span class="line">                signature, \</span><br><span class="line">                message, \</span><br><span class="line">                ec.ECDSA(hashes.SHA512()) \</span><br><span class="line">            )            </span><br><span class="line">            </span><br><span class="line">def main():</span><br><span class="line">    ecdsa_public_key = ECDSA_PUBLIC_KEY(key_filename = &quot;ecdsa_p384_verify.key&quot;)</span><br><span class="line">    ecdsa_public_key.print_key_message()</span><br><span class="line">    ecdsa_public_key.print_key_message_to_file()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="key-len-file"><a href="#key-len-file" class="headerlink" title="key_len_file"></a>key_len_file</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">class ECDSA_KEY_LEN(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for ECDSA_KEY_LEN&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    ECDSA_P256 = &#123;</span><br><span class="line">        &quot;x_len&quot; : 32,</span><br><span class="line">        &quot;y_len&quot; : 32</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ECDSA_P384 = &#123;</span><br><span class="line">        &quot;x_len&quot; : 48,</span><br><span class="line">        &quot;y_len&quot; : 48</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ECDSA_P521 = &#123;</span><br><span class="line">        &quot;x_len&quot; : 66,</span><br><span class="line">        &quot;y_len&quot; : 66</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    ECDSA_KEY = &#123;</span><br><span class="line">        256 : ECDSA_P256,</span><br><span class="line">        384 : ECDSA_P384,</span><br><span class="line">        521 : ECDSA_P521</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(ECDSA_KEY_LEN, self).__init__()</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">from ecdsa_private_key_handle import ECDSA_PRIVATE_KEY</span><br><span class="line">from ecdsa_public_key_handle import ECDSA_PUBLIC_KEY</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    message = &quot;hello mrbluyee.&quot;</span><br><span class="line">    ecdsa_private_key = ECDSA_PRIVATE_KEY(&quot;ecdsa_p384_sign.key&quot;)</span><br><span class="line">    ecdsa_public_key = ECDSA_PUBLIC_KEY(key_filename = &quot;ecdsa_p384_verify.key&quot;)</span><br><span class="line">  </span><br><span class="line">    message_sign = ecdsa_private_key.sign(message.encode(),1)</span><br><span class="line">    print(&quot;message_sign:&quot;)</span><br><span class="line">    print(len(message_sign))</span><br><span class="line">    print([hex(i) for i in message_sign])</span><br><span class="line"></span><br><span class="line">    message_verify = ecdsa_public_key.verify(message.encode(),message_sign,1)</span><br><span class="line">    print(&quot;message verify:&quot;)</span><br><span class="line">    print(message_verify)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message_sign:</span><br><span class="line">102</span><br><span class="line">[&#x27;0x30&#x27;, &#x27;0x64&#x27;, &#x27;0x2&#x27;, &#x27;0x30&#x27;, &#x27;0x62&#x27;, &#x27;0xe6&#x27;, &#x27;0xb5&#x27;, &#x27;0xd&#x27;, &#x27;0x29&#x27;, &#x27;0x63&#x27;, &#x27;0x3&#x27;, &#x27;0x34&#x27;, &#x27;0x81&#x27;, &#x27;0x9b&#x27;, &#x27;0x68&#x27;, &#x27;0xd&#x27;, &#x27;0x39&#x27;, &#x27;0xa8&#x27;, &#x27;0xd0&#x27;, &#x27;0x35&#x27;, &#x27;0xd8&#x27;, &#x27;0xe5&#x27;, &#x27;0x77&#x27;, &#x27;0xe5&#x27;, &#x27;0xa4&#x27;, &#x27;0x69&#x27;, &#x27;0xdb&#x27;, &#x27;0x4&#x27;, &#x27;0x22&#x27;, &#x27;0x57&#x27;, &#x27;0x76&#x27;, &#x27;0x7&#x27;, &#x27;0x29&#x27;, &#x27;0xff&#x27;, &#x27;0xa4&#x27;, &#x27;0xda&#x27;, &#x27;0xc9&#x27;, &#x27;0x44&#x27;, &#x27;0x1f&#x27;, &#x27;0x95&#x27;, &#x27;0x6b&#x27;, &#x27;0xe6&#x27;, &#x27;0x8b&#x27;, &#x27;0x87&#x27;, &#x27;0x42&#x27;, &#x27;0x8f&#x27;, &#x27;0xce&#x27;, &#x27;0x57&#x27;, &#x27;0x6c&#x27;, &#x27;0x49&#x27;, &#x27;0xd1&#x27;, &#x27;0x43&#x27;, &#x27;0x2&#x27;, &#x27;0x30&#x27;, &#x27;0x5e&#x27;, &#x27;0x9a&#x27;, &#x27;0xc8&#x27;, &#x27;0xe&#x27;, &#x27;0xdb&#x27;, &#x27;0x72&#x27;, &#x27;0xb4&#x27;, &#x27;0xee&#x27;, &#x27;0xf7&#x27;, &#x27;0xb5&#x27;, &#x27;0xb&#x27;, &#x27;0x6f&#x27;, &#x27;0xeb&#x27;, &#x27;0xd4&#x27;, &#x27;0x2c&#x27;, &#x27;0x3b&#x27;, &#x27;0x85&#x27;, &#x27;0xcb&#x27;, &#x27;0xc2&#x27;, &#x27;0x79&#x27;, &#x27;0x5a&#x27;, &#x27;0x6&#x27;, &#x27;0x6d&#x27;, &#x27;0x79&#x27;, &#x27;0x70&#x27;, &#x27;0x1&#x27;, &#x27;0xdc&#x27;, &#x27;0x2a&#x27;, &#x27;0x35&#x27;, &#x27;0x62&#x27;, &#x27;0x3a&#x27;, &#x27;0x8c&#x27;, &#x27;0x5c&#x27;, &#x27;0xa5&#x27;, &#x27;0xd2&#x27;, &#x27;0x57&#x27;, &#x27;0xb&#x27;, &#x27;0xed&#x27;, &#x27;0x88&#x27;, &#x27;0xe0&#x27;, &#x27;0x56&#x27;, &#x27;0xba&#x27;, &#x27;0xb1&#x27;, &#x27;0x2f&#x27;, &#x27;0xc9&#x27;, &#x27;0x8f&#x27;, &#x27;0x20&#x27;, &#x27;0xa7&#x27;]</span><br><span class="line">message verify:</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>文章部分内容整理自:<br><a href="https://www.8btc.com/">比特币系统采用的公钥密码学方案和ECDSA签名算法介绍——第一部分：原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA非对称加密算法</title>
      <link href="/2018/11/22/RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/22/RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-openssl-tool"><a href="#linux-openssl-tool" class="headerlink" title="linux openssl tool"></a>linux openssl tool</h2><h3 id="openssl中RSA文件格式解析"><a href="#openssl中RSA文件格式解析" class="headerlink" title="openssl中RSA文件格式解析"></a>openssl中RSA文件格式解析</h3><span id="more"></span><h4 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h4><p>私钥里面包含的内容有：<br>1.version：版本号<br>2.modulus：RSA的合数模n<br>3.public exponent：RSA的公开幂e<br>4.private exponent：RSA的私有幂d<br>5.prime1：n的素数因子p<br>6.prime2：n的素数因子q<br>7.exponent1：为d mod (p - 1)<br>8.exponent2：为d mod (q - 1)<br>9.coefficient：是CRT系数q-1 mod p<br>10.other prime infos：按顺序包含了其他素数r3,…,ru的信息。<br>如果version是0，它应该被忽略。<br>如果version是1，它至少包含一个other prime info。</p><p>other prime info里包含的内容：<br>1.prime：是n的一个素数因子ri，其中i&gt;&#x3D;3。<br>2.exponent：是di &#x3D; d mod (ri - 1)。<br>3.coefficient：是CRT系数 ti &#x3D; (r1<em>r2</em>…ri-1)-1 mod ri</p><p>linux下openssl生成RSA私钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">私钥无加密：</span><br><span class="line">openssl genrsa -out rsa_private.key 2048</span><br><span class="line"></span><br><span class="line">私钥加密（使用aes256加密）：</span><br><span class="line">openssl genrsa -aes256 -out rsa_aes_private.key 2048</span><br><span class="line">然后输入aes加密的密码，或者</span><br><span class="line">openssl genrsa -aes256 -passout pass:11111 -out rsa_aes_private.key 2048</span><br><span class="line">其中 passout 代替shell 进行密码输入。</span><br><span class="line">密钥生成后的内容如下：</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">Proc-Type: 4,ENCRYPTED</span><br><span class="line">DEK-Info: AES-256-CBC,BF1965D1DF10F2C693CD549C3B0EAF81</span><br><span class="line">Base64 Encoded Data</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看私钥明细：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa_private.key -noout -text</span><br><span class="line">或：</span><br><span class="line">openssl rsa -in rsa_aes_private.key -text -out private.txt</span><br></pre></td></tr></table></figure><p>使用-pubin参数可查看公钥明细</p><h4 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h4><p>公钥里面包含的内容有：<br>1.modulus：RSA的合数模n<br>2.public exponent：RSA的公开幂e</p><p>linux下openssl根据RSA私钥生成公钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">私钥无加密：</span><br><span class="line">openssl rsa -in rsa_private.key -pubout -out rsa_public.key</span><br><span class="line"></span><br><span class="line">私钥加密：</span><br><span class="line">openssl rsa -in rsa_aes_private.key -pubout -out rsa_public.key</span><br><span class="line">然后输入aes加密的密码，或者</span><br><span class="line">openssl rsa -in rsa_aes_private.key -passin pass:11111 -pubout -out rsa_public.key</span><br><span class="line">其中 passout 代替shell 进行密码输入。</span><br></pre></td></tr></table></figure><h4 id="转换命令"><a href="#转换命令" class="headerlink" title="转换命令"></a>转换命令</h4><p>1.私钥转非加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa_aes_private.key -passin pass:11111 -out rsa_private.key</span><br></pre></td></tr></table></figure><p>2.私钥转加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa_private.key -aes256 -passout pass:11111 -out rsa_aes_private.key</span><br></pre></td></tr></table></figure><p>3.私钥PEM转DER</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in rsa_private.key -outform der-out rsa_aes_private.der</span><br></pre></td></tr></table></figure><p>-inform和-outform 参数制定输入输出格式，由der转pem格式同理。<br>4.私钥PKCS#1转PKCS#8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -in rsa_private.key -passout pass:111111 -out pkcs8_private.key</span><br></pre></td></tr></table></figure><p>其中-passout指定了密码，输出的pkcs8格式密钥为加密形式，pkcs8默认采用des3 加密算法。<br>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN ENCRYPTED PRIVATE KEY-----</span><br><span class="line">Base64 Encoded Data</span><br><span class="line">-----END ENCRYPTED PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>使用-nocrypt参数可以输出无加密的pkcs8密钥，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">Base64 Encoded Data</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h3><p>1.生成 RSA 私钥和自签名证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -nodes -keyout rsa_private.key -x509 -days 365 -out cert.crt</span><br></pre></td></tr></table></figure><p>req是证书请求的子命令，-newkey rsa:2048 -keyout private_key.pem 表示生成私钥(PKCS8格式)，-nodes 表示私钥不加密，若不带参数将提示输入密码；<br>-x509表示输出证书，-days365 为有效期，此后根据提示输入证书拥有者信息；<br>若执行自动输入，可使用-subj选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -newkey rsa:2048 -nodes -keyout rsa_private.key -x509 -days 365 -out cert.crt -subj &quot;/C=CN/ST=SH/L=SHZ/O=SHU/OU=lib/CN=mrbluyee/emailAddress=mr.bluyee@hotmail.com&quot;</span><br></pre></td></tr></table></figure><p>2.使用 已有RSA 私钥生成自签名证书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -key rsa_private.key -out cert.crt</span><br></pre></td></tr></table></figure><p>-new 指生成证书请求，加上-x509 表示直接输出证书，-key 指定私钥文件，其余选项与上述命令相同。</p><p>3.证书查看及转换<br>查看证书细节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in cert.crt -noout -text</span><br></pre></td></tr></table></figure><p>转换证书编码格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem</span><br></pre></td></tr></table></figure><p>合成 pkcs#12 证书(含私钥)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a.将 pem 证书和私钥转 pkcs#12 证书：</span><br><span class="line">openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:11111 -password pass:11111 -out server.p12</span><br><span class="line">其中-export指导出pkcs#12 证书，-inkey 指定了私钥文件，-passin 为私钥(文件)密码(nodes为无加密)，-password 指定 p12文件的密码(导入导出)</span><br><span class="line"></span><br><span class="line">b.将 pem 证书和私钥/CA 证书 合成pkcs#12 证书：</span><br><span class="line">openssl pkcs12 -export -in server.crt -inkey server.key -passin pass:11111 \</span><br><span class="line">    -chain -CAfile ca.crt -password pass:11111 -out server-all.p12</span><br><span class="line">其中-chain指示同时添加证书链，-CAfile 指定了CA证书，导出的p12文件将包含多个证书。(其他选项：-name可用于指定server证书别名；-caname用于指定ca证书别名)</span><br><span class="line"></span><br><span class="line">c.pcks#12 提取PEM文件(含私钥) </span><br><span class="line">openssl pkcs12 -in server.p12 -password pass:11111 -passout pass:11111 -out out/server.pem</span><br><span class="line">其中-password 指定 p12文件的密码(导入导出)，-passout指输出私钥的加密密码(nodes为无加密)</span><br><span class="line">导出的文件为pem格式，同时包含证书和私钥(pkcs#8)</span><br><span class="line"></span><br><span class="line">仅提取私钥</span><br><span class="line">openssl pkcs12 -in server.p12 -password pass:11111 -passout pass:11111 -nocerts -out out/key.pem</span><br><span class="line"></span><br><span class="line">仅提取证书(所有证书)</span><br><span class="line">openssl pkcs12 -in server.p12 -password pass:11111 -nokeys -out out/key.pem</span><br><span class="line"></span><br><span class="line">仅提取ca证书</span><br><span class="line">openssl pkcs12 -in server-all.p12 -password pass:11111 -nokeys -cacerts -out out/cacert.pem </span><br><span class="line"></span><br><span class="line">仅提取server证书</span><br><span class="line">openssl pkcs12 -in server-all.p12 -password pass:11111 -nokeys -clcerts -out out/cert.pem </span><br></pre></td></tr></table></figure><h3 id="签名请求及CA签名"><a href="#签名请求及CA签名" class="headerlink" title="签名请求及CA签名"></a>签名请求及CA签名</h3><p>使用 RSA私钥生成 CSR 签名请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -aes256 -passout pass:11111 -out server.key 2048</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure><p>此后输入密码、server证书信息完成，也可以命令行指定各类参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -passin pass:111111 -out server.csr -subj &quot;/C=CN/ST=SH/L=SHZ/O=SHU/OU=lib/CN=mrbluyee/emailAddress=mr.bluyee@hotmail.com&quot;</span><br></pre></td></tr></table></figure><p>此时生成的 csr签名请求文件可提交至 CA进行签发</p><h2 id="python-openssl-lib"><a href="#python-openssl-lib" class="headerlink" title="python openssl lib"></a>python openssl lib</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl</span><br></pre></td></tr></table></figure><h3 id="证书操作"><a href="#证书操作" class="headerlink" title="证书操作"></a>证书操作</h3><p>RSA2048</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import OpenSSL</span><br><span class="line">import os</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import padding</span><br><span class="line">from cryptography.hazmat.primitives import hashes</span><br><span class="line"></span><br><span class="line">class Cert_File(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for Cert_File&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, cert_file_name):</span><br><span class="line">        super(Cert_File, self).__init__()</span><br><span class="line">        self.cert_file_name = cert_file_name</span><br><span class="line">        with open(self.cert_file_name) as f:</span><br><span class="line">            self.cert_pem = f.read()</span><br><span class="line">        self.cert_X509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM,self.cert_pem)</span><br><span class="line">        self.cert_X509_subject = self.cert_X509.get_subject()</span><br><span class="line">        self.cert_X509_issuer = self.cert_X509.get_issuer()</span><br><span class="line">        self.cert_X509_version = self.cert_X509.get_version()</span><br><span class="line">        self.cert_X509_subject_components = self.cert_X509_subject.get_components()</span><br><span class="line">        self.cert_X509_issuer_components = self.cert_X509_issuer.get_components()</span><br><span class="line"></span><br><span class="line">        self.cert_X509_digest = self.cert_X509.digest(&#x27;SHA256&#x27;)</span><br><span class="line">        self.cert_X509_hash = self.cert_X509.subject_name_hash()</span><br><span class="line">        self.cert_X509_extension_count = self.cert_X509.get_extension_count()</span><br><span class="line">        self.cert_X509_extension = []</span><br><span class="line">        for i in range(self.cert_X509_extension_count):</span><br><span class="line">            self.cert_X509_extension.append(self.cert_X509.get_extension(i))</span><br><span class="line">        self.cert_X509_not_after = self.cert_X509.get_notAfter()</span><br><span class="line">        self.cert_X509_not_before = self.cert_X509.get_notBefore()</span><br><span class="line">        self.cert_X509_serial_number = self.cert_X509.get_serial_number()</span><br><span class="line">        self.cert_X509_signature_algorithm = self.cert_X509.get_signature_algorithm()</span><br><span class="line"></span><br><span class="line">        self.cert_X509_pubkey = self.cert_X509.get_pubkey()</span><br><span class="line">        self.cert_X509_pubkey_bits = self.cert_X509_pubkey.bits()</span><br><span class="line">        self.cert_X509_pubkey_type = self.cert_X509_pubkey.type()</span><br><span class="line">        self.cert_X509_pubkey_dump = OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_PEM, self.cert_X509_pubkey)</span><br><span class="line">        self.cryptography_public_key = self.cert_X509_pubkey.to_cryptography_key()</span><br><span class="line">        self.cryptography_public_key_numbers = self.cryptography_public_key.public_numbers()</span><br><span class="line">        self.cryptography_public_key_numbers_n = self.cryptography_public_key_numbers.n</span><br><span class="line">        self.cryptography_public_key_numbers_exponent = self.cryptography_public_key_numbers.e</span><br><span class="line">        self.cryptography_public_key_numbers_modulus = self.cryptography_public_key_numbers_n.to_bytes(257, byteorder= &#x27;big&#x27;)</span><br><span class="line"></span><br><span class="line">    def print_cert(self):</span><br><span class="line">        print(&quot;Version: &quot; + str(self.cert_X509_version))</span><br><span class="line">        print(&quot;Serial Number: &quot; + str(self.cert_X509_serial_number))</span><br><span class="line">        print(&quot;Signature Algorithm: &quot; + self.cert_X509_signature_algorithm.decode())</span><br><span class="line">        Issuer = [item[0].decode() + &quot;=&quot; + item[1].decode() for item in self.cert_X509_issuer_components]</span><br><span class="line">        print(&quot;Issuer: &quot; + &quot;, &quot;.join(Issuer))</span><br><span class="line">        print(&quot;Validity:&quot;)</span><br><span class="line">        print(&quot;Not Before: &quot; + self.cert_X509_not_before.decode())</span><br><span class="line">        print(&quot;Not After : &quot; + self.cert_X509_not_after.decode())</span><br><span class="line">        Subject = [item[0].decode() + &quot;=&quot; + item[1].decode() for item in self.cert_X509_subject_components]</span><br><span class="line">        print(&quot;Subject: &quot; + &quot;, &quot;.join(Subject))  </span><br><span class="line">        print(&quot;Public Key: (&quot; + str(self.cert_X509_pubkey_bits) + &quot;bytes)&quot;)</span><br><span class="line">        if self.cert_X509_pubkey_type == OpenSSL.crypto.TYPE_RSA:</span><br><span class="line">            print(&quot;Public Key type: RSA&quot;)</span><br><span class="line">        elif self.cert_X509_pubkey_type == OpenSSL.crypto.TYPE_DSA:</span><br><span class="line">            print(&quot;Public Key type: DSA&quot;)</span><br><span class="line">        print(self.cert_X509_pubkey_dump.decode())</span><br><span class="line">        print(&quot;Public Key modulus: &quot;)</span><br><span class="line">        l = [hex(i) for i in self.cryptography_public_key_numbers_modulus]</span><br><span class="line">        print(l)</span><br><span class="line">        print(&quot;Public Key exponent: &quot; + str(self.cryptography_public_key_numbers_exponent))</span><br><span class="line">        print(&quot;X509 extensions:&quot;)</span><br><span class="line">        for index,value in enumerate(self.cert_X509_extension):</span><br><span class="line">            if index == 0:</span><br><span class="line">                print(&quot;X509v3 Subject Key Identifier: &quot;)</span><br><span class="line">            elif index == 1:</span><br><span class="line">                print(&quot;X509v3 Authority Key Identifier: &quot;)</span><br><span class="line">            elif index == 2:</span><br><span class="line">                print(&quot;X509v3 Basic Constraints: critical&quot;)</span><br><span class="line">            print(value)</span><br><span class="line"></span><br><span class="line">    def print_cert_to_file(self,filename = None):</span><br><span class="line">        f_name = &#x27;&#x27;</span><br><span class="line">        if filename != None:</span><br><span class="line">            f_name = filename</span><br><span class="line">        else:</span><br><span class="line">            f_name = os.path.splitext(self.cert_file_name)[0] + &#x27;.txt&#x27;</span><br><span class="line">        with open(f_name,&quot;w&quot;) as f:</span><br><span class="line">            f.write(self.cert_file_name + &#x27;\n&#x27;)</span><br><span class="line">            f.write(&quot;Version: &quot; + str(self.cert_X509_version)+ &#x27;\n&#x27;)</span><br><span class="line">            f.write(&quot;Serial Number: &quot; + str(self.cert_X509_serial_number)+ &#x27;\n&#x27;)</span><br><span class="line">            f.write(&quot;Signature Algorithm: &quot; + self.cert_X509_signature_algorithm.decode() + &#x27;\r\n&#x27;)</span><br><span class="line">            Issuer = [item[0].decode() + &quot;=&quot; + item[1].decode() for item in self.cert_X509_issuer_components]</span><br><span class="line">            f.write(&quot;Issuer: &quot; + &quot;, &quot;.join(Issuer) + &#x27;\r\n&#x27;)</span><br><span class="line">            f.write(&quot;Validity:\n&quot;)</span><br><span class="line">            f.write(&quot;Not Before: &quot; + self.cert_X509_not_before.decode() + &#x27;\n&#x27;)</span><br><span class="line">            f.write(&quot;Not After : &quot; + self.cert_X509_not_after.decode() + &#x27;\n&#x27;)</span><br><span class="line">            Subject = [item[0].decode() + &quot;=&quot; + item[1].decode() for item in self.cert_X509_subject_components]</span><br><span class="line">            f.write(&quot;Subject: &quot; + &quot;, &quot;.join(Subject) + &#x27;\r\n&#x27;)</span><br><span class="line">            f.write(&quot;Public Key: (&quot; + str(self.cert_X509_pubkey_bits) + &quot;bytes)&quot; + &#x27;\n&#x27;)</span><br><span class="line">            if self.cert_X509_pubkey_type == OpenSSL.crypto.TYPE_RSA:</span><br><span class="line">                f.write(&quot;Public Key type: RSA&quot; + &#x27;\r\n&#x27;)</span><br><span class="line">            elif self.cert_X509_pubkey_type == OpenSSL.crypto.TYPE_DSA:</span><br><span class="line">                f.write(&quot;Public Key type: DSA&quot; + &#x27;\r\n&#x27;)</span><br><span class="line">            f.write(&quot;Public Key dump: \n&quot;)</span><br><span class="line">            f.write(self.cert_X509_pubkey_dump.decode())</span><br><span class="line">            f.write(&quot;\n&quot;)</span><br><span class="line">            f.write(&quot;Public Key modulus: \n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.cryptography_public_key_numbers_modulus]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;Public Key exponent: &quot; + str(self.cryptography_public_key_numbers_exponent) + &quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;X509 extensions:\n&quot;)</span><br><span class="line">            for index,value in enumerate(self.cert_X509_extension):</span><br><span class="line">                if index == 0:</span><br><span class="line">                    f.write(&quot;X509v3 Subject Key Identifier: \n&quot;)</span><br><span class="line">                elif index == 1:</span><br><span class="line">                    f.write(&quot;X509v3 Authority Key Identifier: \n&quot;)</span><br><span class="line">                elif index == 2:</span><br><span class="line">                    f.write(&quot;X509v3 Basic Constraints: critical\n&quot;)</span><br><span class="line">                f.write(str(value))</span><br><span class="line">                f.write(&quot;\n&quot;)</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line"></span><br><span class="line">    def verify(self,message,signature):</span><br><span class="line">        return self.cryptography_public_key.verify( \</span><br><span class="line">            signature, \</span><br><span class="line">            message, \</span><br><span class="line">            padding.PSS( \</span><br><span class="line">            mgf=padding.MGF1(hashes.SHA256()), \</span><br><span class="line">            salt_length=padding.PSS.MAX_LENGTH \</span><br><span class="line">            ), \</span><br><span class="line">            hashes.SHA256() \</span><br><span class="line">        )</span><br><span class="line">            </span><br><span class="line">    def encrypt(self,message):</span><br><span class="line">        return self.cryptography_public_key.encrypt( \</span><br><span class="line">            message, \</span><br><span class="line">            padding.OAEP( \</span><br><span class="line">            mgf=padding.MGF1(algorithm=hashes.SHA256()), \</span><br><span class="line">            algorithm=hashes.SHA256(), \</span><br><span class="line">            label=None \</span><br><span class="line">            )\</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    cert1 = Cert_File(&#x27;cert.crt&#x27;)</span><br><span class="line">    cert1.print_cert()</span><br><span class="line">    cert1.print_cert_to_file()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="私钥操作"><a href="#私钥操作" class="headerlink" title="私钥操作"></a>私钥操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import OpenSSL</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import padding</span><br><span class="line">from cryptography.hazmat.primitives import hashes</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class RSA_PRIVATE_KEY(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for RSA_PRIVATE_KEY&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, key_filename, passwd = None):</span><br><span class="line">        super(RSA_PRIVATE_KEY, self).__init__()</span><br><span class="line">        self.key_filename = key_filename</span><br><span class="line">        with open(self.key_filename,&quot;rb&quot;) as f:</span><br><span class="line">            self.private_key = serialization.load_pem_private_key( \</span><br><span class="line">                f.read(), \</span><br><span class="line">                password = passwd.encode(), \</span><br><span class="line">                backend = default_backend() \</span><br><span class="line">            )</span><br><span class="line">        self.private_key_numbers = self.private_key.private_numbers()</span><br><span class="line">        self.private_key_numbers_public_numbers = self.private_key_numbers.public_numbers</span><br><span class="line">        self.private_key_numbers_modulus = self.private_key_numbers_public_numbers.n.to_bytes(257, byteorder= &#x27;big&#x27;)</span><br><span class="line">        self.private_key_numbers_public_exponent = self.private_key_numbers_public_numbers.e</span><br><span class="line">        self.private_key_numbers_dbytes = self.private_key_numbers.d.to_bytes(256, byteorder= &#x27;big&#x27;)</span><br><span class="line">        self.private_key_numbers_pbytes = self.private_key_numbers.p.to_bytes(129, byteorder= &#x27;big&#x27;)</span><br><span class="line">        self.private_key_numbers_qbytes = self.private_key_numbers.q.to_bytes(129, byteorder= &#x27;big&#x27;)</span><br><span class="line">        self.private_key_numbers_dmp1 = self.private_key_numbers.dmp1.to_bytes(128, byteorder= &#x27;big&#x27;)</span><br><span class="line">        self.private_key_numbers_dmq1 = self.private_key_numbers.dmq1.to_bytes(128, byteorder= &#x27;big&#x27;)</span><br><span class="line">        self.private_key_numbers_iqmp = self.private_key_numbers.iqmp.to_bytes(129, byteorder= &#x27;big&#x27;)</span><br><span class="line"></span><br><span class="line">    def print_key_message(self):</span><br><span class="line">        print(&quot;key size: &quot; + str(self.private_key.key_size))</span><br><span class="line">        print(&quot;modulus:&quot;)</span><br><span class="line">        print([hex(i) for i in self.private_key_numbers_modulus])</span><br><span class="line">        print(&quot;public exponent: &quot; + str(self.private_key_numbers_public_exponent))</span><br><span class="line">        print(&quot;privateExponent INTEGER(d):&quot;)  #RSA的私有幂d。</span><br><span class="line">        print([hex(i) for i in self.private_key_numbers_dbytes])</span><br><span class="line">        print(&quot;prime1 INTEGER(p):&quot;)  #n的素数因子p。</span><br><span class="line">        print([hex(i) for i in self.private_key_numbers_pbytes])</span><br><span class="line">        print(&quot;prime2 INTEGER(q):&quot;)  #n的素数因子q。</span><br><span class="line">        print([hex(i) for i in self.private_key_numbers_qbytes])</span><br><span class="line">        print(&quot;exponent1:&quot;)  #等于d mod (p − 1)</span><br><span class="line">        print([hex(i) for i in self.private_key_numbers_dmp1])</span><br><span class="line">        print(&quot;exponent2:&quot;)  #等于d mod (q − 1)。</span><br><span class="line">        print([hex(i) for i in self.private_key_numbers_dmq1])</span><br><span class="line">        print(&quot;coefficient:&quot;)  #CRT系数 q–1 mod p。</span><br><span class="line">        print([hex(i) for i in self.private_key_numbers_iqmp])</span><br><span class="line"></span><br><span class="line">    def print_key_message_to_file(self,filename = None):</span><br><span class="line">        f_name = &#x27;&#x27;</span><br><span class="line">        if filename != None:</span><br><span class="line">            f_name = filename</span><br><span class="line">        else:</span><br><span class="line">            f_name = os.path.splitext(self.key_filename)[0] + &#x27;.txt&#x27;</span><br><span class="line">        with open(f_name,&quot;w&quot;) as f:</span><br><span class="line">            f.write(self.key_filename + &#x27;\r\n&#x27;)</span><br><span class="line">            f.write(&quot;key size: &quot; + str(self.private_key.key_size))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;modulus:\n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.private_key_numbers_modulus]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;public exponent: &quot; + str(self.private_key_numbers_public_exponent))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;privateExponent INTEGER(d):\n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.private_key_numbers_dbytes]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;prime1 INTEGER(p):\n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.private_key_numbers_pbytes]))   </span><br><span class="line">            f.write(&quot;\r\n&quot;) </span><br><span class="line">            f.write(&quot;prime2 INTEGER(q):\n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.private_key_numbers_qbytes]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;exponent1:\n&quot;)      </span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.private_key_numbers_dmp1]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;exponent2:\n&quot;) </span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.private_key_numbers_dmq1])) </span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;coefficient:\n&quot;) </span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.private_key_numbers_iqmp])) </span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line"></span><br><span class="line">    def sign(self,message):</span><br><span class="line">        return self.private_key.sign( \</span><br><span class="line">            message, \</span><br><span class="line">            padding.PSS( \</span><br><span class="line">            mgf=padding.MGF1(hashes.SHA256()), \</span><br><span class="line">            salt_length=padding.PSS.MAX_LENGTH \</span><br><span class="line">            ), \</span><br><span class="line">            hashes.SHA256() \</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def decrypt(self,ciphertext):</span><br><span class="line">        return self.private_key.decrypt( \</span><br><span class="line">            ciphertext, \</span><br><span class="line">            padding.OAEP( \</span><br><span class="line">            mgf=padding.MGF1(algorithm=hashes.SHA256()), \</span><br><span class="line">            algorithm=hashes.SHA256(), \</span><br><span class="line">            label=None \</span><br><span class="line">            ) \</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    rsa_private_key = RSA_PRIVATE_KEY(&quot;rsa_aes_private.key&quot;,&quot;1111&quot;)</span><br><span class="line">    rsa_private_key.print_key_message()</span><br><span class="line">    rsa_private_key.print_key_message_to_file()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="公钥操作"><a href="#公钥操作" class="headerlink" title="公钥操作"></a>公钥操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import OpenSSL</span><br><span class="line">from cryptography.hazmat.backends import default_backend</span><br><span class="line">from cryptography.hazmat.primitives import serialization</span><br><span class="line">from cryptography.hazmat.primitives.asymmetric import padding</span><br><span class="line">from cryptography.hazmat.primitives import hashes</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class RSA_PUBLIC_KEY(object):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;docstring for RSA_PUBLIC_KEY&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, key_filename):</span><br><span class="line">        super(RSA_PUBLIC_KEY, self).__init__()</span><br><span class="line">        self.key_filename = key_filename</span><br><span class="line">        with open(self.key_filename,&quot;rb&quot;) as f:</span><br><span class="line">            self.public_key = serialization.load_pem_public_key( \</span><br><span class="line">                f.read(), \</span><br><span class="line">                backend = default_backend() \</span><br><span class="line">            )</span><br><span class="line">        self.public_key_numbers = self.public_key.public_numbers()</span><br><span class="line">        self.public_key_numbers_modulus = self.public_key_numbers.n.to_bytes(257, byteorder= &#x27;big&#x27;)</span><br><span class="line">        self.public_key_numbers_exponent = self.public_key_numbers.e</span><br><span class="line"></span><br><span class="line">    def print_key_message(self):</span><br><span class="line">        print(&quot;key size: &quot; + str(self.public_key.key_size))</span><br><span class="line">        print(&quot;modulus:&quot;)</span><br><span class="line">        print([hex(i) for i in self.public_key_numbers_modulus])</span><br><span class="line">        print(&quot;public exponent: &quot; + str(self.public_key_numbers_exponent))</span><br><span class="line"></span><br><span class="line">    def print_key_message_to_file(self,filename = None):</span><br><span class="line">        f_name = &#x27;&#x27;</span><br><span class="line">        if filename != None:</span><br><span class="line">            f_name = filename</span><br><span class="line">        else:</span><br><span class="line">            f_name = os.path.splitext(self.key_filename)[0] + &#x27;.txt&#x27;</span><br><span class="line">        with open(f_name,&quot;w&quot;) as f:</span><br><span class="line">            f.write(self.key_filename + &#x27;\r\n&#x27;)</span><br><span class="line">            f.write(&quot;key size: &quot; + str(self.public_key.key_size))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;modulus:\n&quot;)</span><br><span class="line">            f.write(&#x27;,&#x27;.join([hex(i) for i in self.public_key_numbers_modulus]))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line">            f.write(&quot;public exponent: &quot; + str(self.public_key_numbers_exponent))</span><br><span class="line">            f.write(&quot;\r\n&quot;)</span><br><span class="line"></span><br><span class="line">    def verify(self,message,signature):</span><br><span class="line">        return self.public_key.verify( \</span><br><span class="line">            signature, \</span><br><span class="line">            message, \</span><br><span class="line">            padding.PSS( \</span><br><span class="line">            mgf=padding.MGF1(hashes.SHA256()), \</span><br><span class="line">            salt_length=padding.PSS.MAX_LENGTH \</span><br><span class="line">            ), \</span><br><span class="line">            hashes.SHA256() \</span><br><span class="line">        )</span><br><span class="line">            </span><br><span class="line">    def encrypt(self,message):</span><br><span class="line">        return self.public_key.encrypt( \</span><br><span class="line">            message, \</span><br><span class="line">            padding.OAEP( \</span><br><span class="line">            mgf=padding.MGF1(algorithm=hashes.SHA256()), \</span><br><span class="line">            algorithm=hashes.SHA256(), \</span><br><span class="line">            label=None \</span><br><span class="line">            )\</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    rsa_public_key = RSA_PUBLIC_KEY(&quot;rsa_public.key&quot;)</span><br><span class="line">    rsa_public_key.print_key_message()</span><br><span class="line">    rsa_public_key.print_key_message_to_file()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RSA-test"><a href="#RSA-test" class="headerlink" title="RSA test"></a>RSA test</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">from rsa_private_key_handle import RSA_PRIVATE_KEY</span><br><span class="line">from rsa_public_key_handle import RSA_PUBLIC_KEY</span><br><span class="line">from rsa_cert_file_handle import Cert_File</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    message = &quot;hello mrbluyee.&quot;</span><br><span class="line">    rsa_private_key = RSA_PRIVATE_KEY(&quot;rsa_aes_private.key&quot;,&quot;1111&quot;)</span><br><span class="line">    rsa_public_key = RSA_PUBLIC_KEY(&quot;rsa_public.key&quot;)</span><br><span class="line">    cert1 = Cert_File(&#x27;cert.crt&#x27;)</span><br><span class="line"></span><br><span class="line">    message_sign = rsa_private_key.sign(message.encode())</span><br><span class="line">    print(&quot;message_sign:&quot;)</span><br><span class="line">    print([hex(i) for i in message_sign])</span><br><span class="line"></span><br><span class="line">    message_encrypt0 = rsa_public_key.encrypt(message.encode())</span><br><span class="line">    print(&quot;message_encrypt0:&quot;)</span><br><span class="line">    print([hex(i) for i in message_encrypt0])</span><br><span class="line"></span><br><span class="line">    message_verify0 = rsa_public_key.verify(message.encode(),message_sign)</span><br><span class="line">    print(&quot;message verify0:&quot;)</span><br><span class="line">    print(message_verify0)</span><br><span class="line"></span><br><span class="line">    message_encrypt1 = cert1.encrypt(message.encode())</span><br><span class="line">    print(&quot;message_encrypt1:&quot;)</span><br><span class="line">    print([hex(i) for i in message_encrypt1])</span><br><span class="line"></span><br><span class="line">    message_verify1 = cert1.verify(message.encode(),message_sign)</span><br><span class="line">    print(&quot;message verify1:&quot;)</span><br><span class="line">    print(message_verify1)    </span><br><span class="line"></span><br><span class="line">    message_decrypt0 = rsa_private_key.decrypt(message_encrypt0)</span><br><span class="line">    print(&quot;message decrypt0:&quot;)</span><br><span class="line">    print(message_decrypt0.decode())</span><br><span class="line"></span><br><span class="line">    message_decrypt1 = rsa_private_key.decrypt(message_encrypt1)</span><br><span class="line">    print(&quot;message decrypt1:&quot;)</span><br><span class="line">    print(message_decrypt1.decode())</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message_sign:</span><br><span class="line">[&#x27;0x80&#x27;, &#x27;0x35&#x27;, &#x27;0xb9&#x27;, &#x27;0x97&#x27;, &#x27;0x16&#x27;, &#x27;0x70&#x27;, &#x27;0x69&#x27;, &#x27;0xb9&#x27;, &#x27;0x99&#x27;, &#x27;0x9f&#x27;, &#x27;0xeb&#x27;, &#x27;0x8b&#x27;, &#x27;0x33&#x27;, &#x27;0xd9&#x27;, &#x27;0x3a&#x27;, &#x27;0xf2&#x27;, &#x27;0x17&#x27;, &#x27;0x62&#x27;, &#x27;0xbd&#x27;, &#x27;0x33&#x27;, &#x27;0xb7&#x27;, &#x27;0xe8&#x27;, &#x27;0x38&#x27;, &#x27;0x24&#x27;, &#x27;0xb1&#x27;, &#x27;0x74&#x27;, &#x27;0x28&#x27;, &#x27;0xf8&#x27;, &#x27;0xe9&#x27;, &#x27;0xc3&#x27;, &#x27;0xb5&#x27;, &#x27;0x12&#x27;, &#x27;0x2&#x27;, &#x27;0x1&#x27;, &#x27;0x64&#x27;, &#x27;0xac&#x27;, &#x27;0xf2&#x27;, &#x27;0xa1&#x27;, &#x27;0xef&#x27;, &#x27;0xc5&#x27;, &#x27;0xa6&#x27;, &#x27;0x34&#x27;, &#x27;0x5e&#x27;, &#x27;0x18&#x27;, &#x27;0x9b&#x27;, &#x27;0x52&#x27;, &#x27;0x12&#x27;, &#x27;0xee&#x27;, &#x27;0x17&#x27;, &#x27;0x59&#x27;, &#x27;0xdc&#x27;, &#x27;0x2c&#x27;, &#x27;0x6a&#x27;, &#x27;0x8b&#x27;, &#x27;0x26&#x27;, &#x27;0x8d&#x27;, &#x27;0xd1&#x27;, &#x27;0xef&#x27;, &#x27;0xb0&#x27;, &#x27;0xf1&#x27;, &#x27;0x44&#x27;, &#x27;0x77&#x27;, &#x27;0xad&#x27;, &#x27;0x3&#x27;, &#x27;0xe&#x27;, &#x27;0xfb&#x27;, &#x27;0x3f&#x27;, &#x27;0x49&#x27;, &#x27;0xd6&#x27;, &#x27;0x1d&#x27;, &#x27;0x57&#x27;, &#x27;0xa9&#x27;, &#x27;0x29&#x27;, &#x27;0x69&#x27;, &#x27;0xd7&#x27;, &#x27;0x4c&#x27;, &#x27;0xf7&#x27;, &#x27;0x52&#x27;, &#x27;0x53&#x27;, &#x27;0x40&#x27;, &#x27;0x61&#x27;, &#x27;0x65&#x27;, &#x27;0xe7&#x27;, &#x27;0x18&#x27;, &#x27;0x47&#x27;, &#x27;0x5f&#x27;, &#x27;0x5a&#x27;, &#x27;0xa5&#x27;, &#x27;0x60&#x27;, &#x27;0x8f&#x27;, &#x27;0x2b&#x27;, &#x27;0x30&#x27;, &#x27;0x48&#x27;, &#x27;0x55&#x27;, &#x27;0x11&#x27;, &#x27;0x18&#x27;, &#x27;0x92&#x27;, &#x27;0x8b&#x27;, &#x27;0xa9&#x27;, &#x27;0xb5&#x27;, &#x27;0xe6&#x27;, &#x27;0x7&#x27;, &#x27;0x78&#x27;, &#x27;0xe4&#x27;, &#x27;0x21&#x27;, &#x27;0x5&#x27;, &#x27;0xe1&#x27;, &#x27;0x82&#x27;, &#x27;0xd6&#x27;, &#x27;0x9b&#x27;, &#x27;0x59&#x27;, &#x27;0x4c&#x27;, &#x27;0x71&#x27;, &#x27;0x90&#x27;, &#x27;0x7b&#x27;, &#x27;0x5&#x27;, &#x27;0x72&#x27;, &#x27;0x10&#x27;, &#x27;0xe8&#x27;, &#x27;0xee&#x27;, &#x27;0xea&#x27;, &#x27;0x74&#x27;, &#x27;0x35&#x27;, &#x27;0x6f&#x27;, &#x27;0xbb&#x27;, &#x27;0x17&#x27;, &#x27;0x19&#x27;, &#x27;0xf&#x27;, &#x27;0xda&#x27;, &#x27;0x14&#x27;, &#x27;0xeb&#x27;, &#x27;0xb6&#x27;, &#x27;0x23&#x27;, &#x27;0xe8&#x27;, &#x27;0x8f&#x27;, &#x27;0xaa&#x27;, &#x27;0x9&#x27;, &#x27;0xcf&#x27;, &#x27;0x1f&#x27;, &#x27;0x8&#x27;, &#x27;0xdf&#x27;, &#x27;0x8d&#x27;, &#x27;0xe8&#x27;, &#x27;0xdb&#x27;, &#x27;0x25&#x27;, &#x27;0xb8&#x27;, &#x27;0x31&#x27;, &#x27;0x60&#x27;, &#x27;0x94&#x27;, &#x27;0xce&#x27;, &#x27;0x4c&#x27;, &#x27;0xcc&#x27;, &#x27;0x22&#x27;, &#x27;0x3b&#x27;, &#x27;0x12&#x27;, &#x27;0x81&#x27;, &#x27;0x8b&#x27;, &#x27;0x25&#x27;, &#x27;0x45&#x27;, &#x27;0x94&#x27;, &#x27;0xeb&#x27;, &#x27;0xea&#x27;, &#x27;0x10&#x27;, &#x27;0xc2&#x27;, &#x27;0xea&#x27;, &#x27;0xb&#x27;, &#x27;0x95&#x27;, &#x27;0x3f&#x27;, &#x27;0x58&#x27;, &#x27;0x85&#x27;, &#x27;0x7c&#x27;, &#x27;0x7a&#x27;, &#x27;0x9b&#x27;, &#x27;0x66&#x27;, &#x27;0x5b&#x27;, &#x27;0x72&#x27;, &#x27;0xcd&#x27;, &#x27;0xf7&#x27;, &#x27;0x7e&#x27;, &#x27;0xb0&#x27;, &#x27;0x40&#x27;, &#x27;0x11&#x27;, &#x27;0x7a&#x27;, &#x27;0xc&#x27;, &#x27;0xb4&#x27;, &#x27;0x3b&#x27;, &#x27;0xb9&#x27;, &#x27;0xba&#x27;, &#x27;0x9a&#x27;, &#x27;0xce&#x27;, &#x27;0x8f&#x27;, &#x27;0x2f&#x27;, &#x27;0x71&#x27;, &#x27;0xaf&#x27;, &#x27;0x9a&#x27;, &#x27;0x43&#x27;, &#x27;0x5a&#x27;, &#x27;0x61&#x27;, &#x27;0x6e&#x27;, &#x27;0x96&#x27;, &#x27;0xa5&#x27;, &#x27;0x7e&#x27;, &#x27;0xb0&#x27;, &#x27;0x70&#x27;, &#x27;0x17&#x27;, &#x27;0xa6&#x27;, &#x27;0xa7&#x27;, &#x27;0xd3&#x27;, &#x27;0x7b&#x27;, &#x27;0x12&#x27;, &#x27;0xba&#x27;, &#x27;0xce&#x27;, &#x27;0x14&#x27;, &#x27;0xf5&#x27;, &#x27;0x97&#x27;, &#x27;0x32&#x27;, &#x27;0xee&#x27;, &#x27;0x66&#x27;, &#x27;0xb2&#x27;, &#x27;0x50&#x27;, &#x27;0x87&#x27;, &#x27;0x46&#x27;, &#x27;0x3e&#x27;, &#x27;0x4f&#x27;, &#x27;0x3&#x27;, &#x27;0x87&#x27;, &#x27;0xb7&#x27;, &#x27;0x4d&#x27;, &#x27;0xb7&#x27;, &#x27;0xc&#x27;, &#x27;0xee&#x27;, &#x27;0xff&#x27;, &#x27;0xb3&#x27;, &#x27;0xb6&#x27;, &#x27;0x8b&#x27;, &#x27;0x26&#x27;, &#x27;0x9c&#x27;, &#x27;0x3d&#x27;, &#x27;0xab&#x27;, &#x27;0x59&#x27;, &#x27;0xb4&#x27;, &#x27;0x77&#x27;, &#x27;0xe8&#x27;, &#x27;0xa0&#x27;, &#x27;0x8c&#x27;, &#x27;0x45&#x27;, &#x27;0x25&#x27;, &#x27;0xdf&#x27;, &#x27;0x8d&#x27;, &#x27;0x3a&#x27;, &#x27;0x28&#x27;, &#x27;0x6&#x27;, &#x27;0x4f&#x27;, &#x27;0xb2&#x27;, &#x27;0xf4&#x27;, &#x27;0xd1&#x27;]</span><br><span class="line">message_encrypt0:</span><br><span class="line">[&#x27;0x80&#x27;, &#x27;0xd1&#x27;, &#x27;0x32&#x27;, &#x27;0xca&#x27;, &#x27;0xee&#x27;, &#x27;0x1d&#x27;, &#x27;0x7&#x27;, &#x27;0x7a&#x27;, &#x27;0x30&#x27;, &#x27;0x30&#x27;, &#x27;0x1e&#x27;, &#x27;0x21&#x27;, &#x27;0xa3&#x27;, &#x27;0x39&#x27;, &#x27;0x7b&#x27;, &#x27;0x89&#x27;, &#x27;0x22&#x27;, &#x27;0x49&#x27;, &#x27;0xef&#x27;, &#x27;0xfc&#x27;, &#x27;0xf0&#x27;, &#x27;0xcd&#x27;, &#x27;0x60&#x27;, &#x27;0xc6&#x27;, &#x27;0xa&#x27;, &#x27;0xc&#x27;, &#x27;0x70&#x27;, &#x27;0xd6&#x27;, &#x27;0xc8&#x27;, &#x27;0xb9&#x27;, &#x27;0x6f&#x27;, &#x27;0x3f&#x27;, &#x27;0x2a&#x27;, &#x27;0x74&#x27;, &#x27;0x5a&#x27;, &#x27;0x2d&#x27;, &#x27;0xfd&#x27;, &#x27;0x7d&#x27;, &#x27;0xb5&#x27;, &#x27;0xe7&#x27;, &#x27;0xa&#x27;, &#x27;0xd3&#x27;, &#x27;0xb5&#x27;, &#x27;0xb3&#x27;, &#x27;0x9b&#x27;, &#x27;0x82&#x27;, &#x27;0xa6&#x27;, &#x27;0xe6&#x27;, &#x27;0x89&#x27;, &#x27;0x1e&#x27;, &#x27;0x5c&#x27;, &#x27;0xd2&#x27;, &#x27;0xa7&#x27;, &#x27;0x5c&#x27;, &#x27;0x6a&#x27;, &#x27;0xd0&#x27;, &#x27;0xe1&#x27;, &#x27;0x6c&#x27;, &#x27;0x66&#x27;, &#x27;0xf8&#x27;, &#x27;0x53&#x27;, &#x27;0xc1&#x27;, &#x27;0x7a&#x27;, &#x27;0x66&#x27;, &#x27;0x56&#x27;, &#x27;0x32&#x27;, &#x27;0xf6&#x27;, &#x27;0xfd&#x27;, &#x27;0x57&#x27;, &#x27;0x31&#x27;, &#x27;0xb2&#x27;, &#x27;0xb5&#x27;, &#x27;0x16&#x27;, &#x27;0xe&#x27;, &#x27;0x28&#x27;, &#x27;0x6e&#x27;, &#x27;0xcc&#x27;, &#x27;0x63&#x27;, &#x27;0x61&#x27;, &#x27;0xed&#x27;, &#x27;0x31&#x27;, &#x27;0x5b&#x27;, &#x27;0xb4&#x27;, &#x27;0x80&#x27;, &#x27;0xf9&#x27;, &#x27;0xa8&#x27;, &#x27;0xd8&#x27;, &#x27;0xe5&#x27;, &#x27;0x81&#x27;, &#x27;0xda&#x27;, &#x27;0x6&#x27;, &#x27;0x49&#x27;, &#x27;0xb2&#x27;, &#x27;0xd9&#x27;, &#x27;0x1d&#x27;, &#x27;0xd5&#x27;, &#x27;0x9f&#x27;, &#x27;0x88&#x27;, &#x27;0x3e&#x27;, &#x27;0xb1&#x27;, &#x27;0x7&#x27;, &#x27;0x65&#x27;, &#x27;0xe2&#x27;, &#x27;0xce&#x27;, &#x27;0x26&#x27;, &#x27;0x98&#x27;, &#x27;0x45&#x27;, &#x27;0x40&#x27;, &#x27;0x69&#x27;, &#x27;0x62&#x27;, &#x27;0x9d&#x27;, &#x27;0x95&#x27;, &#x27;0xa2&#x27;, &#x27;0xf0&#x27;, &#x27;0x56&#x27;, &#x27;0xd9&#x27;, &#x27;0xc&#x27;, &#x27;0xe5&#x27;, &#x27;0xea&#x27;, &#x27;0x85&#x27;, &#x27;0xf9&#x27;, &#x27;0x7a&#x27;, &#x27;0x96&#x27;, &#x27;0x2a&#x27;, &#x27;0x73&#x27;, &#x27;0x7e&#x27;, &#x27;0xb5&#x27;, &#x27;0x94&#x27;, &#x27;0xef&#x27;, &#x27;0x12&#x27;, &#x27;0xf1&#x27;, &#x27;0x7b&#x27;, &#x27;0x44&#x27;, &#x27;0xdb&#x27;, &#x27;0x4c&#x27;, &#x27;0x9d&#x27;, &#x27;0x9a&#x27;, &#x27;0x3a&#x27;, &#x27;0x78&#x27;, &#x27;0x45&#x27;, &#x27;0x11&#x27;, &#x27;0xc0&#x27;, &#x27;0x61&#x27;, &#x27;0x5d&#x27;, &#x27;0x4&#x27;, &#x27;0xb7&#x27;, &#x27;0x3d&#x27;, &#x27;0x89&#x27;, &#x27;0xb2&#x27;, &#x27;0x51&#x27;, &#x27;0xd3&#x27;, &#x27;0xbc&#x27;, &#x27;0x66&#x27;, &#x27;0xb8&#x27;, &#x27;0xb&#x27;, &#x27;0xfd&#x27;, &#x27;0xe4&#x27;, &#x27;0x92&#x27;, &#x27;0xc&#x27;, &#x27;0x21&#x27;, &#x27;0x7&#x27;, &#x27;0x32&#x27;, &#x27;0x61&#x27;, &#x27;0x25&#x27;, &#x27;0x5f&#x27;, &#x27;0xaa&#x27;, &#x27;0xf&#x27;, &#x27;0xa8&#x27;, &#x27;0x70&#x27;, &#x27;0x14&#x27;, &#x27;0x19&#x27;, &#x27;0xb7&#x27;, &#x27;0xab&#x27;, &#x27;0x3&#x27;, &#x27;0x4f&#x27;, &#x27;0x3c&#x27;, &#x27;0xef&#x27;, &#x27;0x51&#x27;, &#x27;0x56&#x27;, &#x27;0x84&#x27;, &#x27;0x67&#x27;, &#x27;0xdd&#x27;, &#x27;0x3a&#x27;, &#x27;0x14&#x27;, &#x27;0xea&#x27;, &#x27;0x77&#x27;, &#x27;0x0&#x27;, &#x27;0x18&#x27;, &#x27;0x5a&#x27;, &#x27;0x59&#x27;, &#x27;0x99&#x27;, &#x27;0xb1&#x27;, &#x27;0xb0&#x27;, &#x27;0x56&#x27;, &#x27;0x12&#x27;, &#x27;0x8f&#x27;, &#x27;0xf0&#x27;, &#x27;0xab&#x27;, &#x27;0x8b&#x27;, &#x27;0xc4&#x27;, &#x27;0x6a&#x27;, &#x27;0x91&#x27;, &#x27;0x62&#x27;, &#x27;0xe1&#x27;, &#x27;0x4d&#x27;, &#x27;0xac&#x27;, &#x27;0x61&#x27;, &#x27;0x20&#x27;, &#x27;0xe5&#x27;, &#x27;0xf0&#x27;, &#x27;0xc8&#x27;, &#x27;0x17&#x27;, &#x27;0x6&#x27;, &#x27;0x72&#x27;, &#x27;0x3e&#x27;, &#x27;0xb8&#x27;, &#x27;0x37&#x27;, &#x27;0x0&#x27;, &#x27;0x63&#x27;, &#x27;0x5c&#x27;, &#x27;0xde&#x27;, &#x27;0x70&#x27;, &#x27;0x37&#x27;, &#x27;0x47&#x27;, &#x27;0x19&#x27;, &#x27;0x1c&#x27;, &#x27;0x3d&#x27;, &#x27;0xf3&#x27;, &#x27;0x35&#x27;, &#x27;0xcd&#x27;, &#x27;0x0&#x27;, &#x27;0xe1&#x27;, &#x27;0xe3&#x27;, &#x27;0x2b&#x27;, &#x27;0x8a&#x27;, &#x27;0xe1&#x27;, &#x27;0x2f&#x27;, &#x27;0xc7&#x27;, &#x27;0xf2&#x27;, &#x27;0xd3&#x27;, &#x27;0xef&#x27;, &#x27;0xae&#x27;, &#x27;0xcc&#x27;, &#x27;0x7a&#x27;, &#x27;0x35&#x27;, &#x27;0x38&#x27;, &#x27;0xc4&#x27;, &#x27;0x2e&#x27;, &#x27;0x25&#x27;, &#x27;0x31&#x27;, &#x27;0x6d&#x27;, &#x27;0x94&#x27;, &#x27;0x5&#x27;, &#x27;0xb8&#x27;, &#x27;0xb1&#x27;, &#x27;0x90&#x27;]</span><br><span class="line">message verify0:</span><br><span class="line">None</span><br><span class="line">message_encrypt1:</span><br><span class="line">[&#x27;0x68&#x27;, &#x27;0xf9&#x27;, &#x27;0x6b&#x27;, &#x27;0xb2&#x27;, &#x27;0xa3&#x27;, &#x27;0x6b&#x27;, &#x27;0x32&#x27;, &#x27;0x8e&#x27;, &#x27;0x52&#x27;, &#x27;0x71&#x27;, &#x27;0xb8&#x27;, &#x27;0x68&#x27;, &#x27;0x2b&#x27;, &#x27;0x52&#x27;, &#x27;0xb6&#x27;, &#x27;0xca&#x27;, &#x27;0x76&#x27;, &#x27;0x9c&#x27;, &#x27;0xba&#x27;, &#x27;0xa5&#x27;, &#x27;0x48&#x27;, &#x27;0x4b&#x27;, &#x27;0x5b&#x27;, &#x27;0x5d&#x27;, &#x27;0xb2&#x27;, &#x27;0xce&#x27;, &#x27;0xad&#x27;, &#x27;0xea&#x27;, &#x27;0x78&#x27;, &#x27;0x4b&#x27;, &#x27;0x6d&#x27;, &#x27;0x2b&#x27;, &#x27;0x99&#x27;, &#x27;0xb8&#x27;, &#x27;0xee&#x27;, &#x27;0x22&#x27;, &#x27;0x8b&#x27;, &#x27;0xf4&#x27;, &#x27;0xa8&#x27;, &#x27;0xaf&#x27;, &#x27;0x2e&#x27;, &#x27;0xa1&#x27;, &#x27;0xd9&#x27;, &#x27;0xd7&#x27;, &#x27;0x10&#x27;, &#x27;0x9b&#x27;, &#x27;0x12&#x27;, &#x27;0x1f&#x27;, &#x27;0xfb&#x27;, &#x27;0x6d&#x27;, &#x27;0x7b&#x27;, &#x27;0xb0&#x27;, &#x27;0x96&#x27;, &#x27;0x41&#x27;, &#x27;0xd0&#x27;, &#x27;0x65&#x27;, &#x27;0xba&#x27;, &#x27;0x9&#x27;, &#x27;0x51&#x27;, &#x27;0xde&#x27;, &#x27;0xa0&#x27;, &#x27;0xa3&#x27;, &#x27;0x70&#x27;, &#x27;0x9d&#x27;, &#x27;0xe&#x27;, &#x27;0x68&#x27;, &#x27;0xa7&#x27;, &#x27;0x36&#x27;, &#x27;0xb4&#x27;, &#x27;0xef&#x27;, &#x27;0xb5&#x27;, &#x27;0x7e&#x27;, &#x27;0x18&#x27;, &#x27;0x31&#x27;, &#x27;0x2&#x27;, &#x27;0x79&#x27;, &#x27;0x9f&#x27;, &#x27;0xeb&#x27;, &#x27;0x1d&#x27;, &#x27;0x6&#x27;, &#x27;0x7e&#x27;, &#x27;0xde&#x27;, &#x27;0x14&#x27;, &#x27;0xa0&#x27;, &#x27;0xb5&#x27;, &#x27;0x9b&#x27;, &#x27;0xb&#x27;, &#x27;0x96&#x27;, &#x27;0xf3&#x27;, &#x27;0x5&#x27;, &#x27;0x2e&#x27;, &#x27;0x62&#x27;, &#x27;0x56&#x27;, &#x27;0x22&#x27;, &#x27;0xe0&#x27;, &#x27;0x6f&#x27;, &#x27;0x25&#x27;, &#x27;0x22&#x27;, &#x27;0xc5&#x27;, &#x27;0x46&#x27;, &#x27;0x1e&#x27;, &#x27;0x7a&#x27;, &#x27;0xa6&#x27;, &#x27;0x68&#x27;, &#x27;0x29&#x27;, &#x27;0x8c&#x27;, &#x27;0xe5&#x27;, &#x27;0x92&#x27;, &#x27;0x47&#x27;, &#x27;0x47&#x27;, &#x27;0xb7&#x27;, &#x27;0x3e&#x27;, &#x27;0xc5&#x27;, &#x27;0x47&#x27;, &#x27;0xb4&#x27;, &#x27;0x4b&#x27;, &#x27;0x4d&#x27;, &#x27;0xbf&#x27;, &#x27;0x16&#x27;, &#x27;0xcb&#x27;, &#x27;0x9&#x27;, &#x27;0x55&#x27;, &#x27;0xff&#x27;, &#x27;0xf9&#x27;, &#x27;0x23&#x27;, &#x27;0x99&#x27;, &#x27;0xdd&#x27;, &#x27;0x87&#x27;, &#x27;0x80&#x27;, &#x27;0xfe&#x27;, &#x27;0xde&#x27;, &#x27;0x2d&#x27;, &#x27;0x2b&#x27;, &#x27;0xa2&#x27;, &#x27;0x80&#x27;, &#x27;0x7&#x27;, &#x27;0x47&#x27;, &#x27;0x7b&#x27;, &#x27;0x81&#x27;, &#x27;0xb5&#x27;, &#x27;0x36&#x27;, &#x27;0x95&#x27;, &#x27;0x1f&#x27;, &#x27;0x6e&#x27;, &#x27;0xea&#x27;, &#x27;0xea&#x27;, &#x27;0xd5&#x27;, &#x27;0x3f&#x27;, &#x27;0xd5&#x27;, &#x27;0xc8&#x27;, &#x27;0x58&#x27;, &#x27;0x2f&#x27;, &#x27;0xfc&#x27;, &#x27;0x26&#x27;, &#x27;0x1&#x27;, &#x27;0x39&#x27;, &#x27;0x87&#x27;, &#x27;0x56&#x27;, &#x27;0xa8&#x27;, &#x27;0xed&#x27;, &#x27;0xcc&#x27;, &#x27;0x52&#x27;, &#x27;0xad&#x27;, &#x27;0x96&#x27;, &#x27;0x19&#x27;, &#x27;0xeb&#x27;, &#x27;0xbf&#x27;, &#x27;0x7b&#x27;, &#x27;0x33&#x27;, &#x27;0x74&#x27;, &#x27;0xa3&#x27;, &#x27;0xae&#x27;, &#x27;0x23&#x27;, &#x27;0x4d&#x27;, &#x27;0xcf&#x27;, &#x27;0xb&#x27;, &#x27;0xbb&#x27;, &#x27;0x19&#x27;, &#x27;0xc1&#x27;, &#x27;0x1a&#x27;, &#x27;0xdf&#x27;, &#x27;0x1c&#x27;, &#x27;0xb5&#x27;, &#x27;0xd8&#x27;, &#x27;0x0&#x27;, &#x27;0x21&#x27;, &#x27;0x4f&#x27;, &#x27;0x5a&#x27;, &#x27;0xf7&#x27;, &#x27;0xdf&#x27;, &#x27;0xb0&#x27;, &#x27;0xed&#x27;, &#x27;0x6f&#x27;, &#x27;0x58&#x27;, &#x27;0x3d&#x27;, &#x27;0xf9&#x27;, &#x27;0x88&#x27;, &#x27;0x9&#x27;, &#x27;0x34&#x27;, &#x27;0xa&#x27;, &#x27;0xd5&#x27;, &#x27;0xb0&#x27;, &#x27;0xd6&#x27;, &#x27;0xbd&#x27;, &#x27;0xc8&#x27;, &#x27;0xaf&#x27;, &#x27;0x37&#x27;, &#x27;0x15&#x27;, &#x27;0xb7&#x27;, &#x27;0x8c&#x27;, &#x27;0x7d&#x27;, &#x27;0xdc&#x27;, &#x27;0xd4&#x27;, &#x27;0xea&#x27;, &#x27;0xad&#x27;, &#x27;0xd9&#x27;, &#x27;0xcd&#x27;, &#x27;0x91&#x27;, &#x27;0xeb&#x27;, &#x27;0xe8&#x27;, &#x27;0x85&#x27;, &#x27;0xe5&#x27;, &#x27;0xb0&#x27;, &#x27;0xdd&#x27;, &#x27;0xd9&#x27;, &#x27;0xa9&#x27;, &#x27;0x28&#x27;, &#x27;0x2f&#x27;, &#x27;0xcf&#x27;, &#x27;0xd9&#x27;, &#x27;0xa5&#x27;, &#x27;0x1d&#x27;, &#x27;0x21&#x27;, &#x27;0x8a&#x27;, &#x27;0x11&#x27;, &#x27;0x54&#x27;, &#x27;0xce&#x27;, &#x27;0x92&#x27;, &#x27;0x62&#x27;, &#x27;0xb8&#x27;, &#x27;0x9b&#x27;, &#x27;0xd3&#x27;, &#x27;0xad&#x27;, &#x27;0x7d&#x27;, &#x27;0x26&#x27;, &#x27;0xa4&#x27;, &#x27;0x1d&#x27;, &#x27;0x57&#x27;, &#x27;0x35&#x27;, &#x27;0xa&#x27;, &#x27;0xf&#x27;, &#x27;0x33&#x27;, &#x27;0x75&#x27;, &#x27;0x60&#x27;, &#x27;0x28&#x27;, &#x27;0x9&#x27;]</span><br><span class="line">message verify1:</span><br><span class="line">None</span><br><span class="line">message decrypt0:</span><br><span class="line">hello mrbluyee.</span><br><span class="line">message decrypt1:</span><br><span class="line">hello mrbluyee.</span><br></pre></td></tr></table></figure><p>文章部分内容整理自：<br><a href="https://blog.csdn.net/gengxiaoming7/article/details/78505107">使用 openssl 生成证书（含openssl详解）</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 内存越界引用和缓冲区溢出</title>
      <link href="/2018/11/20/05-%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E5%BC%95%E7%94%A8%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
      <url>/2018/11/20/05-%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E5%BC%95%E7%94%A8%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h3><p>C对于数组引用不进行任何边界检查，而且局部变量和状态信息（如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。</p><span id="more"></span><p>当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。<br>一种特别常见的状态破坏称为缓冲区溢出(buffer overflow)。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Implementation of library function gets()*/</span><br><span class="line">char *gets(char *s)&#123;</span><br><span class="line">    int c;</span><br><span class="line">    char *dest = s;</span><br><span class="line">    while((c = getchar()) != &#x27;\n&#x27; &amp;&amp; c != EOF)</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    if(c == EOF &amp;&amp; dest == s)</span><br><span class="line">        /* No characters read */</span><br><span class="line">        return NULL;</span><br><span class="line">    *dest++ = &#x27;\0&#x27;; /* Terminate string */</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Read input line and write it back */</span><br><span class="line">void echo()&#123;</span><br><span class="line">    char buf[8]; /* way too small */</span><br><span class="line">    gets(buf);</span><br><span class="line">    puts(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给出了库函数gets的一个实现，用来说明这个函数的严重问题。它从标准输入读入一行，在遇到一个回车换行字符或某个错误情况时停止。它将这个字符串复制到参数s指明的位置，并在字符串结尾加上null字符。在函数echo中，我们使用了gets，这个函数只是简单的从标准输入中读入一行，再把它回送到标准输出。</p><p>gets的问题是它没有办法确定是否为保存整个字符串分配了足够的空间。在echo示例中，我们故意将缓冲区设置的非常小——只有8个字节长。任何长度超过7个字符的字符串都会导致写越界。</p><p>检查GCC为echo产生的汇编代码，看看栈是如何组织的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">    subq  $24, %rsp    ; allocate 24 bytes on stack</span><br><span class="line">    movq  %rsp, %rdi   ; compute buf as %rsp</span><br><span class="line">    call  gets         ; call gets</span><br><span class="line">    movq  %rsp, %rdi   ; compute buf as %rsp</span><br><span class="line">    call  puts         ; call puts</span><br><span class="line">    addq  $24, %rsp    ; deallocate stack space</span><br><span class="line">    ret                ; return</span><br></pre></td></tr></table></figure><p>下图画出了echo执行时栈的组织。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/05_%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E5%BC%95%E7%94%A8%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/echo%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E7%BB%84%E7%BB%87.JPG" alt="echo函数的栈组织"><br>该程序把栈指针减去了24，在栈上分配了24个字节。字符数组buf位于栈顶，可以看到，%rsp被复制到%rdi作为调用gets和puts的参数。这个调用的参数和存储的返回指针之间的16字节是未被使用的。只要用户输入不超过7个字符，gets返回的字符串(包括结尾的null)就能够放进为buf分配的空间里。不过，长一些的字符串就会导致gets覆盖栈上存储的某些信息。随着字符串变长，下面的信息会被破坏：</p><table><thead><tr><th>输入的字符数量</th><th>附加的被破坏的状态</th></tr></thead><tbody><tr><td>0-7</td><td>无</td></tr><tr><td>9-23</td><td>未被使用的栈空间</td></tr><tr><td>24-31</td><td>返回地址</td></tr><tr><td>32+</td><td>caller中保存的状态</td></tr></tbody></table><p>字符串到23个字符之前都没有严重的后果，但是超过以后，返回指针的值以及更多可能的保存状态会被破坏。如果存储的返回地址的值被破坏了，那么ret指令会导致程序跳转到一个完全意想不到的位置。如果只看C代码，根本就不可能看出会有上面这些行为。只有通过研究机器代码级别的程序才能理解像gets这样的函数进行的内存越界的影响。</p><p>我们的echo代码很简单，但是有点太随意了。更好一点的版本是使用fgets函数，它包括一个参数，限制待读入的最大字节数。通常，使用gets或其他任何能导致存储溢出的函数，都是不好的编程习惯。不幸的是，很多常用的库函数，包括strcpy、strcat和sprintf，都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列。这样的情况就会导致缓冲区溢出漏洞。</p><p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码(exploit code)，另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret指令的效果就是跳转到攻击代码。</p><p>在一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret指令，(表面上)正常返回到调用者。</p><h3 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h3><p>缓冲区溢出攻击的普遍发生给计算机系统造成了许多的麻烦。现代的编译器和操作系统实现了很多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。</p><h4 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h4><p>为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。因此，如果攻击者可以确定一个常见的web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。许多系统都容易受到同一种病毒的攻击，这种现象常被称作安全单一化(security monoculture)。</p><p>栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。</p><p>实现的方式是：程序开始时，在栈上分配一段0-n字节之间的随机大小的空间，例如，使用分配函数alloca在栈上分配指定字节数量的空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。分配的范围n必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间。</p><p>下面的代码是一种确定“典型的“栈地址的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    long local;</span><br><span class="line">    printf(&quot;local at %p\n&quot;,&amp;local);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只是简单的打印出main函数中局部变量的地址。在32位Linux上运行这段代码10000次，这个地址的变化范围为0xff7fc59c到0xffffd09c,范围大小大约是2^23。在64位Linux上运行，这个地址的变化范围为0x7fff0001b698到0x7ffffffaa4a8,范围大小大约是2^32。</p><p>在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为**地址空间布局随机化(Address-Space Layout Randomization)，或者简称ASLR。采用ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能够对抗一些形式的攻击。</p><p>然而，一个执着的攻击者总是能够用蛮力克服随机化，他可以反复的用不同的地址进行攻击。一种常见的方式是在实际的攻击代码前插入很长一段的nop指令。执行这种指令除了对程序计数器加一，使之指向下一条指令之外，没有任何效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是“空操作雪橇(nop sled)”,意思是程序会“滑过”这个序列。如果我们建立一个256字节的nop sled，那么枚举2^15&#x3D;32768个起始地址，就能破解n &#x3D; 2^23的随机化，这对于一个顽固的攻击者来说，是完全可行的。对于64位的情况，要尝试枚举2^24&#x3D;16777216就有点令人畏惧了。我们可以看到栈随机化和其他一些ASLR技术能够增加成功攻击一个系统的难度，因而大大降低了病毒的传播速度，但也不能提供完全的安全保障。</p><h4 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h4><p>计算机的第二道防线是能够检测到何时栈已经被破坏。我们在echo函数示例中看到，破坏通常发生在当超越局部缓冲区的边界时。在C语言中，没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。</p><p>GCC在产生的代码中加入了一种**栈保护者(stack protector)**机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀(canary)值。这个金丝雀值，也称为哨兵值(guard value)，是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是的，那么程序异常中止。</p><p>GCC会试着确定一个函数是否容易遭受栈溢出攻击，并且自动插入这种溢出检测。实际上，对于前面的栈溢出展示，我们不得不用命令行选项“-fno-stack-protector”来阻止GCC产生这种代码。当不用这个选项来编译echo时，也就是允许使用栈保护者，得到下面的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1  echo:</span><br><span class="line">2      subq  $24, %rsp         ; allocate 24 bytes on stack</span><br><span class="line">3      movq  %fs:40, %rax      ; retrieve canary</span><br><span class="line">4      movq  %rax, 8(%rsp)     ; store on stack</span><br><span class="line">5      xorl  %eax, %eax        ; zero out register</span><br><span class="line">6      movq  %rsp, %rdi        ; compute buf as %rsp</span><br><span class="line">7      call  gets              ; call gets</span><br><span class="line">8      movq  %rsp, %rdi        ; compute buf as %rsp</span><br><span class="line">9      call  puts              ; call puts</span><br><span class="line">10     movq  8(%rsp), %rax     ; retrieve canary</span><br><span class="line">11     xorq  %fs:40, %rax      ; compare to stored value</span><br><span class="line">12     je    .L9               ; if =, goto ok</span><br><span class="line">13     call  __stack_chk_fail  ; stack corrupted</span><br><span class="line">14   .L9:</span><br><span class="line">15     addq  $24, %rsp         ; deallocate stack space</span><br><span class="line">16     ret</span><br></pre></td></tr></table></figure><p>函数从内存中读出一个值（汇编第三行），再把它存放在栈中相对于%rsp偏移量为8的地方。</p><p>指令参数%fs:40 指明金丝雀值是用段寻址(segmented addressing)从内存中读入的，段寻址机制可以追溯到80286的寻址，而现代系统上运行的程序中已经很少见到了。</p><p>将金丝雀值存放在一个特殊的段中，标志为只读，这样攻击者就不能覆盖存储的金丝雀值。在恢复寄存器状态和返回前，函数将存储在栈位置的值与金丝雀值做比较(汇编第十一行)。如果两个数相同，xorq指令就会得到0，函数会按照正常的方式完成。非零的值表明栈上的金丝雀值被修改过，那么代码就会调用一个错误处理函数。</p><p>栈保护很好的防止了缓冲区溢出攻击破坏存储在程序栈上的状态。它只会带来很小的性能损失，特别是因为GCC只在函数中有局部char类型缓冲区的时候才插入这样的代码。当然，也有其他一些方法会破坏一个正在执行的程序的状态，但是降低栈的易受攻击性能够对抗许多常见的攻击策略。</p><h4 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h4><p>最后一招是消除攻击者向系统中插入可执行代码的能力。</p><p>一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。虚拟内存空间在逻辑上被分成了页(page)，典型的每页是2048或者4096个字节。硬件支持多种形式的内存保护，能够指明用户程序和操作系统内核所允许的访问形式。<br>许多系统允许控制三种访问形式：读（从内存读数据）、写（存储数据到内存）和执行（将内存的内容看作机器级代码）。以前，x86体系结构将读和执行访问控制合并成一个1位的标志，这样任何被标记为可读的页也都是可执行的。栈必须是既可读又可写的，因而栈上的字节也都是可执行的。已经实现的很多机制，能够限制一些页是可读但不可执行的，然而这些机制通常会带来严重的性能损失。</p><p>AMD为它的64位处理器的内存保护引入了“NX”(No-Execute,不执行)位，将读和执行访问模式分开，Intel也跟进了。有了这个特性，栈可以被标记为可读可写，但是不可执行，而检查页是否可执行由硬件来完成，效率上没有损失。</p><p>有些类型的程序要求动态产生和执行代码的能力。例如，“即时(just-in-time)”编译技术为解释语言编写的程序动态的产生代码，以提高执行性能。是否能够将可执行代码限制在由编译器在创建原始程序产生的那个部分中，取决于语言和操作系统。</p><p>我们上面总结的这些技术——随机化、栈保护和限制哪部分内存可以存储可执行代码——是用于最小化程序缓冲区溢出攻击漏洞三种最常见的机制。它们都具有这样的属性，既不需要程序员做任何特殊的努力，带来的性能代价都非常小，甚至没有。单独每一种机制都降低了漏洞的等级，而组合起来，它们变得更加有效。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 数据对齐</title>
      <link href="/2018/11/19/04-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/"/>
      <url>/2018/11/19/04-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>许多计算机系统对基本数据类型的合法地址做出一个限制，要求某种类型对象的地址必须是某个值K（通常是2、4、8）的倍数。</p><span id="more"></span><p>这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。例如，假设一个处理器总是从内存中取8个字节，则地址必须为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中。</p><p>无论数据是否对齐，x86-64硬件都能正确的工作。不过，intel还是建议要对齐数据以提高内存系统的性能。对齐原则是任何K字节的基本对象的地址必须是K的倍数。可以看到这条原则会得到如下对齐：</p><table><thead><tr><th>K</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int,float</td></tr><tr><td>8</td><td>long,double,char *</td></tr></tbody></table><p>确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可保证实施对齐。要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC&#x2F;C++和GNU GCC中都是默认是4字节对齐。</p><p>编译器在汇报代码中放入命令，指明全局数据所需的对齐。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.align 8</span><br></pre></td></tr></table></figure><p>表示它后面的数据的起始地址是8的倍数。</p><h3 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h3><p>在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。</p><p>字节对齐的问题主要就是针对结构体。<br>对于包含结构体的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构体本身对它的起始地址也有一些对齐要求。</p><p>先看个简单的例子(32位，X86处理器，GCC编译器)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    int    a;</span><br><span class="line">    char   b;</span><br><span class="line">    short  c;</span><br><span class="line">&#125;;</span><br><span class="line">struct B&#123;</span><br><span class="line">    char   b;</span><br><span class="line">    int    a;</span><br><span class="line">    short  c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>已知32位机器上各数据类型的长度为：char为1字节、short为2字节、int为4字节、long为4字节、float为4字节、double为8字节。那么上面两个结构体大小如何呢？</p><p>结果是：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。 </p><p>结构体A中包含一个4字节的int数据，一个1字节char数据和一个2字节short数据；B也一样。按理说A和B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。</p><h4 id="结构体对齐的基本概念"><a href="#结构体对齐的基本概念" class="headerlink" title="结构体对齐的基本概念"></a>结构体对齐的基本概念</h4><ul><li><p>数据类型自身的对齐值：<br>char型数据自身对齐值为1字节，short型数据为2字节，int&#x2F;float型为4字节，double型为8字节。</p></li><li><p>结构体或类的自身对齐值：<br>其成员中自身对齐值最大的那个值。</p></li><li><p>指定对齐值：</p></li></ul><p>#pragma pack (value)时的指定对齐值value。</p><ul><li>数据成员、结构体和类的有效对齐值：<br>自身对齐值和指定对齐值中较小者，即有效对齐值&#x3D;min{自身对齐值，当前指定的pack值}。</li></ul><p>基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。</p><p>其中，有效对齐值N是最终用来决定数据存放地址方式的值。</p><p>有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N&#x3D;0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。</p><p>下面分析这个结构体定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct B&#123;</span><br><span class="line">    char   b;</span><br><span class="line">    int    a;</span><br><span class="line">    short  c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设B从地址空间0x0000开始存放，且指定对齐值默认为4(4字节对齐)。</p><p>成员变量b的自身对齐值是1，比默认指定对齐值4小，所以其有效对齐值为1，其存放地址0x0000符合0x0000%1&#x3D;0。</p><p>成员变量a自身对齐值为4，所以有效对齐值也为4，只能存放在起始地址为0x0004~0x0007四个连续的字节空间中，符合0x0004%4&#x3D;0且紧靠第一个变量。</p><p>变量c自身对齐值为2，所以有效对齐值也是2，可存放在0x0008<del>0x0009两个字节空间中，符合0x0008%2&#x3D;0。所以从0x0000</del>0x0009存放的都是B内容。</p><p>再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b)所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求， 0x0000<del>0x0009&#x3D;10字节，(10＋2)％4＝0。所以0x0000A</del>0x000B也为结构体B所占用。故B从0x0000到0x000B 共有12个字节，sizeof(struct B)&#x3D;12。</p><p>之所以编译器在后面补充2个字节，是为了实现结构数组的存取效率。试想如果定义一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢？按照数组的定义，数组中所有元素都紧挨着。如果我们不把结构体大小补充为4的整数倍，那么下一个结构的起始地址将是0x0000A，这显然不能满足结构的地址对齐。因此要把结构体补充成有效对齐大小的整数倍。其实对于char&#x2F;short&#x2F;int&#x2F;float&#x2F;double等已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知，所以他们的自身对齐值也就已知。</p><h4 id="结构体的对齐准则"><a href="#结构体的对齐准则" class="headerlink" title="结构体的对齐准则"></a>结构体的对齐准则</h4><p>结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：</p><ul><li>1.结构体变量的首地址能够被其最宽基本类型成员的大小所整除。</li><li>2.结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)。</li><li>3.结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。</li></ul><p>对于以上规则的说明如下：<br>第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。</p><p>第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</p><p>第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</p><h4 id="对齐的隐患"><a href="#对齐的隐患" class="headerlink" title="对齐的隐患"></a>对齐的隐患</h4><h5 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><p>代码中关于对齐的隐患，很多是隐式的。例如，在强制类型转换的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;  </span><br><span class="line">    unsigned int i = 0x12345678;</span><br><span class="line">        </span><br><span class="line">    unsigned char *p = (unsigned char *)&amp;i;</span><br><span class="line">    *p = 0x00;</span><br><span class="line">    unsigned short *p1 = (unsigned short *)(p+1);</span><br><span class="line">    *p1 = 0x0000;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在X86上，类似的操作只会影响效率；但在MIPS或者SPARC上可能导致error，因为它们要求必须字节对齐。</p><p>又如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct B&#123;</span><br><span class="line">    char   b;</span><br><span class="line">    int    a;</span><br><span class="line">    short  c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Func(struct B *p)&#123;</span><br><span class="line">    //Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数体内如果直接访问p-&gt;a，则很可能会异常。因为MIPS认为a是int，其地址应该是4的倍数，但p-&gt;a的地址很可能不是4的倍数。</p><p>如果p的地址不在对齐边界上就可能出问题，比如p来自一个跨CPU的数据包(多种数据类型的数据被按顺序放置在一个数据包中传输)，或p是经过指针移位算出来的。因此要特别注意跨CPU数据的接口函数对接口输入数据的处理，以及指针移位再强制转换为结构指针进行访问时的安全性。 </p><p>解决方式如下：</p><ul><li>1.定义一个此结构的局部变量，用memmove方式将数据拷贝进来。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Func(struct B *p)&#123;</span><br><span class="line">    struct B tData;</span><br><span class="line">    memmove(&amp;tData, p, sizeof(struct B));</span><br><span class="line">    //此后可安全访问tData.a，因为编译器已将tData分配在正确的起始地址上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：如果能确定p的起始地址没问题，则不需要这么处理；如果不能确定(比如跨CPU输入数据、或指针移位运算出来的数据要特别小心)，则需要这样处理。</li><li>2.用#pragma pack (1)将STRUCT_T定义为1字节对齐方式。</li></ul><h5 id="处理器间数据通信"><a href="#处理器间数据通信" class="headerlink" title="处理器间数据通信"></a>处理器间数据通信</h5><p>处理器间通过消息(对于C&#x2F;C++而言就是结构体)进行通信时，需要注意字节对齐以及字节序的问题。</p><p>大多数编译器提供内存对其的选项供用户使用。这样用户可以根据处理器的情况选择不同的字节对齐方式。例如C&#x2F;C++编译器提供的#pragma pack(n) n&#x3D;1，2，4等，让编译器在生成目标文件时，使内存数据按照指定的方式排布在1，2，4等字节整除的内存地址处。</p><p>然而在不同编译平台或处理器上，字节对齐会造成消息结构长度的变化。编译器为了使字节对齐可能会对消息结构体进行填充，不同编译平台可能填充为不同的形式，大大增加处理器间数据通信的风险。</p><p>下面以32位处理器为例，提出一种内存对齐方法以解决上述问题。</p><p>对于本地使用的数据结构，为提高内存访问效率，采用四字节对齐方式；同时为了减少内存的开销，合理安排结构体成员的位置，减少四字节对齐导致的成员之间的空隙，降低内存开销。</p><p>对于处理器之间的数据结构，需要保证消息长度不会因不同编译平台或处理器而导致消息结构体长度发生变化，使用一字节对齐方式对消息结构进行紧缩；为保证处理器之间的消息数据结构的内存访问效率，采用字节填充的方式<strong>自己</strong>对消息中成员进行四字节对齐。</p><p><strong>数据结构的成员位置要兼顾成员之间的关系、数据访问效率和空间利用率。顺序安排原则是：四字节的放在最前面，两字节的紧接最后一个四字节成员，一字节紧接最后一个两字节成员，填充字节放在最后。</strong></p><p>举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tag_T_MSG&#123;</span><br><span class="line">    long  ParaA;</span><br><span class="line">    long  ParaB;</span><br><span class="line">    short ParaC；</span><br><span class="line">    char  ParaD;</span><br><span class="line">    char  Pad;   //填充字节</span><br><span class="line">&#125;T_MSG;</span><br></pre></td></tr></table></figure><h4 id="排查对齐问题"><a href="#排查对齐问题" class="headerlink" title="排查对齐问题"></a>排查对齐问题</h4><p>如果出现对齐或者赋值问题可查看：</p><ul><li>1.编译器的字节序大小端设置；</li><li>2.处理器架构本身是否支持非对齐访问；</li><li>3.如果支持看设置对齐与否，如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。</li></ul><h4 id="更改对齐方式"><a href="#更改对齐方式" class="headerlink" title="更改对齐方式"></a>更改对齐方式</h4><p>主要是更改C编译器的缺省字节对齐方式。   </p><p>在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。<br>一般地，可以通过下面的方法来改变缺省的对界条件：</p><ul><li>使用伪指令#pragma pack(n)：<br>C编译器将按照n个字节对齐；</li><li>使用伪指令#pragma pack()：<br>取消自定义字节对齐方式。<br>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(2)  //指定按2字节对齐</span><br><span class="line">struct C&#123;</span><br><span class="line">    char  b;</span><br><span class="line">    int   a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack()   //取消指定对齐，恢复缺省对齐</span><br></pre></td></tr></table></figure></li></ul><p>另外，还有如下的一种方式(GCC特有语法)：</p><ul><li><p>__attribute((aligned (n)))：<br>让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。</p></li><li><p>__attribute__ ((packed))：<br>取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。</p></li></ul><p>示例，GNU GCC编译器中按1字节对齐可写为以下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define GNUC_PACKED __attribute__((packed))</span><br><span class="line">struct C&#123;</span><br><span class="line">    char  b;</span><br><span class="line">    int   a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;GNUC_PACKED;</span><br></pre></td></tr></table></figure><p>此时sizeof(struct C)的值为7。</p><p><strong>注意：在VC&#x2F;C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。</strong></p><h4 id="位域对齐"><a href="#位域对齐" class="headerlink" title="位域对齐"></a>位域对齐</h4><p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。为了节省存储空间和处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。</p><p>位域是一种特殊的结构成员或联合成员(即只能用在结构或联合中)，用于指定该成员在内存存储时所占用的位数，从而在机器内更紧凑地表示数据。每个位域有一个域名，允许在程序中按域名操作对应的位。这样就可用一个字节的二进制位域来表示几个不同的对象。</p><p>位域定义与结构定义类似，其形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体标签&#123;</span><br><span class="line">    类型说明符位域名:位域长度;</span><br><span class="line">&#125;结构体名;</span><br></pre></td></tr></table></figure><p>位域允许用各种格式输出。</p><p>位域在本质上就是一种结构类型，不过其成员是按二进位分配的。位域变量的说明与结构变量说明的方式相同，可先定义后说明、同时定义说明或直接说明。      </p><p>位域的使用主要为下面两种情况：</p><ul><li>1.当机器可用内存空间较少而使用位域可大量节省内存时。如把结构作为大数组的元素时。</li><li>2.当需要把一结构体或联合映射成某预定的组织结构时。如需要访问字节内的特定位时。</li></ul><h5 id="位域对齐准则"><a href="#位域对齐准则" class="headerlink" title="位域对齐准则"></a>位域对齐准则</h5><p>位域成员不能单独被取sizeof值。下面主要讨论含有位域的结构体的sizeof。 </p><p>C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。</p><p>其对齐规则大致为：</p><ul><li>1.如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li><li>2.如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</li><li>3.如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；</li><li>4.如果位域字段之间穿插着非位域字段，则不进行压缩；</li><li>5.整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。</li></ul><p>例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BitField&#123;</span><br><span class="line">    char element1  : 1;</span><br><span class="line">    char element2  : 4;</span><br><span class="line">    char element3  : 5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域类型为char，第1个字节仅能容纳下element1和element2，所以element1和element2被压缩到第1个字节中，而element3只能从下一个字节开始。因此sizeof(BitField)的结果为2。</p><p>例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BitField1&#123;</span><br><span class="line">    char element1   : 1;</span><br><span class="line">    short element2  : 5;</span><br><span class="line">    char element3   : 7;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。</p><p>例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BitField2&#123;</span><br><span class="line">    char element1  : 3;</span><br><span class="line">    char element2  ;</span><br><span class="line">    char element3  : 5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。</p><p>例4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct StructBitField&#123;</span><br><span class="line">    int element1   : 1;</span><br><span class="line">    int element2   : 5;</span><br><span class="line">    int element3   : 29;</span><br><span class="line">    int element4   : 6;</span><br><span class="line">    char element5  :2;</span><br><span class="line">    char stelement;  //在含位域的结构或联合中也可同时说明普通成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域中最宽类型int的字节数为4，因此结构体按4字节对齐，在VC6中其sizeof为16。</p><h5 id="位域操作注意事项"><a href="#位域操作注意事项" class="headerlink" title="位域操作注意事项"></a>位域操作注意事项</h5><p>关于位域操作有几点需要注意：</p><ul><li>1.位域的地址不能访问，因此不允许将&amp;运算符用于位域。不能使用指向位域的指针也不能使用位域的数组(数组是种特殊指针)。</li></ul><p>例如，scanf函数无法直接向位域中存储数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;  </span><br><span class="line">    struct BitField1 tBit;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;tBit.element2); //error: cannot take address of bit-field &#x27;element2&#x27;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用scanf函数将输入读入到一个普通的整型变量中，然后再赋值给tBit.element2。</p><ul><li>2.位域不能作为函数返回的结果。</li><li>3.位域以定义的类型为单位，且位域的长度不能够超过所定义类型的长度。例如定义int a:33是不允许的。</li><li>4.位域可以不指定位域名，但不能访问无名的位域。</li></ul><p>位域可以无位域名，只用作填充或调整位置，占位大小取决于该类型。例如，char :0表示整个位域向后推一个字节，即该无名位域后的下一个位域从下一个字节开始存放，同理short :0和int :0分别表示整个位域向后推两个和四个字节。</p><p>当空位域的长度为具体数值N时(如int :2)，该变量仅用来占位N位。<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BitField3&#123;</span><br><span class="line">    char element1  : 3;</span><br><span class="line">    char  :6;</span><br><span class="line">    char element3  : 5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小为3。因为element1占3位，后面要保留6位而char为8位，所以保留的6位只能放到第2个字节。同样element3只能放到第3字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct BitField4&#123;</span><br><span class="line">    char element1  : 3;</span><br><span class="line">    char  :0;</span><br><span class="line">    char element3  : 5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员element1分配3位，接着跳过余下的4位到下一个存储单元，然后给成员element3分配5位。故上面的结构体大小为2。</p><ul><li><p>5.位域的表示范围:<br>位域的赋值不能超过其可以表示的范围；<br>位域的类型决定该编码能表示的值的结果。<br>对于第二点，若位域为unsigned类型，则直接转化为正数；若非unsigned类型，则先判断最高位是否为1，若为1表示补码，则对其除符号位外的所有位取反再加一得到最后的结果数据(原码)。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 unsigned int p:3 = 111;   //p表示7</span><br><span class="line">2 int p:3 = 111;            //p 表示-1，对除符号位之外的所有位取反再加一</span><br></pre></td></tr></table></figure></li><li><p>6.带位域的结构在内存中各个位域的存储方式取决于编译器，既可从左到右也可从右到左存储。</p></li><li><p>7.位域的实现会因编译器的不同而不同，使用位域会影响程序可移植性。因此除非必要否则最好不要使用位域。</p></li><li><p>8.尽管使用位域可以节省内存空间，但却增加了处理时间。当访问各个位域成员时，需要把位域从它所在的字中分解出来或反过来把一值压缩存到位域所在的字位中。</p></li></ul><p>文章整理自：<br><a href="https://www.cnblogs.com/clover-toeic/p/3853132.html">C语言字节对齐问题详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 运行时栈</title>
      <link href="/2018/11/17/03-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88/"/>
      <url>/2018/11/17/03-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><span id="more"></span><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>C语言过程调用机制的一个关键特性在于使用了栈数据结构提供的后进先出的内存管理原则。在函数P调用函数Q中，当Q在执行时，P以及所有在向上追溯到P的调用链中的函数，都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个函数的调用。另一方面，当Q返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的函数所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。</p><p>x86-64的栈向低地址方向增长，栈指针%rsp指向栈顶元素。可以用pushq和popq指令将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似的，可以通过增加栈指针来释放空间。</p><p>当x86-64函数需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为函数的栈帧(stack fram)。通用的栈帧结构如下图所示：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88/%E9%80%9A%E7%94%A8%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.JPG" alt="通用栈帧结构"><br>当前正在执行的函数的帧总是在栈顶。当函数P调用函数Q时，会把返回地址压入栈中，指明当Q返回时，要从P的哪个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数函数的栈帧都是定长的，在函数的开始就分配好了。但是有些函数需要变长的帧，这个问题在后面讨论。通过寄存器，函数P可以传递最多6个整数值（也就是指针和整数），但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存好这些参数。</p><p>为了提高空间和时间效率，x86-64函数只分配自己所需要的栈帧部分。例如，许多函数有6个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，上图中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，就可以这样处理。</p><h4 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h4><p>将控制从函数P转移到函数Q只需要简单的把程序计数器(PC)设置为Q的代码的起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。在x86-64机器中，这个信息是用指令 call Q调用函数Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。</p><p>下表给出的是call和ret指令的一般形式：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>call Label</td><td>函数调用</td></tr><tr><td>call .Operand</td><td>函数调用</td></tr><tr><td>ret</td><td>从函数调用中返回</td></tr></tbody></table><p>call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是*后面跟一个操作数指示符。</p><h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>当调用一个函数时，除了要把控制传递给它并在过程返回时再传递回来外，函数调用还可能包括把数据作为参数传递，而从函数返回还有可能包括返回一个值。x86-64中，大部分函数间的数据传送是通过寄存器实现的。例如，参数在寄存器%rdi、%rsi和其他寄存器中传递。当函数P调用函数Q时，P的代码必须首先把参数复制到适当的寄存器中。类似的，当Q返回到P时，P的代码可以访问寄存器%rax中的返回值。</p><p>x86-64中，可以通过寄存器最多传递6个整型（例如整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小。如下表所示的传递函数参数的寄存器：</p><table><thead><tr><th>操作数大小(位)</th><th>参数1</th><th>参数2</th><th>参数3</th><th>参数4</th><th>参数5</th><th>参数6</th></tr></thead><tbody><tr><td>64</td><td>%rdi</td><td>%rsi</td><td>%rdx</td><td>%rcx%</td><td>%r8</td><td>%r9</td></tr><tr><td>32</td><td>%edi</td><td>%esi</td><td>%edx</td><td>%ecx</td><td>%r8d</td><td>%r9d</td></tr><tr><td>16</td><td>%di</td><td>%si</td><td>%dx</td><td>%cx</td><td>%r8w</td><td>%r9w</td></tr><tr><td>8</td><td>%dil</td><td>%sil</td><td>%dl</td><td>%cl</td><td>%r8b</td><td>%r9b</td></tr></tbody></table><p>如果一个函数有大于6个整型参数，超过6个的部分就要通过栈来传递。假设函数P调用函数Q，有n个整型参数，且n&gt;6。那么P的代码分配的栈帧必须要能容纳7到n号参数的存储空间，如下图所示：<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88/%E9%80%9A%E7%94%A8%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.JPG" alt="通用栈帧结构"><br>要把参数1-6复制到对应的寄存器，把参数7-n放到栈上，而参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位以后，程序就可以执行call指令将控制转移到函数Q了。函数Q可以通过寄存器访问参数，有必要的话也可以通过栈访问。相应的，如果Q也调用了某个有超过6个参数的函数，它也需要在自己的栈帧中为超出6个部分的参数分配空间，如上图中标号为”参数构造区“的区域所示。</p><p>参数传递示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void proc(long a1,long *a1p,int a2,int *a2p,short a3,short *a3p,char a4,char *a4p)&#123;</span><br><span class="line">    *a1p += a1;</span><br><span class="line">    *a2p += a2;</span><br><span class="line">    *a3p += a3;</span><br><span class="line">    *a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line">//该函数有8个参数，包括字节数不同的整数(8,4,2,1)和不同类型的指针(每个都是8字节的)</span><br><span class="line">//参数传递：</span><br><span class="line">//a1  in %rdi     (64 bits)</span><br><span class="line">//a1p in %rsi     (64 bits)</span><br><span class="line">//a2  in %edx     (32 bits)</span><br><span class="line">//a2p in %rcx     (64 bits)</span><br><span class="line">//a3  in %r8w     (16 bits)</span><br><span class="line">//a3p in %r9      (64 bits)</span><br><span class="line">//a4  at %rsp+8   (8  bits)</span><br><span class="line">//a4p at %rsp+16  (64 bits)</span><br><span class="line"></span><br><span class="line">生成的汇编代码：</span><br><span class="line">proc:</span><br><span class="line">    movq 16(%rsp), %rax   ; fetch a4p    (64 bits)</span><br><span class="line">    addq %rdi, (%rsi)     ; *a1p += a1   (64 bits)</span><br><span class="line">    addl %edx, (%rcx)     ; *a2p += a2   (32 bits)</span><br><span class="line">    addw %r8w, (%r9)      ; *a3p += a3   (16 bits)</span><br><span class="line">    movl 8(%rsp), %edx    ; fetch a4     (8  bits)   从内存读入4个字节</span><br><span class="line">    addb %dl, (%rax)      ; *a4p += a4   (8  bits)   只用其中的低位一字节</span><br><span class="line">    ret                   ; return</span><br></pre></td></tr></table></figure><p>从上面的例子可以看到，前面6个参数通过寄存器传递，后面2个通过栈传递。作为过程调用的一部分，返回地址被压入栈中，因而这两个参数位于相对于栈指针距离为8和16的位置。</p><p>在汇编代码中，我们可以看到根据操作数的大小，使用了add指令的不同版本：long使用addq，int使用addl，short使用addw，而char使用addb。</p><h4 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h4><p>一些函数运行时不需要超出寄存器大小的本地存储区域，而另外一些函数局部数据必须放在内存中，常见的情况包括：</p><ul><li>寄存器不足够存放所有的本地数据。</li><li>对一个局部变量使用地址运算符&amp;，因此必须能够为它产生一个地址。</li><li>某些局部变量是数组或结构体，因此必须能够通过数组或结构体引用被访问到。</li></ul><p>一般来说，函数通过减小指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为”局部变量“。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//交换指针xp和yp的值，并返回这两个值的和。</span><br><span class="line">long swap_add(long *xp, long *yp)&#123;</span><br><span class="line">    long x = *xp;</span><br><span class="line">    long y = *yp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    *yp = x;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long caller()&#123;</span><br><span class="line">    long arg1 = 534;</span><br><span class="line">    long arg2 = 1057;</span><br><span class="line">    long sum = swap_add(&amp;arg1,&amp;arg2);</span><br><span class="line">    long diff = arg1 - arg2;</span><br><span class="line">    return sum * diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">caller生成的汇编代码：</span><br><span class="line">1    caller:</span><br><span class="line">2        subq  $16, %rsp      ; allocate 16 bytes for stack frame</span><br><span class="line">3        movq  $534, (%rsp)   ; store 534 in arg1</span><br><span class="line">4        movq  $1057, 8(%rsp) ; store 1057 in arg2</span><br><span class="line">5        leaq  8(%rsp), %rsi  ; compute &amp;arg2 as second argument</span><br><span class="line">6        movq  %rsp, %rdi     ; compute &amp;arg1 as first argument</span><br><span class="line">7        call  swap_add       ; call swap_add(&amp;arg1,&amp;arg2)</span><br><span class="line">8        movq  (%rsp), %rdx   ; get arg1</span><br><span class="line">9        subq  8(%rsp), %rdx  ; compute diff = arg1 -arg2</span><br><span class="line">10       imulq %rdx, %rax     ; compute sum * diff</span><br><span class="line">11       addq  $16, %rsp      ; deallocate stack frame</span><br><span class="line">12       ret                  ;  return</span><br></pre></td></tr></table></figure><p>从上面的例子可以看到：<br>1.caller代码开始的时候把栈指针减掉了16；实际上这就是在栈上分配了16个字节。<br>2.局部变量arg1和arg2存放在栈帧中相对于栈指针的偏移量为0和8（汇编第3-4行）。<br>3.当对swap_add的调用完成后，caller的代码会从栈上取出这两个值，计算它们的差（汇编第8-9行），再乘以swap_add在寄存器%rax中返回的值（汇编第10行）。<br>4.最后，该函数把栈指针加16，释放栈帧（第11行）。</p><p>通过这个例子可以看到，运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。</p><h4 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h4><p>寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个函数是活动的，我们仍然必须确保当一个函数调用另外一个函数时，被调用者不会覆盖调用者稍后会使用的寄存器值。</p><p>为此，x86-64采用了一组统一的寄存器使用惯例，所有的函数包括程序库都必须遵循。</p><p>根据惯例，寄存器%rbx、%rbp和%r12-%r15被划分为被调用者保存寄存器。当函数P调用函数Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。</p><p>过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为”保存的寄存器“的一部分。</p><p>有了这条惯例，P的代码就能安全的把值存在被调用者保存寄存器中，调用Q，然后继续使用寄存器中的值，不必担心值被破坏。</p><p>所有其他的寄存器，除了栈指针%rsp，都分类为调用者保存寄存器。者就意味着任何函数都能修改它们。可以这样来理解”调用者保存“这个名字：函数P在某个此类寄存器中有局部数据，然后调用函数Q。因为Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P(调用者)的责任。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">long P(long x, long y)&#123;</span><br><span class="line">    long u = Q(y);</span><br><span class="line">    long v = Q(x);</span><br><span class="line">    return u + v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">汇编代码：</span><br><span class="line">； x in %rdi , y in %rsi</span><br><span class="line">1    P:</span><br><span class="line">2        pushq   %rbp       ; save %rbp</span><br><span class="line">3        pushq   %rbx       ; save %rbx</span><br><span class="line">4        subq    $8, %rsp   ; align stack frame</span><br><span class="line">5        movq    %rdi, %rbp ; save x</span><br><span class="line">6        movq    %rsi, %rdi ; move y to first argument</span><br><span class="line">7        call    Q          ; call Q(y)</span><br><span class="line">8        movq    %rax, %rbx ; save result</span><br><span class="line">9        movq    %rbp, %rdi ; move x to first argument</span><br><span class="line">10       call    Q          ; call Q(x)</span><br><span class="line">11       addq    %rbx, %rax ; add saved Q(y) to Q(x)</span><br><span class="line">12       addq    $8, %rsp   ; deallocated last part of stack</span><br><span class="line">13       popq    %rbx       ; restore %rbx</span><br><span class="line">14       popq    %rbp       ; restore %rbp</span><br><span class="line">15       ret</span><br></pre></td></tr></table></figure><p>从上面的例子可以看到：<br>1.函数P两次调用Q，在第一次调用中，必须保存x的值以备后面使用。<br>2.类似的，在第二次调用中，也必须保存Q(y)的值。<br>3.汇编代码使用了两个被调用者保存寄存器：%rbp保存x，%rbx保存Q(y)的值。<br>4.在函数的开头，把这两个寄存器的值保存到栈中（汇编第2-3行）。<br>5.在第一次调用Q之前，把参数x复制到%rbp（汇编第5行）。<br>6.在第二次调用Q之前，把Q(y)结果复制到%rbx （汇编第8行）<br>7.在函数的结尾，把%rbx、%rbp从栈中弹出，恢复这两个被调用者保护寄存器的值。注意它们的弹出顺序与压入顺序相反，说明了栈的后进先出规则。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 并发和并行</title>
      <link href="/2018/11/16/02-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/"/>
      <url>/2018/11/16/02-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想计算机做的更多，另一个是我们想计算机运行的更快。当处理器能够同时做更多的事情时，这两个因素都会改进。</p><span id="more"></span><p>术语 **并发(concurrency)**是一个通用的概念，指一个同时具有多个活动的系统；<br>而术语 **并行(parallelism)**指的是用并发来使一个系统运行的更快。<br>并行可以在计算机系统的多个抽象层次上运用。<br>在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。</p><h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，这种并发形式允许多个用户同时与系统交互。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为<strong>单处理器系统</strong>。<br>当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个<strong>多处理器系统</strong>。<br>多核处理器是将多个CPU（称为核）集成到一个集成电路芯片上。下图描述的是一个典型多核处理器的组织结构<br>，其中微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中的L1高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/02_%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.JPG" alt="多核处理器的组织结构"><br>超线程，有时称为<strong>同时多线程(simultaneous multi-threading)</strong>,是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好的利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。</p><p>多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行的更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行的高效执行。</p><h4 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h4><p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。其实每条指令从开始到结束需要长的多的时间，大约20个或者更多周期，但是处理器使用了非常多的技巧来同时处理多达100条指令。在流水线的使用中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并发的操作，用来处理不同指令的不同部分。</p><p>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。大多数现代处理器都支持超标量操作。</p><h4 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h4><p>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMID并行。例如，较新几代的Intel和AMD处理器都具有并行的对8对单精度浮点数做加法的指令。</p><p>提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C程序中自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。</p><h3 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h3><p>抽象的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如JAVA类的声明和C语言的函数原型。</p><p>在处理器里，指令集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一次只执行一条指令得处理器上。底层得硬件远比抽象描述得要复杂精细，它并行的执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/02_%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1.JPG" alt="计算机系统提供的一些抽象"></p><ul><li>文件是对I&#x2F;O设备的抽象</li><li>虚拟内存是对程序存储器的抽象</li><li>进程是对一个正在运行的程序的抽象</li><li>虚拟机是对整个计算机的抽象</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Little Kernel 06</title>
      <link href="/2018/11/16/Little-Kernel-06/"/>
      <url>/2018/11/16/Little-Kernel-06/</url>
      
        <content type="html"><![CDATA[<h3 id="lk启动汇编部分"><a href="#lk启动汇编部分" class="headerlink" title="lk启动汇编部分"></a>lk启动汇编部分</h3><span id="more"></span><h4 id="arm-汇编简单介绍"><a href="#arm-汇编简单介绍" class="headerlink" title="arm 汇编简单介绍"></a>arm 汇编简单介绍</h4><h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b:  用于不返回的跳转，比如跳到某个标号处，b  .  </span><br><span class="line">        其中的‘.’代表当前地址，那么 b  .  就是死循环。</span><br><span class="line">bl: 用于子程序跳转，要返回地址，返回地址存于LR中。</span><br><span class="line">        当发生bl跳转前，会在寄存器 R14 （即LR）中保存当前PC-4，即bl跳转指令的下一条指令的地址。</span><br><span class="line">        所以在返回时只要 MOV pc,lr 。</span><br><span class="line">pc: 正在执行的代码地址</span><br></pre></td></tr></table></figure><h5 id="MRC-MCR指令"><a href="#MRC-MCR指令" class="headerlink" title="MRC&#x2F;MCR指令:"></a>MRC&#x2F;MCR指令:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mrc p15, 0, r0, c1, c0&#123;, 0&#125;     ；将 CP15 的寄存器 C1 的值读到 r0 中</span><br><span class="line">mcr p15, 0, r0, c1, c0&#123;, 0&#125;     ；将 r0 的值写到 CP15 的寄存器 C1 中</span><br></pre></td></tr></table></figure><h5 id="MRS-MSR"><a href="#MRS-MSR" class="headerlink" title="MRS&#x2F;MSR:"></a>MRS&#x2F;MSR:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS： 程序状态寄存器到通用寄存器的数据传送指令</span><br><span class="line">MSR： 通用寄存器到程序状态寄存器的数据传送指令</span><br></pre></td></tr></table></figure><h5 id="CP15-中的寄存器-C1-的编码格式及含义说明如下："><a href="#CP15-中的寄存器-C1-的编码格式及含义说明如下：" class="headerlink" title="CP15 中的寄存器 C1 的编码格式及含义说明如下："></a>CP15 中的寄存器 C1 的编码格式及含义说明如下：</h5><p>C1中的控制位含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">M（bit[0]）</span><br><span class="line">0 ：禁止 MMU 或者 PU</span><br><span class="line">1 ：使能 MMU 或者 PU</span><br><span class="line"></span><br><span class="line">A（bit[1]）</span><br><span class="line">0 ：禁止地址对齐检查</span><br><span class="line">1 ：使能地址对齐检查</span><br><span class="line"></span><br><span class="line">C（bit[2]）</span><br><span class="line">当数据cache和指令cache分开时，本控制位禁止/使能数据cache。当数据cache和指令cache统一时，该控制位禁止/使能整个cache。</span><br><span class="line">0 ：禁止数据 / 整个 cache</span><br><span class="line">1 ：使能数据 / 整个 cache</span><br><span class="line"></span><br><span class="line">W（bit[3]）</span><br><span class="line">0 ：禁止写缓冲</span><br><span class="line">1 ：使能写缓冲</span><br><span class="line"></span><br><span class="line">P（bit[4]）</span><br><span class="line">0 ：异常中断处理程序进入 32 位地址模式</span><br><span class="line">1 ：异常中断处理程序进入26 位地址模式</span><br><span class="line"></span><br><span class="line">D（bit[5]）</span><br><span class="line">0 ：禁止 26 位地址异常检查</span><br><span class="line">1 ：使能 26 位地址异常检查</span><br><span class="line"></span><br><span class="line">L（bit[6]）</span><br><span class="line">0 ：选择早期中止模型</span><br><span class="line">1 ：选择后期中止模型</span><br><span class="line"></span><br><span class="line">B（bit[7]）</span><br><span class="line">0 ： little endian </span><br><span class="line">1 ： big endian</span><br><span class="line"></span><br><span class="line">S（bit[8]）</span><br><span class="line">在基于 MMU 的存储系统中，本位用作系统保护</span><br><span class="line"></span><br><span class="line">R（bit[9]）</span><br><span class="line">在基于 MMU 的存储系统中，本位用作 ROM 保护</span><br><span class="line"></span><br><span class="line">F（bit[10]）</span><br><span class="line">由生产商定义</span><br><span class="line"></span><br><span class="line">Z（bit[11]）</span><br><span class="line">0 ：禁止跳转预测功能</span><br><span class="line">1 ：使能跳转预测功能</span><br><span class="line"></span><br><span class="line">I（bit[12]）</span><br><span class="line">当数据cache和指令cache是分开的，本控制位禁止/使能指令cache</span><br><span class="line">0 ：禁止指令 cache </span><br><span class="line">1 ：使能指令 cache</span><br><span class="line"></span><br><span class="line">V（bit[13]）</span><br><span class="line">0 ：选择低端异常中断向量 0x0~0x1c</span><br><span class="line">1 ：选择高端异常中断向量0xffff0000~ 0xffff001c</span><br><span class="line"></span><br><span class="line">PR（bit[14]）</span><br><span class="line">0 ：常规的 cache 淘汰算法，如随机淘汰</span><br><span class="line">1 ：预测性淘汰算法，如round-robin 淘汰算法</span><br><span class="line"></span><br><span class="line">L4（bit[15]）</span><br><span class="line">0 ：保持 ARMv5 以上版本的正常功能</span><br><span class="line">1 ：将 ARMv5 以上版本与以前版本处理器兼容，不根据跳转地址的 bit[0] 进行 ARM 指令和 Thumb 状态切换： bit[0] 等于 0 表示 ARM 指令，等于 1 表示 Thumb 指令</span><br><span class="line"></span><br><span class="line">Bits[31:16]）</span><br><span class="line">保留将来使用</span><br></pre></td></tr></table></figure><h5 id="CPSR-当前程序状态寄存器"><a href="#CPSR-当前程序状态寄存器" class="headerlink" title="CPSR 当前程序状态寄存器"></a>CPSR 当前程序状态寄存器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bit32</span><br><span class="line">bit[31：24]为条件标志位域，用f 表示；</span><br><span class="line">bit[23：16]为状态位域，用s 表示；</span><br><span class="line">bit[15：8]为扩展位域，用x 表示；</span><br><span class="line">bit[7：0]为控制位域，用c 表示；</span><br><span class="line"></span><br><span class="line">运行模式位[4-0]</span><br><span class="line"> 0b10000 用户模式user</span><br><span class="line"> 0b10001 FIQ模式</span><br><span class="line"> 0b10010 IRQ模式</span><br><span class="line"> 0b10011 管理模式</span><br><span class="line"> 0b10111 终止模式Abort</span><br><span class="line"> 0b11011 未定义模式</span><br><span class="line"> 0b11111 系统模式</span><br><span class="line">IFT[7-5],I=1禁止IRQ,F=1禁止FIQ,T=1执行thumb指令</span><br><span class="line"></span><br><span class="line">[27-8]保留</span><br><span class="line"></span><br><span class="line">NZCV[31-28]</span><br><span class="line">N-(负)标志,N=1表示运算结果为负数,N=0表示运算结果为正数或零</span><br><span class="line">Z-(零)标志,Z=1表示运算结果为零，Z=0表示运算结果为非零</span><br><span class="line">C-(进位)标志</span><br><span class="line">V-(溢出)标志</span><br></pre></td></tr></table></figure><h4 id="lk-arch-arm-arm-start-S"><a href="#lk-arch-arm-arm-start-S" class="headerlink" title="lk&#x2F;arch&#x2F;arm&#x2F;arm&#x2F;start.S"></a>lk&#x2F;arch&#x2F;arm&#x2F;arm&#x2F;start.S</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;asm.h&gt;</span><br><span class="line">#include &lt;arch/arm/cores.h&gt;</span><br><span class="line">#include &lt;arch/arm/mmu.h&gt;</span><br><span class="line">#include &lt;kernel/vm.h&gt;</span><br><span class="line"></span><br><span class="line">.section &quot;.text.boot&quot;</span><br><span class="line">.globl _start    // 声明全局符号_start</span><br><span class="line">_start:</span><br><span class="line">    b   platform_reset</span><br><span class="line">    b   arm_undefined</span><br><span class="line">    b   arm_syscall</span><br><span class="line">    b   arm_prefetch_abort</span><br><span class="line">    b   arm_data_abort</span><br><span class="line">    b   arm_reserved</span><br><span class="line">    b   arm_irq</span><br><span class="line">    b   arm_fiq</span><br><span class="line">#if WITH_SMP</span><br><span class="line">    b   arm_reset</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">.weak platform_reset</span><br><span class="line">platform_reset:</span><br><span class="line">    /* Fall through for the weak symbol */</span><br><span class="line"></span><br><span class="line">.globl arm_reset</span><br><span class="line">arm_reset:</span><br><span class="line">    /* do some early cpu setup */</span><br><span class="line">    mrc     p15, 0, r12, c1, c0, 0</span><br><span class="line">    /* i/d cache disable, mmu disabled */</span><br><span class="line">    bic     r12, #(1&lt;&lt;12)</span><br><span class="line">    bic     r12, #(1&lt;&lt;2 | 1&lt;&lt;0)</span><br><span class="line">#if WITH_KERNEL_VM</span><br><span class="line">    /* enable caches so atomics and spinlocks work */</span><br><span class="line">    orr     r12, r12, #(1&lt;&lt;12)</span><br><span class="line">    orr     r12, r12, #(1&lt;&lt;2)</span><br><span class="line">#endif // WITH_KERNEL_VM</span><br><span class="line">    mcr     p15, 0, r12, c1, c0, 0</span><br><span class="line"></span><br><span class="line">    /* calculate the physical offset from our eventual virtual location */</span><br><span class="line">.Lphys_offset:</span><br><span class="line">    ldr     r4, =.Lphys_offset</span><br><span class="line">    adr     r11, .Lphys_offset</span><br><span class="line">    sub     r11, r11, r4</span><br><span class="line"></span><br><span class="line">#if WITH_SMP</span><br><span class="line">    /* figure out our cpu number */</span><br><span class="line">    mrc     p15, 0, r12, c0, c0, 5 /* read MPIDR */</span><br><span class="line"></span><br><span class="line">    /* mask off the bottom bits to test cluster number:cpu number */</span><br><span class="line">    ubfx    r12, r12, #0, #SMP_CPU_ID_BITS</span><br><span class="line"></span><br><span class="line">    /* if we&#x27;re not cpu 0:0, fall into a trap and wait */</span><br><span class="line">    teq     r12, #0</span><br><span class="line">    movne   r0, r12</span><br><span class="line">    bne     arm_secondary_setup</span><br><span class="line">#endif // WITH_SMP</span><br><span class="line"></span><br><span class="line">#if WITH_CPU_EARLY_INIT</span><br><span class="line">    /* call platform/arch/etc specific init code */</span><br><span class="line">    bl      __cpu_early_init</span><br><span class="line">#endif // WITH_CPU_EARLY_INIT</span><br><span class="line"></span><br><span class="line">#if WITH_NO_PHYS_RELOCATION</span><br><span class="line">    /* assume that image is properly loaded in physical memory */</span><br><span class="line">#else</span><br><span class="line">    /* see if we need to relocate to our proper location in physical memory */</span><br><span class="line">    adr     r4, _start                           /* this emits sub r4, pc, #constant */</span><br><span class="line">    ldr     r5, =(MEMBASE + KERNEL_LOAD_OFFSET)  /* calculate the binary&#x27;s physical load address */</span><br><span class="line">    subs    r12, r4, r5                          /* calculate the delta between where we&#x27;re loaded and the proper spot */</span><br><span class="line">    beq     .Lrelocate_done</span><br><span class="line"></span><br><span class="line">    /* we need to relocate ourselves to the proper spot */</span><br><span class="line">    ldr     r6, =__data_end</span><br><span class="line">    ldr     r7, =(KERNEL_BASE - MEMBASE)</span><br><span class="line">    sub     r6, r7</span><br><span class="line">    add     r6, r12</span><br><span class="line"></span><br><span class="line">.Lrelocate_loop:             // 进行循环拷贝，将代码段拷贝到代码地址处</span><br><span class="line">    ldr     r7, [r4], #4</span><br><span class="line">    str     r7, [r5], #4</span><br><span class="line">    cmp     r4, r6           // 判断拷贝是否完成</span><br><span class="line">    bne     .Lrelocate_loop</span><br><span class="line"></span><br><span class="line">    /* we&#x27;re relocated, jump to the right address */</span><br><span class="line">    sub     pc, r12</span><br><span class="line">    nop     /* skipped in the add to pc */</span><br><span class="line"></span><br><span class="line">    /* recalculate the physical offset */</span><br><span class="line">    sub     r11, r11, r12</span><br><span class="line"></span><br><span class="line">.Lrelocate_done:</span><br><span class="line">#endif // !WITH_NO_PHYS_RELOCATION</span><br><span class="line"></span><br><span class="line">#if ARM_WITH_MMU</span><br><span class="line">.Lsetup_mmu:</span><br><span class="line"></span><br><span class="line">    /* set up the mmu according to mmu_initial_mappings */</span><br><span class="line"></span><br><span class="line">    /* load the base of the translation table and clear the table */</span><br><span class="line">    ldr     r4, =arm_kernel_translation_table</span><br><span class="line">    add     r4, r4, r11</span><br><span class="line">        /* r4 = physical address of translation table */</span><br><span class="line"></span><br><span class="line">    mov     r5, #0</span><br><span class="line">    mov     r6, #0</span><br><span class="line"></span><br><span class="line">    /* walk through all the entries in the translation table, setting them up */</span><br><span class="line">0:</span><br><span class="line">    str     r5, [r4, r6, lsl #2]</span><br><span class="line">    add     r6, #1</span><br><span class="line">    cmp     r6, #4096</span><br><span class="line">    bne     0b</span><br><span class="line"></span><br><span class="line">    /* load the address of the mmu_initial_mappings table and start processing */</span><br><span class="line">    ldr     r5, =mmu_initial_mappings</span><br><span class="line">    add     r5, r5, r11</span><br><span class="line">        /* r5 = physical address of mmu initial mapping table */</span><br><span class="line"></span><br><span class="line">.Linitial_mapping_loop:</span><br><span class="line">    ldmia   r5!, &#123; r6-r10 &#125;</span><br><span class="line">        /* r6 = phys, r7 = virt, r8 = size, r9 = flags, r10 = name */</span><br><span class="line"></span><br><span class="line">    /* round size up to 1MB alignment */</span><br><span class="line">    ubfx        r10, r6, #0, #20</span><br><span class="line">    add     r8, r8, r10</span><br><span class="line">    add     r8, r8, #(1 &lt;&lt; 20)</span><br><span class="line">    sub     r8, r8, #1</span><br><span class="line"></span><br><span class="line">    /* mask all the addresses and sizes to 1MB boundaries */</span><br><span class="line">    lsr     r6, #20  /* r6 = physical address / 1MB */</span><br><span class="line">    lsr     r7, #20  /* r7 = virtual address / 1MB */</span><br><span class="line">    lsr     r8, #20  /* r8 = size in 1MB chunks */</span><br><span class="line"></span><br><span class="line">    /* if size == 0, end of list */</span><br><span class="line">    cmp     r8, #0</span><br><span class="line">    beq     .Linitial_mapping_done</span><br><span class="line"></span><br><span class="line">    /* set up the flags */</span><br><span class="line">    ldr     r10, =MMU_KERNEL_L1_PTE_FLAGS</span><br><span class="line">    teq     r9, #MMU_INITIAL_MAPPING_FLAG_UNCACHED</span><br><span class="line">    ldreq   r10, =MMU_INITIAL_MAP_STRONGLY_ORDERED</span><br><span class="line">    beq     0f</span><br><span class="line">    teq     r9, #MMU_INITIAL_MAPPING_FLAG_DEVICE</span><br><span class="line">    ldreq   r10, =MMU_INITIAL_MAP_DEVICE</span><br><span class="line">        /* r10 = mmu entry flags */</span><br><span class="line"></span><br><span class="line">0:</span><br><span class="line">    orr     r12, r10, r6, lsl #20</span><br><span class="line">        /* r12 = phys addr | flags */</span><br><span class="line"></span><br><span class="line">    /* store into appropriate translation table entry */</span><br><span class="line">    str     r12, [r4, r7, lsl #2]</span><br><span class="line"></span><br><span class="line">    /* loop until we&#x27;re done */</span><br><span class="line">    add     r6, #1</span><br><span class="line">    add     r7, #1</span><br><span class="line">    subs    r8, #1</span><br><span class="line">    bne     0b</span><br><span class="line"></span><br><span class="line">    b       .Linitial_mapping_loop</span><br><span class="line"></span><br><span class="line">.Linitial_mapping_done:</span><br><span class="line"></span><br><span class="line">#if MMU_WITH_TRAMPOLINE</span><br><span class="line">    /* move arm_kernel_translation_table address to r8 and</span><br><span class="line">     * set cacheable attributes on translation walk</span><br><span class="line">     */</span><br><span class="line">    orr     r8, r4, #MMU_TTBRx_FLAGS</span><br><span class="line"></span><br><span class="line">    /* Prepare tt_trampoline page table */</span><br><span class="line">    /* Calculate pagetable physical addresses */</span><br><span class="line">    ldr     r4, =tt_trampoline  /* r4 = tt_trampoline vaddr */</span><br><span class="line">    add     r4, r4, r11     /* r4 = tt_trampoline paddr */</span><br><span class="line"></span><br><span class="line">    /* Zero tt_trampoline translation tables */</span><br><span class="line">    mov     r6, #0</span><br><span class="line">    mov     r7, #0</span><br><span class="line">1:</span><br><span class="line">    str     r7, [r4, r6, lsl#2]</span><br><span class="line">    add     r6, #1</span><br><span class="line">    cmp     r6, #0x1000</span><br><span class="line">    blt     1b</span><br><span class="line"></span><br><span class="line">    /* Setup 1M section mapping at</span><br><span class="line">     * phys  -&gt; phys   and</span><br><span class="line">     * virt  -&gt; phys</span><br><span class="line">     */</span><br><span class="line">    lsr     r6, pc, #20     /* r6 = paddr index */</span><br><span class="line">    ldr     r7, =MMU_KERNEL_L1_PTE_FLAGS</span><br><span class="line">    add     r7, r7, r6, lsl #20 /* r7 = pt entry */</span><br><span class="line"></span><br><span class="line">    str     r7, [r4, r6, lsl #2]    /* tt_trampoline[paddr index] = pt entry */</span><br><span class="line"></span><br><span class="line">    rsb     r6, r11, r6, lsl #20    /* r6 = vaddr */</span><br><span class="line">    str     r7, [r4, r6, lsr #(20 - 2)] /* tt_trampoline[vaddr index] = pt entry */</span><br><span class="line">#endif // MMU_WITH_TRAMPOLINE</span><br><span class="line"></span><br><span class="line">    /* set up the mmu */</span><br><span class="line">    bl      .Lmmu_setup</span><br><span class="line">#endif // WITH_KERNEL_VM</span><br><span class="line"></span><br><span class="line">    /* at this point we&#x27;re running at our final location in virtual memory (if enabled) */</span><br><span class="line">.Lstack_setup:</span><br><span class="line">    /* set up the stack for irq, fiq, abort, undefined, system/user, and lastly supervisor mode */</span><br><span class="line">    mov     r12, #0</span><br><span class="line"></span><br><span class="line">    cpsid   i,#0x12       /* irq */</span><br><span class="line">    mov     sp, r12</span><br><span class="line"></span><br><span class="line">    cpsid   i,#0x11       /* fiq */</span><br><span class="line">    mov     sp, r12</span><br><span class="line"></span><br><span class="line">    cpsid   i,#0x17       /* abort */</span><br><span class="line">    mov     sp, r12</span><br><span class="line"></span><br><span class="line">    cpsid   i,#0x1b       /* undefined */</span><br><span class="line">    mov     sp, r12</span><br><span class="line"></span><br><span class="line">    cpsid   i,#0x1f       /* system */</span><br><span class="line">    mov     sp, r12</span><br><span class="line"></span><br><span class="line">    cpsid   i,#0x13       /* supervisor */</span><br><span class="line">    ldr     r12, =abort_stack</span><br><span class="line">    add     r12, #ARCH_DEFAULT_STACK_SIZE</span><br><span class="line">    mov     sp, r12</span><br><span class="line"></span><br><span class="line">    /* stay in supervisor mode from now on out */</span><br><span class="line"></span><br><span class="line">    /* copy the initialized data segment out of rom if necessary */</span><br><span class="line">    ldr     r4, =__data_start_rom</span><br><span class="line">    ldr     r5, =__data_start</span><br><span class="line">    ldr     r6, =__data_end</span><br><span class="line"></span><br><span class="line">    cmp     r4, r5</span><br><span class="line">    beq     .L__do_bss</span><br><span class="line"></span><br><span class="line">.L__copy_loop:</span><br><span class="line">    cmp     r5, r6</span><br><span class="line">    ldrlt   r7, [r4], #4</span><br><span class="line">    strlt   r7, [r5], #4</span><br><span class="line">    blt     .L__copy_loop</span><br><span class="line"></span><br><span class="line">.L__do_bss:</span><br><span class="line">#if FOR_VERIFICATION_DONT_CLEAR_BSS == 0</span><br><span class="line">    /* clear out the bss */</span><br><span class="line">    ldr     r4, =__bss_start</span><br><span class="line">    ldr     r5, =_end</span><br><span class="line">    mov     r6, #0</span><br><span class="line">.L__bss_loop:</span><br><span class="line">    cmp     r4, r5</span><br><span class="line">    strlt   r6, [r4], #4</span><br><span class="line">    blt     .L__bss_loop</span><br><span class="line">#endif</span><br><span class="line">#if FOR_VERIFICATION == 1</span><br><span class="line">    mov r0, #0</span><br><span class="line">    mov r1, #0</span><br><span class="line">    mov r2, #0</span><br><span class="line">    mov r3, #0</span><br><span class="line">#endif</span><br><span class="line">    bl      lk_main</span><br><span class="line">    b       .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Little Kernel 05</title>
      <link href="/2018/11/15/Little-Kernel-05/"/>
      <url>/2018/11/15/Little-Kernel-05/</url>
      
        <content type="html"><![CDATA[<h3 id="kernel-hooks"><a href="#kernel-hooks" class="headerlink" title="kernel hooks"></a>kernel hooks</h3><p>The Kernel Hooks Interface is a generalised facility for placing hooks in arbitrary kernel locations. </p><span id="more"></span><p>A hook is a location in the kernel that calls out of the kernel to a kernel module routine - a hook exit routine. It enables many kernel enhancements, which are otherwise self-contained, to become loadable kernel modules and retain a substantial degree of independence from the kernel source.</p><p>Hooks are implemented as fast and slim-line insertions to kernel space code. When not active that have practically no overhead to the kernel.</p><h3 id="LK-init-hook"><a href="#LK-init-hook" class="headerlink" title="LK init hook"></a>LK init hook</h3><p>在lk&#x2F;top下除了main.c文件外还有一个init.c，实现了init hook功能。下面解析一下代码。</p><h4 id="mian-c"><a href="#mian-c" class="headerlink" title="mian.c"></a>mian.c</h4><p>在lk_main()中的函数有(按顺序排)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//在thread_init_early()和arch_early_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_ARCH_EARLY - 1);</span><br><span class="line"></span><br><span class="line">//在arch_early_init()和platform_early_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH_EARLY, LK_INIT_LEVEL_PLATFORM_EARLY - 1);</span><br><span class="line"></span><br><span class="line">//在platform_early_init()和target_early_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_LEVEL_TARGET_EARLY - 1);</span><br><span class="line"></span><br><span class="line">//在target_early_init()和heap_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET_EARLY, LK_INIT_LEVEL_HEAP - 1);</span><br><span class="line"></span><br><span class="line">//在heap_init()和kernel_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_HEAP, LK_INIT_LEVEL_KERNEL - 1);</span><br><span class="line"></span><br><span class="line">//在kernel_init()和thread_create()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_KERNEL, LK_INIT_LEVEL_THREADING - 1);</span><br></pre></td></tr></table></figure><p>在bootstrap2()中的函数有(按顺序排)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//在bootstrap2()函数刚进来，arch_init()之前：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);</span><br><span class="line"></span><br><span class="line">//在arch_init()和platform_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);</span><br><span class="line"></span><br><span class="line">//在platform_init()和target_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);</span><br><span class="line"></span><br><span class="line">//在target_init()和apps_init()之间：</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);</span><br><span class="line"></span><br><span class="line">//在apps_init()之后</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);</span><br></pre></td></tr></table></figure><p>在lk_init_secondary_cpus()中的函数有(按顺序排)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_LAST);</span><br></pre></td></tr></table></figure><h4 id="init-h"><a href="#init-h" class="headerlink" title="init.h"></a>init.h</h4><p>定义的枚举在init.h中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enum lk_init_level &#123;</span><br><span class="line">    LK_INIT_LEVEL_EARLIEST = 1,</span><br><span class="line"></span><br><span class="line">    LK_INIT_LEVEL_ARCH_EARLY     = 0x10000,</span><br><span class="line">    LK_INIT_LEVEL_PLATFORM_EARLY = 0x20000,</span><br><span class="line">    LK_INIT_LEVEL_TARGET_EARLY   = 0x30000,</span><br><span class="line">    LK_INIT_LEVEL_HEAP           = 0x40000,</span><br><span class="line">    LK_INIT_LEVEL_VM             = 0x50000,</span><br><span class="line">    LK_INIT_LEVEL_KERNEL         = 0x60000,</span><br><span class="line">    LK_INIT_LEVEL_THREADING      = 0x70000,</span><br><span class="line">    LK_INIT_LEVEL_ARCH           = 0x80000,</span><br><span class="line">    LK_INIT_LEVEL_PLATFORM       = 0x90000,</span><br><span class="line">    LK_INIT_LEVEL_TARGET         = 0xa0000,</span><br><span class="line">    LK_INIT_LEVEL_APPS           = 0xb0000,</span><br><span class="line"></span><br><span class="line">    LK_INIT_LEVEL_LAST = UINT_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum lk_init_flags &#123;</span><br><span class="line">    LK_INIT_FLAG_PRIMARY_CPU     = 0x1,</span><br><span class="line">    LK_INIT_FLAG_SECONDARY_CPUS  = 0x2,</span><br><span class="line">    LK_INIT_FLAG_ALL_CPUS        = LK_INIT_FLAG_PRIMARY_CPU | LK_INIT_FLAG_SECONDARY_CPUS,</span><br><span class="line">    LK_INIT_FLAG_CPU_SUSPEND     = 0x4,</span><br><span class="line">    LK_INIT_FLAG_CPU_RESUME      = 0x8,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lk_primary_cpu_init_level等函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*lk_init_hook)(uint level); //函数类型的typedef，在下面的struct中用到，该函数接收一个uint类型的level参数，返回为空（void）。</span><br><span class="line"></span><br><span class="line">void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);</span><br><span class="line"></span><br><span class="line">static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level)</span><br><span class="line">&#123;</span><br><span class="line">    lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);</span><br><span class="line">&#125; // 指定lk_init_flags flags为LK_INIT_FLAG_PRIMARY_CPU</span><br><span class="line"></span><br><span class="line">static inline void lk_init_level_all(enum lk_init_flags flags)</span><br><span class="line">&#123;</span><br><span class="line">    lk_init_level(flags, LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_LAST);</span><br><span class="line">&#125; //init_level包含整个区间</span><br><span class="line"></span><br><span class="line">struct lk_init_struct &#123;</span><br><span class="line">    uint level;     //init level</span><br><span class="line">    uint flags;     // lk_init_flags flags</span><br><span class="line">    lk_init_hook hook;  //指向的函数</span><br><span class="line">    const char *name;   //hook name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define LK_INIT_HOOK_FLAGS(_name, _hook, _level, _flags) \</span><br><span class="line">    const struct lk_init_struct _init_struct_##_name __ALIGNED(sizeof(void *)) __SECTION(&quot;.lk_init&quot;) = &#123; \</span><br><span class="line">        .level = _level, \</span><br><span class="line">        .flags = _flags, \</span><br><span class="line">        .hook = _hook, \</span><br><span class="line">        .name = #_name, \  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//该宏声明一个const型的lk_init_struct并对其进行初始化，宏传入4个参数（_name, _hook, _level, _flags）</span><br><span class="line">//lk_init_struct 的名字为_init_struct_+&#x27;_name&#x27;</span><br><span class="line">//_init_struct_+&#x27;_name&#x27;.level = _level</span><br><span class="line">//_init_struct_+&#x27;_name&#x27;.flags = _flags</span><br><span class="line">//_init_struct_+&#x27;_name&#x27;.hook = _hook</span><br><span class="line">//_init_struct_+&#x27;_name&#x27;.name = &#x27;_name&#x27;</span><br><span class="line"></span><br><span class="line">#define LK_INIT_HOOK(_name, _hook, _level) \</span><br><span class="line">    LK_INIT_HOOK_FLAGS(_name, _hook, _level, LK_INIT_FLAG_PRIMARY_CPU)</span><br><span class="line">//该宏将LK_INIT_HOOK_FLAGS中的_flags定为LK_INIT_FLAG_PRIMARY_CPU</span><br></pre></td></tr></table></figure><p>通过 __ALIGNED(sizeof(void *)) __SECTION(“.lk_init”)在编译器编译时，将各个地方LK_INIT_HOOK声明的lk_init_struct加入到.lk_init的数据段中。</p><p>__SECTION(“name”)是gcc编译器支持的一个编译特性（arm编译器也支持此特性），实现在编译时把某个函数&#x2F;数据放到name的数据段中。</p><h4 id="init-c"><a href="#init-c" class="headerlink" title="init.c"></a>init.c</h4><p>lk_init_level()函数在init.c中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">注意两个外部声明：</span><br><span class="line">extern const struct lk_init_struct __lk_init[];</span><br><span class="line">extern const struct lk_init_struct __lk_init_end[];</span><br><span class="line"></span><br><span class="line">void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)</span><br><span class="line">&#123;</span><br><span class="line">    LTRACEF(&quot;flags %#x, start_level %#x, stop_level %#x\n&quot;,</span><br><span class="line">            required_flag, start_level, stop_level);</span><br><span class="line"></span><br><span class="line">    ASSERT(start_level &gt; 0);</span><br><span class="line">    uint last_called_level = start_level - 1;</span><br><span class="line">    const struct lk_init_struct *last = NULL;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        /* search for the lowest uncalled hook to call */</span><br><span class="line">        LTRACEF(&quot;last %p, last_called_level %#x\n&quot;, last, last_called_level);</span><br><span class="line"></span><br><span class="line">        const struct lk_init_struct *found = NULL;</span><br><span class="line">        bool seen_last = false;</span><br><span class="line">        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) &#123;</span><br><span class="line">            LTRACEF(&quot;looking at %p (%s) level %#x, flags %#x, seen_last %d\n&quot;, ptr, ptr-&gt;name, ptr-&gt;level, ptr-&gt;flags, seen_last);</span><br><span class="line"></span><br><span class="line">            if (ptr == last)</span><br><span class="line">                seen_last = true;</span><br><span class="line"></span><br><span class="line">            /* reject the easy ones */</span><br><span class="line">            if (!(ptr-&gt;flags &amp; required_flag))</span><br><span class="line">                continue;</span><br><span class="line">            if (ptr-&gt;level &gt; stop_level)</span><br><span class="line">                continue;</span><br><span class="line">            if (ptr-&gt;level &lt; last_called_level)</span><br><span class="line">                continue;</span><br><span class="line">            if (found &amp;&amp; found-&gt;level &lt;= ptr-&gt;level)</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            /* keep the lowest one we haven&#x27;t called yet */</span><br><span class="line">            if (ptr-&gt;level &gt;= start_level &amp;&amp; ptr-&gt;level &gt; last_called_level) &#123;</span><br><span class="line">                found = ptr;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* if we&#x27;re at the same level as the last one we called and we&#x27;ve</span><br><span class="line">             * already passed over it this time around, we can mark this one</span><br><span class="line">             * and early terminate the loop.</span><br><span class="line">             */</span><br><span class="line">            if (ptr-&gt;level == last_called_level &amp;&amp; ptr != last &amp;&amp; seen_last) &#123;</span><br><span class="line">                found = ptr;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!found)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">#if TRACE_INIT</span><br><span class="line">        if (found-&gt;level &gt;= EARLIEST_TRACE_LEVEL) &#123;</span><br><span class="line">            printf(&quot;INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n&quot;,</span><br><span class="line">                   arch_curr_cpu_num(), found-&gt;hook, found-&gt;name, found-&gt;level, found-&gt;flags);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        found-&gt;hook(found-&gt;level);</span><br><span class="line">        last_called_level = found-&gt;level;</span><br><span class="line">        last = found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lk_init_level()中主要为一个循环，从__lk_init到__lk_init_end之间遍历，找到符合条件的init hook去执行。</p><p>__lk_init 和 __lk_init_end 是 .lk_init数据段中定义的起始和结束，定义在lk&#x2F;top&#x2F;init.ld文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    .lk_init : &#123;</span><br><span class="line">        __lk_init = .;</span><br><span class="line">        KEEP (*(.lk_init))</span><br><span class="line">        __lk_init_end = .;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">INSERT AFTER .rodata;</span><br></pre></td></tr></table></figure><h4 id="使用init-hook"><a href="#使用init-hook" class="headerlink" title="使用init hook"></a>使用init hook</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void test_hook(uint level)</span><br><span class="line">&#123;</span><br><span class="line">    LTRACEF(&quot;level %#x\n&quot;, level);</span><br><span class="line">&#125;</span><br><span class="line">LK_INIT_HOOK(test, test_hook, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void dpc_init(uint level)</span><br><span class="line">&#123;</span><br><span class="line">    event_init(&amp;dpc_event, false, 0);</span><br><span class="line"></span><br><span class="line">    thread_detach_and_resume(thread_create(&quot;dpc&quot;, &amp;dpc_thread_routine, NULL, DPC_PRIORITY, DEFAULT_STACK_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LK_INIT_HOOK(libdpc, &amp;dpc_init, LK_INIT_LEVEL_THREADING);</span><br><span class="line"></span><br><span class="line">//lk中dpc thread就是以init hook的方式，在bootstrap2(void *arg)函数的开头创建的。</span><br></pre></td></tr></table></figure><p>NOTE:<br>1.在编译好的lk.elf里查找.lk_init</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-elf-readelf build-path/lk.elf -x .lk_init</span><br></pre></td></tr></table></figure><p>2.查看一些debug信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim build-path/lk.elf.debug.lst </span><br></pre></td></tr></table></figure><p>3.查看system-onesegment信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim build-path/system-onesegment.ld </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux解压缩命令</title>
      <link href="/2018/11/15/linux%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/11/15/linux%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h4><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">.tar</span><br><span class="line">压缩：tar cvf FileName.tar FileName</span><br><span class="line">解压：tar xvf FileName.tar</span><br><span class="line">--------------------------------------------- </span><br><span class="line">.gz</span><br><span class="line">解压1：gunzip FileName.gz </span><br><span class="line">解压2：gzip -d FileName.gz </span><br><span class="line">压缩：gzip FileName </span><br><span class="line">.tar.gz </span><br><span class="line">解压：tar zxvf FileName.tar.gz </span><br><span class="line">压缩：tar zcvf FileName.tar.gz DirName </span><br><span class="line">压缩多个文件：tar zcvf FileName.tar.gz DirName1 DirName2 DirName3 ...</span><br><span class="line">--------------------------------------------- </span><br><span class="line">.bz2 </span><br><span class="line">解压1：bzip2 -d FileName.bz2 </span><br><span class="line">解压2：bunzip2 FileName.bz2 </span><br><span class="line">压缩： bzip2 -z FileName </span><br><span class="line">.tar.bz2 </span><br><span class="line">解压：tar jxvf FileName.tar.bz2 </span><br><span class="line">压缩：tar jcvf FileName.tar.bz2 DirName </span><br><span class="line">--------------------------------------------- </span><br><span class="line">.bz </span><br><span class="line">解压1：bzip2 -d FileName.bz </span><br><span class="line">解压2：bunzip2 FileName.bz </span><br><span class="line">压缩：未知 </span><br><span class="line">.tar.bz </span><br><span class="line">解压：tar jxvf FileName.tar.bz </span><br><span class="line">压缩：未知 </span><br><span class="line">--------------------------------------------- </span><br><span class="line">.Z </span><br><span class="line">解压：uncompress FileName.Z </span><br><span class="line">压缩：compress FileName </span><br><span class="line">.tar.Z </span><br><span class="line">解压：tar Zxvf FileName.tar.Z </span><br><span class="line">压缩：tar Zcvf FileName.tar.Z DirName </span><br><span class="line">--------------------------------------------- </span><br><span class="line">.tgz </span><br><span class="line">解压：tar zxvf FileName.tgz </span><br><span class="line">压缩：未知 </span><br><span class="line">.tar.tgz </span><br><span class="line">解压：tar zxvf FileName.tar.tgz </span><br><span class="line">压缩：tar zcvf FileName.tar.tgz FileName </span><br><span class="line">--------------------------------------------- </span><br><span class="line">.zip </span><br><span class="line">解压：unzip FileName.zip </span><br><span class="line">压缩：zip FileName.zip DirName </span><br><span class="line">--------------------------------------------- </span><br><span class="line">.rar </span><br><span class="line">解压：rar a FileName.rar </span><br><span class="line">压缩：rar e FileName.rar </span><br><span class="line">---------------------------------------------</span><br><span class="line">.7z</span><br><span class="line">解压：7za x FileName.7z -r -o./</span><br><span class="line">参数含义：</span><br><span class="line">x  代表解压缩文件，并且是按原始目录树解压（还有个参数 e 也是解压缩文件，</span><br><span class="line">但其会将所有文件都解压到根下，而不是自己原有的文件夹下）</span><br><span class="line">-r 表示递归解压缩所有的子文件夹</span><br><span class="line">-o 是指定解压到的目录，-o后是没有空格的，直接接目录。</span><br><span class="line"></span><br><span class="line">压缩：7za a -t7z -r FileName.7z /.../FileName/*</span><br><span class="line">a  代表添加文件／文件夹到压缩包</span><br><span class="line">-t 是指定压缩类型，这里定为7z，可不指定，因为7za默认压缩类型就是7z。</span><br><span class="line">-r 表示递归所有的子文件夹</span><br><span class="line">FileName.7z 是压缩好后的压缩包名</span><br><span class="line">/.../FileName/*：是压缩目标。</span><br></pre></td></tr></table></figure><p>压缩包各个不同后缀的含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.tar打包格式：tar程序打包的数据，并没有压缩过</span><br><span class="line">.z格式：compress程序压缩的文件</span><br><span class="line">.gz压缩格式：gzip程序压缩的文件 .bz2压缩格式：bzip2程序压缩的文件</span><br><span class="line">.tar.gz打包压缩：tar程序打包的文件，其中并且经过 gzip 的压缩</span><br><span class="line">.tar.bz2打包压缩：tar程序打包的文件，其中并且经过 bzip2 的压缩</span><br></pre></td></tr></table></figure><p>tar是打包命令，比较常见，下面给出他的不同参数的含义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure><p>下面的5个参数是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用,但这五个命令只能用其中一个,是根据需要在压缩或解压档案时可选的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-o：将文件解开到标准输出</span><br></pre></td></tr></table></figure><p>最后：<br>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名，并且是必须的。</p><p>文章整理自：<br><a href="https://blog.csdn.net/liuyanfeier/article/details/62422315">Linux下的打包和解压缩命令</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux查找命令</title>
      <link href="/2018/11/15/linux%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/11/15/linux%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h3><p>语法：find 搜索路径 匹配表达式</p><span id="more"></span><p>功能：该命令用于在指定路径中查找符合条件的文件，搜索路径可以是多个目录，不同目录之间以空格分隔。</p><h4 id="匹配表达式1"><a href="#匹配表达式1" class="headerlink" title="匹配表达式1"></a>匹配表达式1</h4><p>1.-name filename：<br>要查找的文件名。可以使用通配符“*”，“?”,但要用双引号将文件名引起来。<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;h*&quot; -print</span><br><span class="line">#在当前目录下查找以h开头的文件</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.java&quot; </span><br><span class="line">#查找当前目录下所有扩展名为java的文件</span><br><span class="line"></span><br><span class="line">find / -name hosts -print</span><br><span class="line">#在整个文件系统中查找名为hosts的文件</span><br></pre></td></tr></table></figure><p>2.-user username：<br>查找属于username用户的文件。<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /home -user user1 -print</span><br><span class="line">#找出/home下属于用户user1的所有文件</span><br></pre></td></tr></table></figure><p>3.-group groupname：<br>查找属于groupname组的文件。</p><p>NOTE：<br>-print：显示找到文件路径名。</p><h4 id="匹配表达式2"><a href="#匹配表达式2" class="headerlink" title="匹配表达式2"></a>匹配表达式2</h4><p>1.-exec 命令 ｛｝：<br>对找到的匹配文件，执行所列出的命令，而不询问用户是否执行这些命令，参数｛｝ 由find找到当前的文件路径名取代，命令行末尾必须有“;”。<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find /home –user user1 –exec cat &#123;&#125;\;|more</span><br><span class="line">#找出/home下属于用户user1的所有文件并显示其内容</span><br><span class="line"></span><br><span class="line">find /home –user user1 –exec rm –r &#123;&#125; \;</span><br><span class="line">#找出/home下属于用户user1的所有文件并删除</span><br></pre></td></tr></table></figure><p>2.-ok 命令 {}：<br>与-exec的用法相同，在执行命令之前询问用户是否要执行命令。</p><h4 id="匹配表达式3"><a href="#匹配表达式3" class="headerlink" title="匹配表达式3"></a>匹配表达式3</h4><p>1.-atime n：查找前n天访问过的文件（仅第n天这一天）。<br>2.-atime +n：查找前n天之前访问过的文件；-n则表示前n天之后。<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find /home –atime +365 –print</span><br><span class="line">#找出用户一年前访问过的文件</span><br><span class="line"></span><br><span class="line">find $home –user user1 –atime +3 –exec rm –r &#123;&#125; \;</span><br><span class="line">#找出用户user1主目录下属于自己的前3天之前访问过文件并删除</span><br><span class="line"></span><br><span class="line">find / -amin -10 　　</span><br><span class="line">#查找在系统中最后10分钟访问的文件(access time)</span><br><span class="line"></span><br><span class="line">find / -atime -2　　 </span><br><span class="line">#查找在系统中最后48小时访问的文件</span><br><span class="line"></span><br><span class="line">find / -mmin -5 　　</span><br><span class="line">#查找在系统中最后5分钟里修改过的文件(modify time)</span><br><span class="line"></span><br><span class="line">find / -mtime -1 　　</span><br><span class="line">#查找在系统中最后24小时里修改过的文件</span><br></pre></td></tr></table></figure><h4 id="匹配表达式4"><a href="#匹配表达式4" class="headerlink" title="匹配表达式4"></a>匹配表达式4</h4><p>1.-type filetype：<br>指定查找的文件类型。<br>filetype 可以是：b块文件；c字符设备文件；d目录文件；f一般文件。<br>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find –type d –print</span><br><span class="line">#查找当前目录下的所有的子目录</span><br><span class="line"></span><br><span class="line">find –type f –print</span><br><span class="line">#查找当前目录下的所有的普通文件</span><br></pre></td></tr></table></figure><h4 id="匹配表达式5"><a href="#匹配表达式5" class="headerlink" title="匹配表达式5"></a>匹配表达式5</h4><p>-size 按照文件大小进行查找。<br>(c:字节，w:双字，k:KB，M:MB，G:GB)</p><ul><li>-size Number  Number大小以块（一般是512字节）为单位，找对应大小的文件</li><li>-size Numberc Numberc大小以字节为单位，找对应大小的文件</li><li>-size -Numberc 查找比该值小的文件</li><li>-size +Numberc 查找比该值大的文件</li></ul><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find –size -10 –print</span><br><span class="line">#查找当前目录下所有长度小于10块的文件</span><br><span class="line"></span><br><span class="line">find –size -10c –print | ls –l</span><br><span class="line">#查找当前目录下所有长度小于10字节的文件并以长格式显示文件信息</span><br><span class="line"></span><br><span class="line">find –size +100 –size -200 –exec ls –s &#123;&#125; \;</span><br><span class="line">#在当前目录下查找100~200块长的文件并显示文件的实际块数</span><br></pre></td></tr></table></figure><h4 id="其他-混合使用"><a href="#其他-混合使用" class="headerlink" title="其他&#x2F;混合使用"></a>其他&#x2F;混合使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -empty 　　</span><br><span class="line"># 查找在系统中为空的文件或者文件夹</span><br></pre></td></tr></table></figure><p><strong>混合使用：</strong><br>参数有： ！，-and(-a)，-or(-o)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -size +10000c -and -mtime +2 　　</span><br><span class="line">#在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件</span><br><span class="line"></span><br><span class="line">find / -user fred -or -user george 　　</span><br><span class="line">#在/目录下查找用户是fred或者george的文件文件</span><br><span class="line"></span><br><span class="line">find /tmp ! -user panda　　</span><br><span class="line">#在/tmp目录中查找所有不属于panda用户的文件</span><br></pre></td></tr></table></figure><h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><p>语法：grep【参数】 查找模式 文件名 【文件名】</p><p>功能：grep命令用于在指定文件中查找与模式匹配的行，并将匹配的行显示在标准输出上。如果没有指定文件，则从标准输入中读取。当在多个文件中进行查找中，将在每一行输出之前加上文件名。在搜索的文件名中允许使用通配符。</p><h4 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数:"></a>主要参数:</h4><ul><li>-c：只输出匹配行的计数。</li><li>-i：不区分大小写</li><li>-h：查询多文件时不显示文件名。</li><li>-l：查询多文件时只输出包含匹配字符的文件名。</li><li>-n：显示匹配行及行号。</li><li>-s：不显示不存在或无匹配文本的错误信息。</li><li>-v：显示不包含匹配文本的所有行。</li><li>-f: filename：从指定文件中获取搜索模式，每行一个搜索模式项。</li></ul><h4 id="pattern正则表达式主要参数："><a href="#pattern正则表达式主要参数：" class="headerlink" title="pattern正则表达式主要参数："></a>pattern正则表达式主要参数：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\： 忽略正则表达式中特殊字符的原有含义。</span><br><span class="line">^：匹配正则表达式的开始行。</span><br><span class="line">$: 匹配正则表达式的结束行。</span><br><span class="line">\&lt;：从匹配正则表达 式的行开始。</span><br><span class="line">\&gt;：到匹配正则表达式的行结束。</span><br><span class="line">[ ]：单个字符，如[A]即A符合要求 。</span><br><span class="line">[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。</span><br><span class="line">.：所有的单个字符。</span><br><span class="line">* ：有字符，长度可以为0。</span><br></pre></td></tr></table></figure><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;test&#x27; d*　　</span><br><span class="line">#显示所有以d开头的文件中包含 test的行</span><br><span class="line"></span><br><span class="line">grep ‘test’ aa bb cc 　　 </span><br><span class="line">#显示在aa，bb，cc文件中包含test的行</span><br><span class="line"></span><br><span class="line">grep ‘[a-z]\&#123;5\&#125;’ aa 　　</span><br><span class="line">#显示所有包含每行字符串至少有5个连续小写字符的字符串的行</span><br><span class="line"></span><br><span class="line">grep magic /usr/src　　</span><br><span class="line">#显示/usr/src目录下的文件(不含子目录)包含magic的行</span><br><span class="line"></span><br><span class="line">grep -r magic /usr/src　　</span><br><span class="line">#显示/usr/src目录下的文件(包含子目录)包含magic的行</span><br><span class="line"></span><br><span class="line">grep -w pattern files </span><br><span class="line">#只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)</span><br><span class="line"></span><br><span class="line">grep printf *.c</span><br><span class="line">#在当前目录下的所有C文件中查找printf字符串</span><br><span class="line"></span><br><span class="line">grep user1 /ect/password</span><br><span class="line">#将系统帐号中文件包含user1的行显示出来。</span><br><span class="line"></span><br><span class="line">默认情况下，’grep’只搜索当前目录。如果 此目录下有许多子目录，’grep’会以如下形式列出：</span><br><span class="line">grep: sound: Is a directory</span><br><span class="line">这可能会使’grep’ 的输出难于阅读。这里有两种解决的办法：</span><br><span class="line">明确要求搜索子目录：grep -r</span><br><span class="line">或忽略子目录：grep -d skip</span><br><span class="line">如果有很多 输出时，可以通过管道将其转到’less’上阅读：</span><br><span class="line">grep magic /usr/src/Linux/Documentation/* | less</span><br><span class="line">这样就可以更方便地阅读。</span><br></pre></td></tr></table></figure><h3 id="find与grep命令组合使用"><a href="#find与grep命令组合使用" class="headerlink" title="find与grep命令组合使用"></a>find与grep命令组合使用</h3><p>find与grep命令组合使用，在大量文件中查找非常方便，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.c&quot; | xargs grep &quot;hello&quot; #在当前目录所有.c文件查找包含hello字符串的文件</span><br><span class="line"></span><br><span class="line">find -name &quot;*.c&quot; | grep -s gt9xx</span><br><span class="line">#查找路径下带某个文件夹或者文件名的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Little Kernel 04</title>
      <link href="/2018/11/14/Little-Kernel-04/"/>
      <url>/2018/11/14/Little-Kernel-04/</url>
      
        <content type="html"><![CDATA[<h3 id="LK-build-system"><a href="#LK-build-system" class="headerlink" title="LK build system"></a>LK build system</h3><p>The LK build system thinks of the world in four layers.</p><span id="more"></span><h4 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h4><p>Projects are what you ask make to build.<br>They are a set of modules (typically apps and libraries) built for a Target. </p><p>They are defined in <strong>project&#x2F;name.mk</strong>. </p><p>The Target is selected via <strong>TARGET :&#x3D; name</strong>in this makefile or an included makefile (in the case where multiple projects share a common configuration). You choose your project by either passing it to make on the commandline (<strong>make name</strong>) or putting a <strong>PROJECT :&#x3D; name</strong> directive in local.mk.</p><h4 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h4><p>Targets are typically a specific PCB (or family of extremely closely related PCBs, maybe differing just a little, detectable by some revision resistors or the like). </p><p>They belong to a Platform and are defined in <strong>target&#x2F;name&#x2F;rules.mk</strong>.</p><p>The Platform is selected via <strong>PLATFORM :&#x3D; name</strong> in this makefile.</p><h4 id="Platforms"><a href="#Platforms" class="headerlink" title="Platforms"></a>Platforms</h4><p>Platforms typically are Systems-on-Chip (either individual or related families). </p><p>They belong to an Architecture and are defined in <strong>platform&#x2F;name&#x2F;rules.mk</strong>. </p><p>The Architecture is selected via <strong>ARCH :&#x3D; name</strong> in this makefile.</p><h4 id="Architectures"><a href="#Architectures" class="headerlink" title="Architectures"></a>Architectures</h4><p>Architectures are a specific CPU or CPU family (ARM Cortex M3, Intel IA32, etc).</p><h4 id="Example-Project"><a href="#Example-Project" class="headerlink" title="Example Project"></a>Example Project</h4><p>An example project is stm32f4-discovery-test. </p><p>The Target there is stm32f4-discovery (the ST development board of the same name). </p><p>Its Platform is stm32f4xx, a family of ST microcontrollers. STM32_CHIP is set to stm32f407 for things that may be specific to that chip. Some GLOBAL_DEFINES are configured here as well, like HSE_VALUE which is the frequency of the crystal — a platform-specific definition. </p><p>The Platform stm32f4xx sets ARCH as arm and ARM_CPU (specific to arm architecture) to cortex-m4, as well as configuring other platform-specific values.</p><p>The above configuration information lives in the following files in the lk source tree:</p><ul><li>project&#x2F;stm32f4-discovery-test.mk</li><li>target&#x2F;stm32f4-discovery&#x2F;rules.mk</li><li>platform&#x2F;stm32f4xx&#x2F;rules.mk</li><li>arch&#x2F;arm&#x2F;rules.mk</li></ul><h3 id="Building-Outside-The-LK-Tree"><a href="#Building-Outside-The-LK-Tree" class="headerlink" title="Building Outside The LK Tree"></a>Building Outside The LK Tree</h3><p>The build system provides a mechanism to overlay additional projects, targets, platforms, apps, libs, etc, from sibling directory hierarchies. This allows you to more easily build and maintain projects that are not part of the main lk tree.</p><p>For example, say you have LK checked out in an lk directory, and next to that you have a mystuff directory (a checkout of your own source tree). It can contain your own projects, libraries, and apps, like so:</p><ul><li>mystuff&#x2F;project&#x2F;toaster-oven.mk</li><li>mystuff&#x2F;target&#x2F;toaster-oven&#x2F;{rules.mk, init.c, …}</li><li>mystuff&#x2F;app&#x2F;toaster-ui&#x2F;{rules.mk, main.c, …}</li><li>mystuff&#x2F;lib&#x2F;cool-lcd&#x2F;{rules.mk, lcddriver.c, …}</li><li>mystuff&#x2F;lib&#x2F;pid-controller&#x2F;…</li></ul><p>If you copy lk&#x2F;makefile to mystuff&#x2F;makefile and create lk_inc.mk like so:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_DIR := mystuff</span><br><span class="line">LKMAKEROOT := ..</span><br><span class="line">LKROOT := lk</span><br><span class="line">LKINC := $(LOCAL_DIR)</span><br><span class="line">DEFAULT_PROJECT ?= toaster-oven</span><br><span class="line">BUILDROOT ?= $(LOCAL_DIR)</span><br></pre></td></tr></table></figure><p>You can then cd to mystuff and run make to build your project. You don’t need to modify anything in the main lk tree, so it’s easy to keep that up to date — no need to fork it, merge or rebase your changes, etc.</p><h4 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h4><ul><li><strong>LKMAKEROOT</strong> is the relative path from the overlay tree you’re building in to the directory that’s above the lk directory and any overlay tree directories (you can have multiple of these if you like). This variable is the only one that can have .. path elements in it. Such elements used anywhere else will cause the build system to misbehave.</li><li><strong>LKROOT</strong> is the path relative to LKMAKEROOT to LK itself.</li><li><strong>LKINC</strong> is the set of paths relative to LKMAKEROOT to overlay directories.</li><li><strong>DEFAULT_PROJECT</strong> does what it says — sets the project to build if another is not specified when make is invoked.</li><li><strong>BUILDROOT</strong> is relative to LKMAKEROOT and is the directory where build-$(PROJECT) will live, containing the build results.</li><li>You can also specify your <strong>TOOLCHAIN_PREFIX</strong> here to point at your chosen cross-compiler for this overlay.</li></ul><h4 id="Alternate-Approach"><a href="#Alternate-Approach" class="headerlink" title="Alternate Approach"></a>Alternate Approach</h4><p>If you’d rather run make from the top directory (that contains lk and mystuff), you can copy lk&#x2F;makefile and set up lk_inc.mk there instead. Just change the value of LKMAKEROOT and BUILDROOT both to . and you’re all set.</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="build-essential"><a href="#build-essential" class="headerlink" title="build essential"></a>build essential</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h4 id="for-arch-arm64-build"><a href="#for-arch-arm64-build" class="headerlink" title="for arch arm64 build"></a>for arch arm64 build</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. mkdir -p gcc_linario_aarch64_toolchain</span><br><span class="line">2. cd gcc_linario_aarch64_toolchain</span><br><span class="line">3. wget -c https://releases.linaro.org/components/toolchain/binaries/latest-7/aarch64-elf/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-elf.tar.xz</span><br><span class="line">4. tar xf gcc-linaro-7.3.1-2018.05-x86_64_aarch64-elf.tar.xz</span><br><span class="line">5. export PATH=$PATH:`pwd`/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-elf/bin </span><br></pre></td></tr></table></figure><h4 id="for-arch-arm-build"><a href="#for-arch-arm-build" class="headerlink" title="for arch arm build"></a>for arch arm build</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. mkdir -p arm-eabi-5.3.0-Linux-x86_64</span><br><span class="line">2. cd arm-eabi-5.3.0-Linux-x86_64</span><br><span class="line">3. wget -c http://newos.org/toolchains/arm-eabi-5.3.0-Linux-x86_64.tar.xz</span><br><span class="line">4. tar xf arm-eabi-5.3.0-Linux-x86_64.tar.xz</span><br><span class="line">5. export PATH=$PATH:`pwd`/arm-eabi-5.3.0-Linux-x86_64/bin</span><br></pre></td></tr></table></figure><h4 id="install-qemu"><a href="#install-qemu" class="headerlink" title="install qemu"></a>install qemu</h4><p>1.sudo apt-get install qemu<br>2.安装QEMU之后，命令行输入”qemu- + Tab”可以找到有如下的命令可用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64              qemu-make-debian-root     qemu-nios2                qemu-sparc32plus          qemu-system-microblazeel  qemu-system-ppc64le       qemu-system-xtensa</span><br><span class="line">qemu-alpha                qemu-microblaze           qemu-or1k                 qemu-sparc64              qemu-system-mips          qemu-system-ppcemb        qemu-system-xtensaeb</span><br><span class="line">qemu-arm                  qemu-microblazeel         qemu-ppc                  qemu-system-aarch64       qemu-system-mips64        qemu-system-s390x         qemu-tilegx</span><br><span class="line">qemu-armeb                qemu-mips                 qemu-ppc64                qemu-system-alpha         qemu-system-mips64el      qemu-system-sh4           qemu-x86_64</span><br><span class="line">qemu-cris                 qemu-mips64               qemu-ppc64abi32           qemu-system-arm           qemu-system-mipsel        qemu-system-sh4eb         </span><br><span class="line">qemu-hppa                 qemu-mips64el             qemu-ppc64le              qemu-system-cris          qemu-system-moxie         qemu-system-sparc         </span><br><span class="line">qemu-i386                 qemu-mipsel               qemu-s390x                qemu-system-i386          qemu-system-nios2         qemu-system-sparc64       </span><br><span class="line">qemu-img                  qemu-mipsn32              qemu-sh4                  qemu-system-lm32          qemu-system-or1k          qemu-system-tricore       </span><br><span class="line">qemu-io                   qemu-mipsn32el            qemu-sh4eb                qemu-system-m68k          qemu-system-ppc           qemu-system-unicore32     </span><br><span class="line">qemu-m68k                 qemu-nbd                  qemu-sparc                qemu-system-microblaze    qemu-system-ppc64         qemu-system-x86_64   </span><br></pre></td></tr></table></figure><p>可以看到它可以模拟很多种不同的架构。还有像qemu-img其实是一个工具，可以用来生成虚拟盘。<br>这里我们主要使用qemu-system-aarch64和qemu-system-arm。<br>3.可以查看qemu版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-system-arm -version</span><br><span class="line">QEMU emulator version 2.11.1(Debian 1:2.11+dfsg-1ubuntu7.7)</span><br><span class="line">Copyright (c) 2003-2017 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><p>主要参数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.支持的machine</span><br><span class="line">qemu-system-aarch64 -machine help</span><br><span class="line"></span><br><span class="line">其中，virt为：                 </span><br><span class="line">QEMU 2.11 ARM Virtual Machine (alias of virt-2.11)</span><br><span class="line"></span><br><span class="line">2.支持的cpu</span><br><span class="line">qemu-system-aarch64 -machine virt -cpu help</span><br><span class="line"></span><br><span class="line">其中，可以看到支持的arm cortex系列有：</span><br><span class="line">cortex-a15</span><br><span class="line">cortex-a53</span><br><span class="line">cortex-a57</span><br><span class="line">cortex-a7</span><br><span class="line">cortex-a8</span><br><span class="line">cortex-a9</span><br><span class="line">cortex-m3</span><br><span class="line">cortex-m4</span><br><span class="line">cortex-r5</span><br><span class="line"></span><br><span class="line">3.设置内存</span><br><span class="line">-m [size=]megs[,slots=n,maxmem=size]</span><br><span class="line">                configure guest RAM</span><br><span class="line">                size: initial amount of guest memory</span><br><span class="line">                slots: number of hotplug slots (default: none)</span><br><span class="line">                maxmem: maximum amount of guest memory (default: none)</span><br><span class="line"></span><br><span class="line">4.设置cpu核数</span><br><span class="line">-smp [cpus=]n[,maxcpus=cpus][,cores=cores][,threads=threads][,sockets=sockets]</span><br><span class="line">                set the number of CPUs to &#x27;n&#x27; [default=1]</span><br><span class="line">                maxcpus= maximum number of total cpus, including</span><br><span class="line">                offline CPUs for hotplug, etc</span><br><span class="line">                cores= number of CPU cores on one socket</span><br><span class="line">                threads= number of threads on one CPU core</span><br><span class="line">                sockets= number of discrete sockets in the system</span><br><span class="line">5.设置镜像文件</span><br><span class="line">-kernel bzImage use &#x27;bzImage&#x27; as kernel image</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm  -M vexpress-a9 -m 512M -nographic -append &quot;console=ttyAMA0&quot; -kernel  /root/zImage-3.0</span><br><span class="line"></span><br><span class="line">-M vexpress-a9 模拟vexpress-a9单板</span><br><span class="line">-m 512M 单板运行物理内存512M</span><br><span class="line">-kernel /root/zImage-3.16  告诉qemu单板运行内核镜像路径</span><br><span class="line">-nographic 不使用图形化界面，只使用串口</span><br><span class="line">-append &quot;console=ttyAMA0&quot; 内核启动参数，这里告诉内核vexpress单板运行，串口设备是哪个tty。 </span><br></pre></td></tr></table></figure><h4 id="get-lk-code-and-build"><a href="#get-lk-code-and-build" class="headerlink" title="get lk code and build"></a>get lk code and build</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line">git clone https://github.com/littlekernel/lk</span><br><span class="line"></span><br><span class="line">cd lk/</span><br><span class="line"></span><br><span class="line">make list</span><br><span class="line">可以看到列出来的project list</span><br><span class="line"></span><br><span class="line">make list_name</span><br><span class="line">编译project list_name，例：</span><br><span class="line">make qemu-virt-a53-test</span><br><span class="line">编译完后，在lk下可以看到build-qemu-virt-a53-test文件夹，里面lk.elf即为生成的镜像文件</span><br></pre></td></tr></table></figure><p>我们看一下mk文件里定义了哪些内容：<br>lk&#x2F;project&#x2F;qemu-virt-a53-test.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># main project for qemu-aarch64</span><br><span class="line">MODULES += \</span><br><span class="line">        app/shell</span><br><span class="line"></span><br><span class="line">include project/virtual/test.mk</span><br><span class="line">include project/virtual/fs.mk</span><br><span class="line">include project/virtual/minip.mk</span><br><span class="line">include project/target/qemu-virt-a53.mk</span><br></pre></td></tr></table></figure><p>lk&#x2F;project&#x2F;target&#x2F;qemu-virt-a53.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># main project for qemu-aarch64</span><br><span class="line">ARCH := arm64</span><br><span class="line">ARM_CPU := cortex-a53</span><br><span class="line"></span><br><span class="line">include project/target/qemu-virt.mk</span><br></pre></td></tr></table></figure><p>lk&#x2F;project&#x2F;target&#x2F;qemu-virt.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># main project for qemu-virt</span><br><span class="line">TARGET := qemu-virt</span><br><span class="line"></span><br><span class="line">WITH_LINKER_GC := 0</span><br></pre></td></tr></table></figure><p>lk&#x2F;project&#x2F;virtual&#x2F;fs.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># modules related to a file system layer</span><br><span class="line"></span><br><span class="line">MODULES += \</span><br><span class="line">    lib/fs \</span><br><span class="line">    lib/fs/ext2 \</span><br><span class="line">    lib/fs/fat32 \</span><br><span class="line">    lib/fs/spifs \</span><br><span class="line">    lib/fs/spifs/test \</span><br><span class="line">    lib/fs/memfs</span><br></pre></td></tr></table></figure><p>lk&#x2F;project&#x2F;virtual&#x2F;test.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># common libraries for -test variants</span><br><span class="line"></span><br><span class="line">MODULES += \</span><br><span class="line">  app/shell \</span><br><span class="line">  app/stringtests \</span><br><span class="line">  app/tests \</span><br><span class="line">  lib/aes \</span><br><span class="line">  lib/aes/test \</span><br><span class="line">  lib/cksum \</span><br><span class="line">  lib/debugcommands \</span><br><span class="line">  lib/libm \</span><br><span class="line">  lib/version \</span><br><span class="line"></span><br><span class="line">WITH_CPP_SUPPORT=true</span><br></pre></td></tr></table></figure><p>lk&#x2F;project&#x2F;virtual&#x2F;minip.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># modules related to the minip stack</span><br><span class="line"></span><br><span class="line">MODULES += \</span><br><span class="line">    lib/minip \</span><br><span class="line">    app/inetsrv</span><br></pre></td></tr></table></figure><h4 id="qemu-run"><a href="#qemu-run" class="headerlink" title="qemu run"></a>qemu run</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -machine virt -cpu cortex-a53 -smp 1 -m 512M -kernel build-qemu-virt-a53-test/lk.elf</span><br></pre></td></tr></table></figure><p>可以看到有一个窗口弹出，默认为qemu console,Ctrl + Alt + 2切换到运行的系统的console，Ctrl + Alt + 1再切换回来。<br>在系统的console可以看到打印出来的启动过程：<br><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/little_kernel/QEMU01.PNG" alt="lk启动过程"></p><p>help 命令可以查看支持的测试指令。</p><p>命令添加参数-nographic -append “root&#x3D;&#x2F;dev&#x2F;ram init&#x3D;&#x2F;init console&#x3D;ttyS0”，可以重定向qemu的打印消息到当前console，这样就可以靠鼠标滚轮查看内核启动消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -machine virt -cpu cortex-a53 -smp 1 -m 512M -nographic -append &quot;root=/dev/ram init=/init console=ttyS0&quot; -kernel build-qemu-virt-a53-test/lk.elf</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/little_kernel/QEMU02.PNG" alt="打印到当前console"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Little Kernel 03</title>
      <link href="/2018/11/13/Little-Kernel-03/"/>
      <url>/2018/11/13/Little-Kernel-03/</url>
      
        <content type="html"><![CDATA[<h3 id="LK-kernel-timer"><a href="#LK-kernel-timer" class="headerlink" title="LK kernel timer"></a>LK kernel timer</h3><p>Timers are used to setup one-shot or repeating callbacks in units of milliseconds.</p><span id="more"></span><p>These callbacks happen from interrupt context, so the available APIs are limited to things like signaling an event or unblocking a thread on a wait queue.</p><p>It is always safe to reprogram or cancel a timer from its own callback.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler_return a_timer_callback(struct timer *, lk_time_t now, void *arg);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void timer_initialize(timer_t *);</span><br><span class="line">void timer_set_oneshot(timer_t *, lk_time_t delay, timer_callback, void *arg);</span><br><span class="line">void timer_set_periodic(timer_t *, lk_time_t period, timer_callback, void *arg);</span><br><span class="line">void timer_cancel(timer_t *);</span><br></pre></td></tr></table></figure><p><strong>Timekeeping: lk_time_t</strong><br>This unsigned type is used by kernel functions involving timers, timeouts, etc, and is in units of milliseconds. The maximum value (defined as INFINITE_TIME) is used to specify a timeout that will never expire. The value 0 passed as a timeout parameter always means &#96;&#96;return immediately if you would have to wait.’’</p><p>ERR_TIMED_OUT is the status returned by a function taking a timeout value, if the timeout expires before the requested action can be accomplished.</p><p><strong>Safe Actions From IRQ handlers and Timer Callbacks:</strong><br>(Timer callbacks happen from IRQ context)</p><p>A number of these functions take a ‘reschedule’ parameter, which must be false when called from IRQ context. If your interrupt handler takes action which will wake a thread and you want to ensure it wakes now (provided priority is high enough) rather than when the next quantum expires, return INT_RESCHEDULE instead of INT_NO_RESCHEDULE. This will cause the kernel to invoke the scheduler before returning to thread context.</p><p>The follow actions are IRQ-safe:</p><ul><li>Signal an event with event_signal().</li><li>Reprogram a timer with timer_set_oneshot(), timer_set_periodic(), or timer_cancel().</li><li>Timer reprogramming is safe even from within that timer’s callback.</li><li>Using spinlocks.</li><li>Wake threads on wait queues with wake_queue_wake_one() or wake_queue_wake_all(), provided you hold the thread lock while doing so (useful for building new synchronization primitives).</li></ul><h4 id="timer-init"><a href="#timer-init" class="headerlink" title="timer_init"></a>timer_init</h4><p>timer_init 函数位于 kernel&#x2F;timer.c 文件中，主要的作用创建 lk 中的定时器链表和定时器处理函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void timer_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    timer_lock = SPIN_LOCK_INITIAL_VALUE;</span><br><span class="line">    for (uint i = 0; i &lt; SMP_MAX_CPUS; i++) &#123;</span><br><span class="line">        list_initialize(&amp;timers[i].timer_queue);</span><br><span class="line">    &#125;</span><br><span class="line">#if !PLATFORM_HAS_DYNAMIC_TIMER</span><br><span class="line">    /* register for a periodic timer tick */</span><br><span class="line">    platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个定时器都存储在 struct timer_t 类型的结构体中：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct timer &#123;</span><br><span class="line">    int magic;</span><br><span class="line">    struct list_node node;</span><br><span class="line"></span><br><span class="line">    lk_time_t scheduled_time;</span><br><span class="line">    lk_time_t periodic_time;</span><br><span class="line"></span><br><span class="line">    timer_callback callback;</span><br><span class="line">    void *arg;</span><br><span class="line">&#125; timer_t;</span><br></pre></td></tr></table></figure>timer_t初始化定义为一个宏：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define TIMER_INITIAL_VALUE(t) \</span><br><span class="line">&#123; \</span><br><span class="line">    .magic = TIMER_MAGIC, \</span><br><span class="line">    .node = LIST_INITIAL_CLEARED_VALUE, \</span><br><span class="line">    .scheduled_time = 0, \</span><br><span class="line">    .periodic_time = 0, \</span><br><span class="line">    .callback = NULL, \</span><br><span class="line">    .arg = NULL, \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>全局链表 timer_queue 的作用就是存储定时器,定义如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct timer_state &#123;</span><br><span class="line">    struct list_node timer_queue;</span><br><span class="line">&#125; __CPU_ALIGN;</span><br><span class="line"></span><br><span class="line">static struct timer_state timers[SMP_MAX_CPUS];</span><br></pre></td></tr></table></figure></li><li>通过platform_set_periodic_timer设定timer每10ms中断一次，中断callback是timer_tick。</li></ul><h4 id="timer-tick"><a href="#timer-tick" class="headerlink" title="timer_tick"></a>timer_tick</h4><p>timer_tick 函数的作用则是遍历 timer_queue 来处理其中注册的定时器回调函数,代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/* called at interrupt time to process any pending timers */</span><br><span class="line">static enum handler_return timer_tick(void *arg, lk_time_t now)</span><br><span class="line">&#123;</span><br><span class="line">    timer_t *timer;</span><br><span class="line">    enum handler_return ret = INT_NO_RESCHEDULE;</span><br><span class="line"></span><br><span class="line">    DEBUG_ASSERT(arch_ints_disabled());</span><br><span class="line"></span><br><span class="line">    THREAD_STATS_INC(timer_ints);</span><br><span class="line">//  KEVLOG_TIMER_TICK(); // enable only if necessary</span><br><span class="line"></span><br><span class="line">    uint cpu = arch_curr_cpu_num();</span><br><span class="line"></span><br><span class="line">    LTRACEF(&quot;cpu %u now %u, sp %p\n&quot;, cpu, now, __GET_FRAME());</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;timer_lock);</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        /* see if there&#x27;s an event to process */</span><br><span class="line">        timer = list_peek_head_type(&amp;timers[cpu].timer_queue, timer_t, node);</span><br><span class="line">        if (likely(timer == 0))</span><br><span class="line">            break;</span><br><span class="line">        LTRACEF(&quot;next item on timer queue %p at %u now %u (%p, arg %p)\n&quot;, timer, timer-&gt;scheduled_time, now, timer-&gt;callback, timer-&gt;arg);</span><br><span class="line">        if (likely(TIME_LT(now, timer-&gt;scheduled_time)))</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        /* process it */</span><br><span class="line">        LTRACEF(&quot;timer %p\n&quot;, timer);</span><br><span class="line">        DEBUG_ASSERT(timer &amp;&amp; timer-&gt;magic == TIMER_MAGIC);</span><br><span class="line">        list_delete(&amp;timer-&gt;node);</span><br><span class="line"></span><br><span class="line">        /* we pulled it off the list, release the list lock to handle it */</span><br><span class="line">        spin_unlock(&amp;timer_lock);</span><br><span class="line"></span><br><span class="line">        LTRACEF(&quot;dequeued timer %p, scheduled %u periodic %u\n&quot;, timer, timer-&gt;scheduled_time, timer-&gt;periodic_time);</span><br><span class="line"></span><br><span class="line">        THREAD_STATS_INC(timers);</span><br><span class="line"></span><br><span class="line">        bool periodic = timer-&gt;periodic_time &gt; 0;</span><br><span class="line"></span><br><span class="line">        LTRACEF(&quot;timer %p firing callback %p, arg %p\n&quot;, timer, timer-&gt;callback, timer-&gt;arg);</span><br><span class="line">        KEVLOG_TIMER_CALL(timer-&gt;callback, timer-&gt;arg);</span><br><span class="line">        if (timer-&gt;callback(timer, now, timer-&gt;arg) == INT_RESCHEDULE)</span><br><span class="line">            ret = INT_RESCHEDULE;</span><br><span class="line"></span><br><span class="line">        /* it may have been requeued or periodic, grab the lock so we can safely inspect it */</span><br><span class="line">        spin_lock(&amp;timer_lock);</span><br><span class="line"></span><br><span class="line">        /* if it was a periodic timer and it hasn&#x27;t been requeued</span><br><span class="line">         * by the callback put it back in the list</span><br><span class="line">         */</span><br><span class="line">        if (periodic &amp;&amp; !list_in_list(&amp;timer-&gt;node) &amp;&amp; timer-&gt;periodic_time &gt; 0) &#123;</span><br><span class="line">            LTRACEF(&quot;periodic timer, period %u\n&quot;, timer-&gt;periodic_time);</span><br><span class="line">            timer-&gt;scheduled_time = now + timer-&gt;periodic_time;</span><br><span class="line">            insert_timer_in_queue(cpu, timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if PLATFORM_HAS_DYNAMIC_TIMER</span><br><span class="line">    /* reset the timer to the next event */</span><br><span class="line">    timer = list_peek_head_type(&amp;timers[cpu].timer_queue, timer_t, node);</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">        /* has to be the case or it would have fired already */</span><br><span class="line">        DEBUG_ASSERT(TIME_GT(timer-&gt;scheduled_time, now));</span><br><span class="line"></span><br><span class="line">        lk_time_t delay = timer-&gt;scheduled_time - now;</span><br><span class="line"></span><br><span class="line">        LTRACEF(&quot;setting new timer for %u msecs for event %p\n&quot;, (uint)delay, timer);</span><br><span class="line">        platform_set_oneshot_timer(timer_tick, NULL, delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* we&#x27;re done manipulating the timer queue */</span><br><span class="line">    spin_unlock(&amp;timer_lock);</span><br><span class="line">#else</span><br><span class="line">    /* release the timer lock before calling the tick handler */</span><br><span class="line">    spin_unlock(&amp;timer_lock);</span><br><span class="line"></span><br><span class="line">    /* let the scheduler have a shot to do quantum expiration, etc */</span><br><span class="line">    /* in case of dynamic timer, the scheduler will set up a periodic timer */</span><br><span class="line">    if (thread_timer_tick() == INT_RESCHEDULE)</span><br><span class="line">        ret = INT_RESCHEDULE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timer_tick 是个死循环，会从变量timer_queue 中是否有到期的时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* see if there&#x27;s an event to process */</span><br><span class="line">        timer = list_peek_head_type(&amp;timers[cpu].timer_queue, timer_t, node);</span><br></pre></td></tr></table></figure><p>如果timer为空或者还未到期，则跳出循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (likely(timer == 0))</span><br><span class="line">    break;</span><br><span class="line">LTRACEF(&quot;next item on timer queue %p at %u now %u (%p, arg %p)\n&quot;, timer, timer-&gt;scheduled_time, now, timer-&gt;callback, timer-&gt;arg);</span><br><span class="line">if (likely(TIME_LT(now, timer-&gt;scheduled_time)))</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>如果有的话，就从timer_queue 中删除:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_delete(&amp;timer-&gt;node);</span><br></pre></td></tr></table></figure><p>并调用这个timer到期时间需要执行的callback</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* we pulled it off the list, release the list lock to handle it */</span><br><span class="line">spin_unlock(&amp;timer_lock);</span><br><span class="line"></span><br><span class="line">LTRACEF(&quot;dequeued timer %p, scheduled %u periodic %u\n&quot;, timer, timer-&gt;scheduled_time, timer-&gt;periodic_time);</span><br><span class="line"></span><br><span class="line">THREAD_STATS_INC(timers);</span><br><span class="line"></span><br><span class="line">bool periodic = timer-&gt;periodic_time &gt; 0;</span><br><span class="line"></span><br><span class="line">LTRACEF(&quot;timer %p firing callback %p, arg %p\n&quot;, timer, timer-&gt;callback, timer-&gt;arg);</span><br><span class="line">KEVLOG_TIMER_CALL(timer-&gt;callback, timer-&gt;arg);</span><br><span class="line">if (timer-&gt;callback(timer, now, timer-&gt;arg) == INT_RESCHEDULE)</span><br><span class="line">    ret = INT_RESCHEDULE;</span><br><span class="line"></span><br><span class="line">/* it may have been requeued or periodic, grab the lock so we can safely inspect it */</span><br><span class="line">spin_lock(&amp;timer_lock);</span><br></pre></td></tr></table></figure><p>如果这个timer是periodic类型的额，那么再次插入到timer_queue中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* if it was a periodic timer and it hasn&#x27;t been requeued</span><br><span class="line"> - by the callback put it back in the list</span><br><span class="line"> */</span><br><span class="line">if (periodic &amp;&amp; !list_in_list(&amp;timer-&gt;node) &amp;&amp; timer-&gt;periodic_time &gt; 0) &#123;</span><br><span class="line">    LTRACEF(&quot;periodic timer, period %u\n&quot;, timer-&gt;periodic_time);</span><br><span class="line">    timer-&gt;scheduled_time = now + timer-&gt;periodic_time;</span><br><span class="line">    insert_timer_in_queue(cpu, timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h4><p>在timer中，调用的platform层的函数分为：</p><ul><li>platform_set_periodic_timer<br>与</li><li>platform_set_oneshot_timer</li><li>platform_stop_timer<br>两种。</li></ul><p>这两种类型通过一个宏区分：<br>PLATFORM_HAS_DYNAMIC_TIMER</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if PLATFORM_HAS_DYNAMIC_TIMER</span><br><span class="line">    调用platform_set_oneshot_timer、platform_stop_timer</span><br><span class="line"></span><br><span class="line">#if !PLATFORM_HAS_DYNAMIC_TIMER</span><br><span class="line">    调用platform_set_periodic_timer</span><br></pre></td></tr></table></figure><p>这三个函数在lk&#x2F;dev&#x2F;timer中对应的平台下实现<br><strong>例1：platform为lk&#x2F;dev&#x2F;timer&#x2F;arm_generic。</strong><br>其中宏PLATFORM_HAS_DYNAMIC_TIMER定义在arm_generic&#x2F;rules.mk中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GLOBAL_DEFINES += \</span><br><span class="line">    PLATFORM_HAS_DYNAMIC_TIMER=1</span><br><span class="line"></span><br><span class="line">MODULE_SRCS += \</span><br><span class="line">    $(LOCAL_DIR)/arm_generic_timer.c</span><br></pre></td></tr></table></figure><p>arm_generic&#x2F;arm_generic_timer.c文件里实现了定时器的底层操作函数，并实现了以下几个与外部调用相关的函数：</p><h5 id="platform-set-oneshot-timer"><a href="#platform-set-oneshot-timer" class="headerlink" title="platform_set_oneshot_timer"></a>platform_set_oneshot_timer</h5><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">status_t platform_set_oneshot_timer(platform_timer_callback callback, void *arg, lk_time_t interval)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t cntpct_interval = lk_time_to_cntpct(interval);</span><br><span class="line"></span><br><span class="line">    ASSERT(arg == NULL);</span><br><span class="line"></span><br><span class="line">    t_callback = callback;</span><br><span class="line">    if (cntpct_interval &lt;= INT_MAX)</span><br><span class="line">        write_cntp_tval(cntpct_interval);</span><br><span class="line">    else</span><br><span class="line">        write_cntp_cval(read_cntpct() + cntpct_interval);</span><br><span class="line">    write_cntp_ctl(1);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.将interval的单位为ms的延时时间转换为要设置的定时器计数的寄存器值。<br>2.设置中断服务程序中要执行的callback函数。<br>3.将要设置的计数器的值写入寄存器。<br>4.开启定时器。</p><h5 id="platform-stop-timer"><a href="#platform-stop-timer" class="headerlink" title="platform_stop_timer"></a>platform_stop_timer</h5><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void platform_stop_timer(void)</span><br><span class="line">&#123;</span><br><span class="line">    write_cntp_ctl(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.关闭定时器。</p><h5 id="platform-tick"><a href="#platform-tick" class="headerlink" title="platform_tick"></a>platform_tick</h5><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static enum handler_return platform_tick(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    write_cntp_ctl(0);</span><br><span class="line">    if (t_callback) &#123;</span><br><span class="line">        return t_callback(arg, current_time());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return INT_NO_RESCHEDULE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.关闭定时器。<br>2.执行中断处理程序。</p><h5 id="arm-generic-timer-init"><a href="#arm-generic-timer-init" class="headerlink" title="arm_generic_timer_init"></a>arm_generic_timer_init</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void arm_generic_timer_init(int irq, uint32_t freq_override)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cntfrq;</span><br><span class="line"></span><br><span class="line">    if (freq_override == 0) &#123;</span><br><span class="line">        cntfrq = read_cntfrq();</span><br><span class="line"></span><br><span class="line">        if (!cntfrq) &#123;</span><br><span class="line">            TRACEF(&quot;Failed to initialize timer, frequency is 0\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cntfrq = freq_override;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if LOCAL_TRACE</span><br><span class="line">    LTRACEF(&quot;Test min cntfrq\n&quot;);</span><br><span class="line">    arm_generic_timer_init_conversion_factors(1);</span><br><span class="line">    test_time_conversions(1);</span><br><span class="line">    LTRACEF(&quot;Test max cntfrq\n&quot;);</span><br><span class="line">    arm_generic_timer_init_conversion_factors(~0);</span><br><span class="line">    test_time_conversions(~0);</span><br><span class="line">    LTRACEF(&quot;Set actual cntfrq\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">    arm_generic_timer_init_conversion_factors(cntfrq);</span><br><span class="line">    test_time_conversions(cntfrq);</span><br><span class="line"></span><br><span class="line">    LTRACEF(&quot;register irq %d on cpu %d\n&quot;, irq, arch_curr_cpu_num());</span><br><span class="line">    register_int_handler(irq, &amp;platform_tick, NULL);</span><br><span class="line">    unmask_interrupt(irq);</span><br><span class="line"></span><br><span class="line">    timer_irq = irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中注册中断服务程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">register_int_handler(irq, &amp;platform_tick, NULL);</span><br><span class="line">unmask_interrupt(irq);</span><br><span class="line"></span><br><span class="line">timer_irq = irq;</span><br></pre></td></tr></table></figure><p><strong>例2：platform为lk&#x2F;dev&#x2F;timer&#x2F;or1k_ticktimer。</strong><br>其中宏PLATFORM_HAS_DYNAMIC_TIMER在or1k_ticktimer&#x2F;rules.mk中被屏蔽掉，表示不定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#GLOBAL_DEFINES += \</span><br><span class="line">#   PLATFORM_HAS_DYNAMIC_TIMER=1</span><br><span class="line"></span><br><span class="line">MODULE_SRCS += \</span><br><span class="line">    $(LOCAL_DIR)/or1k_ticktimer.c</span><br></pre></td></tr></table></figure><p>or1k_ticktimer&#x2F;or1k_ticktimer.c文件里实现了定时器的底层操作函数，并实现了以下几个与外部调用相关的函数：</p><h5 id="platform-set-periodic-timer"><a href="#platform-set-periodic-timer" class="headerlink" title="platform_set_periodic_timer"></a>platform_set_periodic_timer</h5><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">status_t platform_set_periodic_timer(platform_timer_callback callback, void *arg, lk_time_t interval)</span><br><span class="line">&#123;</span><br><span class="line">    LTRACEF(&quot;cb %p, arg %p, interval %ld\n&quot;, callback, arg, interval);</span><br><span class="line"></span><br><span class="line">    uint32_t ttmr = (uint64_t)timer_freq * interval / 1000;</span><br><span class="line">    LTRACEF(&quot;count 0x%x\n&quot;, ttmr);</span><br><span class="line"></span><br><span class="line">    timer_cb = callback;</span><br><span class="line">    timer_arg = arg;</span><br><span class="line"></span><br><span class="line">    /* disable timer before doing changes */</span><br><span class="line">    mtspr(OR1K_SPR_TICK_TTMR_ADDR, 0);</span><br><span class="line">    /* reset timer counter */</span><br><span class="line">    mtspr(OR1K_SPR_TICK_TTCR_ADDR, 0);</span><br><span class="line">    /* enable timer with given interval in &#x27;restart&#x27; mode */</span><br><span class="line">    ttmr = OR1K_SPR_TICK_TTMR_MODE_SET(ttmr | OR1K_SPR_TICK_TTMR_IE_MASK,</span><br><span class="line">                                       OR1K_SPR_TICK_TTMR_MODE_RESTART);</span><br><span class="line">    mtspr(OR1K_SPR_TICK_TTMR_ADDR, ttmr);</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.根据interval计算定时器计数器需要设置的初始值ttmr。<br>2.设置中断服务程序中要执行的callback函数。<br>3.关闭定时器并配置定时器参数。<br>4.启动定时器。</p><h5 id="platform-tick-1"><a href="#platform-tick-1" class="headerlink" title="platform_tick"></a>platform_tick</h5><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum handler_return platform_tick(void)</span><br><span class="line">&#123;</span><br><span class="line">    ticks++;</span><br><span class="line"></span><br><span class="line">    /* clear pending interrupt flag */</span><br><span class="line">    mtspr(OR1K_SPR_TICK_TTMR_ADDR,</span><br><span class="line">          mfspr(OR1K_SPR_TICK_TTMR_ADDR) &amp; ~(OR1K_SPR_TICK_TTMR_IP_MASK));</span><br><span class="line"></span><br><span class="line">    return timer_cb(timer_arg, ticks * 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.清除中断标记位。<br>2.执行callback函数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Little Kernel 02</title>
      <link href="/2018/11/13/Little-Kernel-02/"/>
      <url>/2018/11/13/Little-Kernel-02/</url>
      
        <content type="html"><![CDATA[<h3 id="LK-kernel-thread"><a href="#LK-kernel-thread" class="headerlink" title="LK kernel thread"></a>LK kernel thread</h3><p>Warning: many of the functions in here are for internal use of the kernel.</p><span id="more"></span><p>There are 32 priority levels. DEFAULT_PRIORITY is appropriate for typical threads. LOW_PRIORITY and HIGH_PRIORITY are relative to default priority. Threads that are set to real time will not be preempted by other threads of the same or lower priority when they are running. Use with caution.</p><p>Threads do not begin running until thread_resume() is called on them. Typically calls to thread_create() are followed immediately by thread_resume(). Threads that exit will wait, consuming resources like stack space until thread_join() is called to obtain their exit status, unless thread_detach() is called on them prior to exit (in which case they will silently exit and clean up). Threads may give up their quantum voluntarily by calling thread_yield().</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a_thread_start_routine(void *arg);</span><br></pre></td></tr></table></figure><p>Functions to create, start, and obtain exit status from a thread:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread_t *thread_create(const char *name, thread_start_routine entry, void *arg, int priority, size_t stack_size);</span><br><span class="line">status_t thread_resume(thread_t *);</span><br><span class="line">status_t thread_detach(thread_t *t);</span><br><span class="line">status_t thread_detach_and_resume(thread_t *t);</span><br><span class="line">status_t thread_join(thread_t *t, int *retcode, lk_time_t timeout);</span><br></pre></td></tr></table></figure><p>Functions to temporarily or permanently stop executing a thread:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void thread_yield(void);</span><br><span class="line">void thread_sleep(lk_time_t delay);</span><br><span class="line">void thread_exit(int retcode);</span><br></pre></td></tr></table></figure><p>Functions for a thread to modify its state:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void thread_set_name(const char *name);</span><br><span class="line">void thread_set_priority(int priority);</span><br><span class="line">status_t thread_set_real_time(thread_t *t);</span><br></pre></td></tr></table></figure><h4 id="thread-init"><a href="#thread-init" class="headerlink" title="thread_init"></a>thread_init</h4><p>thread_init 函数位于 kernel&#x2F;thread.c 文件中，关于线程的初始化在 thread_init_early 中已经完成。前一篇文章中已对thread_init_early做了解析。</p><h4 id="thread-create"><a href="#thread-create" class="headerlink" title="thread_create"></a>thread_create</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_t *thread_create(const char *name, thread_start_routine entry, void *arg, int priority, size_t stack_size)</span><br><span class="line">&#123;</span><br><span class="line">    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread_create_etc代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  Create a new thread</span><br><span class="line"> *</span><br><span class="line"> * This function creates a new thread.  The thread is initially suspended, so you</span><br><span class="line"> * need to call thread_resume() to execute it.</span><br><span class="line"> *</span><br><span class="line"> * @param  name        Name of thread</span><br><span class="line"> * @param  entry       Entry point of thread</span><br><span class="line"> * @param  arg         Arbitrary argument passed to entry()</span><br><span class="line"> * @param  priority    Execution priority for the thread.</span><br><span class="line"> * @param  stack_size  Stack size for the thread.</span><br><span class="line"> *</span><br><span class="line"> * Thread priority is an integer from 0 (lowest) to 31 (highest).  Some standard</span><br><span class="line"> * prioritys are defined in &lt;kernel/thread.h&gt;:</span><br><span class="line"> *</span><br><span class="line"> *  HIGHEST_PRIORITY</span><br><span class="line"> *  DPC_PRIORITY</span><br><span class="line"> *  HIGH_PRIORITY</span><br><span class="line"> *  DEFAULT_PRIORITY</span><br><span class="line"> *  LOW_PRIORITY</span><br><span class="line"> *  IDLE_PRIORITY</span><br><span class="line"> *  LOWEST_PRIORITY</span><br><span class="line"> *</span><br><span class="line"> * Stack size is typically set to DEFAULT_STACK_SIZE</span><br><span class="line"> *</span><br><span class="line"> * @return  Pointer to thread object, or NULL on failure.</span><br><span class="line"> */</span><br><span class="line">thread_t *thread_create_etc(thread_t *t, const char *name, thread_start_routine entry, void *arg, int priority, void *stack, size_t stack_size)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int flags = 0;</span><br><span class="line"></span><br><span class="line">    if (!t) &#123;</span><br><span class="line">        t = malloc(sizeof(thread_t));</span><br><span class="line">        if (!t)</span><br><span class="line">            return NULL;</span><br><span class="line">        flags |= THREAD_FLAG_FREE_STRUCT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_thread_struct(t, name);</span><br><span class="line"></span><br><span class="line">    t-&gt;entry = entry;</span><br><span class="line">    t-&gt;arg = arg;</span><br><span class="line">    t-&gt;priority = priority;</span><br><span class="line">    t-&gt;state = THREAD_SUSPENDED;</span><br><span class="line">    t-&gt;blocking_wait_queue = NULL;</span><br><span class="line">    t-&gt;wait_queue_block_ret = NO_ERROR;</span><br><span class="line">    thread_set_curr_cpu(t, -1);</span><br><span class="line"></span><br><span class="line">    t-&gt;retcode = 0;</span><br><span class="line">    wait_queue_init(&amp;t-&gt;retcode_wait_queue);</span><br><span class="line"></span><br><span class="line">#if WITH_KERNEL_VM</span><br><span class="line">    t-&gt;aspace = NULL;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* create the stack */</span><br><span class="line">    if (!stack) &#123;</span><br><span class="line">#if THREAD_STACK_BOUNDS_CHECK</span><br><span class="line">        stack_size += THREAD_STACK_PADDING_SIZE;</span><br><span class="line">        flags |= THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK;</span><br><span class="line">#endif</span><br><span class="line">        t-&gt;stack = malloc(stack_size);</span><br><span class="line">        if (!t-&gt;stack) &#123;</span><br><span class="line">            if (flags &amp; THREAD_FLAG_FREE_STRUCT)</span><br><span class="line">                free(t);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        flags |= THREAD_FLAG_FREE_STACK;</span><br><span class="line">#if THREAD_STACK_BOUNDS_CHECK</span><br><span class="line">        memset(t-&gt;stack, STACK_DEBUG_BYTE, THREAD_STACK_PADDING_SIZE);</span><br><span class="line">#endif</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t-&gt;stack = stack;</span><br><span class="line">    &#125;</span><br><span class="line">#if THREAD_STACK_HIGHWATER</span><br><span class="line">    if (flags &amp; THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK) &#123;</span><br><span class="line">        memset(t-&gt;stack + THREAD_STACK_PADDING_SIZE, STACK_DEBUG_BYTE,</span><br><span class="line">               stack_size - THREAD_STACK_PADDING_SIZE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        memset(t-&gt;stack, STACK_DEBUG_BYTE, stack_size);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    t-&gt;stack_size = stack_size;</span><br><span class="line"></span><br><span class="line">    /* save whether or not we need to free the thread struct and/or stack */</span><br><span class="line">    t-&gt;flags = flags;</span><br><span class="line"></span><br><span class="line">    /* inheirit thread local storage from the parent */</span><br><span class="line">    thread_t *current_thread = get_current_thread();</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i &lt; MAX_TLS_ENTRY; i++)</span><br><span class="line">        t-&gt;tls[i] = current_thread-&gt;tls[i];</span><br><span class="line"></span><br><span class="line">    /* set up the initial stack frame */</span><br><span class="line">    arch_thread_initialize(t);</span><br><span class="line"></span><br><span class="line">    /* add it to the global thread list */</span><br><span class="line">    THREAD_LOCK(state);</span><br><span class="line">    list_add_head(&amp;thread_list, &amp;t-&gt;thread_list_node);</span><br><span class="line">    THREAD_UNLOCK(state);</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread_create 的逻辑比较简单，总体上来说只有 3 个步骤：<br>申请并填充 thread_t 结构体<br>初始化线程栈空间<br>添加线程到 thread_list 头部</p><h5 id="arch-thread-initialize-t"><a href="#arch-thread-initialize-t" class="headerlink" title="arch_thread_initialize(t)"></a>arch_thread_initialize(t)</h5><p>lk 的线程栈初始化。<br>线程栈的初始化由 arch_thread_initialize 完成，这个函数位于 arch&#x2F;arm&#x2F;thread.c 文件中，其代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct context_switch_frame &#123;</span><br><span class="line">    vaddr_t r4;</span><br><span class="line">    vaddr_t r5;</span><br><span class="line">    vaddr_t r6;</span><br><span class="line">    vaddr_t r7;</span><br><span class="line">    vaddr_t r8;</span><br><span class="line">    vaddr_t r9;</span><br><span class="line">    vaddr_t r10;</span><br><span class="line">    vaddr_t r11;</span><br><span class="line">    vaddr_t lr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void arch_thread_initialize(thread_t *t)</span><br><span class="line">&#123;</span><br><span class="line">    // create a default stack frame on the stack</span><br><span class="line">    vaddr_t stack_top = (vaddr_t)t-&gt;stack + t-&gt;stack_size;</span><br><span class="line"></span><br><span class="line">    // make sure the top of the stack is 8 byte aligned for EABI compliance</span><br><span class="line">    stack_top = ROUNDDOWN(stack_top, 8);</span><br><span class="line"></span><br><span class="line">    struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);</span><br><span class="line">    frame--;</span><br><span class="line"></span><br><span class="line">    // fill it in</span><br><span class="line">    memset(frame, 0, sizeof(*frame));</span><br><span class="line">    frame-&gt;lr = (vaddr_t)&amp;initial_thread_func;</span><br><span class="line"></span><br><span class="line">    // set the stack pointer</span><br><span class="line">    t-&gt;arch.sp = (vaddr_t)frame;</span><br><span class="line"></span><br><span class="line">#if ARM_WITH_VFP</span><br><span class="line">    arm_fpu_thread_initialize(t);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化线程栈空间其实就是在栈顶使用一块空间用于后续保存寄存器信息以方便线程切换。需要保存的寄存器信息定义在 context_switch_frame 结构体中，其中 lr 用于保存线程函数入口。 当这块内存空间设置好以后，线程栈的初始化工作基本就完成了，剩下的就是通过 thread_resume 来启动线程。</p><h4 id="thread-resume"><a href="#thread-resume" class="headerlink" title="thread_resume"></a>thread_resume</h4><p>thread_resume 函数位于 kernel&#x2F;thread.c 文件中，其代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  Make a suspended thread executable.</span><br><span class="line"> *</span><br><span class="line"> * This function is typically called to start a thread which has just been</span><br><span class="line"> * created with thread_create()</span><br><span class="line"> *</span><br><span class="line"> * @param t  Thread to resume</span><br><span class="line"> *</span><br><span class="line"> * @return NO_ERROR on success, ERR_NOT_SUSPENDED if thread was not suspended.</span><br><span class="line"> */</span><br><span class="line">status_t thread_resume(thread_t *t)</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG_ASSERT(t-&gt;magic == THREAD_MAGIC);</span><br><span class="line">    DEBUG_ASSERT(t-&gt;state != THREAD_DEATH);</span><br><span class="line"></span><br><span class="line">    bool resched = false;</span><br><span class="line">    bool ints_disabled = arch_ints_disabled();</span><br><span class="line">    THREAD_LOCK(state);</span><br><span class="line">    if (t-&gt;state == THREAD_SUSPENDED) &#123;</span><br><span class="line">        t-&gt;state = THREAD_READY;</span><br><span class="line">        insert_in_run_queue_head(t);</span><br><span class="line">        if (!ints_disabled) /* HACK, don&#x27;t resced into bootstrap thread before idle thread is set up */</span><br><span class="line">            resched = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp_reschedule(MP_CPU_ALL_BUT_LOCAL, 0);</span><br><span class="line"></span><br><span class="line">    THREAD_UNLOCK(state);</span><br><span class="line"></span><br><span class="line">    if (resched)</span><br><span class="line">        thread_yield();</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑简单明了，只有以下两个步骤：<br>修改 thread 的状态为 THREAD_READY, 然后添加到 run_queue 中。</p><h5 id="insert-in-run-queue-head"><a href="#insert-in-run-queue-head" class="headerlink" title="insert_in_run_queue_head"></a>insert_in_run_queue_head</h5><p>insert_in_run_queue_head 函数位于同一文件中，其代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void insert_in_run_queue_tail(thread_t *t)</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG_ASSERT(t-&gt;magic == THREAD_MAGIC);</span><br><span class="line">    DEBUG_ASSERT(t-&gt;state == THREAD_READY);</span><br><span class="line">    DEBUG_ASSERT(!list_in_list(&amp;t-&gt;queue_node));</span><br><span class="line">    DEBUG_ASSERT(arch_ints_disabled());</span><br><span class="line">    DEBUG_ASSERT(spin_lock_held(&amp;thread_lock));</span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;run_queue[t-&gt;priority], &amp;t-&gt;queue_node);</span><br><span class="line">    run_queue_bitmap |= (1&lt;&lt;t-&gt;priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run_queue 在 thread_init_early 中已经有过了解，就是一个大小为 32 的全局链表数组，这个数组每一项对应一个线程优先级，下标越大的数组项优先级越大。比较有趣的是使用了一个uint32类型的全局变量 run_queue_bitmap 来作为优先级的索引。这个变量的每一位对应数组的每一项, 通过检查对应位的值是 0 或 1 就可以知道优先级的使用情况。</p><h4 id="thread-yield"><a href="#thread-yield" class="headerlink" title="thread_yield"></a>thread_yield</h4><p>调用 thread_yield 来获取 cpu 执行。thread_yield 函数位于同一文件中，主要是修改current_thread 的状态的 THREAD_READY并插入对应优先级项链表的尾部，然后调用 thread_resched 函数来切换线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Yield the cpu to another thread</span><br><span class="line"> *</span><br><span class="line"> * This function places the current thread at the end of the run queue</span><br><span class="line"> * and yields the cpu to another waiting thread (if any.)</span><br><span class="line"> *</span><br><span class="line"> * This function will return at some later time. Possibly immediately if</span><br><span class="line"> * no other threads are waiting to execute.</span><br><span class="line"> */</span><br><span class="line">void thread_yield(void)</span><br><span class="line">&#123;</span><br><span class="line">    thread_t *current_thread = get_current_thread();</span><br><span class="line"></span><br><span class="line">    DEBUG_ASSERT(current_thread-&gt;magic == THREAD_MAGIC);</span><br><span class="line">    DEBUG_ASSERT(current_thread-&gt;state == THREAD_RUNNING);</span><br><span class="line"></span><br><span class="line">    THREAD_LOCK(state);</span><br><span class="line"></span><br><span class="line">    THREAD_STATS_INC(yields);</span><br><span class="line"></span><br><span class="line">    /* we are yielding the cpu, so stick ourselves into the tail of the run queue and reschedule */</span><br><span class="line">    current_thread-&gt;state = THREAD_READY;</span><br><span class="line">    current_thread-&gt;remaining_quantum = 0;</span><br><span class="line">    if (likely(!thread_is_idle(current_thread))) &#123; /* idle thread doesn&#x27;t go in the run queue */</span><br><span class="line">        insert_in_run_queue_tail(current_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    thread_resched();</span><br><span class="line"></span><br><span class="line">    THREAD_UNLOCK(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="thread-resched"><a href="#thread-resched" class="headerlink" title="thread_resched"></a>thread_resched</h5><p>切换线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  Cause another thread to be executed.</span><br><span class="line"> *</span><br><span class="line"> * Internal reschedule routine. The current thread needs to already be in whatever</span><br><span class="line"> * state and queues it needs to be in. This routine simply picks the next thread and</span><br><span class="line"> * switches to it.</span><br><span class="line"> *</span><br><span class="line"> * This is probably not the function you&#x27;re looking for. See</span><br><span class="line"> * thread_yield() instead.</span><br><span class="line"> */</span><br><span class="line">void thread_resched(void)</span><br><span class="line">&#123;</span><br><span class="line">    thread_t *oldthread;</span><br><span class="line">    thread_t *newthread;</span><br><span class="line"></span><br><span class="line">    thread_t *current_thread = get_current_thread();</span><br><span class="line">    uint cpu = arch_curr_cpu_num();</span><br><span class="line"></span><br><span class="line">    DEBUG_ASSERT(arch_ints_disabled());</span><br><span class="line">    DEBUG_ASSERT(spin_lock_held(&amp;thread_lock));</span><br><span class="line">    DEBUG_ASSERT(current_thread-&gt;state != THREAD_RUNNING);</span><br><span class="line"></span><br><span class="line">    THREAD_STATS_INC(reschedules);</span><br><span class="line"></span><br><span class="line">    newthread = get_top_thread(cpu);</span><br><span class="line"></span><br><span class="line">    DEBUG_ASSERT(newthread);</span><br><span class="line"></span><br><span class="line">    newthread-&gt;state = THREAD_RUNNING;</span><br><span class="line"></span><br><span class="line">    oldthread = current_thread;</span><br><span class="line"></span><br><span class="line">    if (newthread == oldthread)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    /* set up quantum for the new thread if it was consumed */</span><br><span class="line">    if (newthread-&gt;remaining_quantum &lt;= 0) &#123;</span><br><span class="line">        newthread-&gt;remaining_quantum = 5; // XXX make this smarter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* mark the cpu ownership of the threads */</span><br><span class="line">    thread_set_curr_cpu(oldthread, -1);</span><br><span class="line">    thread_set_curr_cpu(newthread, cpu);</span><br><span class="line"></span><br><span class="line">#if WITH_SMP</span><br><span class="line">    if (thread_is_idle(newthread)) &#123;</span><br><span class="line">        mp_set_cpu_idle(cpu);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mp_set_cpu_busy(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (thread_is_realtime(newthread)) &#123;</span><br><span class="line">        mp_set_cpu_realtime(cpu);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mp_set_cpu_non_realtime(cpu);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if THREAD_STATS</span><br><span class="line">    THREAD_STATS_INC(context_switches);</span><br><span class="line"></span><br><span class="line">    if (thread_is_idle(oldthread)) &#123;</span><br><span class="line">        lk_bigtime_t now = current_time_hires();</span><br><span class="line">        thread_stats[cpu].idle_time += now - thread_stats[cpu].last_idle_timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    if (thread_is_idle(newthread)) &#123;</span><br><span class="line">        thread_stats[cpu].last_idle_timestamp = current_time_hires();</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    KEVLOG_THREAD_SWITCH(oldthread, newthread);</span><br><span class="line"></span><br><span class="line">#if PLATFORM_HAS_DYNAMIC_TIMER</span><br><span class="line">    if (thread_is_real_time_or_idle(newthread)) &#123;</span><br><span class="line">        if (!thread_is_real_time_or_idle(oldthread)) &#123;</span><br><span class="line">            /* if we&#x27;re switching from a non real time to a real time, cancel</span><br><span class="line">             * the preemption timer. */</span><br><span class="line">#if DEBUG_THREAD_CONTEXT_SWITCH</span><br><span class="line">            dprintf(ALWAYS, &quot;arch_context_switch: stop preempt, cpu %d, old %p (%s), new %p (%s)\n&quot;,</span><br><span class="line">                    cpu, oldthread, oldthread-&gt;name, newthread, newthread-&gt;name);</span><br><span class="line">#endif</span><br><span class="line">            timer_cancel(&amp;preempt_timer[cpu]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (thread_is_real_time_or_idle(oldthread)) &#123;</span><br><span class="line">        /* if we&#x27;re switching from a real time (or idle thread) to a regular one,</span><br><span class="line">         * set up a periodic timer to run our preemption tick. */</span><br><span class="line">#if DEBUG_THREAD_CONTEXT_SWITCH</span><br><span class="line">        dprintf(ALWAYS, &quot;arch_context_switch: start preempt, cpu %d, old %p (%s), new %p (%s)\n&quot;,</span><br><span class="line">                cpu, oldthread, oldthread-&gt;name, newthread, newthread-&gt;name);</span><br><span class="line">#endif</span><br><span class="line">        timer_set_periodic(&amp;preempt_timer[cpu], 10, (timer_callback)thread_timer_tick, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* set some optional target debug leds */</span><br><span class="line">    target_set_debug_led(0, !thread_is_idle(newthread));</span><br><span class="line"></span><br><span class="line">    /* do the switch */</span><br><span class="line">    set_current_thread(newthread);</span><br><span class="line"></span><br><span class="line">#if DEBUG_THREAD_CONTEXT_SWITCH</span><br><span class="line">    dprintf(ALWAYS, &quot;arch_context_switch: cpu %d, old %p (%s, pri %d, flags 0x%x), new %p (%s, pri %d, flags 0x%x)\n&quot;,</span><br><span class="line">            cpu, oldthread, oldthread-&gt;name, oldthread-&gt;priority,</span><br><span class="line">            oldthread-&gt;flags, newthread, newthread-&gt;name,</span><br><span class="line">            newthread-&gt;priority, newthread-&gt;flags);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if THREAD_STACK_BOUNDS_CHECK</span><br><span class="line">    /* check that the old thread has not blown its stack just before pushing its context */</span><br><span class="line">    if (oldthread-&gt;flags &amp; THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK) &#123;</span><br><span class="line">        STATIC_ASSERT((THREAD_STACK_PADDING_SIZE % sizeof(uint32_t)) == 0);</span><br><span class="line">        uint32_t *s = (uint32_t *)oldthread-&gt;stack;</span><br><span class="line">        for (size_t i = 0; i &lt; THREAD_STACK_PADDING_SIZE / sizeof(uint32_t); i++) &#123;</span><br><span class="line">            if (unlikely(s[i] != STACK_DEBUG_WORD)) &#123;</span><br><span class="line">                /* NOTE: will probably blow the stack harder here, but hopefully enough</span><br><span class="line">                 * state exists to at least get some sort of debugging done.</span><br><span class="line">                 */</span><br><span class="line">                panic(&quot;stack overrun at %p: thread %p (%s), stack %p\n&quot;, &amp;s[i],</span><br><span class="line">                      oldthread, oldthread-&gt;name, oldthread-&gt;stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef WITH_LIB_UTHREAD</span><br><span class="line">    uthread_context_switch(oldthread, newthread);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if WITH_KERNEL_VM</span><br><span class="line">    /* see if we need to swap mmu context */</span><br><span class="line">    if (newthread-&gt;aspace != oldthread-&gt;aspace) &#123;</span><br><span class="line">        vmm_context_switch(oldthread-&gt;aspace, newthread-&gt;aspace);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* do the low level context switch */</span><br><span class="line">    arch_context_switch(oldthread, newthread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程如下：</p><p>通过get_top_thread(cpu)函数从 run_queue_bitmap 中获取优先级最高的线程。<br>设置线程状态为 THREAD_RUNNING, 如果新线程不等于老线程则调用 arch_context_switch 切换线程。arch_context_switch 函数位于 arch&#x2F;arm&#x2F;thread.c 文件中，只是作为转接 arm_context_switch 的媒介。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void arch_context_switch(thread_t *oldthread, thread_t *newthread)</span><br><span class="line">&#123;</span><br><span class="line">//  TRACEF(&quot;arch_context_switch: cpu %u old %p (%s), new %p (%s)\n&quot;, arch_curr_cpu_num(), oldthread, oldthread-&gt;name, newthread, newthread-&gt;name);</span><br><span class="line">#if ARM_WITH_VFP</span><br><span class="line">    arm_fpu_thread_swap(oldthread, newthread);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    arm_context_switch(&amp;oldthread-&gt;arch.sp, newthread-&gt;arch.sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>arm_context_switch 函数位于 arch&#x2F;arm&#x2F;asm.S 文件中，是汇编代码，其代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    /* context switch frame is as follows:</span><br><span class="line">     * lr</span><br><span class="line">     * r11</span><br><span class="line">     * r10</span><br><span class="line">     * r9</span><br><span class="line">     * r8</span><br><span class="line">     * r7</span><br><span class="line">     * r6</span><br><span class="line">     * r5</span><br><span class="line">     * r4</span><br><span class="line">     */</span><br><span class="line">/* arm_context_switch(addr_t *old_sp, addr_t new_sp) */</span><br><span class="line">FUNCTION(arm_context_switch)</span><br><span class="line">    /* save non callee trashed supervisor registers */</span><br><span class="line">    /* spsr and user mode registers are saved and restored in the iframe by exceptions.S */</span><br><span class="line">    push    &#123; r4-r11, lr &#125;</span><br><span class="line"></span><br><span class="line">    /* save old sp */</span><br><span class="line">    str     sp, [r0]</span><br><span class="line"></span><br><span class="line">    /* clear any exlusive locks that the old thread holds */</span><br><span class="line">#if ARM_ARCH_LEVEL &gt;= 7</span><br><span class="line">    /* can clear it directly */</span><br><span class="line">    clrex</span><br><span class="line">#elif ARM_ARCH_LEVEL == 6</span><br><span class="line">    /* have to do a fake strex to clear it */</span><br><span class="line">    ldr     r0, =strex_spot</span><br><span class="line">    strex   r3, r2, [r0]</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* load new regs */</span><br><span class="line">    mov     sp, r1</span><br><span class="line">    pop     &#123; r4-r11, lr &#125;</span><br><span class="line">    bx      lr</span><br></pre></td></tr></table></figure><p>函数的功能很简单，保存 old_thread 的寄存器环境到内存，从内存加载 new_thread 的寄存器环境，跳转到线程入口,到这里新的线程就会执行起来。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Little Kernel 01</title>
      <link href="/2018/11/03/Little-Kernel-01/"/>
      <url>/2018/11/03/Little-Kernel-01/</url>
      
        <content type="html"><![CDATA[<h3 id="LK是什么"><a href="#LK是什么" class="headerlink" title="LK是什么"></a>LK是什么</h3><p>LK 是 Little Kernel 它是 appsbl （Applications ARM Boot Loader）流程代码  ，little kernel 是小内核小操作系统。</p><span id="more"></span><p><a href="https://github.com/littlekernel/lk">lk</a><br><a href="https://github.com/littlekernel/lk/wiki">lk doc</a></p><p>LK主要功能：</p><ul><li>初始化硬件模块，如时钟，中断，UART，USB，LCD，PMIC，eMMC&#x2F;UFS等。</li><li>更新cmdline。其中重要的是区分启动模式。</li><li>选择和更新device tree。</li><li>设置好系统状态，跳转到kernel。 MMU &#x3D; off, D-cache &#x3D; off, I-cache &#x3D; on or off，x0 &#x3D; physical address to the FDT blob。</li><li>fastboot功能。</li><li>鉴权。</li></ul><p>LK 代码结构:</p><ul><li>app<br>&#x2F;&#x2F; 应用相关</li><li>arch<br>&#x2F;&#x2F; arm 体系 </li><li>dev<br>&#x2F;&#x2F; 设备相关</li><li>include<br>&#x2F;&#x2F; 头文件</li><li>kernel<br>&#x2F;&#x2F; lk系统相关   </li><li>platform<br>&#x2F;&#x2F; 相关驱动</li><li>projiect<br>&#x2F;&#x2F; makefile文件</li><li>scripts<br>&#x2F;&#x2F; Jtag 脚本</li><li>target<br>&#x2F;&#x2F; 具体板子相关</li></ul><h3 id="一些宏定义"><a href="#一些宏定义" class="headerlink" title="一些宏定义"></a>一些宏定义</h3><table><thead><tr><th>宏定义</th><th>意思</th></tr></thead><tbody><tr><td>WITH_KERNEL_VM</td><td>支持虚拟内存</td></tr><tr><td>WITH_SMP</td><td>支持多核</td></tr><tr><td>ARM_CPU_CORTEX_A8</td><td>A8架构</td></tr><tr><td>ARM_WITH_MMU</td><td>支持MMU</td></tr></tbody></table><h3 id="LK流程分析"><a href="#LK流程分析" class="headerlink" title="LK流程分析"></a>LK流程分析</h3><p>lk主要任务：</p><ul><li>1.进行各种早期的初始化工作，包括 cpu, emmc, ddr, clocks, thread etc。</li><li>2.判断进入 recovery 或 fastboot 的条件是否被触发。</li><li>3.从 emmc 中获取 boot.img 并加载到指定内存区域 (scratch region)。</li><li>4.从 scratch region 加载 kernel 到 KERNEL_ADDRESS 。</li><li>5.从 scratch region 加载 ramdisk 到 RAMDISK_ADDRESS 。</li><li>6.加载设备树到 TAGS_ADDRESS 。</li><li>7.关闭 cache, interrupts, 跳转到 kernel。</li></ul><p>在 lk&#x2F;arch&#x2F;arm64&#x2F;ssystem-onesegment.ld 连接文件中 ENTRY（_start）指定 LK 从_start 函数开始，_start 在 lk&#x2F;arch&#x2F;start.S中 。</p><p>start.S 主要做一些基本的 CPU 的初始化。</p><ul><li>1.enable caches so atomics and spinlocks work</li><li>2.set up the mmu（主要部分）</li><li>3.clear bss</li><li>4.Set up the stack<br>最后，通过bl  lk_main跳转到 C 代码中。</li></ul><p>在lk&#x2F;top&#x2F;main.c中定义了lk_main函数。</p><h4 id="lk-main流程"><a href="#lk-main流程" class="headerlink" title="lk_main流程"></a>lk_main流程</h4><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/little_kernel/1.png" alt="lk main流程"><br>1.thread_init_early()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// get us into some sort of thread context</span><br><span class="line">thread_init_early(); </span><br></pre></td></tr></table></figure><p>初始化进程（lk 中的简单进程）相关结构体，初始化lk的线程系统。</p><p>2.arch_early_init()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// early arch stuff</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_ARCH_EARLY - 1);</span><br><span class="line">arch_early_init();</span><br></pre></td></tr></table></figure><p>架构相关早期初始化，arch_early_init 和所使用的 CPU架构有很强的耦合性，这个函数的代码也主要是针对 CPU 的一些特性做设置。做一些如 关闭cache，使能 mmu ，开启一些协处理器特性的 arm 相关工作。</p><p>3.platform_early_init()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// do any super early platform initialization</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH_EARLY, LK_INIT_LEVEL_PLATFORM_EARLY - 1);</span><br><span class="line">platform_early_init();</span><br></pre></td></tr></table></figure><p>相关平台的早期初始化，如获取板级信息，初始化时钟、中断、定时器等，为 lk的启动和运行提供硬件环境。</p><p>4.target_early_init()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// do any super early target initialization</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_LEVEL_TARGET_EARLY - 1);</span><br><span class="line">target_early_init();</span><br></pre></td></tr></table></figure><p>初始化板子相关，其中只初始化了串口，开启uart调试接口。</p><p>5.heap_init()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bring up the kernel heap</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET_EARLY, LK_INIT_LEVEL_HEAP - 1);</span><br><span class="line">dprintf(SPEW, &quot;initializing heap\n&quot;);</span><br><span class="line">heap_init();</span><br></pre></td></tr></table></figure><p>lk系统相关的堆栈初始化，用于malloc等函数的内存分配</p><p>6.call_constructors()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// deal with any static constructors</span><br><span class="line">dprintf(SPEW, &quot;calling constructors\n&quot;);</span><br><span class="line">call_constructors();</span><br></pre></td></tr></table></figure><p>构造函数相关初始化，这个函数是 lk 和 c++ 联合编译使用的特性，主要是为了调用 c++ 代码的构造函数，单纯的 lk 中这个函数并没有作用。</p><p>7.kernel_init()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// initialize the kernel</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_HEAP, LK_INIT_LEVEL_KERNEL - 1);</span><br><span class="line">kernel_init();</span><br></pre></td></tr></table></figure><p>内核初始化。</p><p>8.创建并唤醒bootstrap2线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_KERNEL, LK_INIT_LEVEL_THREADING - 1);</span><br><span class="line"></span><br><span class="line">// create a thread to complete system initialization</span><br><span class="line">dprintf(SPEW, &quot;creating bootstrap completion thread\n&quot;);</span><br><span class="line">thread_t *t = thread_create(&quot;bootstrap2&quot;, &amp;bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);</span><br><span class="line">thread_set_pinned_cpu(t, 0);</span><br><span class="line">thread_detach(t);</span><br><span class="line">thread_resume(t);</span><br><span class="line"></span><br><span class="line">// become the idle thread and enable interrupts to start the scheduler</span><br><span class="line">thread_become_idle();</span><br></pre></td></tr></table></figure><p>用于进一步完成bootloader工作，最终将本线程切换到idle状态。</p><p><strong>以上与 boot 启动初始化相关函数是 arch_early_init、  platform_early_init 、bootstrap2</strong></p><p>lk_init相关定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">enum lk_init_level &#123;</span><br><span class="line">    LK_INIT_LEVEL_EARLIEST = 1,</span><br><span class="line"></span><br><span class="line">    LK_INIT_LEVEL_ARCH_EARLY     = 0x10000,</span><br><span class="line">    LK_INIT_LEVEL_PLATFORM_EARLY = 0x20000,</span><br><span class="line">    LK_INIT_LEVEL_TARGET_EARLY   = 0x30000,</span><br><span class="line">    LK_INIT_LEVEL_HEAP           = 0x40000,</span><br><span class="line">    LK_INIT_LEVEL_VM             = 0x50000,</span><br><span class="line">    LK_INIT_LEVEL_KERNEL         = 0x60000,</span><br><span class="line">    LK_INIT_LEVEL_THREADING      = 0x70000,</span><br><span class="line">    LK_INIT_LEVEL_ARCH           = 0x80000,</span><br><span class="line">    LK_INIT_LEVEL_PLATFORM       = 0x90000,</span><br><span class="line">    LK_INIT_LEVEL_TARGET         = 0xa0000,</span><br><span class="line">    LK_INIT_LEVEL_APPS           = 0xb0000,</span><br><span class="line"></span><br><span class="line">    LK_INIT_LEVEL_LAST = UINT_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum lk_init_flags &#123;</span><br><span class="line">    LK_INIT_FLAG_PRIMARY_CPU     = 0x1,</span><br><span class="line">    LK_INIT_FLAG_SECONDARY_CPUS  = 0x2,</span><br><span class="line">    LK_INIT_FLAG_ALL_CPUS        = LK_INIT_FLAG_PRIMARY_CPU | LK_INIT_FLAG_SECONDARY_CPUS,</span><br><span class="line">    LK_INIT_FLAG_CPU_SUSPEND     = 0x4,</span><br><span class="line">    LK_INIT_FLAG_CPU_RESUME      = 0x8,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="thread-init-early"><a href="#thread-init-early" class="headerlink" title="thread_init_early()"></a>thread_init_early()</h4><p>lk系统的thread初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i=0; i &lt; NUM_PRIORITIES; i++)     //NUM_PRIORITIES=32</span><br><span class="line">    list_initialize(&amp;run_queue[i]);    //初始化32个运行队列</span><br></pre></td></tr></table></figure><p>thread_init_early 所完成的主要工作就是为 lk 完成早期的线程初始化工作，包括运行队列 的初始化，线程链表的初始化，第一个线程的创建等工作。在这个过程中一共有以下重要的数据结构：</p><ul><li>运行队列 run_queue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define NUM_PRIORITIES 32</span><br><span class="line"></span><br><span class="line">struct list_node &#123;</span><br><span class="line">  struct list_node *prev;</span><br><span class="line">  struct list_node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct list_node run_queue[NUM_PRIORITIES];</span><br></pre></td></tr></table></figure>run_queue 是作为多线程的调度中心存在，数组不同的下标对应不同的<strong>运行优先级</strong>，具体的应用会在后面涉及到。  </li><li>线程链表 thread_list<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static struct list_node thread_list;</span><br></pre></td></tr></table></figure>全局的线程链表，保存了所有创建的线程信息。</li><li>bootstrap 线程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* create a thread to cover the current running state */</span><br><span class="line">thread_t *t = idle_thread(0);</span><br><span class="line">init_thread_struct(t, &quot;bootstrap&quot;);</span><br><span class="line"></span><br><span class="line">/* half construct this thread, since we&#x27;re already running */</span><br><span class="line">t-&gt;priority = HIGHEST_PRIORITY;</span><br><span class="line">t-&gt;state = THREAD_RUNNING;</span><br><span class="line">t-&gt;flags = THREAD_FLAG_DETACHED;</span><br><span class="line">thread_set_curr_cpu(t, 0);</span><br><span class="line">thread_set_pinned_cpu(t, 0);</span><br><span class="line">wait_queue_init(&amp;t-&gt;retcode_wait_queue);</span><br><span class="line">list_add_head(&amp;thread_list, &amp;t-&gt;thread_list_node);</span><br><span class="line">set_current_thread(t);</span><br></pre></td></tr></table></figure>每个线程的上下文信息都通过 thread_t 结构体保存，而 bootstrap 是作为 lk的第一个线程存在, 拥有 最高优先级(HIGHEST_PROORITY) 。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* since we&#x27;re implicitly uniprocessor, store a pointer to the current thread here */</span><br><span class="line">thread_t *_current_thread;</span><br></pre></td></tr></table></figure>current_thread 是一个全局变量，保存了当前运行的线程的信息。<br>这些数据结构都进行了初始化后，lk 就具有了创建和管理线程的结构及能力。</li></ul><h4 id="arch-early-init"><a href="#arch-early-init" class="headerlink" title="arch_early_init()"></a>arch_early_init()</h4><p>不同的芯片架构初始化内容不同，lk支持microblaze、or1k、mips、arm、arm-m、arm64，以arm64为例。函数定义在lk&#x2F;arch&#x2F;arm64&#x2F;arch.c中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void arch_early_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    arm64_cpu_early_init();</span><br><span class="line">    platform_init_mmu_mappings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="arm64-cpu-early-init"><a href="#arm64-cpu-early-init" class="headerlink" title="arm64_cpu_early_init"></a>arm64_cpu_early_init</h5><ul><li>1.设置向量基地址（中断相关）</li><li>2.switch to EL1</li><li>3.enable fiqs</li></ul><h5 id="platform-init-mmu-mappings"><a href="#platform-init-mmu-mappings" class="headerlink" title="platform_init_mmu_mappings"></a>platform_init_mmu_mappings</h5><p>初始化MMU映射，与platform有关，定义在platform文件夹下对应平台的platform.c文件，大部分定义为空函数。</p><h4 id="platform-early-init"><a href="#platform-early-init" class="headerlink" title="platform_early_init()"></a>platform_early_init()</h4><p>与平台相关，一般任务为从共享内存中读取板级信息、初始化时钟、初始化ARM GIC中断控制器、初始化timer。在lk&#x2F;platform&#x2F;armemu&#x2F;platform.c中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void platform_early_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* initialize the interrupt controller */</span><br><span class="line">    platform_init_interrupts();</span><br><span class="line"></span><br><span class="line">    /* initialize the timer block */</span><br><span class="line">    platform_init_timer();</span><br><span class="line"></span><br><span class="line">    /* initialize the display */</span><br><span class="line">    platform_init_display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成中断初始化、定时器初始化和显示初始化。</p><h4 id="target-early-init"><a href="#target-early-init" class="headerlink" title="target_early_init()"></a>target_early_init()</h4><p>在目标平台定义。</p><h4 id="heap-init"><a href="#heap-init" class="headerlink" title="heap_init()"></a>heap_init()</h4><p>堆栈初始化<br>start the heap off with some spare memory in the page allocator.<br>malloc等内存分配函数在heap_wrapper.c文件下实现。</p><h4 id="call-constructors"><a href="#call-constructors" class="headerlink" title="call_constructors()"></a>call_constructors()</h4><p>构造函数相关初始化</p><h4 id="bootstrap2"><a href="#bootstrap2" class="headerlink" title="bootstrap2"></a>bootstrap2</h4><p>bootstrap2 在kmain的末尾以线程方式开启。主要分三步：platform_init、target_init、apps_init。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);</span><br><span class="line">arch_init();</span><br></pre></td></tr></table></figure><p>1.initialize the arch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dprintf(SPEW, &quot;initializing platform\n&quot;);</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);</span><br><span class="line">platform_init();</span><br></pre></td></tr></table></figure><p>2.initialize the rest of the platform</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dprintf(SPEW, &quot;initializing target\n&quot;);</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);</span><br><span class="line">target_init();</span><br></pre></td></tr></table></figure><p>3.initialize the target</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dprintf(SPEW, &quot;calling apps_init()\n&quot;);</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);</span><br><span class="line">apps_init();</span><br><span class="line">lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);</span><br></pre></td></tr></table></figure><p>4.calling apps_init</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 系统的硬件组成</title>
      <link href="/2018/10/31/01-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/"/>
      <url>/2018/10/31/01-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h3 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h3><span id="more"></span><h4 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h4><p>贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32位），要么是8个字节（64位）。</p><h4 id="2-I-O设备"><a href="#2-I-O设备" class="headerlink" title="2.I&#x2F;O设备"></a>2.I&#x2F;O设备</h4><p>I&#x2F;O(输入&#x2F;输出)是系统与外部世界的联系通道。系统主要的I&#x2F;O设备有：作为用户输入输出的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。每个I&#x2F;O设备都通过一个控制器或适配器与I&#x2F;O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I&#x2F;O设备本身或者系统主板上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I&#x2F;O总线和I&#x2F;O设备之间传递信息。</p><h4 id="3-主存"><a href="#3-主存" class="headerlink" title="3.主存"></a>3.主存</h4><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从0开始的。</p><h4 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4.处理器"></a>4.处理器</h4><p>中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br>从系统通电开始，直到系统断电，处理器一直在不断的执行PC指向的指令，再更新PC，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含一系列的步骤。处理器从PC指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。<br>这样的简单操作并不多，它们围绕着主存、寄存器文件（register file）和算术&#x2F;逻辑单元（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作。</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li><li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC中原来的值。</li></ul><p>处理器看上去是它的指令架构的简单实现，但实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：<strong>指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</strong></p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件读取数据比从主存中读取几乎快100倍。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜的多。</p><p>针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器（cache memory,简称为cache或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。位于处理器上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5~10倍。L1和L2高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。处理能力更强大的系统甚至有三级高速缓存：L1、L2、L3。系统可以获得一个很大的存储器，同时访问速度很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p><h3 id="存储设备的层次结构"><a href="#存储设备的层次结构" class="headerlink" title="存储设备的层次结构"></a>存储设备的层次结构</h3><p>每个计算机系统中的存储设备都被组织成了一个存储器层次结构。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01_%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.JPG" alt="存储器的层次结构"><br>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。</p><h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p>我们把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。</p><p>操作系统有两个基本功能：</p><ul><li>1.防止硬件被失控的应用程序滥用</li><li>2.向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ul><p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。<br>文件是对I&#x2F;O设备的抽象表示，<br>虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，<br>进程则是对处理器、主存和I&#x2F;O设备的抽象表示。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>程序在操作系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占的使用处理器、主存和I&#x2F;O设备。处理器看上去就好像在不间断的一条接一条的执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。</p><p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。</p><p>从一个进程到另一个进程的转换是由操作系统内核(kernel)管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用(system call)指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>在系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型。当有多处理器可用的时候，多线程也是一种使得程序可以运行的更快的方法。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。下图所示的是Linux进程的虚拟地址空间。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。图中的地址是从下往上增大的。<br><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01_%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.JPG" alt="进程的虚拟地址空间"><br>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。我们从最低的地址开始，逐步向上介绍。</p><ul><li><strong>程序代码和数据。</strong> 对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。</li><li><strong>堆。</strong> 代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态的扩展和收缩。</li><li><strong>共享库。</strong> 大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li><li><strong>栈。</strong> 位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态的扩展和收缩。特别的，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</li><li><strong>内核虚拟内存。</strong> 地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。</li></ul><p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件就是字节序列。每个I&#x2F;O设备，包括磁盘、键盘、显示器，甚至是网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I&#x2F;O的系统函数调用读写文件来实现的。</p><p>文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I&#x2F;O设备。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息摘要算法</title>
      <link href="/2018/10/29/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/29/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h3><p>消息摘要是把任意长度的输入揉和而产生长度固定的伪随机输入的算法。消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，目前可以被解密逆向的只有CRC32算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。消息摘要算法不存在密钥的管理与分发问题，适合于分布式网络上使用。数据摘要算法也被称为哈希（Hash）算法或散列算法。</p><span id="more"></span><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出，SHA-1的变体可以产生192比特位和256比特位的消息摘要。一般认为，摘要的最终输出越长，该摘要算法就越安全。</li><li>消息摘要看起来是“随机的”。这些比特看上去是胡乱的杂凑在一起的。可以用大量的输入来检验其输出是否相同，一般，不同的输入会有不同的输出，而且输出的摘要消息可以通过随机性检验。但是，一个摘要并不是真正随机的，因为用相同的算法对相同的消息求两次摘要，其结果必然相同；而若是真正随机的，则无论如何都是无法重现的。因此消息摘要是“伪随机的”。</li><li>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。这正是好的消息摘要算法所具有的性质：输入改变了，输出也就改变了；两条相似的消息的摘要确不相近，甚至会大相径庭。</li><li>消息摘要函数是无陷门的单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。当然，可以采用强力攻击的方法，即尝试每一个可能的信息，计算其摘要，看看是否与已有的摘要相同，如果这样做，最终肯定会恢复出摘要的消息。但实际上，要得到的信息可能是无穷个消息之一，所以这种强力攻击几乎是无效的。</li><li>好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。即对于给定的一个摘要，不可能找到一条信息使其摘要正好是给定的。或者说，无法找到两条消息，使它们的摘要相同。</li></ul><h3 id="常见数据摘要算法"><a href="#常见数据摘要算法" class="headerlink" title="常见数据摘要算法"></a>常见数据摘要算法</h3><h4 id="CRC8、CRC16、CRC32"><a href="#CRC8、CRC16、CRC32" class="headerlink" title="CRC8、CRC16、CRC32"></a>CRC8、CRC16、CRC32</h4><p>CRC（Cyclic Redundancy Check，循环冗余校验）算法出现时间较长，应用也十分广泛，尤其是通讯领域，现在应用最多的就是 CRC32 算法，它产生一个4字节（32位）的校验值，一般是以8位十六进制数，如FA 12 CD 45等。CRC算法的优点在于简便、速度快，严格的来说，CRC更应该被称为数据校验算法，但其功能与数据摘要算法类似，因此也作为测试的可选算法。</p><p>在 WinRAR、WinZIP 等软件中，也是以 CRC32 作为文件校验算法的。一般常见的简单文件校验（Simple File Verify – SFV）也是以 CRC32算法为基础，它通过生成一个后缀名为 .SFV 的文本文件，这样可以任何时候可以将文件内容 CRC32运算的结果与 .SFV 文件中的值对比来确定此文件的完整性。</p><h4 id="MD2-、MD4、MD5"><a href="#MD2-、MD4、MD5" class="headerlink" title="MD2 、MD4、MD5"></a>MD2 、MD4、MD5</h4><p>这是应用非常广泛的一个算法家族，尤其是 MD5（Message-Digest Algorithm 5，消息摘要算法版本5），它由MD2、MD3、MD4发展而来，由Ron Rivest（RSA公司）在1992年提出，被广泛应用于数据完整性校验、数据（消息）摘要、数据加密等。MD2、MD4、MD5 都产生16字节（128位）的校验值，一般用32位十六进制数表示。MD2的算法较慢但相对安全，MD4速度很快，但安全性下降，MD5比MD4更安全、速度更快。</p><p>在互联网上进行大文件传输时，都要得用MD5算法产生一个与文件匹配的、存储MD5值的文本文件（后缀名为 .md5或.md5sum），这样接收者在接收到文件后，就可以利用与 SFV 类似的方法来检查文件完整性，绝大多数大型软件公司或开源组织都是以这种方式来校验数据完整性，而且部分操作系统也使用此算法来对用户密码进行加密，另外，它也是目前计算机犯罪中数据取证的最常用算法。</p><h4 id="SHA1、SHA256、SHA384、SHA512"><a href="#SHA1、SHA256、SHA384、SHA512" class="headerlink" title="SHA1、SHA256、SHA384、SHA512"></a>SHA1、SHA256、SHA384、SHA512</h4><p>SHA（Secure Hash Algorithm）是由美国专门制定密码算法的标准机构—— 美国国家标准技术研究院（NIST）制定的，SHA系列算法的摘要长度分别为：SHA为20字节（160位）、SHA256为32字节（256位）、 SHA384为48字节（384位）、SHA512为64字节（512位），由于它产生的数据摘要的长度更长，因此更难以发生碰撞，因此也更为安全，它是未来数据摘要算法的发展方向。由于SHA系列算法的数据摘要长度较长，因此其运算速度与MD5相比，也相对较慢。<br>SHA1的应用较为广泛，主要应用于CA和数字证书中，另外在互联网中流行的BT软件中，也是使用SHA1来进行文件校验的。</p><h4 id="RIPEMD、PANAMA、TIGER、ADLER32-等"><a href="#RIPEMD、PANAMA、TIGER、ADLER32-等" class="headerlink" title="RIPEMD、PANAMA、TIGER、ADLER32 等"></a>RIPEMD、PANAMA、TIGER、ADLER32 等</h4><p>RIPEMD是Hans Dobbertin等3人在对MD4，MD5缺陷分析基础上，于1996年提出来的，有4个标准128、160、256和320，其对应输出长度分别为16字节、20字节、32字节和40字节。IGER由Ross在1995年提出。Tiger号称是最快的Hash算法，专门为64位机器做了优化。</p><h3 id="数据摘要算法的应用"><a href="#数据摘要算法的应用" class="headerlink" title="数据摘要算法的应用"></a>数据摘要算法的应用</h3><p>一般地，把对一个信息的摘要称为该消息的指纹或数字签名。数字签名是保证信息的完整性和不可否认性的方法。数据的完整性是指信宿接收到的消息一定是信源发送的信息，而中间绝无任何更改；信息的不可否认性是指信源不能否认曾经发送过的信息。其实，通过数字签名还能实现对信源的身份识别（认证），即确定“信源”是否是信宿意定的通信伙伴。 数字签名应该具有唯一性，即不同的消息的签名是不一样的；同时还应具有不可伪造性，即不可能找到另一个消息，使其签名与已有的消息的签名一样；还应具有不可逆性，即无法根据签名还原被签名的消息的任何信息。这些特征恰恰都是消息摘要算法的特征，所以消息摘要算法适合作为数字签名算法。</p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名方案是一种以电子形式存储消息签名的方法。一个完整的数字签名方案应该由两部分组成：签名算法和验证算法。一般地说，任何一个公钥密码体制都可以单独地作为一种数字签名方案使用。</p><p>如RSA作为数字签名方案，这种签名实际上就是用信源的私钥加密消息，加密后的消息即成了签体；而用对应的公钥进行验证，若公钥解密后的消息与原来的消息相同，则消息是完整的，否则消息不完整。它正好和公钥密码用于消息保密是相反的过程。因为只有信源才拥有自己地私钥，别人无法重新加密源消息，所以即使有人截获且更改了源消息，也无法重新生成签体，因为只有用信源的私钥才能形成正确地签体。同样信宿只要验证用信源的公钥解密的消息是否与明文消息相同，就可以知道消息是否被更改过，而且可以认证消息是否是确实来自意定的信源，还可以使信源不能否认曾将发送的消息。所以这样可以完成数字签名的功能。</p><p>但这种方案过于单纯，它仅可以保证消息的完整性，而无法确保消息的保密性。而且这种方案要对所有的消息进行加密操作，这在消息的长度比较大时，效率使非常低的，主要原因在于公钥体制的加解密过程的低效性。所以这种方案一般不可取。</p><p>几乎所有的数字签名方案都要和快速高效的摘要算法（Hash函数）一起使用，当公钥算法与摘要算法结合起来使用时，便构成了一种有效地数字签名方案。</p><p>这个过程是：首先用摘要算法对消息进行摘要，然后在把摘要值用信源的私钥加密；接收方先把接收的明文用同样的摘要算法摘要，形成“准签体”，然后再把准签体与用信源的公钥解密出的“签体”进行比较，如果相同就认为消息是完整的，否则消息不完整。</p><p>这种方法使公钥加密只对消息摘要进行操作，因为一种摘要算法的摘要消息长度是固定的，而且都比较“短”（相对于消息而言），正好符合公钥加密的要求。这样效率得到了提高，而其安全性也并未因为使用摘要算法而减弱。</p><p>文章整理自：<br><a href="https://www.cnblogs.com/lianshuiwuyi/p/7967619.html">添砖加瓦：几种常见的数据摘要算法（MD5、CRC32、SHA1和SHA256）</a><br><a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/3286770?fr=aladdin&fromtitle=%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95&fromid=12011257">百度百科：消息摘要算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C按位操作实现CRC计算算法</title>
      <link href="/2018/10/28/C%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0CRC%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/28/C%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0CRC%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="C按位操作实现CRC计算算法"><a href="#C按位操作实现CRC计算算法" class="headerlink" title="C按位操作实现CRC计算算法"></a>C按位操作实现CRC计算算法</h3><p><a href="https://github.com/MrBluyee/arithmetic_c/tree/master/CRC">github源码</a></p><span id="more"></span><p>CRC算法参数模型解释： </p><p>NAME：参数模型名称。<br>WIDTH：宽度，即CRC比特数。<br>POLY：生成项的简写，以16进制表示。例如：CRC-32即是0x04C11DB7，忽略了最高位的”1”，即完整的生成项是0x104C11DB7。<br>INIT：这是算法开始时寄存器（crc）的初始化预置值，十六进制表示。<br>REFIN：待测数据的每个字节是否按位反转，True或False。<br>REFOUT：在计算后之后，异或输出之前，整个数据是否按位反转，True或False。<br>XOROUT：计算结果与此参数异或后得到最终的CRC值。</p><h4 id="模型数据结构定义"><a href="#模型数据结构定义" class="headerlink" title="模型数据结构定义"></a>模型数据结构定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CRC8_TYPE&#123;</span><br><span class="line">    uint8_t poly;   //多项式</span><br><span class="line">    uint8_t init;   //reg初始值</span><br><span class="line">    uint8_t xorout; //结果异或值</span><br><span class="line">    uint8_t refin;   //输入数据反转</span><br><span class="line">    uint8_t refout;  //输出数据反转</span><br><span class="line">&#125;CRC8_TYPE;</span><br><span class="line"></span><br><span class="line">typedef struct CRC16_TYPE&#123;</span><br><span class="line">    uint16_t poly;   //多项式</span><br><span class="line">    uint16_t init;   //reg初始值</span><br><span class="line">    uint16_t xorout; //结果异或值</span><br><span class="line">    uint8_t refin;   //输入数据反转</span><br><span class="line">    uint8_t refout;  //输出数据反转</span><br><span class="line">&#125;CRC16_TYPE;</span><br><span class="line"></span><br><span class="line">typedef struct CRC32_TYPE&#123;</span><br><span class="line">    uint32_t poly;   //多项式</span><br><span class="line">    uint32_t init;   //reg初始值</span><br><span class="line">    uint32_t xorout; //结果异或值</span><br><span class="line">    uint8_t refin;   //输入数据反转</span><br><span class="line">    uint8_t refout;  //输出数据反转</span><br><span class="line">&#125;CRC32_TYPE;</span><br><span class="line"></span><br><span class="line">typedef struct CRC64_TYPE&#123;</span><br><span class="line">    uint64_t poly;   //多项式</span><br><span class="line">    uint64_t init;   //reg初始值</span><br><span class="line">    uint64_t xorout; //结果异或值</span><br><span class="line">    uint8_t refin;   //输入数据反转</span><br><span class="line">    uint8_t refout;  //输出数据反转</span><br><span class="line">&#125;CRC64_TYPE;</span><br></pre></td></tr></table></figure><h3 id="按位计算算法大致流程"><a href="#按位计算算法大致流程" class="headerlink" title="按位计算算法大致流程"></a>按位计算算法大致流程</h3><h4 id="字节的左右反转"><a href="#字节的左右反转" class="headerlink" title="字节的左右反转"></a>字节的左右反转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint32_t reflect_uint32_t_bits(uint32_t data)&#123;</span><br><span class="line">    uint32_t result = 0,index = 0x01;</span><br><span class="line">    uint8_t i;</span><br><span class="line">    for (i = 0;i &lt; 32;i++,index &lt;&lt;= 1)&#123;</span><br><span class="line">        if(data &amp; index)&#123;</span><br><span class="line">            result |= 0x01 &lt;&lt; (31 - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CRC按位计算的两种方式（一般计算与反序计算）"><a href="#CRC按位计算的两种方式（一般计算与反序计算）" class="headerlink" title="CRC按位计算的两种方式（一般计算与反序计算）"></a>CRC按位计算的两种方式（一般计算与反序计算）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint32_t crc32(uint8_t *data, uint32_t length, uint32_t crc_reg,CRC32_TYPE crc_type)&#123;</span><br><span class="line">    uint8_t i;</span><br><span class="line">    while(length--)&#123;</span><br><span class="line">        if(crc_type.refin)&#123;</span><br><span class="line">            uint32_t poly_ref = reflect_uint32_t_bits(crc_type.poly);</span><br><span class="line">            crc_reg ^= *data++;</span><br><span class="line">            for (i=0;i&lt;8;i++)&#123;</span><br><span class="line">                if (crc_reg &amp; 0x01)&#123;</span><br><span class="line">                    crc_reg = (crc_reg &gt;&gt; 1) ^ poly_ref;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    crc_reg &gt;&gt;= 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            crc_reg ^= (*data++ &lt;&lt; 24);</span><br><span class="line">            for (i=0;i&lt;8;i++)&#123;</span><br><span class="line">                if (crc_reg &amp; 0x80000000)&#123;</span><br><span class="line">                    crc_reg = (crc_reg &lt;&lt; 1) ^ crc_type.poly;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    crc_reg &lt;&lt;= 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return crc_reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CRC结果异或返回"><a href="#CRC结果异或返回" class="headerlink" title="CRC结果异或返回"></a>CRC结果异或返回</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint32_t crc32_final_process(uint32_t crc_reg,CRC32_TYPE crc_type)&#123;</span><br><span class="line">    if(crc_type.refin ^ crc_type.refout)&#123;</span><br><span class="line">        crc_reg = reflect_uint32_t_bits(crc_reg);</span><br><span class="line">    &#125;</span><br><span class="line">    return crc_reg ^ crc_type.xorout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用CRC计算模型"><a href="#常用CRC计算模型" class="headerlink" title="常用CRC计算模型"></a>常用CRC计算模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CRC8_TYPE crc_8 = &#123;0x07,0x00,0x00,0,0&#125;;</span><br><span class="line">CRC8_TYPE crc_8_ITU = &#123;0x07,0x00,0x55,0,0&#125;;</span><br><span class="line">CRC8_TYPE crc_8_ROHC = &#123;0x07,0xFF,0x00,1,1&#125;;</span><br><span class="line">CRC8_TYPE crc_8_MAXIM = &#123;0x31,0x00,0x00,1,1&#125;;</span><br><span class="line"></span><br><span class="line">CRC16_TYPE crc_16_IBM = &#123;0x8005,0x0000,0x0000,1,1&#125;;</span><br><span class="line">CRC16_TYPE crc_16_MAXIM = &#123;0x8005,0x0000,0xFFFF,1,1&#125;;</span><br><span class="line">CRC16_TYPE crc_16_USB = &#123;0x8005,0xFFFF,0xFFFF,1,1&#125;;</span><br><span class="line">CRC16_TYPE crc_16_MODBUS = &#123;0x8005,0xFFFF,0x0000,1,1&#125;;</span><br><span class="line">CRC16_TYPE crc_16_CCITT = &#123;0x1021,0x0000,0x0000,1,1&#125;;</span><br><span class="line">CRC16_TYPE crc_16_CCITT_FALSE = &#123;0x1021,0xFFFF,0x0000,0,0&#125;;</span><br><span class="line">CRC16_TYPE crc_16_X25 = &#123;0x1021,0xFFFF,0xFFFF,1,1&#125;;</span><br><span class="line">CRC16_TYPE crc_16_XMODEM = &#123;0x1021,0x0000,0x0000,0,0&#125;;</span><br><span class="line">CRC16_TYPE crc_16_DNP = &#123;0x3D65,0x0000,0xFFFF,1,1&#125;;</span><br><span class="line"></span><br><span class="line">CRC32_TYPE crc_32 = &#123;0x04C11DB7,0xFFFFFFFF,0xFFFFFFFF,1,1&#125;;</span><br><span class="line">CRC32_TYPE crc_32_MPEG_2 = &#123;0x04C11DB7,0xFFFFFFFF,0x00000000,0,0&#125;;</span><br><span class="line">CRC32_TYPE crc_32_BZIP_2 = &#123;0x04C11DB7,0xFFFFFFFF,0xFFFFFFFF,0,0&#125;;</span><br><span class="line">CRC32_TYPE crc_32_SCTP = &#123;0x1EDC6F41,0xFFFFFFFF,0xFFFFFFFF,0,0&#125;;</span><br><span class="line">CRC32_TYPE crc_32_JAMCRC = &#123;0x04C11DB7,0xFFFFFFFF,0x00000000,1,1&#125;;</span><br><span class="line"></span><br><span class="line">CRC64_TYPE crc_64 = &#123;0x000000000000001B,0x0000000000000000,0x0000000000000000,0,0&#125;;</span><br><span class="line">CRC64_TYPE crc_64_ECMA = &#123;0x42F0E1EBA9EA3693,0xFFFFFFFFFFFFFFFF,0xFFFFFFFFFFFFFFFF,0,0&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRC循环冗余校验算法</title>
      <link href="/2018/10/27/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/27/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>循环冗余校验（Cyclic redundancy check，通称“CRC”）是一种根据网络数据数据包或计算机文件等数据产生简短固定位数校验码的一种散列函數，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。</p><span id="more"></span><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>CRC校验（循环冗余校验）是数据通讯中最常采用的校验方式。在嵌入式软件开发中，经常要用到CRC 算法对各种数据进行校验。</p><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>奇偶校验是CRC 校验的一种(CRC-1)。RS232串行通讯可以设置奇偶校验位，所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个。比如我们要发送的字节是0x1a，二进制表示为0001 1010。</p><ul><li>采用奇校验，则在数据后补上个0，数据变为0001 1010 0，数据中1的个数为奇数个（3个）</li><li>采用偶校验，则在数据后补上个1，数据变为0001 1010 1，数据中1的个数为偶数个（4个）</li></ul><p>接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错。</p><p>奇偶校验的缺点也很明显，首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大。因此，在高速数据通讯中很少采用奇偶校验。奇偶校验优点也很明显，它很简单，因此可以用硬件来实现，这样可以减少软件的负担。因此，奇偶校验也被广泛的应用着。</p><h4 id="累加和校验"><a href="#累加和校验" class="headerlink" title="累加和校验"></a>累加和校验</h4><p>另一种常见的校验方式是累加和校验。所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后加入一个字节的校验数据。这个字节内容为前面数据包中全部数据的忽略进位的按字节累加和。比如下面的例子：</p><p>我们要传输的信息为： 6、23、4<br>加上校验和后的数据包：6、23、4、33</p><p>这里 33 为前三个字节的校验和。接收方收到全部数据后对前三个数据进行同样的累加计算，如果累加和与最后一个字节相同的话就认为传输的数据没有错误。</p><p>加和校验由于实现起来非常简单，也被广泛的采用。但是这种校验方式的检错能力也比较一般，对于单字节的校验和大概有1&#x2F;256 的概率将原本是错误的通讯数据误判为正确数据。之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节）。</p><h3 id="CRC算法"><a href="#CRC算法" class="headerlink" title="CRC算法"></a>CRC算法</h3><p>CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面。CRC算法中，将二进制数据流作为多项式的系数，然后进行的是多项式的乘除法。</p><p>下面是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">要传输的数据为：1101011011</span><br><span class="line">除数设为：10011</span><br><span class="line"></span><br><span class="line">在计算前先将原始数据后面填上4个0：11010110110000</span><br><span class="line">          1100001010</span><br><span class="line">      ——————————————</span><br><span class="line">10011)11010110110000</span><br><span class="line">      10011</span><br><span class="line">      ——————————————</span><br><span class="line">       10011</span><br><span class="line">       10011</span><br><span class="line">      ——————————————</span><br><span class="line">            10110</span><br><span class="line">            10011</span><br><span class="line">      ——————————————</span><br><span class="line">              10100</span><br><span class="line">              10011</span><br><span class="line">      ——————————————</span><br><span class="line">                1110</span><br></pre></td></tr></table></figure><p>从这个例子可以看出，采用了模2的加减法(异或运算符)后，不需要考虑借位的问题，所以除法变简单了。最后得到的余数就是CRC 校验字。为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“生成多项式”。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。</p><p>最常用的几种生成多项式如下：</p><ul><li>CRC8 &#x3D; X^8 + X^5 + X^4 + X^0 &#x3D; 1 0011 0001 (0x31)</li><li>CRC12 &#x3D; X^12 + X^11 + X^3 + X^2 + X^0 &#x3D; 1  1000 0000 1101 (0x080D)</li><li>CRC-CCITT &#x3D; X^16 + X^12 + X^5 + X^0 &#x3D; 1 0001 0000 0010 0001 (0x1021)</li><li>CRC16 &#x3D; X^16 + X^15 + X^2 + X^0 &#x3D; 1 1000 0000 0000 0101 (0x8005)</li><li>CRC32 &#x3D; X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 + X^8 + X^7 + X^5 + X^4 + X^2 + X^1 + X^0 &#x3D; 1 0000 0100 1100 0001 0001 1101 1011 0111 (0x04C11DB7)</li></ul><p>生成多项式经常会说到多项式的位宽（Width，简记为W），这个位宽不是多项式对应的二进制数的位数，而是位数减1。比如CRC8中用到的位宽为8的生成多项式，其实对应得二进制数有九位：100110001。</p><p>另外一点，多项式表示和二进制表示都很繁琐，交流起来不方便。<br>因此，多用16进制简写法来表示，因为生成多项式的最高位肯定为1，最高位的位置由位宽可知，故在简记式中，将最高的1统一去掉了，如CRC32的生成多项式简记为04C11DB7实际上表示的是104C11DB7。当然，这样简记除了方便外，在编程计算时也有它的用处。</p><p>对于上面的例子，位宽为4（W&#x3D;4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0。</p><p>位宽W&#x3D;1的生成多项式(CRC1)有两种，分别是X1和X1+X0，10对应的就是奇偶校验中的奇校验，而11对应则是偶校验。</p><h4 id="原始CRC算法"><a href="#原始CRC算法" class="headerlink" title="原始CRC算法"></a>原始CRC算法</h4><p>假设生成多项式(被除数)为：100110001（简记为0x31），也就是CRC-8，<br>原始CRC计算步骤如下：</p><ul><li>1.将CRC寄存器（8-bits，比生成多项式少1bit）赋初值0</li><li>2.在待传输信息流后面加入8个0</li><li>3.While (数据未处理完)</li><li>4.Begin</li><li>5.—If (CRC寄存器首位是1)</li><li>6.——reg &#x3D; reg XOR 0x31</li><li>7.— CRC寄存器左移一位，读入一个新的数据于CRC寄存器的0 bit的位置。</li><li>8.End</li></ul><p>CRC寄存器就是我们所要求的余数。<br>实际C代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsigned char crc8_gen(unsigned char *data,unsigned char length)&#123;</span><br><span class="line">    int j;</span><br><span class="line">    unsigned char crc_reg = 0;</span><br><span class="line">    while(length--)&#123;</span><br><span class="line">        crc_reg ^= *data++;</span><br><span class="line">        for(j=0;j&lt;8;j++)&#123;</span><br><span class="line">            if(crc_reg &amp; 0x80)&#123;</span><br><span class="line">                crc_reg = (crc_reg &lt;&lt; 1) ^ 0x31;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                crc_reg = crc_reg &lt;&lt; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return crc_reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，真正的CRC 计算通常与上面描述的还有些出入。这是因为这种最基本的CRC除法有个很明显的缺陷，就是数据流的开头添加一些0并不影响最后校验字的结果。因此真正应用的CRC 算法基本都在原始的CRC算法的基础上做了些小的改动。所谓的改动，也就是增加了两个概念，第一个是“余数初始值”，第二个是“结果异或值”。</p><p>所谓的“余数初始值”就是在计算CRC值的开始，给CRC寄存器一个初始值。“结果异或值”是在其余计算完成后将CRC寄存器的值在与这个值进行一下异或操作作为最后的校验值。</p><h4 id="实际CRC算法"><a href="#实际CRC算法" class="headerlink" title="实际CRC算法"></a>实际CRC算法</h4><p>实际CRC计算步骤如下：</p><ul><li>1.设置CRC寄存器，并给其赋值为“余数初始值”。</li><li>2.将数据的第一个8-bit字符与CRC寄存器进行异或，并把结果存入CRC寄存器。</li><li>3.CRC寄存器向左移一位，LSB补零，移出并检查MSB。</li><li>4.如果MSB为0，重复第三步；若MSB为1，CRC寄存器与0x31相异或。</li><li>5.重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。</li><li>6.重复第2至第5步直到所有数据全部处理完成。</li><li>7.最终CRC寄存器的内容与“结果异或值”进行异或操作后即为CRC值。</li></ul><p>实际使用中除了寄存器初始值、结果异或值外还有字节颠倒的标记RefIn和RefOut：<br>所谓颠倒意思是字节数左右取反，例如11010010，字节颠倒后变为01001011。</p><p><strong>RefIn</strong>：这是个BOOL值，表示字符串是否进行了字节颠倒。某些硬件传输时使用LSB模式，即先传输低位的bit，这样使用MSB模式收到的字节就是颠倒的。假如A传输的是1000 0000，但是底层硬件传输时按照0000 0001的顺序传给B，B的传输模式是MSB，即认为接收的第一个bit是高位bit。那么本来应该是0x80，但是B却认为它接收的是0x01。</p><p>对于这种情况，在做crc之前把每一个字节颠倒过来就好了。但是这么做将浪费大量时间和工作量，于是出现了颠倒crc算法，即除了源串字节不进行颠倒以外，初始值、poly、进寄存器方向、最后的crc结果都进行颠倒。这样与费时费事的颠倒每个字节计算的结果完全一致。</p><p><strong>RefOut</strong>：颠倒输出结果。</p><p>常见CRC参数模型如下：</p><table><thead><tr><th>CRC算法名称</th><th>宽度</th><th>多项式</th><th>初始值</th><th>结果异或值</th><th>输入值反转</th><th>输出值反转</th></tr></thead><tbody><tr><td>CRC-4&#x2F;ITU</td><td>4</td><td>03</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-5&#x2F;EPC</td><td>5</td><td>09</td><td>09</td><td>00</td><td>false</td><td>false</td></tr><tr><td>CRC-5&#x2F;ITU</td><td>5</td><td>15</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-5&#x2F;USB</td><td>5</td><td>05</td><td>1F</td><td>1F</td><td>true</td><td>true</td></tr><tr><td>CRC-6&#x2F;ITU</td><td>6</td><td>03</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-7&#x2F;MMC</td><td>7</td><td>09</td><td>00</td><td>00</td><td>false</td><td>false</td></tr><tr><td>CRC-8</td><td>8</td><td>07</td><td>00</td><td>00</td><td>false</td><td>false</td></tr><tr><td>CRC-8&#x2F;ITU</td><td>8</td><td>07</td><td>00</td><td>55</td><td>false</td><td>false</td></tr><tr><td>CRC-8&#x2F;ROHC</td><td>8</td><td>07</td><td>FF</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-8&#x2F;MAXIM</td><td>8</td><td>31</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-16&#x2F;IBM</td><td>16</td><td>8005</td><td>0000</td><td>0000</td><td>true</td><td>true</td></tr><tr><td>CRC-16&#x2F;MAXIM</td><td>16</td><td>8005</td><td>0000</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-16&#x2F;USB</td><td>16</td><td>8005</td><td>FFFF</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-16&#x2F;MODBUS</td><td>16</td><td>8005</td><td>FFFF</td><td>0000</td><td>true</td><td>true</td></tr><tr><td>CRC-16&#x2F;CCITT</td><td>16</td><td>1021</td><td>0000</td><td>0000</td><td>true</td><td>true</td></tr><tr><td>CRC-16&#x2F;CCITT-FALSE</td><td>16</td><td>1021</td><td>FFFF</td><td>0000</td><td>false</td><td>false</td></tr><tr><td>CRC-16&#x2F;x^5</td><td>16</td><td>1021</td><td>FFFF</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-16&#x2F;XMODEM</td><td>16</td><td>1021</td><td>0000</td><td>0000</td><td>false</td><td>false</td></tr><tr><td>CRC-16&#x2F;DNP</td><td>16</td><td>3D65</td><td>0000</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-32</td><td>32</td><td>04C11DB7</td><td>FFFFFFFF</td><td>FFFFFFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-32&#x2F;MPEG-2</td><td>32</td><td>04C11DB7</td><td>FFFFFFFF</td><td>00000000</td><td>false</td><td>false</td></tr></tbody></table><p>实现CRC算法主要有逐位计算和查表两种，逐位计算效率比查表低很多。具体算法实现将在后续章节给出。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的反转</title>
      <link href="/2018/10/25/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/"/>
      <url>/2018/10/25/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>链表的翻转常见的解决方法分为迭代和递归两种。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>递归和迭代两个函数在SingleLinkedList文件夹中的SingleLinkedList.c中实现。</p><span id="more"></span><p>假设创建好的链表结构如下：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/1.JPG" alt="创建好的链表"></p><h4 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int reverseList1(SingleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    if (p == NULL || p-&gt;next == NULL) return -1;</span><br><span class="line">    Node *temp = NULL, *newH = NULL;</span><br><span class="line">    while (p != NULL)&#123;</span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = newH;</span><br><span class="line">        newH = p;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    This-&gt;This-&gt;next = newH;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行过程分析：<br>开始：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/2.JPG" alt="开始"><br>第1步：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/3.JPG" alt="第1步"><br>第2步：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/4.JPG" alt="第2步"><br>第3步：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/5.JPG" alt="第3步"><br>第4步：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/6.JPG" alt="第4步"><br>第5步：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/7.JPG" alt="第5步"><br>第6步：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/8.JPG" alt="第6步"><br>结束：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/9.JPG" alt="结束"></p><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//递归方式</span><br><span class="line">static Node *ReverseList2(Node *head)&#123;</span><br><span class="line">    if (head == NULL || head-&gt;next == NULL)&#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Node *temp = head-&gt;next, *newH = NULL;</span><br><span class="line">        head-&gt;next = NULL;</span><br><span class="line">        newH = ReverseList2(temp);</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        return newH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int reverseList2(SingleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    if (p == NULL || p-&gt;next == NULL) return -1;</span><br><span class="line">    This-&gt;This-&gt;next = ReverseList2(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行过程分析：<br>第1层递归：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/10.JPG" alt="第1层递归"><br>第2层递归：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/11.JPG" alt="第2层递归"><br>第3层递归：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/12.JPG" alt="第3层递归"><br>返回到第2层：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/13.JPG" alt="返回到第2层"><br>返回到第1层：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/14.JPG" alt="返回到第1层"><br>结束：<br><img src="/images/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/15.JPG" alt="结束"></p><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc SingleLinkedList.c testSingleLinkedList.c -o testSingleLinkedList</span><br></pre></td></tr></table></figure><p>运行testSingleLinkedList，结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">list is empty:1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">list is empty:0</span><br><span class="line">list length:10</span><br><span class="line">reverse1 list :              //迭代方式</span><br><span class="line">9 8 7 6 5 4 3 2 1 0</span><br><span class="line">reverse2 list :             //递归方式</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">the elem of index 3 is 13</span><br><span class="line">modify the elem of index 3 to 31</span><br><span class="line">10 11 12 31 14 15 16 17 18 19</span><br><span class="line">insert elem 25 to index 5</span><br><span class="line">10 11 12 31 14 25 15 16 17 18 19</span><br><span class="line">delete elem 16 of index 7</span><br><span class="line">10 11 12 31 14 25 15 17 18 19</span><br><span class="line">the index of 14 is 4</span><br><span class="line">pop elem 19</span><br><span class="line">10 11 12 31 14 25 15 17 18</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android保护APP内部数据总结</title>
      <link href="/2018/10/23/Android%E4%BF%9D%E6%8A%A4APP%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/10/23/Android%E4%BF%9D%E6%8A%A4APP%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>最近两周在利用闲暇时间开发一款非常实用的App，故最近都没有时间来更新博客。现在这款App的Version 1.0已经接近尾声，第一代中构思的大部分功能都已经实现，之后不久会选择上架，写出使用说明书。这款app主要是干什么的，现在暂时保密，后续会与使用说明书一起贴出。<br>今天这篇文章对针对这款app内部数据的保护作一个总结。</p><span id="more"></span><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>Android程序打完包之后得到的是一个APK文件，这个文件是可以直接安装到任何Android手机上的，反编译其实也就是对这个APK文件进行反编译。</p><p>Android的反编译主要又分为两个部分，一个是对代码的反编译，一个是对资源的反编译。<br>具体反编译内容参考文章<br><a href="https://blog.csdn.net/guolin_blog/article/details/49738023">Android安全攻防战，反编译与混淆技术完全解析（上）</a></p><h4 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h4><p>混淆代码并不是让代码无法被反编译，而是将代码中的类、方法、变量等信息进行重命名，把它们改成一些毫无意义的名字。混淆代码可以在不影响程序正常运行的前提下让破解者很头疼，从而大大提升了程序的安全性。</p><p>在Android Studio当中混淆APK，借助SDK中自带的Proguard工具，只需要修改build.gradle中的一行配置即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中minifyEnabled用于设置是否启用混淆，proguardFiles用于选定混淆配置文件。build.gradle中minifyEnabled的值，这里我们只需要把值改成true，打出来的APK包就会是混淆过的了。</p><p>注意，在release闭包内进行配置，因此只有打出正式版的APK才会进行混淆，Debug版的APK是不会混淆的。</p><p>特点：</p><ul><li>使用ProGuard混淆的应用，通过apktool还是可以看到Manifest和res资源。</li><li>使用dex2jar，混淆后的源码还是可以看个大概。</li></ul><p>参考文章<br><a href="https://blog.csdn.net/guolin_blog/article/details/50451259">Android安全攻防战，反编译与混淆技术完全解析（下）</a></p><h3 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h3><p>在Android应用开发过程中，通过Log类输出日志是一种很重要的调试手段。</p><h4 id="Android的log缓存区"><a href="#Android的log缓存区" class="headerlink" title="Android的log缓存区"></a>Android的log缓存区</h4><p>Android提供的四个log缓存区：</p><ul><li>&#x2F;dev&#x2F;log&#x2F;main<br>主应用程序log，除了下三个外，其他用户空间log将写入此节点，包括System.out.print及System.erro.print等。</li><li>&#x2F;dev&#x2F;log&#x2F;events<br>系统事件信息，二进制log信息将写入此节点，需要程序解析。</li><li>&#x2F;dev&#x2F;log&#x2F;radio<br>射频通话相关信息，tag 为”HTC_RIL” “RILJ” “RILC” “RILD” “RIL” “AT” “GSM” “STK”的log信息将写入此节点。</li><li>&#x2F;dev&#x2F;log&#x2F;system<br>低等级系统信息和debugging,为了防止mian缓存区溢出,而从中分离出来。</li></ul><p>通过ADB清除Android缓存区日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -c 清除main缓存区域日志</span><br><span class="line">adb logcat -c -b events 清除系统事件信息日志</span><br><span class="line">adb logcat -c -b main -b events -b radio -b system 清除所有日志</span><br></pre></td></tr></table></figure><p>为了减少信息的泄漏，app日志需要做处理。</p><p>一般Log类的使用原则：</p><ul><li>在Debug模式下打印日志，在Release模式下不打印日志。</li><li>避免滥用Log类进行输出日志。因为这样可能造成日志刷屏，淹没真正有用的日志。</li><li>封装Log类，以提供同时输出日志到文件等功能。</li></ul><p>具体总结为以下几个方法：</p><h4 id="禁用System-out-println"><a href="#禁用System-out-println" class="headerlink" title="禁用System.out.println"></a>禁用System.out.println</h4><p>Android应用中，一般通过封装过的Log类来输出日志，方便控制。而System.out.println是标准的Java输出方法，使用不当，可能造成Release模式下输出日志的结果。</p><h4 id="禁用e-printStackTrace"><a href="#禁用e-printStackTrace" class="headerlink" title="禁用e.printStackTrace"></a>禁用e.printStackTrace</h4><p>禁用理由同上。<br>建议通过封装过的Log类来输出异常堆栈信息。</p><h4 id="静态变量标记"><a href="#静态变量标记" class="headerlink" title="静态变量标记"></a>静态变量标记</h4><p>Debug模式下，通过一个静态变量，控制日志的显示隐藏。<br>例如，使用BuildConfig.DEBUG标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final boolean isDebug = BuildConfig.DEBUG;</span><br><span class="line"></span><br><span class="line">public static void i(String tag, String msg) &#123;</span><br><span class="line">    if (isDebug) &#123;</span><br><span class="line">        Log.i(tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置Proguard"><a href="#配置Proguard" class="headerlink" title="配置Proguard"></a>配置Proguard</h4><p>Release模式下，通过Proguard配置来移除日志。使用gradle 进行打包时，添加混淆配置可以将log输出给删去。<br>在Proguard配置文件中，确保没有添加 –dontoptimize选项 来禁用优化。<br>build.gradle中修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        shrinkResources true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;),&#x27;proguard-rules.pro&#x27;</span><br><span class="line">        signingConfig signingConfigs.SginConfig</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在proguard-rules.pro中添加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-assumenosideeffects class android.util.Log &#123;</span><br><span class="line">    public static *** println(...);</span><br><span class="line">    public static *** v(...);</span><br><span class="line">    public static *** i(...);</span><br><span class="line">    public static *** w(...);</span><br><span class="line">    public static *** d(...);</span><br><span class="line">    public static *** e(...);</span><br><span class="line">    public static *** wtf(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启Proguard前提下，各种情况下的测试结论：</p><ul><li>日志被彻底移除，不会额外增加内存的情况:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Log.i（简单字符串）</span><br><span class="line">Log.i（局部变量）</span><br><span class="line">Log.i（成员变量）</span><br><span class="line">Log.i（简单字符串+局部变量）</span><br><span class="line">Log.i（成员函数） 其中，成员函数返回值为： 简单字符串</span><br><span class="line">Log.i（成员函数） 其中，成员函数返回值为： 简单字符串+局部变量</span><br></pre></td></tr></table></figure></li><li>日志被移除，但是字符串拼接会存在，并占用内存的情况：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.i（简单字符串+成员变量）</span><br><span class="line">Log.i（成员函数） 其中，成员函数返回值为： 简单字符串+成员变量</span><br></pre></td></tr></table></figure>参考文章<br><a href="https://www.jianshu.com/p/5e0210694ee6">Android优化系列一： 日志清理</a></li></ul><p><a href="https://www.jianshu.com/p/4b61391a665f">Androrid应用打包release版时关闭log日志输出</a></p><h3 id="content-provider"><a href="#content-provider" class="headerlink" title="content provider"></a>content provider</h3><p>如果不打算向其他应用授予访问APP的 ContentProvider的权限，在应用清单中将其标记为 [android:exported&#x3D;false]；要允许其他应用访问APP的数据，将 [android:exported]属性设置为 “true”。</p><h4 id="android-exported"><a href="#android-exported" class="headerlink" title="android:exported"></a>android:exported</h4><p>android:exported 是Android中的四大组件 Activity，Service，Provider，Receiver 四大组件中都会有的一个属性。</p><p>总体来说它的主要作用是：是否支持其它应用调用当前组件。<br>默认值：如果包含有intent-filter 默认值为true; 没有intent-filter默认值为false。<br>在Activity中，该属性用来表示：当前Activity是否可以被另一个Application的组件启动：<br>true允许被启动；false不允许被启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:exported=[&quot;true&quot; | &quot;false&quot;]</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。<br>exported 的默认值根据Activity中是否有intent filter 来定。<br>没有任何的filter意味着这个Activity只有在详细的描述了他的class name后才能被唤醒。这意味着这个Activity只能在应用内部使用，因为其它application并不知道这个class的存在。所以在这种情况下，它的默认值是false。从另一方面讲，如果Activity里面至少有一个filter的话，意味着这个Activity可以被其它应用从外部唤起，这个时候它的默认值是true。</p><h4 id="android-protectionLevel"><a href="#android-protectionLevel" class="headerlink" title="android:protectionLevel"></a>android:protectionLevel</h4><p>如果要在其他自己的应用上访问该APP，那么首先将 [android:exported]属性设置为 “true”，然后最好设置一下[android:protectionLevel]属性。</p><p>Android protectionLevel分4个级别：</p><ul><li>normal<br>低风险权限，只要申请了就可以使用（在AndroidManifest.xml中添加&lt;uses-permission&gt;标签），安装时不需要用户确认。</li><li>dangerous<br>高风险权限，安装时需要用户的确认才可使用。</li><li>signature<br>只有当申请权限的应用程序的数字签名与声明此权限的应用程序的数字签名相同时（如果是申请系统权限，则需要与系统签名相同），才能将权限授给它。</li><li>signatureOrSystem<br>签名相同，或者申请权限的应用为系统应用（在system image中）。</li></ul><p>如果开发者需要对自己的应用程序（或部分应用）进行访问控制，则可以通过在AndroidManifest.xml中添加&lt;permission&gt;标签，最好将其属性中的protectionLevel设置为signature 保护级别。</p><p>访问内容提供程序时，请使用参数化的查询方法（例如 query()、update() 和 delete()），以免产生来源不受信任的 SQL 注入风险。请注意，如果以组合用户数据的方式构建 selection 参数，然后再将其提交至参数化方法，则使用参数化方法可能不够安全。</p><p>参考文章<br><a href="https://blog.csdn.net/watermusicyes/article/details/46460347">android:exported 属性详解</a></p><p><a href="https://blog.csdn.net/u013553529/article/details/53167072">Android 权限的一些细节</a></p><h3 id="Activity组件安全"><a href="#Activity组件安全" class="headerlink" title="Activity组件安全"></a>Activity组件安全</h3><p>使用activity的风险和选择取决于需求对activity的定义。这里我们基于activity的使用方式将其分为4中类型：</p><ul><li>私有activity：只能有APP内部使用的activity，最安全的activity。</li><li>公共activity：任意APP都能启动此类activity。</li><li>伙伴activity：合作伙伴APP才能启动的activity，授权。</li><li>内部activity：只有内部APP才能启动，全家桶。</li></ul><h4 id="私有activity"><a href="#私有activity" class="headerlink" title="私有activity"></a>私有activity</h4><p>私有activity不能由其他应用程序启动，因此它是最安全的。当一个activity只在本APP内部使用时，只要将activity声明为显式intent调用方式，那么就不需要担心其他应用程序调用开启。</p><p>然而，有一个风险是第三方APP可以读取一个开启activity的intent。因此，为了避免第三方应用程序读取Intent来复制intent，我们可以在intent中放置一些extra做判断，避免第三方应用程序调用。</p><p>一个私有activity必须做到的关键几点如下：</p><ul><li>不声明taskAffinity</li><li>不声明launchMode</li><li>设置exported属性为false</li><li>保证intent发送时的安全性，确定intent是来自本应用程序(签名验证和包名验证)</li><li>启动activity的时候不设置FLAG_ACTIVITY_NEW_TASK</li><li>使用显示的intent和指定的类的方式来调用一个activity</li><li>敏感信息放在extra中发送</li><li>在onActivityResult的时候需要对返回的data小心处理</li></ul><h4 id="组件传输数据验证"><a href="#组件传输数据验证" class="headerlink" title="组件传输数据验证"></a>组件传输数据验证</h4><p>对组件之间，特别是跨应用的组件之间的数据传入和返回做数据验证，防止恶意数据传入，更要防止敏感数据的返回。<br>对于导出的组件，最好做intent的校验：<br>数据格式或数据结构校验；<br>异常处理：防止crash攻击。</p><p>隐式intent没有明确指明哪些接收方有权限接收，恶意程序指定action标识后，可以获取intent内容，导致数据泄漏、intent劫持、仿冒、钓鱼应用等风险使用。</p><p>建议：</p><ul><li>显示intent调用，直接写类名</li><li>使用Intent.setPackage、Intent.setComponent、Intent.setClassName、Intent.setClass四种方法中任一种明确指定目标组件名称。</li></ul><p>传输端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent;</span><br><span class="line">intent = new Intent(MainActivity.this,SecondActivity.class);</span><br><span class="line">intent.setPackage(getPackageName());</span><br><span class="line">bundle = new Bundle();</span><br><span class="line">bundle.put...;</span><br><span class="line">intent.putExtra(&quot;...&quot;,bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">String packagename = intent.getPackage().toString();</span><br><span class="line">if(packagename.equals(getPackageName())) &#123;</span><br><span class="line">    Bundle bundle = intent.getBundleExtra(&quot;...&quot;);</span><br><span class="line">    if(bundle != null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>需要特别注意的点：</p><ul><li>权限检查：<br>a) 最小化系统权限<br>b) 自定义权限进行级别保护设置</li><li>调试标记检查：debuggable&#x3D;”false”</li><li>程序数据任意备份检查：allowBackup&#x3D;”false”</li></ul><p>参考文章<br><a href="https://www.jianshu.com/p/0eb6df1e9c4d">Android App 安全策略</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity的四种launchMode</title>
      <link href="/2018/10/14/Activity%E7%9A%84%E5%9B%9B%E7%A7%8DlaunchMode/"/>
      <url>/2018/10/14/Activity%E7%9A%84%E5%9B%9B%E7%A7%8DlaunchMode/</url>
      
        <content type="html"><![CDATA[<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><p>launchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。</p><span id="more"></span><p>task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。</p><p>Activity一共有以下四种launchMode：</p><ul><li>standard</li><li>singleTop</li><li>singleTask</li><li>singleInstance</li></ul><p>我们可以在AndroidManifest.xml配置&lt;activity&gt;的android:launchMode属性为以上四种之一即可。</p><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>standard模式是默认的启动模式，不用为&lt;activity&gt;配置android:launchMode属性即可，当然也可以指定值为standard。<br>启动模式示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FirstActivity为默认启动模式</span><br><span class="line"></span><br><span class="line">Intent intent = new Intent(FirstActivity.this, FirstActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>每次intent跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。</p><p><strong>这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。</strong></p><h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>将上面的示例修改FirstActivity启动模式，FirstActivity指定属性android:launchMode&#x3D;”singleTop”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(FirstActivity.this, FirstActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>每次intent跳转到同一个FirstActivity实例，如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line">Intent intent = new Intent(SecondActivity.this, FirstActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>先从FirstActivity跳转到SecondActivity，然后SecondActivity再跳转到FirstActivity时，因为此时之前的FirstActivity不在栈顶，此时栈顶是SecondActivity，故从SecondActivity跳转到FirstActivity时新建了一个FirstActivity实例。</p><p><strong>intent跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用；如果没有则创建一个新的实例；如果task里有，但是对应的Activity不是位于栈顶,仍然创建一个新的实例。</strong></p><h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>将上面的示例修改FirstActivity启动模式，FirstActivity指定属性android:launchMode&#x3D;”singleTask”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line">Intent intent = new Intent(SecondActivity.this, FirstActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>先从FirstActivity跳转到SecondActivity，然后SecondActivity再跳转到FirstActivity，在这个的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。</p><p>从SecondActivity跳转到FirstActivity时，FirstActivity用的之前创建的，同时SecondActivity实例被迫出栈，栈顶只有FirstActivity。</p><p>如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例也不是唯一的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。</p><p><strong>这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。</strong></p><p><strong>launchMode为singleTask的时候，通过Intent启到一个Activity,如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法</strong></p><p><strong>不要忘记，系统可能会随时杀掉后台运行的Activity，如果这一切发生，那么系统就会调用onCreate方法，而不调用onNewIntent方法，一个好的解决方法就是在onCreate和onNewIntent方法中调用同一个处理数据的方法</strong></p><h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。</p><p>将FirstActivity启动模式设置为android:launchMode&#x3D;”standard”：<br>将SecondActivity启动模式设置为android:launchMode&#x3D;”singleInstance”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，就再次回到原始栈结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line">Intent intent = new Intent(SecondActivity.this, FirstActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中新生成一个FirstActivity实例，此时在原始栈中有2个FirstActivity实例。</p><p>然后按下后退键，从第2个FirstActivity实例回退到第1个FirstActivity实例，再按下后退键时，程序并不退出，而是回到SecondActivity。因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。</p><p>将FirstActivity启动模式设置为singleTop、singleTask、singleInstance中的任意一个，<br>将SecondActivity启动模式设置为android:launchMode&#x3D;”singleInstance”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line">Intent intent = new Intent(SecondActivity.this, FirstActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，在SecondActivity中再次跳转到FirstActivity时跳转到原来的FirstActivity实例，然后按下后退键时，回到SecondActivity。</p><p>文章整理自<a href="https://blog.csdn.net/liuhe688/article/details/6754323/"><br>基础总结篇之二：Activity的四种launchMode</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android命名规范</title>
      <link href="/2018/10/13/Android%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2018/10/13/Android%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="标识符命名方法"><a href="#标识符命名方法" class="headerlink" title="标识符命名方法"></a>标识符命名方法</h3><ul><li>小驼峰命名法，除首单词外，其余所有单词的第一个字母大写。如：allPrice，getAllNames。</li><li>大驼峰命名法，所有单词的第一个字母大写。如：GuideActivity，StudentInfoBean。</li><li>下划线命名法:单词与单词间用下划线做间隔。如：activity_main,select_backGround_color。</li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><h4 id="包（packages）"><a href="#包（packages）" class="headerlink" title="包（packages）"></a>包（packages）</h4><p>采用反域名命名规则，全部使用小写字母。一级包名为com，二级包名lwz（为个人或公司名称，可以简写），三级包名guidecity（根据应用进行命名），四级包名ui或utils等（模块名或层级名），根据实际情况也是可以用五级包名，六级包名。这里的四级包名是要重点理解和分类的，例如：com.lwz.应用.utils ，此包中包含：公共工具方法类。</p><ul><li>utils<br>此包中包含：公共工具方法类，比如：SPHelperUtil、TimeUitl、FileUtil等</li><li>adapter<br>此包中包含：一些适配器的类，比如：ArticleAdapter、FansAdapter，HistorAdaper等</li><li>base<br>此包中包含：一些共同类的基类，比如：BaseActivity（所有的Activity类都继承这个类）、BaseFragment（所有的Fragment都继承这个类），ListItemAdapter（封装了Base Adapter的基类）等</li><li>bean<br>此包中包含：一些属性对象类，比如：StudentBean、LonginBean、ArticleBean等</li><li>config<br>此包中包含：最顶级的配置类，比如：MyApp（继承了Application）</li><li>httpservice<br>此包中包含：Http数据的请求接口类，好像Retrofit网络框架请求网络数据才要使用。如：ILogin接口，IAddTopic接口，IUpdate等</li><li>interface<br>此包中包含：某个页面或对象的所用操作接口类，这个接口主要是定义这个对象的所有方法。如：IUser接口，IArticle接口，ITopic接口等</li><li>model<br>这是MVC或MVP框架设计中的M。此包中包含：某个页面或对象的所用操作类，这个类继承了上面定义的interface接口，重写并实现厘米那的方法。如：UserModel，ArticleMode类，TopicMode类等</li><li>ui<br>这个ui表示的页面的意思，也是MVC或MVP中的V，很多人把这个包名写成activity，其实是不准确的，因为ui包含了activity和fragment，所以ui是四级包名，而activity和fragment是ui包下的五级包名。 activity此包中包含：Activity对象类。如：MainActivity类，HomeActivity类，FansListActivity类等。如果是使用了MVP框架模式，activity包名下还可以有六级包名，比如：loginMVP（包含ILoginView接口类，LoginPresenter类）、seleteTopicMVP fragment此包中包含：Fragment对象类。但是Fragment一般都是多个存在的，所以fragment包下一般还有六级包名，表示里面是哪个页面的Fragment对象。</li><li>weight<br>此包中包含：自定义View或自定义对话框等视图类。如：CursroDialog类，SpringScrollView类，ScrollListView类等</li><li>db<br>此包中包含：数据库操作类</li><li>service<br>此包中包含：Service服务类</li><li>broadcast<br>此包中包含：Broadcast广播接收者类</li><li>provider<br>此包中包含：Provider内容提供者类（用得很少）</li></ul><h4 id="类（classes）"><a href="#类（classes）" class="headerlink" title="类（classes）"></a>类（classes）</h4><p>一般用名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的，比如HTML,URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。<br>以下是部分示例说明： </p><ul><li>1.activity 类，如欢迎页面类WelcomeActivity. </li><li>2.adapter类,如商品详情适配器ProductDetailAdapter </li><li>3.util公共方法类，如：线程池管理类：ThreadPoolManager，日志工具类：LogUtil </li><li>4.db数据库类，以DBHelper后缀标识。如城市数据库：CityDBHelper </li><li>5.Service类，以Service为后缀标识 </li><li>6.BroadcastReceive，以Broadcast为后缀标识 </li><li>7.ContentProvider，以Provider为后缀标识</li></ul><h4 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h4><p>命名规则与类一样采用大驼峰命名法，多以able或ible结尾或以I开头，如Runnable、Accessible、IUser。</p><h4 id="方法（methods）"><a href="#方法（methods）" class="headerlink" title="方法（methods）"></a>方法（methods）</h4><p>一般使用动词或动名词，采用小驼峰命名法 例如:onCreate(),run()</p><ul><li>1.initXXX()初始化相关方法,使用init为前缀标识</li><li>2.isXXX()、checkXXX() 方法返回值为boolean型的请使用is或check为前缀标识</li><li>3.getXXX()返回某个值的方法，使用get为前缀标识</li><li>4.processXXX() 对数据进行处理的方法，尽量使用process为前缀标识</li><li>5.displayXXX() 弹出提示框和提示信息，使用display为前缀标识</li><li>6.saveXXX()    与保存数据相关的，使用sav为e前缀标识</li><li>7.resetXXX()   对数据重组的，使用reset前缀标识</li><li>8.clearXXX()、removeXXX()  清除数据相关的，使用clear或remove为前缀标识</li><li>9.drawXXX()     绘制数据或效果相关的，使用draw前缀标识</li></ul><h4 id="变量（variables）"><a href="#变量（variables）" class="headerlink" title="变量（variables）"></a>变量（variables）</h4><p>变量（variables）采用小驼峰命名法。类中控件名称一般与xml布局id保持一致。</p><h4 id="常量（constants）"><a href="#常量（constants）" class="headerlink" title="常量（constants）"></a>常量（constants）</h4><p>常量（constants）全部大写,采用下划线命名法.例如：MIN_WIDTH。</p><h4 id="XML文件（布局文件）"><a href="#XML文件（布局文件）" class="headerlink" title="XML文件（布局文件）"></a>XML文件（布局文件）</h4><p>XML文件（布局文件）：全部小写，采用下划线命名法，例如：main_activity.xml， item_activity.xml、homeposter_item_poster.xml</p><h4 id="资源文件（图片）"><a href="#资源文件（图片）" class="headerlink" title="资源文件（图片）"></a>资源文件（图片）</h4><p>资源文件（图片）： 全部小写，采用下划线命名法，加前缀区分。</p><table><thead><tr><th>命名</th><th>说明</th></tr></thead><tbody><tr><td>btn_login_normal</td><td>按钮图片使用btn_功能_说明</td></tr><tr><td>bg_head</td><td>背景图片使用bg_功能_说明</td></tr><tr><td>def_search_cell</td><td>默认图片使用def_功能_说明</td></tr><tr><td>icon_more_help</td><td>图标图片使用icon_功能_说明</td></tr><tr><td>seg_list_line</td><td>具有分隔特征的图片使用seg_功能_说明</td></tr><tr><td>sel_ok</td><td>选择图标使用sel_功能_说明</td></tr></tbody></table><h4 id="动画文件（anim包）"><a href="#动画文件（anim包）" class="headerlink" title="动画文件（anim包）"></a>动画文件（anim包）</h4><p>动画文件（anim包）：全部小写，采用下划线命名法，加前缀区分。</p><table><thead><tr><th>命名</th><th>说明</th></tr></thead><tbody><tr><td>click_head_left</td><td>点击背景切换动画使用click前缀标识</td></tr><tr><td>bg_shape_rectangle</td><td>背景自定义图形使用bg前缀标识</td></tr><tr><td>show_shopcar_add</td><td>小动画效果使用show前缀标识</td></tr></tbody></table><h4 id="资源ID（resources-id）"><a href="#资源ID（resources-id）" class="headerlink" title="资源ID（resources id）"></a>资源ID（resources id）</h4><p>资源ID（resources id）：大小写规范与方法名一致，采用小驼峰命名法。<br>命名规范为“资源控件的缩写名”+“变量名”。例如TextView的id&#x3D;“tv_userName”。注意：页面控件名称应该和控件id名一般是一致，例如：TextView tv_userName&#x3D;(TextView)findViewById(R.id.tv_userName);</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中关键字的作用域</title>
      <link href="/2018/10/13/Android%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2018/10/13/Android%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="Android中关键字的作用域"><a href="#Android中关键字的作用域" class="headerlink" title="Android中关键字的作用域"></a>Android中关键字的作用域</h4><p>Android中public、private、protected、friendly的作用域:</p><span id="more"></span><p>public,protected,friendly,private的访问权限如下：</p><table><thead><tr><th>关键字</th><th>当前类</th><th>同一package</th><th>子孙类</th><th>其他package</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>friendly</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>通过上面表格可以看出：</p><ul><li>不写时默认为friendly</li><li>public声明的变量及方法，表明在整个包内包外都可使用。</li><li>private 声明的变量及方法，只在声明的类内可以使用。</li><li>protected包外不可使用。包内可以使用。</li><li>不使用关键字默认为包内使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下配置路由表</title>
      <link href="/2018/10/10/Linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E8%A1%A8/"/>
      <url>/2018/10/10/Linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="路由的基础知识"><a href="#路由的基础知识" class="headerlink" title="路由的基础知识"></a>路由的基础知识</h3><span id="more"></span><h4 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h4><p>路由：   跨越从源主机到目标主机的一个互联网络来转发数据包的过程<br>路由器：能够将数据包转发到正确的目的地，并在转发过程中选择最佳路径的设备<br>路由表：在路由器中维护的路由条目，路由器根据路由表做路径选择<br>直连路由：当在路由器上配置了接口的IP地址，并且接口状态为up的时候，路由表中就出现直连路由项<br>静态路由：是由管理员手工配置的，是单向的。<br>默认路由：当路由器在路由表中找不到目标网络的路由条目时，路由器把请求转发到默认路由接口 。</p><h4 id="静态路由和默认路由的特点"><a href="#静态路由和默认路由的特点" class="headerlink" title="静态路由和默认路由的特点"></a>静态路由和默认路由的特点</h4><ul><li><p>静态路由特点:<br>路由表是手工设置的；<br>除非网络管理员干预，否则静态路由不会发生变化；<br>路由表的形成不需要占用网络资源；<br>适用环境：一般用于网络规模很小、拓扑结构固定的网络中。</p></li><li><p>默认路由特点:<br>在所有路由类型中，默认路由的优先级最低<br>适用环境：一般应用在只有一个出口的末端网络中或作为其他路由的补充</p></li><li><p>浮动静态路由：<br>路由表中存在相同目标网络的路由条目时，根据路由条目优先级的高低，将请求转发到相应端口；<br>链路冗余的作用；</p></li></ul><h4 id="路由器转发数据包时的封装过程"><a href="#路由器转发数据包时的封装过程" class="headerlink" title="路由器转发数据包时的封装过程"></a>路由器转发数据包时的封装过程</h4><p>源IP和目标IP不发生变化，在网络的每一段传输时，源和目标MAC发生变化，进行重新封装，分别是每一段的源和目标地址。</p><h4 id="要完成对数据包的路由，一个路由器必须至少了解以下内容："><a href="#要完成对数据包的路由，一个路由器必须至少了解以下内容：" class="headerlink" title="要完成对数据包的路由，一个路由器必须至少了解以下内容："></a>要完成对数据包的路由，一个路由器必须至少了解以下内容：</h4><ul><li>目的地址</li><li>相连路由器，并可以从哪里获得远程网络的信息</li><li>到所有远程网络的可能路由</li><li>到达每个远程网络的最佳路由</li><li>如何维护并验证路由信息</li><li>路由和交换的对比</li></ul><p>路由工作在网络层：</p><ul><li>根据“路由表”转发数据</li><li>路由选择</li><li>路由转发</li></ul><p>交换工作在数据链路层：</p><ul><li>根据“MAC地址表”转发数据</li><li>硬件转发</li></ul><h3 id="Linux中的route"><a href="#Linux中的route" class="headerlink" title="Linux中的route"></a>Linux中的route</h3><h4 id="使用route-n命令查看Linux内核路由表"><a href="#使用route-n命令查看Linux内核路由表" class="headerlink" title="使用route -n命令查看Linux内核路由表"></a>使用route -n命令查看Linux内核路由表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi@pi:~ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    202    0        0 eth0</span><br><span class="line">0.0.0.0         10.89.0.1       0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">10.89.0.0       0.0.0.0         255.255.240.0   U     303    0        0 wlan0</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     202    0        0 eth0</span><br></pre></td></tr></table></figure><p>输出说明：</p><table><thead><tr><th>输出项</th><th>说明</th></tr></thead><tbody><tr><td>Destination</td><td>目标网段或者主机</td></tr><tr><td>Gateway</td><td>网关地址，*表示目标是本主机所属的网络，不需要路由</td></tr><tr><td>Genmask</td><td>网络掩码</td></tr><tr><td>Flags</td><td>标记</td></tr><tr><td>Metric</td><td>路由距离，到达指定网络所需要的中转数</td></tr><tr><td>Ref</td><td>路由项引用次数</td></tr><tr><td>Use</td><td>此路由项被路由软件查找的次数</td></tr><tr><td>Iface</td><td>此路由项对应的输出接口</td></tr></tbody></table><p>Flags的一些标记含义：</p><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>U</td><td>路由是活动的</td></tr><tr><td>H</td><td>目标是个主机</td></tr><tr><td>G</td><td>路由指向网关</td></tr><tr><td>R</td><td>恢复动态路由产生的表项</td></tr><tr><td>D</td><td>由路由的后台程序动态的安装</td></tr><tr><td>M</td><td>由路由的后台程序修改</td></tr><tr><td>!</td><td>拒绝路由</td></tr></tbody></table><h4 id="三种路由类型说明"><a href="#三种路由类型说明" class="headerlink" title="三种路由类型说明"></a>三种路由类型说明</h4><ul><li>1.主机路由：<br>主机路由是路由选择表中指向单个IP地址或主机名的路由记录。主机路由的Flags字段为H。例如，在下面的示例中，本地主机通过IP地址192.168.1.1的路由器到达IP地址为10.89.0.10的主机。<br>添加主机路由时，需要指定网络 ID 和主机 ID，此时需要设置 netmask 255.255.255.255。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask                 Flags Metric Ref    Use Iface</span><br><span class="line">10.89.0.10      192.168.1.1     255.255.255.255         UH      0    0        0 eth0</span><br></pre></td></tr></table></figure></li><li>2.网络路由：<br>网络路由是代表主机可以到达的网络。网络路由的Flags字段为N。例如，在下面的示例中，本地主机将发送到网络192.19.12的数据包转发到IP地址为192.168.1.1的路由器。<br>添加网络路由时，只需指定网络 ID，通过 netmask 设置掩码长度。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask               Flags Metric Ref    Use Iface</span><br><span class="line">192.19.12       192.168.1.1     255.255.255.0         UN      0    0        0 eth0</span><br></pre></td></tr></table></figure></li><li>3.默认路由：<br>当主机不能在路由表中查找到目标主机的IP地址或网络路由时，数据包就被发送到默认路由（默认网关）上。默认路由的Flags字段为G。例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    202    0        0 eth0</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置路由route的命令"><a href="#配置路由route的命令" class="headerlink" title="配置路由route的命令"></a>配置路由route的命令</h4><p>设置和查看路由表都可以用 route 命令，设置内核路由表的命令格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route  [add|del] [-net|-host] target [netmask Nm] [gw Gw] [[dev] If]</span><br></pre></td></tr></table></figure><p>参数解释：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>add</td><td>添加一条路由规则</td></tr><tr><td>del</td><td>删除一条路由规则</td></tr><tr><td>-net</td><td>目的地址是一个网络</td></tr><tr><td>-host</td><td>目的地址是一个主机</td></tr><tr><td>target</td><td>目的网络或主机</td></tr><tr><td>netmask</td><td>目的地址的网络掩码</td></tr><tr><td>gw</td><td>路由数据包通过的网关</td></tr><tr><td>dev</td><td>为路由指定的网络接口</td></tr></tbody></table><p>route命令使用举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">添加到主机的路由</span><br><span class="line"># route add -host 192.168.1.2 dev eth0:0</span><br><span class="line"># route add -host 10.20.30.148 gw 10.20.30.40</span><br><span class="line">  </span><br><span class="line">添加到网络的路由</span><br><span class="line"># route add -net 10.20.30.40 netmask 255.255.255.248 eth0</span><br><span class="line"># route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41</span><br><span class="line"># route add -net 192.168.1.0/24 eth1</span><br><span class="line">  </span><br><span class="line">添加默认路由</span><br><span class="line"># route add default gw 192.168.1.1</span><br><span class="line">  </span><br><span class="line">删除路由</span><br><span class="line"># route del -host 192.168.1.2 dev eth0:0</span><br><span class="line"># route del -host 10.20.30.148 gw 10.20.30.40</span><br><span class="line"># route del -net 10.20.30.40 netmask 255.255.255.248 eth0</span><br><span class="line"># route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41</span><br><span class="line"># route del -net 192.168.1.0/24 eth1</span><br><span class="line"># route del default gw 192.168.1.1                  //route del default   删除所有的默认路由</span><br><span class="line"> </span><br><span class="line">添加一条默认路由</span><br><span class="line"># route add default gw 10.0.0.1      //默认只在内存中生效</span><br><span class="line">开机自启动可以追加到/etc/rc.local文件里</span><br><span class="line"># echo &quot;route add default gw 10.0.0.1&quot; &gt;&gt;/etc/rc.local</span><br><span class="line"> </span><br><span class="line">添加一条静态路由</span><br><span class="line"># route add -net 192.168.2.0/24 gw 192.168.2.254</span><br><span class="line">要永久生效的话要这样做：</span><br><span class="line"># echo &quot;any net 192.168.2.0/24 gw 192.168.2.254&quot; &gt;&gt;/etc/sysconfig/static-routes</span><br><span class="line"> </span><br><span class="line">添加到一台主机的静态路由</span><br><span class="line"># route add -host 192.168.2.2 gw 192.168.2.254</span><br><span class="line">要永久生效的话要这样做：</span><br><span class="line"># echo &quot;any  host 192.168.2.2 gw 192.168.2.254 &quot; &gt;&gt;/etc/sysconfig/static-routes</span><br><span class="line">注：Linux 默认没有这个文件 ，得手动创建一个</span><br></pre></td></tr></table></figure><h4 id="设置包转发"><a href="#设置包转发" class="headerlink" title="设置包转发"></a>设置包转发</h4><p>在Linux中默认的内核配置已经包含了路由功能，但默认并没有在系统启动时启用此功能；<br>开启Linux的路由功能可以通过调整内核的网络参数来实现，方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">临时开启路由功能：</span><br><span class="line"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">或者</span><br><span class="line"># sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">永久开启路由功能</span><br><span class="line"># vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"># sysctl -p</span><br></pre></td></tr></table></figure><h4 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h4><p>添加静态路由到路由表的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route [destination_network] [mask] [next-hop_address] administrative_distance]</span><br></pre></td></tr></table></figure><p>参数解释：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>destination_network</td><td>需要发布到路由表中的网段</td></tr><tr><td>mask</td><td>在这一网络上使用的子网掩码</td></tr><tr><td>next-hop_address</td><td>下一跳路由器的地址</td></tr><tr><td>administrative_distance</td><td>默认时，静态路由有一个取值为1 的管理性距离。在这个命令的尾部添加管理权来修改这个默认值。</td></tr></tbody></table><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route 172.16.1.0 255.255.255.0 172.16.2.1</span><br></pre></td></tr></table></figure><p>查看路由表除了使用route -n命令外，还可以使用ip route:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default via 192.168.1.1 dev eth0 src 192.168.1.109 metric 202</span><br><span class="line">default via 10.89.0.1 dev wlan0 src 10.89.2.144 metric 303</span><br><span class="line">10.89.0.0/20 dev wlan0 proto kernel scope link src 10.89.2.144 metric 303</span><br><span class="line">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.109 metric 202</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmcli的使用方法</title>
      <link href="/2018/10/09/nmcli%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/10/09/nmcli%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Red Hat Enterprise Linux 7 与 CentOS 7 中默认的网络服务由 NetworkManager 提供，这是动态控制及配置网络的守护进程，它用于保持当前网络设备及连接处于工作状态，同时也支持传统的 ifcfg 类型的配置文件。</p><span id="more"></span><p>NetworkManager 可以用于以下类型的连接：Ethernet，VLANS，Bridges，Bonds，Teams，Wi-Fi，mobile boradband（如移动3G）以及 IP-over-InfiniBand。针对与这些网络类型，NetworkManager 可以配置他们的网络别名，IP 地址，静态路由，DNS，VPN连接以及很多其它的特殊参数。</p><p>可以用命令行工具 nmcli 来控制 NetworkManager。在CentOS &#x2F; RHEL 7中网络管理命令行工具，也叫nmcli。经常使用ifconfig的用户应该在CentOS 7中避免使用ifconfig了。nmcli的功能要强大、复杂的多。</p><p>network-manager (包括 nmcli, nm-tool 等工具) 比 wpa_supplicant 要更加智能，方便一些。 配置 network-manager 的文件在 &#x2F;etc&#x2F;NetworkManager&#x2F;NetworkManager.conf 中，如果某个网卡不想通过 network-manager 控制，可以在配置文件中指定。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install network-manager</span><br></pre></td></tr></table></figure><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>命令语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli[ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OBJECT和COMMAND可以用全称也可以用简称，最少可以只用一个字母，建议用头三个字母。OBJECT里面我们平时用的最多的就是connection和device，这里需要简单区分一下connection和device。</p><p>device叫网络接口，是物理设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device -show and manage network interfaces</span><br><span class="line">nmcli device help</span><br></pre></td></tr></table></figure><p>connection是连接，偏重于逻辑设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection -start, stop, and manage network connections</span><br><span class="line">nmcli connection help</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>1.显示所有包括不活动连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show</span><br></pre></td></tr></table></figure><p>2.显示所有活动连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show --active</span><br></pre></td></tr></table></figure><p>3.显示网络连接配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con show &quot;System eth0“</span><br></pre></td></tr></table></figure><p>4.显示设备状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli dev status</span><br></pre></td></tr></table></figure><p>5.显示网络接口属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli dev show eno16777736</span><br></pre></td></tr></table></figure><p>6.创建新连接default，IP自动通过dhcp获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con add con-name default type Ethernet ifnameeth0</span><br></pre></td></tr></table></figure><p>7.删除连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con del default</span><br></pre></td></tr></table></figure><p>8.创建新连接static ，指定静态IP，不自动连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcticon add con-name static ifnameeth0 autoconnect no type Ethernet </span><br><span class="line">ip4 172.25.X.10/24  gw4 172.25.X.254</span><br></pre></td></tr></table></figure><p>con add – 添加新的连接<br>con-name – 连接名<br>type – 设备类型<br>ifname – 接口名<br>autoconnect no - 禁止开机自动启动<br>命令完成后，会在&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;下生成一个配置文件，但是网卡没有绑定，所以并没有生效。<br>9.启用static连接配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con up static</span><br></pre></td></tr></table></figure><p>10.启用default连接配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con up default</span><br></pre></td></tr></table></figure><p>11.删除一个连接配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli con delete home</span><br></pre></td></tr></table></figure><p>12.修改连接设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nmcli con mod“static” connection.autoconnect no</span><br><span class="line">nmcli con mod “static” ipv4.dns 172.25.X.254</span><br><span class="line">nmcli con mod “static” +ipv4.dns 8.8.8.8</span><br><span class="line">nmcli con mod “static” -ipv4.dns 8.8.8.8</span><br><span class="line">nmcli con mod “static” ipv4.addresses “172.25.X.10/24 172.25.X.254”</span><br><span class="line">nmcli con mod “static” +ipv4.addresses 10.10.10.10/16</span><br></pre></td></tr></table></figure><p>+：添加第二个参数<br>-：删除参数<br>无+或-：修改参数</p><p>设备配置被保存在文本文件中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/ifcfg-&lt;name&gt;</span><br></pre></td></tr></table></figure><p>帮助文档列出完整选项列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/doc/initcripts-*/sysconfig.txt</span><br></pre></td></tr></table></figure><p>13.修改连接配置后，需要重新加载配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmcli con reload</span><br><span class="line">nmcli con down “system eth0” 可被自动激活</span><br><span class="line">nmcli con up “system eth0”</span><br><span class="line">nmcli dev dis eth0 禁用网卡，访止被自动激活</span><br></pre></td></tr></table></figure><h4 id="wifi"><a href="#wifi" class="headerlink" title="wifi"></a>wifi</h4><p>1.Get Wifi status</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli radio wifi</span><br></pre></td></tr></table></figure><p>2.Turn wifi on or off</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli radio wifi &lt;on|off&gt;</span><br></pre></td></tr></table></figure><p>3.List available access points(AP) to connect to</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure><p>4.Refresh previous list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi rescan</span><br></pre></td></tr></table></figure><p>5.Create a new connection to an open AP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect &lt;SSID|BSSID&gt;</span><br></pre></td></tr></table></figure><p>6.Create a new connection to a password protected AP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect &lt;SSID|BSSID&gt; password &lt;password&gt;</span><br></pre></td></tr></table></figure><p>7.create a WPA2 Enterprise connection </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add \</span><br><span class="line"> type wifi con-name &quot;MySSID&quot; ifname wlp3s0 ssid &quot;MySSID&quot; -- \</span><br><span class="line"> wifi-sec.key-mgmt wpa-eap 802-1x.eap tls 802-1x.identity &quot;USERNAME&quot; \</span><br><span class="line"> 802-1x.ca-cert ~/ca.pem 802-1x.client-cert ~/cert.pem \</span><br><span class="line"> 802-1x.private-key-password &quot;...&quot; 802-1x.private-key ~/key.pem</span><br></pre></td></tr></table></figure><p>substitute your own wifi device name for wlp3s0, and so forth.<br>It will then be listed under nmcli connection, and can be brought up using nmcli connection up MySSID.</p><p>8.Authenticating with a username and password<br>if you use a username&#x2F;password auth (likely via RADIUS) you can use the command below to add it (use the correct 802-1x.eap option for your network, the example of ttls as below doesn’t require a certificate to be defined) and then use –ask the first time you go to connect to save the password into the connection file.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add \</span><br><span class="line"> type wifi con-name &quot;MySSID&quot; ifname wlp3s0 ssid &quot;MySSID&quot; -- \</span><br><span class="line"> wifi-sec.key-mgmt wpa-eap 802-1x.eap ttls \</span><br><span class="line"> 802-1x.phase2-auth mschapv2 802-1x.identity &quot;USERNAME&quot; </span><br></pre></td></tr></table></figure><p>If using the username&#x2F;password option you should add –ask after nmcli the first time you bring it up to save the password without leaving it in your command history. It will give you an error message saying as much when you attempt to bring it up otherwise. You will probably get prompted about additional wireless settings when using –ask, you can type no for them unless you need to specify a static IP, in which case answer yes for that option and set the correct information, and in the future you shouldn’t need to use –ask unless your password changes.</p><p>or:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># nmcli con edit CONNECTION_NAME</span><br><span class="line">nmcli&gt; set ipv4.method auto</span><br><span class="line">nmcli&gt; set 802-1x.eap peap</span><br><span class="line">nmcli&gt; set 802-1x.identity USERNAME</span><br><span class="line">nmcli&gt; set 802-1x.phase2-auth mschapv2</span><br><span class="line">nmcli&gt; save</span><br><span class="line">nmcli&gt; quit</span><br></pre></td></tr></table></figure><p>then vim &#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;CONNECTION_NAME to hold your password</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[connection]</span><br><span class="line">id=CONNECTION_NAME</span><br><span class="line"> </span><br><span class="line">[802-1x]</span><br><span class="line">password=YOUR_8021X_PASSWORD</span><br></pre></td></tr></table></figure><p>Restart NetworkManager to pick up the changes:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure><p>You may need to bring the interface down and up to test the new changes:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli con down CONNECTION_NAME</span><br><span class="line">nmcli con up CONNECTION_NAME</span><br></pre></td></tr></table></figure><p>9.Exploring nmcli on your own<br>In general, the space of possible nmcli settings can be explored by adding the words asdf.asdf asdf to the end of the command line to produce an error message stating what words are possible substitutions for the first asdf. Choose one, and then you will get an error message listing the possible sub-settings for the second asdf. Choose one of those, and you will see the possible settings:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nmcli connection add ... asdf.asdf asdf</span><br><span class="line">Error: invalid or not allowed setting &#x27;asdf&#x27;: &#x27;asdf&#x27; not among [connection, 802-11-wireless (wifi), 802-11-wireless-security (wifi-sec), 802-1x, ipv4, ipv6].</span><br><span class="line">$ nmcli connection add ... wifi-sec.asdf asdf</span><br><span class="line">Error: invalid property &#x27;asdf&#x27;: &#x27;asdf&#x27; not among [key-mgmt, wep-tx-keyidx, auth-alg, proto, pairwise, group, leap-username, wep-key0, wep-key1, wep-key2, wep-key3, wep-key-flags, wep-key-type, psk, psk-flags, leap-password, leap-password-flags].</span><br><span class="line">$ nmcli connection add ... wifi-sec.proto asdf</span><br><span class="line">Error: failed to modify wifi-sec.proto: &#x27;asdf&#x27; not among [wpa, rsn].</span><br></pre></td></tr></table></figure><p>By iterating through all of the sub-settings, I was able to piece together the successful command line shown above. The one surprise was that the password must precede the private key path — if you put the password later, it has no effect!</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Linux系统开发要点</title>
      <link href="/2018/10/05/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%A6%81%E7%82%B9/"/>
      <url>/2018/10/05/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="嵌入式Linux系统开发要点"><a href="#嵌入式Linux系统开发要点" class="headerlink" title="嵌入式Linux系统开发要点"></a>嵌入式Linux系统开发要点</h3><p>嵌入式Linux开发就是构建一个Linux系统，这需要熟悉Linux系统组成部分，熟悉Linux开发工具，还要熟悉Linux编程。<br>嵌入式Linux系统包含Bootloader（引导程序）、内核和文件系统3部分。对于嵌入式Linux系统来说，这3个部分是必不可少的。</p><span id="more"></span><p>在启动一个嵌入式Linux项目之前，必须仔细考虑下面要点。</p><ul><li>1.选择嵌入式Linux发行版<br>商业的Linux发行版是作为产品开发维护的，经过严格的测试验证，并且可以得到厂家的技术支持。它为开发者提供了可靠的软件和完整的开发工具包。</li><li>2.熟悉开发环境和工具<br>交叉开发环境是嵌入式Linux开发的基本模型。Linux环境配置、GNU工具链、测试工具甚至集成开发环境都是开发嵌入式Linux开发的利器。</li><li>3.熟悉Linux内核<br>因为嵌入式Linux开发一般需要重新定制Linux内核，所以熟悉内核配置、编译和移植也很重要。</li><li>4.熟悉目标板引导方式<br>开发板的Bootloader负责硬件平台的最基本的初始化，并且具备引导Linux内核启动的功能。由于硬件平台是专门定制的，一般需要修改编译Bootloader。</li><li>5.熟悉Linux根文件系统<br>Linux离不开文件系统，程序和文件都存放在文件系统中。系统启动必须的程序和文件都必须放在根文件系统中。Linux内核命令行参数可以指定要挂接的根文件系统。</li><li>6.理解Linux内存模型<br>Linux是保护模式的操作系统。内核和应用程序分别运行在完全分离的虚拟地址空间，物理地址必须映射到虚拟地址才能访问。只有理解Linux内存模型，才能最大程度的优化系统性能。</li><li>7.理解Linux调度机制和进程线程编程<br>Linux调度机制影响到任务的实时性，理解调度机制可以更好的运用任务优先级。进程和线程编程则是应用程序开发所必须的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的一些细节问题（一）</title>
      <link href="/2018/10/05/C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/10/05/C%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="不同的增值语句的区别"><a href="#不同的增值语句的区别" class="headerlink" title="不同的增值语句的区别"></a>不同的增值语句的区别</h3><p>考虑下面四条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x + 1; //正规形式</span><br><span class="line">++x; //前缀自增</span><br><span class="line">x++; //后缀自增</span><br><span class="line">x += 1; //复合赋值</span><br></pre></td></tr></table></figure><p>显然，这四条语句的功能是相等的，它们都把x的值增加1。<br>最后一条等价于第一条，没什么好说的。看看中间两条，前缀自增和后缀自增。</p><p>表达式++x先将x的值递增1，然后再使用变量x的值；<br>表达式x++则是先使用变量n的值，然后再将n的值递增1。</p><p>这些区别与编译器的中间代码有关，<br>++x表示取x的地址，增加它的值，然后把值放在寄存器中；<br>x++则表示取x的地址，把它的值装入寄存器中，然后增加内存中的x的值。</p><p>在一行代码中，仅有前缀自增或后缀自增的情况下，前缀方式和后缀方式的效果相同。<br>对于使用变量x的值的上下文来说，++x和x++的效果是不同的。如果x的值是5，那么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = x++;</span><br></pre></td></tr></table></figure><p>执行后的结果是将n的值置为5（x先用后加）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = ++x;</span><br></pre></td></tr></table></figure><p>执行后的结果是将n的值置为6（x先加后用）。</p><p><strong>注意，自增与自减运算符只能作用于变量，类似于表达式(i+j)++是非法的。</strong></p><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。例如，下列宏定义定义了一个宏max：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define max(A,B) ((A) &gt; (B) ? (A) : (B))</span><br></pre></td></tr></table></figure><p>使用宏max看起来很像是函数调用，但宏调用直接将替换文本插入到代码中。形式参数（在此为A或B）的每次出现都将被替换成对应的实际参数。</p><p>因此，语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = max(p+q, r+s);</span><br></pre></td></tr></table></figure><p>将被替换为下列形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = ((p+q) &gt; (r+s) ? (p+q) : (r+s));</span><br></pre></td></tr></table></figure><p>如果对各种类型的参数的处理是一致的，则可以将同一个宏定义应用于任何数据类型，而无需针对不同的数据类型需要定义不同的max函数。</p><p>仔细考虑一下max的展开式，就会发现它存在一些缺陷。其中，作为参数的表达式要重复计算两次，如果表达式存在副作用（比如含有自增运算符或输入&#x2F;输出），则会出现不正确的情况。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(i++;j++);</span><br></pre></td></tr></table></figure><p>它将对每个参数执行两次自增操作。同时还必须注意，要适当使用圆括号以保证计算次序的正确性。考虑下列宏定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define square(x) x * x</span><br></pre></td></tr></table></figure><p>当用square(z+1)调用该宏定义时会出现错误结果。</p><p>可以通过#undef指令取消名字的宏定义，这样做可以保证后续的调用是函数调用，而不是宏调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#undef getchar</span><br><span class="line">int getchar(void) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>形式参数不能用带引号的字符串替换。但是，如果在替换文本中，参数名以#作为前缀则结果将被扩展为由实际参数替换该参数带引号的字符串中。例如，可以将它与字符串连接运算结合起来编写一个调试打印宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define dprint(expr) printf(#expr &quot; = %g\n&quot;,expr)</span><br></pre></td></tr></table></figure><p>使用语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dprint(x/y)</span><br></pre></td></tr></table></figure><p>调用该宏时，该宏将被扩展为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x/y&quot; &quot; = %g\n&quot;,x/y);</span><br></pre></td></tr></table></figure><p>其中的字符串被连接起来了，这样，该宏调用的效果等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x/y = %g\n&quot;,x/y);</span><br></pre></td></tr></table></figure><p>在实际参数中，每个双引号”将被替换为&quot;,反斜杠\将被替换为\\，因此替换后的字符串是合法的字符串常量。</p><p>预处理器运算符##为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与##相邻，则该参数将被实际参数替换，##与前后的空白符将被删除，并对替换后的结果重新扫描。例如，下面定义的宏paste用于连接两个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define paste(front,back) front ## back</span><br></pre></td></tr></table></figure><p>因此，宏调用paste(name,1)的结果将建立记号name1。</p><h3 id="大端存储与小端存储"><a href="#大端存储与小端存储" class="headerlink" title="大端存储与小端存储"></a>大端存储与小端存储</h3><p>所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；</p><p>所谓小端模式（Little-endian）, 是指数据的高字节保存在内存的高地址中,而数据的低字节保存在内在的低地址中,这种存储模式将地址的高低和数据位 权有效结合起来,高地址部分权值高,低地址部分权值低,和我们的逻辑方法一致;</p><p>如果将一个32位的整数0x12345678存放到一个整型变量（int）中，这个整型变量采用大端或者小端模式在内存中的存储由下表所示。为简单起见，本文使用OP0表示一个32位数据的最高字节MSB（Most Significant Byte），使用OP3表示一个32位数据最低字节LSB（Least Significant Byte）。 </p><table><thead><tr><th>地址偏移</th><th>大端模式</th><th>小端模式</th></tr></thead><tbody><tr><td>0x00</td><td>12(OP0)</td><td>78(OP3)</td></tr><tr><td>0X01</td><td>34(OP1)</td><td>56(OP2)</td></tr><tr><td>0X02</td><td>56(OP2)</td><td>34(OP1)</td></tr><tr><td>0X03</td><td>78(OP3)</td><td>12(OP0)</td></tr></tbody></table><p>为什么有大小端之分:<br>因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p><p>判断一个机器是大端存储还是小端存储：<br>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 0x12345678;</span><br><span class="line">char c = ((char *)&amp;a)[0];</span><br><span class="line">if(c == 0x12) 大端</span><br><span class="line">if(c == 0x78) 小端</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">int a;</span><br><span class="line">char b[4];</span><br><span class="line">&#125;c;</span><br><span class="line">c.a = 0x12345678;</span><br><span class="line">if(c.b[0] == 0x12) 大端</span><br><span class="line">if(c.b[0] == 0x78) 小端</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再论指针</title>
      <link href="/2018/10/04/%E5%86%8D%E8%AE%BA%E6%8C%87%E9%92%88/"/>
      <url>/2018/10/04/%E5%86%8D%E8%AE%BA%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="多维数组的内存布局"><a href="#多维数组的内存布局" class="headerlink" title="多维数组的内存布局"></a>多维数组的内存布局</h3><p>C语言并未像其他语言所要求的那样定义了详细的运行时程序来支持这个特性。对于某些结构如动态数组，我们必须使用指针显示的分配和操纵内存，而不是由编译器自动完成。另外还有一些结构（作为参数的多维数组），在C语言中并没有一般的形式来表达。</p><span id="more"></span><p>如果我们有以下声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char pea[4][6];</span><br></pre></td></tr></table></figure><p>有人把二维数组看作是排列在一张表格中的一行行的一维数组，事实上系统绝不允许程序按照这种方式存储数据。单个元素的存储和引用实际上是以线性形式顺序排列在内存中的。</p><p>数组下标的规则告诉我们如何计算左值pea[i][j]，首先找到pea[i]的位置，然后根据偏移量[j]取得字符。因此，pea[i][j]将被编译器解析为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(*(pea + i) + j)</span><br></pre></td></tr></table></figure><p>pea[i]的意思随pea定义的不同而变化。</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>首先看一下C语言中最常见最重要的数据结构：指向字符串一维指针数组。</p><p>可以通过声明一个一维指针数组，其中每个指针指向一个字符串来取得类似二维字符数组的效果，这种形式的声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *pea[4];</span><br></pre></td></tr></table></figure><p>注意char *pea[4]把pea声明为一个具有4个元素的数组，每个元素的类型是一个指向字符串（或字符）的指针。</p><p>在<a href="https://www.mrbluyee.com/2018/07/28/%E5%88%86%E6%9E%90C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%881%EF%BC%89/">分析C语言的声明（1）</a>里详细介绍了数组指针与指针数组的定义与区别。</p><p>这种数组必须用指向为字符串而分配的内存的指针进行初始化，可以在编译时用一个常量初始值，也可以在运行时用下面这样的代码进行初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(j=0;j&lt;4;j++)&#123;</span><br><span class="line">pea[j] = (char *)malloc(10 * sizeof(char));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是一次性的用malloc分配整个x * y个数据的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(char *)malloc(row_size * column_size * sizeof(char));</span><br></pre></td></tr></table></figure><p>然后，使用一个循环，用指针指向这块内存的各个区域。整个数组保证能够存储在连续的内存中，即按C用于分配静态数组的次序。它减少了调用malloc的维护性开销，但缺点是当处理完一个字符串时无法单独将其释放。</p><p>两个下标的二维数组和一维指针数组所存在的一个问题是：<br><strong>当你看到pea[i][j]这样的引用形式时，你并不知道pea是怎样被声明的</strong><br>这有点类似于在函数内部无法分辨传递给函数的实参究竟是一个数组还是一个指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pea[4][6]; //int型的二维数组</span><br><span class="line">int *pea[4]; //4个int型的指针的数组</span><br><span class="line">int **pea; //int类型的指针的指针</span><br></pre></td></tr></table></figure><p>在上面几种定义中，都可以使用如pea[i][j]这样的形式，尽管在不同的情况中访问的实际类型并不相同。</p><p>与二维数组一样，一个指针数组（char *pea[4]）中的单个字符也是使用两个下标来引用数组中的元素(如pea[i][j])。指针下标引用的规则告诉我们pea[i][j]被编译器解释为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(*(pea + i) + j)</span><br></pre></td></tr></table></figure><p>是不是觉得很熟悉？它和一个二维数组引用的分解形式完全一样，在许多C语言书中就是这样解释的。然而，这里存在一个很大的问题，尽管这两种下标形式在源代码里看上去是一样的，而且被编译器解释为同一种指针表达式，但它们在各自的情况下所引用的实际类型并不相同。</p><h4 id="二维数组char-pea-4-6"><a href="#二维数组char-pea-4-6" class="headerlink" title="二维数组char pea[4][6]"></a>二维数组char pea[4][6]</h4><p>char pea[4][6]的定义表示pea是一个包含4个元素的数组，每个元素是一个char类型的数组（长度为6）。<br>假设在编译器符号表中，pea的地址为9980，pea[i][j]引用时步骤：</p><ul><li>1.取i的值，把它的长度调整为一行的宽度（这里是6），然后加到9980上。</li><li>2.取j的值，把它的长度调整为一个元素的宽度（这里是1），然后加到前面所得出的结果上。</li><li>3.从地址（9980 + i*scale-factor1 + j*scale-factor2）中取出内容。</li></ul><h4 id="指针数组char-pea-4"><a href="#指针数组char-pea-4" class="headerlink" title="指针数组char *pea[4]"></a>指针数组char *pea[4]</h4><p>char *pea[4]的定义表示pea是一个包含4个元素的数组，每个元素为一个指向char的指针。<br>假设在编译器的符号表中，pea的地址为4624，pea[i][j]引用时步骤：</p><ul><li>1.取i的值，乘以指针的宽度（4个字节），并把结果加到4624上。</li><li>2.从地址（4624 + i*4）取出内容，为5081。</li><li>3.取j的值，乘以元素的宽度（这里是1个字节），并把结果加到5081上。</li><li>4.从地址（5081 + j*1）取出内容。</li></ul><p>除非指针已经指向字符（或字符数组），否则查找过程无法完成，假定每个指针都给定了一个值，那么查寻过程先找到数组的第i个元素（每个元素均为指针），取出指针的值，加上偏移量j，以此为地址，取出地址的内容。</p><p>指针数组的一个应用场景是：存储各行长度不一的表以及在一个函数调用中传递一个字符串数组。<br>如果需要存储50个字符串，每个字符串的最大长度可以达到255个字节，可以声明下面的二维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char carrot[50][256];</span><br></pre></td></tr></table></figure><p>它声明了50个字符串，其中每一个都保留256字节的空间，即使有些字符串的实际长度只到一两个字节。如果经常这样做，内存的浪费很大。一种替代方法就是使用字符串指针数组，所有第二级数组并不需要长度都相同。如果声明一个字符串指针数组，并根据需要为这些字符串分配内存，将会大大节省系统资源。字符串指针可以直接使用现有的，也可以通过分配内存创建一份现有字符串的拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *carrot[50];</span><br><span class="line">char my_string[] = &quot;your message here&quot;;</span><br><span class="line">carrot[i] = &amp;my_string[0];</span><br><span class="line">carrot[j] = (char *)malloc((strlen(my_string) + 1)*sizeof(char));</span><br><span class="line">strcpy(carrot[j],my_string);</span><br></pre></td></tr></table></figure><p>只要有可能，尽量不要选择拷贝整个字符串的方法。如果需要从两个不同的数据结构访问它，拷贝一个指针比拷贝整个数组快的多，空间也节省很多。另一个可能影响性能的因素是指针数组可能会使字符串分配于内存中不同的页面中。这就违反了局部引用的规则（一次读写的数据位于同一页面上），并导致更加频繁的页面切换，具体如何取决于怎样访问数据以及访问的频率。</p><h4 id="数组和指针参数是如何被编译器修改的"><a href="#数组和指针参数是如何被编译器修改的" class="headerlink" title="数组和指针参数是如何被编译器修改的"></a>数组和指针参数是如何被编译器修改的</h4><p>“数组名被改写成一个指针参数”的规则并不是递归定义的。数组的数组会被改写为数组的指针，而不是指针的指针。</p><table><thead><tr><th>实参</th><th>解释</th><th>所匹配的形参</th><th>解释</th></tr></thead><tbody><tr><td>char c[8][10];</td><td>数组的数组</td><td>char (*c)[10];</td><td>数组指针</td></tr><tr><td>char *c[15];</td><td>指针数组</td><td>char **c;</td><td>指针的指针</td></tr><tr><td>char (*c)[64];</td><td>数组指针</td><td>char (*c)[64];</td><td>不改变</td></tr><tr><td>char **c;</td><td>指针的指针</td><td>char **c;</td><td>不改变</td></tr></tbody></table><p>之所以能在main()函数中看到char **argv这样的参数，是因为argv是一个指针数组（即char *argv[]）。这个表达式被编译器改写为指向数组第一个元素的指针，也就是一个指向指针的指针。如果argv参数事实上被声明为一个二维数组（也就是char argv[10][15]）,它将被编译器改写为char (*argv)[15]（也就是一个字符数组指针），而不是char **argv。</p><h3 id="向函数传递一个一维数组"><a href="#向函数传递一个一维数组" class="headerlink" title="向函数传递一个一维数组"></a>向函数传递一个一维数组</h3><p>在C语言中，任何一维数组均可以作为函数的实参。形参被改写为指向数组第一个元素的指针，所以需要一个约定来提示数组的长度。一般有两个基本方法：</p><ul><li>增加一个额外的参数，表示元素的数目（argc就是起这个作用）。</li><li>赋予数组最后一个元素一个特殊的值，提示它是数组的尾部（字符串结尾的’\0’字符就是起这个作用）。这个特殊值必须不会作为正常的元素值在数组中出现。</li></ul><p>二维数组的情况要复杂一些，数组被改写为指向数组第一行的指针。<br>现在需要两个约定，其中一个用于提示每行的结束，另外一个用于提示所有行的结束。<br>提示单行结束可以使用一维数组所用的两种方法，提示所有行结束也可以这样。</p><p>我们所接收的是一个指向数组第一个元素的指针。每次当对指针执行自增操作时，指针就指向数组中下一行的起始位置，但怎么知道指针到达了数组的最后一行了呢？</p><ul><li>我们可以增加一个额外的行，行内所有元素的值都是不可能在数组正常元素中出现的，能够提示数组超出了范围。当对指针进行自增操作时，要对它进行检查，看看它是否到达了那一行。</li><li>另一种方法是，定义一个额外的参数，提示数组的行数。</li></ul><h3 id="使用指针向函数传递一个多维数组"><a href="#使用指针向函数传递一个多维数组" class="headerlink" title="使用指针向函数传递一个多维数组"></a>使用指针向函数传递一个多维数组</h3><p>使用上面所描述的笨拙方法，可以解决标记数组范围这个难题。但还存在一个问题，就是如何在函数内部声明一个二维数组参数，这才是真正的麻烦所在。C语言没有办法表达“这个数组的边界在不同的调用中可以变化”这个概念。<strong>C编译器必须要知道数组的边界，以便为下标引用产生正确的代码。</strong></p><p>在C语言中，没有办法向函数传递一个通用的多维数组，这是因为我们需要知道每一维的长度，以便为地址运算提供正确的单位长度。因此，你必须提供除了最左边一维以外的所有维的长度。这样就把实参限制为除最左边一维外所有维都必须与形参匹配的数组。</p><p>我们能够采取的最好方法就是放弃传递二维数组，把array[x][y]这样的形式改写为一个一维数组array[x+1],它的元素类型是指向array[y]的指针。这样就改变了问题的性质（传递的是一个指针数组），而改变后的问题是我们已经解决了的。在数组最后的那个元素array[x+1]里存储一个NULL指针，提示数组的结束。</p><h3 id="向函数传递多维数组参数的方法"><a href="#向函数传递多维数组参数的方法" class="headerlink" title="向函数传递多维数组参数的方法"></a>向函数传递多维数组参数的方法</h3><p><strong>方法一：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_func(int my_array[10][20]);</span><br></pre></td></tr></table></figure><p>尽管这是最简单的方法，但同时也是作用最小的。因为它迫使函数只处理10行20列的int型数组。我们想要的是一个确定更为普通的多维数组形参的方法，使函数能够操作任意长度的数组。</p><p>注意，多维数组最主要的一维的长度（最左边一维）不必显示写明。所有的函数都必须知道数组其他维的确切长度和数组的基地址。有了这些信息，它就可以一次跳过一个完整的行，到达下一行。</p><p><strong>方法二：</strong><br>我们可以合法的省略第一维的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_func(int my_array[][20]);</span><br></pre></td></tr></table></figure><p>但这样做法仍不够充分，因为每一行都必须正好是20个整数的长度。<br>函数也可以类似的声明为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_func(int (*my_array)[20]);</span><br></pre></td></tr></table></figure><p>参数列表中(*my_array)周围的括号是绝对需要的，这样可以确保它被翻译为一个指向20个元素的int数组的指针，而不是一个20个int指针元素的数组。同样，我们对最右边一维的长度必须为20而感到不快。</p><p><strong>方法三：</strong><br>我们可以采取的第三种方法是放弃二维数组，把它的结构改为一个数组指针。也就是说，创建一个一维数组，数组中的元素是指向其他东西的指针。可以简单的传递一个指向数组参数的第一个元素的指针，如下所示（用于二维数组）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_func(char **my_array);</span><br></pre></td></tr></table></figure><p><strong>注意：只有把二维数组改为一个指向二维数组每行的指针数组的前提下才可以这样做！</strong><br>指针数组这种数据结构的美感在于：它允许任意的字符串指针数组传递给函数，但必须是指针数组，而且必须是指向字符串的指针数组。这是因为字符串和指针都有一个显示的越界值（分别为NUL和NULL），可以作为结束标记。至于其他类型，并没有一种类似的通用且可靠的值，所以并没有一种内置的方法知道何时到达数组某一维的结束位置。即使是指向字符串的指针数组，通常也需要一个计数参数argc，记录字符串的数量。</p><p><strong>方法四：</strong><br>我们可以采取的最后一种方法也是放弃多维数组的形式，提供自己的下标方式。例如若多维数组各维的长度都是一个相同的固定值，那么可以定义为一个一维数组，而在引用时采取如下的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char_array[row_size * i + j] = ...</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>一维数组——没有问题，但需要包括一个计数值或者是一个能够标识越界位置的结束符。被调用的函数无法检测数组参数的边界。</li><li>二维数组——不能直接传递给函数，但可以把二维数组改写为一个一维的指针数组，并使用相同的下标表示方法。对于字符串来说，这样做是可以的，对于其他类型，需要增加一个记数值或者能够标识越界位置的结束符。同样，它依赖于调用函数和被调用函数之间的约定。</li><li>三维或更多维的数组——都无法使用。必须把它分解为几个维数更少的数组。</li></ul><h3 id="使用指针从函数返回一个数组"><a href="#使用指针从函数返回一个数组" class="headerlink" title="使用指针从函数返回一个数组"></a>使用指针从函数返回一个数组</h3><p>严格的说，无法直接从函数返回一个数组。但是，可以让函数返回一个指向任何数据结构的指针，当然也可以是一个指向数组的指针。</p><p>记住，声明必须在使用之前。一个声明的例子是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*paf())[20];</span><br></pre></td></tr></table></figure><p>这里，paf是一个函数，它返回一个指向包含20个int元素的数组的指针。<br>它的定义可能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int (*paf())[20]&#123;</span><br><span class="line">int (*pear)[20];</span><br><span class="line">pear = malloc(20*sizeof(int));</span><br><span class="line">return pear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用这样的方法来调用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (*result)[20];</span><br><span class="line">result = paf();</span><br><span class="line">(*result)[3] = 12;</span><br></pre></td></tr></table></figure><p>或者玩个花样，定义一个结构体(利用结构体可以整体赋值的特性)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct a_tag&#123;</span><br><span class="line">int array[20];</span><br><span class="line">&#125;x,y;</span><br><span class="line">struct a_tag my_func()&#123;... return y;&#125;</span><br><span class="line">x = y;</span><br><span class="line">x = my_func();</span><br><span class="line">x.array[i] = 38;</span><br></pre></td></tr></table></figure><p><strong>千万要注意，不能从函数中返回一个指向函数的局部变量的指针</strong></p><h3 id="使用指针创建和使用动态数组"><a href="#使用指针创建和使用动态数组" class="headerlink" title="使用指针创建和使用动态数组"></a>使用指针创建和使用动态数组</h3><p>当预先并不知道数据的长度时，可以使用动态数组。其基本思路就是使用malloc()库函数来得到一个指向一大块内存的指针。然后，像引用数组一样引用这块内存，其机理就是一个数组下标访问可以改写为一个指针加上偏移量。</p><p>动态数组对于避免预定义的限制也是非常有用的。这方面的经典例子是在编译器中。我们不想把编译器符号表的记录数量限制在一个固定的数目上。，但也不想一开始就建立一个非常巨大的固定长度的表，这样会导致其他操作的内存空间不够。</p><p>我们真正需要实现的是使表具有根据需要自动增长的能力，这样它的唯一限制就是内存的总容量。如果你不是直接声明一个数组，而是在运行时在堆上分配数组的内存，这可以实现这个目标。有一个库函数realloc()，它能够对一个现在的内存块大小进行重新分配（通常是使之扩大），同时不会丢失原先内存块的内容。当需要在动态表中增长一个项目时，可以进行如下操作：</p><ul><li>1.对表进行检查，看看它是否真的已满。</li><li>2.如果确实已满，使用realloc()函数扩展表的长度。并进行检查，确保realloc()操作成功进行。</li><li>3.在表中增加所需要的项目。</li></ul><p><strong>realloc()使用的注意点：</strong></p><ul><li>1.在实践中，不要把realloc()函数的返回值直接赋值给当前指针。如果realloc()函数失败，它会使该指针的值变成NULL，这样就无法对现有的表进行访问。</li><li>2.当一个大型表突然需要增长时，系统的运行速度可能会慢下来，而且这在什么时候发生是无法预测的。内存分配成倍增长是最关键的原因。</li><li>3.重分配操作很可能把原先的整个内存块移到一个不同的位置，这样表中元素的地址便不再有效。为避免麻烦，应该使用下标而不是元素的地址。</li><li>4.所有的“增加“和”删除”操作都必须通过函数来进行，这样才能维持表的完整性。只是这样一来，修改表所涉及到的东西就比仅仅使用下标要多得多。</li><li>5.如果表的项目数量减少，可能应该缩小表并释放多余的内存。这样内存收缩的操作对程序的运行速度有很大的影响。每次收缩表时，编译器最好能够知道任一时刻表的大小。</li><li>6.当某个线程对表进行内存重新分配时，你可能想锁住表，保护表的访问，防止其他线程读取表。对于多线程代码，这种锁总是必要的。</li></ul><p>数据结构动态增长的另一种方法是使用链表，但链表不能进行随机访问。你只能线性的访问链表（除非你把频繁访问的链表元素的地址保存在缓冲区内），而数组则允许随机访问，这可能在性能上造成很大的差别。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现广义表GList对象</title>
      <link href="/2018/10/03/C%E5%AE%9E%E7%8E%B0%E5%B9%BF%E4%B9%89%E8%A1%A8GList%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/10/03/C%E5%AE%9E%E7%8E%B0%E5%B9%BF%E4%B9%89%E8%A1%A8GList%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><p>顾名思义，广义表是线性表的推广。也有人称其为列表（list）。广泛的用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。<br><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><span id="more"></span><p>广义表一般记作LS &#x3D; [a1,a2,…,an],其中LS是广义表的名称，n是它的长度。在线性表的定义中，ai只限于是单个元素，而在广义表的定义中，ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。</p><p>由于广义表中的数据元素可以具有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构，每个数据元素可用一个结点表示。</p><p>我设计的广义表的结点元素定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef enum GLNodeElemTag&#123;</span><br><span class="line">    ATOM,  //原子结点</span><br><span class="line">    LIST   //表结点</span><br><span class="line">&#125;GLNodeElemTag;</span><br><span class="line"></span><br><span class="line">typedef struct GLNode&#123;</span><br><span class="line">    GLNodeElemTag tag;   //tag用于区分原子结点和表结点</span><br><span class="line">    union content&#123;              //原子结点和表结点的联合</span><br><span class="line">        GLNodeElemType *elem;  //原子结点的指针</span><br><span class="line">        struct GLNode *hp; //表结点的表头指针</span><br><span class="line">    &#125;content;</span><br><span class="line">    struct GLNode *prior; //指向前一个元素的结点 </span><br><span class="line">    struct GLNode *next; //指向下一个元素的结点 </span><br><span class="line">&#125;GLNode;</span><br></pre></td></tr></table></figure><p>如果一个结点的元素为原子，那么结点的tag设置为ATOM，联合体中的elem指向该原子元素的地址；如果一个结点的元素为列表，那么结点的tag设置为LIST，联合体中的hp指向该子表的表头。</p><p>其中GLNodeElemType定义为MyString，以方便处理。</p><p>MyString是前面文章中用C封装的一个字符串的对象:<a href="https://www.mrbluyee.com/2018/09/05/C%E5%B0%81%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/">C封装字符串、字符串数组对象</a></p><p>广义表对象GList定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct GList&#123;</span><br><span class="line">    GLNode *root;</span><br><span class="line">    GLNode *tear;</span><br><span class="line">    int (*isEmpty)(struct GList *This);</span><br><span class="line">    int (*length)(struct GList *This);</span><br><span class="line">    void (*print)(struct GList *This);</span><br><span class="line">    int (*getDepth)(struct GList *This);</span><br><span class="line">    int (*getHead)(struct GList *This,GLNode **n);</span><br><span class="line">    int (*getTear)(struct GList *This,GLNode **n);</span><br><span class="line">    int (*getGLNode)(struct GList *This,int index,GLNode **n);</span><br><span class="line">    int (*insertGLNode)(struct GList *This, int index, GLNode *n);</span><br><span class="line">    int (*insertGLNodeFront)(struct GList *This, GLNode *n);</span><br><span class="line">    int (*deleteGLNodeFront)(struct GList *This);</span><br><span class="line">    int (*insertGLNodeTear)(struct GList *This, GLNode *n);</span><br><span class="line">    int (*deleteGLNodeTear)(struct GList *This);</span><br><span class="line">    void (*traversal)(struct GList *This,int (*visit)(GLNodeElemType **elem));</span><br><span class="line">&#125;GList;</span><br></pre></td></tr></table></figure><p>此外对于GList的操作函数有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GList *initGListFromString(char *listStr);</span><br><span class="line">GList *initGListFromGLNode(GLNode *n);</span><br><span class="line">GList *copyGList(GList *L);</span><br><span class="line">void DestroyGList(GList *L);</span><br></pre></td></tr></table></figure><p>可以单独操作结点GLNode的函数有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void printGLNode(GLNode *n);</span><br><span class="line">int getGLNodeDepth(GLNode *n);</span><br><span class="line">GLNode *copyGLNode(GLNode *n);</span><br><span class="line">void traversalGLNode(GLNode *n,int (*visit)(GLNodeElemType **elem));</span><br><span class="line">void destroyGLNode(GLNode *n);</span><br></pre></td></tr></table></figure><p>因为广义表的支持表嵌套的特性，大部分底层操作函数均用递归实现。<br>例如，以一个字符串创建一个GList对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">static GLNode *createGListFromString(GLNode **p,MyString *gListStr)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    GLNode **create_temp = p;</span><br><span class="line">    GLNode *glnode_temp = NULL;</span><br><span class="line">    GLNode *glnode_root = NULL;</span><br><span class="line">    MyString *elemstr = NULL;</span><br><span class="line">    MyString *leftstr = NULL;</span><br><span class="line">    MyString *substr = substrMyString(gListStr,1,gListStr-&gt;length-1);//脱去括号</span><br><span class="line">    destroyMyString(gListStr);</span><br><span class="line">    if(!substr)&#123; //括号内是一个空表</span><br><span class="line">        *create_temp = (GLNode*)malloc(sizeof(GLNode)); //添加原子结点</span><br><span class="line">        if(*create_temp)&#123;</span><br><span class="line">            (*create_temp)-&gt;tag = ATOM;</span><br><span class="line">            (*create_temp)-&gt;content.elem = elemstr;</span><br><span class="line">            (*create_temp)-&gt;prior = NULL;</span><br><span class="line">            (*create_temp)-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        glnode_root = *create_temp;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        do&#123;</span><br><span class="line">            if(substr)&#123;</span><br><span class="line">                if(*(substr-&gt;str) != &#x27;[&#x27;)&#123;</span><br><span class="line">                    i = myStringIndexChar(substr,&#x27;,&#x27;,0);</span><br><span class="line">                    if(i != -1)&#123;</span><br><span class="line">                        elemstr = substrMyString(substr,0,i);//提取表头</span><br><span class="line">                        leftstr = substrMyString(substr,i+1,substr-&gt;length);//提取剩余部分</span><br><span class="line">                        destroyMyString(substr);</span><br><span class="line">                        substr = leftstr;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        elemstr = substrMyString(substr,0,substr-&gt;length);</span><br><span class="line">                        destroyMyString(substr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    glnode_temp = *create_temp;</span><br><span class="line">                    *create_temp = (GLNode*)malloc(sizeof(GLNode)); //添加原子结点</span><br><span class="line">                    if(*create_temp)&#123;</span><br><span class="line">                        (*create_temp)-&gt;tag = ATOM;</span><br><span class="line">                        (*create_temp)-&gt;content.elem = elemstr;</span><br><span class="line">                        if(glnode_temp)&#123;</span><br><span class="line">                            (*create_temp)-&gt;prior = glnode_temp;</span><br><span class="line">                            glnode_temp-&gt;next = *create_temp;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            (*create_temp)-&gt;prior = NULL;</span><br><span class="line">                            glnode_root = *create_temp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        (*create_temp)-&gt;next = NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    i = getMatchingBracketIndex(substr,&#x27;[&#x27;,0);</span><br><span class="line">                    if(i != -1)&#123;</span><br><span class="line">                        elemstr = substrMyString(substr,0,i+1);//提取表头,完整的一个Glist</span><br><span class="line">                        leftstr = substrMyString(substr,i+2,substr-&gt;length);//提取剩余部分</span><br><span class="line">                        destroyMyString(substr);</span><br><span class="line">                        substr = leftstr;</span><br><span class="line">                    &#125;</span><br><span class="line">                    glnode_temp = *create_temp;</span><br><span class="line">                    *create_temp = (GLNode*)malloc(sizeof(GLNode)); //添加列表结点</span><br><span class="line">                    if(*create_temp)&#123;</span><br><span class="line">                        (*create_temp)-&gt;tag = LIST;</span><br><span class="line">                        if(glnode_temp)&#123;</span><br><span class="line">                            (*create_temp)-&gt;prior = glnode_temp;</span><br><span class="line">                            glnode_temp-&gt;next = *create_temp;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            (*create_temp)-&gt;prior = NULL;</span><br><span class="line">                            glnode_root = *create_temp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        (*create_temp)-&gt;next = NULL;</span><br><span class="line">                        (*create_temp)-&gt;content.hp = NULL;</span><br><span class="line">                        (*create_temp)-&gt;content.hp = createGListFromString(&amp;((*create_temp)-&gt;content.hp),elemstr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(i != -1);</span><br><span class="line">    &#125;</span><br><span class="line">    return glnode_root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GList *initGListFromString(char *listStr)&#123;</span><br><span class="line">    MyString *gListStr = NULL;</span><br><span class="line">    GLNode *p = NULL;</span><br><span class="line">    GList *L = (GList *)malloc(sizeof(GList));</span><br><span class="line">    if(!L) return NULL;</span><br><span class="line">    gListStr = myStringAssign(listStr);</span><br><span class="line">    if(!gListStr)&#123;</span><br><span class="line">        free(L);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*(gListStr-&gt;str) != &#x27;[&#x27;)&#123;</span><br><span class="line">        printf(&quot;ListStr format error\n&quot;);</span><br><span class="line">        destroyMyString(gListStr);</span><br><span class="line">        free(L);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isBracketMatching(gListStr,&#x27;[&#x27;) == 0)&#123;</span><br><span class="line">        printf(&quot;ListStr Bracke not match\n&quot;);</span><br><span class="line">        destroyMyString(gListStr);</span><br><span class="line">        free(L);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;root = NULL;</span><br><span class="line">    L-&gt;root = createGListFromString(&amp;(L-&gt;root),gListStr);</span><br><span class="line">    p = L-&gt;root;</span><br><span class="line">    while(p-&gt;next)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;tear = p;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;print = print;</span><br><span class="line">    L-&gt;getDepth = getDepth;</span><br><span class="line">    L-&gt;getHead = getHead;</span><br><span class="line">    L-&gt;getTear = getTear;</span><br><span class="line">    L-&gt;getGLNode = getGLNode;</span><br><span class="line">    L-&gt;insertGLNode = insertGLNode;</span><br><span class="line">    L-&gt;insertGLNodeFront = insertGLNodeFront;</span><br><span class="line">    L-&gt;deleteGLNodeFront = deleteGLNodeFront;</span><br><span class="line">    L-&gt;insertGLNodeTear = insertGLNodeTear;</span><br><span class="line">    L-&gt;deleteGLNodeTear = deleteGLNodeTear;</span><br><span class="line">    L-&gt;traversal = traversal;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码请见github的DataStructure_C项目中Glist文件夹内。<a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GLNode *node1 = NULL;</span><br><span class="line">GList *L = initGListFromString(&quot;[1D,2AD,[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH],9YJRDFB]&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;list L:\n&quot;);</span><br><span class="line">L-&gt;print(L);</span><br><span class="line">printf(&quot;is list L empty:%d\n&quot;,L-&gt;isEmpty(L));</span><br><span class="line">printf(&quot;list L length:%d\n&quot;,L-&gt;length(L));</span><br><span class="line">printf(&quot;list L depth:%d\n&quot;,L-&gt;getDepth(L));</span><br><span class="line"></span><br><span class="line">printf(&quot;the index 3 of list L is : &quot;);</span><br><span class="line">L-&gt;getGLNode(L,3,&amp;node1);</span><br><span class="line">printGLNode(node1);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;get glnode of index 2 of L:\n&quot;);</span><br><span class="line">L-&gt;getGLNode(L,2,&amp;node1);</span><br><span class="line">printGLNode(node1);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">DestroyGList(L);</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list L:</span><br><span class="line">[1D,2AD,[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH],9YJRDFB]</span><br><span class="line">is list L empty:0</span><br><span class="line">list L length:4</span><br><span class="line">list L depth:6</span><br><span class="line">the index 3 of list L is : 9YJRDFB</span><br><span class="line"></span><br><span class="line">get glnode of index 2 of L:</span><br><span class="line">[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br></pre></td></tr></table></figure><h4 id="测试DEMO"><a href="#测试DEMO" class="headerlink" title="测试DEMO"></a>测试DEMO</h4><p><strong>testGlist.c文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;Glist.h&quot;</span><br><span class="line"></span><br><span class="line">int visitGLNode(GLNodeElemType **elem)&#123;</span><br><span class="line">    printMyString(*elem);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    GLNode *node1 = NULL;</span><br><span class="line">    GLNode *node2 = NULL;</span><br><span class="line">    GList *L = initGListFromString(&quot;[1D,2AD,[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH],9YJRDFB]&quot;);</span><br><span class="line">    GList *L2 = NULL;</span><br><span class="line">    GList *L3 = NULL;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;list L:\n&quot;);</span><br><span class="line">    L-&gt;print(L);</span><br><span class="line">    printf(&quot;is list L empty:%d\n&quot;,L-&gt;isEmpty(L));</span><br><span class="line">    printf(&quot;list L length:%d\n&quot;,L-&gt;length(L));</span><br><span class="line">    printf(&quot;list L depth:%d\n&quot;,L-&gt;getDepth(L));</span><br><span class="line">    </span><br><span class="line">    printf(&quot;the index 3 of list L is : &quot;);</span><br><span class="line">    L-&gt;getGLNode(L,3,&amp;node1);</span><br><span class="line">    printGLNode(node1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;get glnode of index 2 of L:\n&quot;);</span><br><span class="line">    L-&gt;getGLNode(L,2,&amp;node1);</span><br><span class="line">    printGLNode(node1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    L2 = initGListFromGLNode(node1);</span><br><span class="line">    printf(&quot;list L2:\n&quot;);</span><br><span class="line">    L2-&gt;print(L2);</span><br><span class="line">    printf(&quot;is list L2 empty:%d\n&quot;,L2-&gt;isEmpty(L2));</span><br><span class="line">    printf(&quot;list L2 length:%d\n&quot;,L2-&gt;length(L2));</span><br><span class="line">    printf(&quot;list L2 depth:%d\n&quot;,L2-&gt;getDepth(L2));</span><br><span class="line">    printf(&quot;the index 0 of list L2 is : &quot;);</span><br><span class="line">    L2-&gt;getGLNode(L2,0,&amp;node2);</span><br><span class="line">    printGLNode(node2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    L2-&gt;insertGLNodeFront(L2,node1);</span><br><span class="line">    printf(&quot;insertGLNodeFront list L2:\n&quot;);</span><br><span class="line">    L2-&gt;print(L2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    L2-&gt;insertGLNodeTear(L2,node1);</span><br><span class="line">    printf(&quot;insertGLNodeTear list L2:\n&quot;);</span><br><span class="line">    L2-&gt;print(L2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;get glnode of index 0 of L2:\n&quot;);</span><br><span class="line">    L2-&gt;getGLNode(L2,0,&amp;node2);</span><br><span class="line">    printGLNode(node2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;get glnode of index 1 of L2:\n&quot;);</span><br><span class="line">    L2-&gt;getGLNode(L2,1,&amp;node2);</span><br><span class="line">    printGLNode(node2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;get head of L2:\n&quot;);</span><br><span class="line">    L2-&gt;getHead(L2,&amp;node2);</span><br><span class="line">    printGLNode(node2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;get tear of L2:\n&quot;);</span><br><span class="line">    L2-&gt;getTear(L2,&amp;node2);</span><br><span class="line">    printGLNode(node2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    L2-&gt;deleteGLNodeTear(L2);</span><br><span class="line">    printf(&quot;list L2:\n&quot;);</span><br><span class="line">    L2-&gt;print(L2);</span><br><span class="line">    printf(&quot;get tear of L2:\n&quot;);</span><br><span class="line">    L2-&gt;getTear(L2,&amp;node2);</span><br><span class="line">    printGLNode(node2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    L2-&gt;deleteGLNodeFront(L2);</span><br><span class="line">    L2-&gt;deleteGLNodeFront(L2);</span><br><span class="line">    printf(&quot;list L2:\n&quot;);</span><br><span class="line">    L2-&gt;print(L2);</span><br><span class="line">    printf(&quot;get head of L2:\n&quot;);</span><br><span class="line">    L2-&gt;getHead(L2,&amp;node2);</span><br><span class="line">    printGLNode(node2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    L3 = copyGList(L2);</span><br><span class="line">    printf(&quot;list L3:\n&quot;);</span><br><span class="line">    L3-&gt;print(L3);</span><br><span class="line">    </span><br><span class="line">    L3-&gt;insertGLNodeTear(L3,node1);</span><br><span class="line">    printf(&quot;insertGLNodeTear list L3:\n&quot;);</span><br><span class="line">    L3-&gt;print(L3);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    L3-&gt;insertGLNodeFront(L3,node2);</span><br><span class="line">    printf(&quot;insertGLNodeFront list L3:\n&quot;);</span><br><span class="line">    L3-&gt;print(L3);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    while(L3-&gt;length(L3))&#123;</span><br><span class="line">        printf(&quot;get tear of L3:\n&quot;);</span><br><span class="line">        L3-&gt;getTear(L3,&amp;node2);</span><br><span class="line">        printGLNode(node2);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        </span><br><span class="line">        L3-&gt;deleteGLNodeTear(L3);</span><br><span class="line">        printf(&quot;list L3:\n&quot;);</span><br><span class="line">        L3-&gt;print(L3);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;is list L3 empty:%d\n&quot;,L3-&gt;isEmpty(L3));</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;list L2:\n&quot;);</span><br><span class="line">    L2-&gt;print(L2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    while(L2-&gt;length(L2))&#123;</span><br><span class="line">        printf(&quot;get head of L2:\n&quot;);</span><br><span class="line">        L2-&gt;getHead(L2,&amp;node2);</span><br><span class="line">        printGLNode(node2);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        </span><br><span class="line">        L2-&gt;deleteGLNodeFront(L2);</span><br><span class="line">        printf(&quot;list L2:\n&quot;);</span><br><span class="line">        L2-&gt;print(L2);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;is list L2 empty:%d\n&quot;,L2-&gt;isEmpty(L2));</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;node1 traversal\n&quot;);</span><br><span class="line">    traversalGLNode(node1,visitGLNode);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;list L traversal\n&quot;);</span><br><span class="line">    L-&gt;traversal(L,visitGLNode);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    DestroyGList(L);</span><br><span class="line">    DestroyGList(L2);</span><br><span class="line">    DestroyGList(L3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc MyString.c MyStringArray.c Glist.c testGlist.c -o testGlist</span><br></pre></td></tr></table></figure><p><strong>运行testGlist：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">list L:</span><br><span class="line">[1D,2AD,[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH],9YJRDFB]</span><br><span class="line">is list L empty:0</span><br><span class="line">list L length:4</span><br><span class="line">list L depth:6</span><br><span class="line">the index 3 of list L is : 9YJRDFB</span><br><span class="line"></span><br><span class="line">get glnode of index 2 of L:</span><br><span class="line">[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">list L2:</span><br><span class="line">[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line">is list L2 empty:0</span><br><span class="line">list L2 length:3</span><br><span class="line">list L2 depth:5</span><br><span class="line">the index 0 of list L2 is : 3SFDS</span><br><span class="line"></span><br><span class="line">insertGLNodeFront list L2:</span><br><span class="line">[[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH],3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">insertGLNodeTear list L2:</span><br><span class="line">[[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH],3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH,[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]]</span><br><span class="line"></span><br><span class="line">get glnode of index 0 of L2:</span><br><span class="line">[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">get glnode of index 1 of L2:</span><br><span class="line">3SFDS</span><br><span class="line"></span><br><span class="line">get head of L2:</span><br><span class="line">[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">get tear of L2:</span><br><span class="line">[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">list L2:</span><br><span class="line">[[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH],3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line">get tear of L2:</span><br><span class="line">8GRGRH</span><br><span class="line"></span><br><span class="line">list L2:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line">get head of L2:</span><br><span class="line">[4FEF,[5GRG,[6HJJY,[]]],7TKU]</span><br><span class="line"></span><br><span class="line">list L3:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line">insertGLNodeTear list L3:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH,[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]]</span><br><span class="line"></span><br><span class="line">insertGLNodeFront list L3:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU],[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH,[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]]</span><br><span class="line"></span><br><span class="line">get tear of L3:</span><br><span class="line">[3SFDS,[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">list L3:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU],[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">get tear of L3:</span><br><span class="line">8GRGRH</span><br><span class="line"></span><br><span class="line">list L3:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU],[4FEF,[5GRG,[6HJJY,[]]],7TKU]]</span><br><span class="line"></span><br><span class="line">get tear of L3:</span><br><span class="line">[4FEF,[5GRG,[6HJJY,[]]],7TKU]</span><br><span class="line"></span><br><span class="line">list L3:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU]]</span><br><span class="line"></span><br><span class="line">get tear of L3:</span><br><span class="line">[4FEF,[5GRG,[6HJJY,[]]],7TKU]</span><br><span class="line"></span><br><span class="line">list L3:</span><br><span class="line"></span><br><span class="line">is list L3 empty:1</span><br><span class="line"></span><br><span class="line">list L2:</span><br><span class="line">[[4FEF,[5GRG,[6HJJY,[]]],7TKU],8GRGRH]</span><br><span class="line"></span><br><span class="line">get head of L2:</span><br><span class="line">[4FEF,[5GRG,[6HJJY,[]]],7TKU]</span><br><span class="line"></span><br><span class="line">list L2:</span><br><span class="line">[8GRGRH]</span><br><span class="line"></span><br><span class="line">get head of L2:</span><br><span class="line">8GRGRH</span><br><span class="line"></span><br><span class="line">list L2:</span><br><span class="line"></span><br><span class="line">is list L2 empty:1</span><br><span class="line"></span><br><span class="line">node1 traversal</span><br><span class="line">3SFDS, length :5</span><br><span class="line">4FEF, length :4</span><br><span class="line">5GRG, length :4</span><br><span class="line">6HJJY, length :5</span><br><span class="line">7TKU, length :4</span><br><span class="line">8GRGRH, length :6</span><br><span class="line"></span><br><span class="line">list L traversal</span><br><span class="line">1D, length :2</span><br><span class="line">2AD, length :3</span><br><span class="line">3SFDS, length :5</span><br><span class="line">4FEF, length :4</span><br><span class="line">5GRG, length :4</span><br><span class="line">6HJJY, length :5</span><br><span class="line">7TKU, length :4</span><br><span class="line">8GRGRH, length :6</span><br><span class="line">9YJRDFB, length :7</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装基于双向链表的队列对象</title>
      <link href="/2018/09/26/C%E5%B0%81%E8%A3%85%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/09/26/C%E5%B0%81%E8%A3%85%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="DoubleLinkedListQueue双链队列"><a href="#DoubleLinkedListQueue双链队列" class="headerlink" title="DoubleLinkedListQueue双链队列"></a>DoubleLinkedListQueue双链队列</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><p>队列的结点数据结构定义如下：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DLLQNode&#123;</span><br><span class="line">    DLLQElemType *elem;</span><br><span class="line">    struct DLLQNode *prior;</span><br><span class="line">    struct DLLQNode *next;</span><br><span class="line">&#125;DLLQNode;</span><br></pre></td></tr></table></figure><p>队列的对象数据结构定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DLLQueue&#123;</span><br><span class="line">    DLLQNode *front;</span><br><span class="line">    DLLQNode *tear;</span><br><span class="line">    void (*clear)(struct DLLQueue *This);</span><br><span class="line">    int (*isEmpty)(struct DLLQueue *This);</span><br><span class="line">    int (*length)(struct DLLQueue *This);</span><br><span class="line">    void (*riseTraverse)(struct DLLQueue *This,int (*visit)(DLLQElemType **e));</span><br><span class="line">    void (*downTraverse)(struct DLLQueue *This,int (*visit)(DLLQElemType **e));</span><br><span class="line">    int (*getHead)(struct DLLQueue *This, DLLQElemType **e);</span><br><span class="line">    int (*enQueue)(struct DLLQueue *This, DLLQElemType *e);</span><br><span class="line">    int (*deQueue)(struct DLLQueue *This, DLLQElemType **e);</span><br><span class="line">&#125;DLLQueue;</span><br></pre></td></tr></table></figure><h4 id="DLLQueue-c"><a href="#DLLQueue-c" class="headerlink" title="DLLQueue.c"></a>DLLQueue.c</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DLLQueue.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(DLLQueue *This);</span><br><span class="line">static int isEmpty(DLLQueue *This);</span><br><span class="line">static int length(DLLQueue *This);</span><br><span class="line">static void riseTraverse(DLLQueue *This,int (*visit)(DLLQElemType **e));</span><br><span class="line">static void downTraverse(DLLQueue *This,int (*visit)(DLLQElemType **e));</span><br><span class="line">static int getHead(DLLQueue *This, DLLQElemType **e);</span><br><span class="line">static int enQueue(DLLQueue *This, DLLQElemType *e);</span><br><span class="line">static int deQueue(DLLQueue *This, DLLQElemType **e);</span><br><span class="line"></span><br><span class="line">DLLQueue *InitDLLQueue()&#123;</span><br><span class="line">    DLLQueue *Q = (DLLQueue *)malloc(sizeof(DLLQueue));</span><br><span class="line">    if(!Q) return NULL;</span><br><span class="line">    DLLQNode *p = (DLLQNode *)malloc(sizeof(DLLQNode));</span><br><span class="line">    if(!p)&#123;</span><br><span class="line">        free(Q);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;front = p;</span><br><span class="line">    Q-&gt;tear = Q-&gt;front;</span><br><span class="line">    p-&gt;prior = NULL;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    Q-&gt;clear = clear;</span><br><span class="line">    Q-&gt;isEmpty = isEmpty;</span><br><span class="line">    Q-&gt;length = length;</span><br><span class="line">    Q-&gt;riseTraverse = riseTraverse;</span><br><span class="line">    Q-&gt;downTraverse = downTraverse;</span><br><span class="line">    Q-&gt;getHead = getHead;</span><br><span class="line">    Q-&gt;enQueue = enQueue;</span><br><span class="line">    Q-&gt;deQueue = deQueue;</span><br><span class="line">    return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyDLLQueue(DLLQueue *Q)&#123;</span><br><span class="line">    if(Q)&#123;</span><br><span class="line">        if(Q-&gt;front)&#123;</span><br><span class="line">            Q-&gt;clear(Q);</span><br><span class="line">            free(Q-&gt;front);</span><br><span class="line">        &#125;</span><br><span class="line">        free(Q);</span><br><span class="line">        Q = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(DLLQueue *This)&#123;</span><br><span class="line">    DLLQNode *p = This-&gt;front-&gt;next;</span><br><span class="line">    DLLQNode *temp = NULL;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;front;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    This-&gt;tear = This-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(DLLQueue *This)&#123;</span><br><span class="line">    DLLQNode *p = This-&gt;front;</span><br><span class="line">    if(p-&gt;next)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(DLLQueue *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    DLLQNode *p = This-&gt;front-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void riseTraverse(DLLQueue *This,int (*visit)(DLLQElemType **e))&#123;</span><br><span class="line">    DLLQNode *p = This-&gt;front-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(visit(&amp;(p-&gt;elem)) != 0) break;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void downTraverse(DLLQueue *This,int (*visit)(DLLQElemType **e))&#123;</span><br><span class="line">    DLLQNode *p = This-&gt;tear;</span><br><span class="line">    while(p != This-&gt;front)&#123;</span><br><span class="line">        if(visit(&amp;(p-&gt;elem)) != 0) break;</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int getHead(DLLQueue *This, DLLQElemType **e)&#123;</span><br><span class="line">    if(isEmpty(This)) return -1;</span><br><span class="line">    *e = This-&gt;front-&gt;next-&gt;elem;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int enQueue(DLLQueue *This, DLLQElemType *e)&#123;</span><br><span class="line">    DLLQNode *p = This-&gt;tear;</span><br><span class="line">    DLLQNode *temp = (DLLQNode *)malloc(sizeof(DLLQNode));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    temp-&gt;elem = e;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line">    This-&gt;tear = temp;</span><br><span class="line">    temp-&gt;next =  NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deQueue(DLLQueue *This, DLLQElemType **e)&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        *e = NULL;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    DLLQNode *p = This-&gt;front-&gt;next;</span><br><span class="line">    *e = p-&gt;elem;</span><br><span class="line">    This-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    if(This-&gt;tear == p)&#123;</span><br><span class="line">        This-&gt;tear = This-&gt;front;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        p-&gt;next-&gt;prior = This-&gt;front;</span><br><span class="line">    &#125;</span><br><span class="line">    free(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DLLQueue-h"><a href="#DLLQueue-h" class="headerlink" title="DLLQueue.h"></a>DLLQueue.h</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _DLLQUEUE_H</span><br><span class="line">#define _DLLQUEUE_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">#include &quot;ElemTypeDefine.h&quot;</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">typedef struct DLLQueue&#123;</span><br><span class="line">    DLLQNode *front;</span><br><span class="line">    DLLQNode *tear;</span><br><span class="line">    void (*clear)(struct DLLQueue *This);</span><br><span class="line">    int (*isEmpty)(struct DLLQueue *This);</span><br><span class="line">    int (*length)(struct DLLQueue *This);</span><br><span class="line">    void (*riseTraverse)(struct DLLQueue *This,int (*visit)(DLLQElemType **e));</span><br><span class="line">    void (*downTraverse)(struct DLLQueue *This,int (*visit)(DLLQElemType **e));</span><br><span class="line">    int (*getHead)(struct DLLQueue *This, DLLQElemType **e);</span><br><span class="line">    int (*enQueue)(struct DLLQueue *This, DLLQElemType *e);</span><br><span class="line">    int (*deQueue)(struct DLLQueue *This, DLLQElemType **e);</span><br><span class="line">&#125;DLLQueue;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">DLLQueue *InitDLLQueue();</span><br><span class="line">void DestroyDLLQueue(DLLQueue *Q);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>为了方便在其他的工程代码里对不同元素类型使用DLLQueue，我把ElemTypeDefine抽取出来单独放在一个头文件里。这样，想要适用不同元素类型的DLLQueue，只要修改ElemTypeDefine.h里的 DLLQElemType定义即可。默认的元素类型为int。</p><h4 id="ElemTypeDefine-h文件"><a href="#ElemTypeDefine-h文件" class="headerlink" title="ElemTypeDefine.h文件"></a>ElemTypeDefine.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _ELEMTYPEDEFINE_H</span><br><span class="line">#define _ELEMTYPEDEFINE_H</span><br><span class="line"></span><br><span class="line">typedef int DLLQElemType;</span><br><span class="line"></span><br><span class="line">typedef struct DLLQNode&#123;</span><br><span class="line">    DLLQElemType *elem;</span><br><span class="line">    struct DLLQNode *prior;</span><br><span class="line">    struct DLLQNode *next;</span><br><span class="line">&#125;DLLQNode;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testDLLQueue-c文件"><a href="#testDLLQueue-c文件" class="headerlink" title="testDLLQueue.c文件"></a>testDLLQueue.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DLLQueue.h&quot;</span><br><span class="line"></span><br><span class="line">int printElem(DLLQElemType **e)&#123;</span><br><span class="line">    printf(&quot;%d&quot;,**e);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i = 0,*elem;</span><br><span class="line">    int *num = (int *)malloc(10*sizeof(int));</span><br><span class="line">    if(!num) return 0;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        *(num + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DLLQueue *Q = InitDLLQueue();</span><br><span class="line">    printf(&quot;is DLLQueue empty:%d\n&quot;,Q-&gt;isEmpty(Q));</span><br><span class="line">    printf(&quot;DLLQueue length:%d\n&quot;,Q-&gt;length(Q));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        Q-&gt;enQueue(Q,num + i);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;is DLLQueue empty:%d\n&quot;,Q-&gt;isEmpty(Q));</span><br><span class="line">    printf(&quot;DLLQueue length:%d\n&quot;,Q-&gt;length(Q));</span><br><span class="line">    Q-&gt;riseTraverse(Q,printElem);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    Q-&gt;clear(Q);</span><br><span class="line">    printf(&quot;is DLLQueue empty:%d\n&quot;,Q-&gt;isEmpty(Q));</span><br><span class="line">    printf(&quot;DLLQueue length:%d\n&quot;,Q-&gt;length(Q));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        *(num + i) = i*2;</span><br><span class="line">        Q-&gt;enQueue(Q,num + i);</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;downTraverse(Q,printElem);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        Q-&gt;getHead(Q,&amp;elem);</span><br><span class="line">        printf(&quot;Head elem:%d\n&quot;,*elem);</span><br><span class="line">        Q-&gt;deQueue(Q,&amp;elem);</span><br><span class="line">        printf(&quot;deQueue elem:%d\n&quot;,*elem);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;is DLLQueue empty:%d\n&quot;,Q-&gt;isEmpty(Q));</span><br><span class="line">    printf(&quot;DLLQueue length:%d\n&quot;,Q-&gt;length(Q));</span><br><span class="line">    DestroyDLLQueue(Q);</span><br><span class="line">    free(num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc DLLQueue.c testDLLQueue.c -o testDLLQueue</span><br></pre></td></tr></table></figure><p>执行testDLLQueue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">is DLLQueue empty:1</span><br><span class="line">DLLQueue length:0</span><br><span class="line">is DLLQueue empty:0</span><br><span class="line">DLLQueue length:10</span><br><span class="line">0123456789</span><br><span class="line">is DLLQueue empty:1</span><br><span class="line">DLLQueue length:0</span><br><span class="line">181614121086420</span><br><span class="line">Head elem:0</span><br><span class="line">deQueue elem:0</span><br><span class="line">Head elem:2</span><br><span class="line">deQueue elem:2</span><br><span class="line">Head elem:4</span><br><span class="line">deQueue elem:4</span><br><span class="line">Head elem:6</span><br><span class="line">deQueue elem:6</span><br><span class="line">Head elem:8</span><br><span class="line">deQueue elem:8</span><br><span class="line">Head elem:10</span><br><span class="line">deQueue elem:10</span><br><span class="line">Head elem:12</span><br><span class="line">deQueue elem:12</span><br><span class="line">Head elem:14</span><br><span class="line">deQueue elem:14</span><br><span class="line">Head elem:16</span><br><span class="line">deQueue elem:16</span><br><span class="line">Head elem:18</span><br><span class="line">deQueue elem:18</span><br><span class="line">is DLLQueue empty:1</span><br><span class="line">DLLQueue length:0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装基于双向链表的栈对象</title>
      <link href="/2018/09/26/C%E5%B0%81%E8%A3%85%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A0%88%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/09/26/C%E5%B0%81%E8%A3%85%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A0%88%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="DoubleLinkedListStack双链栈"><a href="#DoubleLinkedListStack双链栈" class="headerlink" title="DoubleLinkedListStack双链栈"></a>DoubleLinkedListStack双链栈</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><p>栈的结点数据结构定义如下：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int DLLSElemType;</span><br><span class="line"></span><br><span class="line">typedef struct DLLSNode&#123;</span><br><span class="line">    DLLSElemType *elem;</span><br><span class="line">    struct DLLSNode *prior;</span><br><span class="line">    struct DLLSNode *next;</span><br><span class="line">&#125;DLLSNode;</span><br></pre></td></tr></table></figure><p>栈的对象数据结构定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DLLStack&#123;</span><br><span class="line">    DLLSNode *front;</span><br><span class="line">    DLLSNode *tear;</span><br><span class="line">    void (*clear)(struct DLLStack *This);</span><br><span class="line">    int (*isEmpty)(struct DLLStack *This);</span><br><span class="line">    int (*length)(struct DLLStack *This);</span><br><span class="line">    void (*riseTraverse)(struct DLLStack *This,int (*visit)(DLLSElemType **e));</span><br><span class="line">    void (*downTraverse)(struct DLLStack *This,int (*visit)(DLLSElemType **e));</span><br><span class="line">    int (*getTopElem)(struct DLLStack *This, DLLSElemType **e);</span><br><span class="line">    int (*pushElem)(struct DLLStack *This, DLLSElemType *e);</span><br><span class="line">    int (*popElem)(struct DLLStack *This, DLLSElemType **e);</span><br><span class="line">&#125;DLLStack;</span><br></pre></td></tr></table></figure><h4 id="DLLStack-c"><a href="#DLLStack-c" class="headerlink" title="DLLStack.c"></a>DLLStack.c</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DLLStack.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(DLLStack *This);</span><br><span class="line">static int isEmpty(DLLStack *This);</span><br><span class="line">static int length(DLLStack *This);</span><br><span class="line">static void riseTraverse(DLLStack *This,int (*visit)(DLLSElemType **e));</span><br><span class="line">static void downTraverse(DLLStack *This,int (*visit)(DLLSElemType **e));</span><br><span class="line">static int getTopElem(DLLStack *This, DLLSElemType **e);</span><br><span class="line">static int pushElem(DLLStack *This, DLLSElemType *e);</span><br><span class="line">static int popElem(DLLStack *This, DLLSElemType **e);</span><br><span class="line"></span><br><span class="line">DLLStack *InitDLLStack()&#123;</span><br><span class="line">    DLLStack *S = (DLLStack *)malloc(sizeof(DLLStack));</span><br><span class="line">    if(!S) return NULL;</span><br><span class="line">    DLLSNode *p = (DLLSNode *)malloc(sizeof(DLLSNode));</span><br><span class="line">    if(!p)&#123;</span><br><span class="line">        free(S);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;front = p;</span><br><span class="line">    S-&gt;tear = S-&gt;front;</span><br><span class="line">    p-&gt;prior = NULL;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    S-&gt;clear = clear;</span><br><span class="line">    S-&gt;isEmpty = isEmpty;</span><br><span class="line">    S-&gt;length = length;</span><br><span class="line">    S-&gt;riseTraverse = riseTraverse;</span><br><span class="line">    S-&gt;downTraverse = downTraverse;</span><br><span class="line">    S-&gt;getTopElem = getTopElem;</span><br><span class="line">    S-&gt;pushElem = pushElem;</span><br><span class="line">    S-&gt;popElem = popElem;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyDLLStack(DLLStack *S)&#123;</span><br><span class="line">    if(S)&#123;</span><br><span class="line">        if(S-&gt;front)&#123;</span><br><span class="line">            S-&gt;clear(S);</span><br><span class="line">            free(S-&gt;front);</span><br><span class="line">        &#125;</span><br><span class="line">        free(S);</span><br><span class="line">        S = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(DLLStack *This)&#123;</span><br><span class="line">    DLLSNode *p = This-&gt;front-&gt;next;</span><br><span class="line">    DLLSNode *temp = NULL;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;front;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    This-&gt;tear = This-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(DLLStack *This)&#123;</span><br><span class="line">    DLLSNode *p = This-&gt;front;</span><br><span class="line">    if(p-&gt;next)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(DLLStack *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    DLLSNode *p = This-&gt;front-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void riseTraverse(DLLStack *This,int (*visit)(DLLSElemType **e))&#123;</span><br><span class="line">    DLLSNode *p = This-&gt;front-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(visit(&amp;(p-&gt;elem)) != 0) break;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void downTraverse(DLLStack *This,int (*visit)(DLLSElemType **e))&#123;</span><br><span class="line">    DLLSNode *p = This-&gt;tear;</span><br><span class="line">    while(p != This-&gt;front)&#123;</span><br><span class="line">        if(visit(&amp;(p-&gt;elem)) != 0) break;</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int getTopElem(DLLStack *This, DLLSElemType **e)&#123;</span><br><span class="line">    if(isEmpty(This)) return -1;</span><br><span class="line">    *e = This-&gt;tear-&gt;elem;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int pushElem(DLLStack *This, DLLSElemType *e)&#123;</span><br><span class="line">    DLLSNode *p = This-&gt;tear;</span><br><span class="line">    DLLSNode *temp = (DLLSNode *)malloc(sizeof(DLLSNode));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    temp-&gt;elem = e;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line">    This-&gt;tear = temp;</span><br><span class="line">    temp-&gt;next =  NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int popElem(DLLStack *This, DLLSElemType **e)&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        *e = NULL;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    DLLSNode *p = This-&gt;tear;</span><br><span class="line">    DLLSNode *temp = NULL;</span><br><span class="line">    temp = p-&gt;prior;</span><br><span class="line">    *e = p-&gt;elem;</span><br><span class="line">    free(p);</span><br><span class="line">    This-&gt;tear = temp;</span><br><span class="line">    temp-&gt;next = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DLLStack-h"><a href="#DLLStack-h" class="headerlink" title="DLLStack.h"></a>DLLStack.h</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _DLLSTACK_H</span><br><span class="line">#define _DLLSTACK_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">#include &quot;ElemTypeDefine.h&quot;</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">typedef struct DLLStack&#123;</span><br><span class="line">    DLLSNode *front;</span><br><span class="line">    DLLSNode *tear;</span><br><span class="line">    void (*clear)(struct DLLStack *This);</span><br><span class="line">    int (*isEmpty)(struct DLLStack *This);</span><br><span class="line">    int (*length)(struct DLLStack *This);</span><br><span class="line">    void (*riseTraverse)(struct DLLStack *This,int (*visit)(DLLSElemType **e));</span><br><span class="line">    void (*downTraverse)(struct DLLStack *This,int (*visit)(DLLSElemType **e));</span><br><span class="line">    int (*getTopElem)(struct DLLStack *This, DLLSElemType **e);</span><br><span class="line">    int (*pushElem)(struct DLLStack *This, DLLSElemType *e);</span><br><span class="line">    int (*popElem)(struct DLLStack *This, DLLSElemType **e);</span><br><span class="line">&#125;DLLStack;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">DLLStack *InitDLLStack();</span><br><span class="line">void DestroyDLLStack(DLLStack *S);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>为了方便在其他的工程代码里对不同元素类型使用DLLStack，我把ElemTypeDefine抽取出来单独放在一个头文件里。这样，想要适用不同元素类型的DLLStack，只要修改ElemTypeDefine.h里的 DLLSElemType定义即可。默认的元素类型为int。</p><h4 id="ElemTypeDefine-h文件"><a href="#ElemTypeDefine-h文件" class="headerlink" title="ElemTypeDefine.h文件"></a>ElemTypeDefine.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _ELEMTYPEDEFINE_H</span><br><span class="line">#define _ELEMTYPEDEFINE_H</span><br><span class="line"></span><br><span class="line">typedef int DLLSElemType;</span><br><span class="line"></span><br><span class="line">typedef struct DLLSNode&#123;</span><br><span class="line">    DLLSElemType *elem;</span><br><span class="line">    struct DLLSNode *prior;</span><br><span class="line">    struct DLLSNode *next;</span><br><span class="line">&#125;DLLSNode;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testDLLStack-c文件"><a href="#testDLLStack-c文件" class="headerlink" title="testDLLStack.c文件"></a>testDLLStack.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DLLStack.h&quot;</span><br><span class="line"></span><br><span class="line">int printElem(DLLSElemType **e)&#123;</span><br><span class="line">    printf(&quot;%d&quot;,**e);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i = 0,*elem;</span><br><span class="line">    int *num = (int *)malloc(10*sizeof(int));</span><br><span class="line">    if(!num) return 0;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        *(num + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DLLStack *S = InitDLLStack();</span><br><span class="line">    printf(&quot;is DLLStack empty:%d\n&quot;,S-&gt;isEmpty(S));</span><br><span class="line">    printf(&quot;DLLStack length:%d\n&quot;,S-&gt;length(S));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        S-&gt;pushElem(S,num + i);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;is DLLStack empty:%d\n&quot;,S-&gt;isEmpty(S));</span><br><span class="line">    printf(&quot;DLLStack length:%d\n&quot;,S-&gt;length(S));</span><br><span class="line">    S-&gt;riseTraverse(S,printElem);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    S-&gt;clear(S);</span><br><span class="line">    printf(&quot;is DLLStack empty:%d\n&quot;,S-&gt;isEmpty(S));</span><br><span class="line">    printf(&quot;DLLStack length:%d\n&quot;,S-&gt;length(S));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        *(num + i) = i*2;</span><br><span class="line">        S-&gt;pushElem(S,num + i);</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;downTraverse(S,printElem);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        S-&gt;getTopElem(S,&amp;elem);</span><br><span class="line">        printf(&quot;top elem:%d\n&quot;,*elem);</span><br><span class="line">        S-&gt;popElem(S,&amp;elem);</span><br><span class="line">        printf(&quot;pop elem:%d\n&quot;,*elem);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;is DLLStack empty:%d\n&quot;,S-&gt;isEmpty(S));</span><br><span class="line">    printf(&quot;DLLStack length:%d\n&quot;,S-&gt;length(S));</span><br><span class="line">    DestroyDLLStack(S);</span><br><span class="line">    free(num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc DLLStack.c testDLLStack.c -o testDLLStack</span><br></pre></td></tr></table></figure><p>执行testDLLStack：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">is DLLStack empty:1</span><br><span class="line">DLLStack length:0</span><br><span class="line">is DLLStack empty:0</span><br><span class="line">DLLStack length:10</span><br><span class="line">0123456789</span><br><span class="line">is DLLStack empty:1</span><br><span class="line">DLLStack length:0</span><br><span class="line">181614121086420</span><br><span class="line">top elem:18</span><br><span class="line">pop elem:18</span><br><span class="line">top elem:16</span><br><span class="line">pop elem:16</span><br><span class="line">top elem:14</span><br><span class="line">pop elem:14</span><br><span class="line">top elem:12</span><br><span class="line">pop elem:12</span><br><span class="line">top elem:10</span><br><span class="line">pop elem:10</span><br><span class="line">top elem:8</span><br><span class="line">pop elem:8</span><br><span class="line">top elem:6</span><br><span class="line">pop elem:6</span><br><span class="line">top elem:4</span><br><span class="line">pop elem:4</span><br><span class="line">top elem:2</span><br><span class="line">pop elem:2</span><br><span class="line">top elem:0</span><br><span class="line">pop elem:0</span><br><span class="line">is DLLStack empty:1</span><br><span class="line">DLLStack length:0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵的特征值与特征向量算法</title>
      <link href="/2018/09/25/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/25/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="矩阵特征值和特征向量定义"><a href="#矩阵特征值和特征向量定义" class="headerlink" title="矩阵特征值和特征向量定义"></a>矩阵特征值和特征向量定义</h3><p>A为n阶矩阵，若数λ和n维非0列向量x满足Ax&#x3D;λx，那么数λ称为A的特征值，x称为A的对应于特征值λ的特征向量。式Ax&#x3D;λx也可写成( A-λE)x&#x3D;0，并且|λE-A|叫做A 的特征多项式。当特征多项式等于0的时候，称为A的特征方程，特征方程是一个齐次线性方程组，求解特征值的过程其实就是求解特征方程的解。</p><p>依据普通线性代数中的概念，特征值和特征向量能够用传统的方法求得，可是实际项目中一般都是用数值分析的方法来计算。</p><p>这里介绍一下雅可比(Jacobi)迭代法求解特征值和特征向量。</p><h3 id="雅可比-Jacobi-迭代法"><a href="#雅可比-Jacobi-迭代法" class="headerlink" title="雅可比(Jacobi)迭代法"></a>雅可比(Jacobi)迭代法</h3><p>雅克比方法用于求实对称阵的所有特征值、特征向量。Jacobi算法计算简单、稳定性好、精度高、<br>求得的特征向量正交性好。但当A为稀疏阵时，Givens旋转变换将破坏其稀疏性，且只能适用于<br>实对称矩阵。</p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><ul><li>矩阵A与相似矩阵 B &#x3D; P A P-1的特征值相同。</li><li>若矩阵Q满足QT Q &#x3D; I,则称Q为正交矩阵。显然Q-1 &#x3D; QT,且正交阵的乘积仍为正交阵。</li><li>若A为实对称矩阵，则存在正交阵Q，使Q A QT &#x3D; diag(λ1,λ2,…,λn)，且QT的列是相应的特征向量。</li><li>实对称矩阵的特征值均为实数，且存在标准正交的特征向量系。</li><li>Givens 旋转矩阵R(p,q,θ)是正交阵，其中<br><img src="https://upload-images.jianshu.io/upload_images/9169686-24e27e682587f27c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Givens 旋转矩阵R"></li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>Jacobi 方法用平面旋转对实对称矩阵 A 做一系列旋转相似变换，从而将A约化为对角阵，进而求出特征值与特征向量。</li><li>R A RT 与A元素之间的关系：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-65ba449f613b6591.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br>为使R A RT 为对角矩阵，可选择θ为：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-5de230ba3470be5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></li></ul><p>当A为n阶实对称矩阵时，设A有非对角元，apq ≠ 0 ，设Givens 旋转矩阵R(p,q,θ)为：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-24e27e682587f27c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br>令C &#x3D; R A RT,则有：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-761cec604b06b27e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br>若令C的非对角元素cpq &#x3D; cqp &#x3D; 0,则：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-fa9cdb14674ed857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br>C与A的元素满足下列关系：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-28f45bc31b91f645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br><img src="https://upload-images.jianshu.io/upload_images/9169686-2b11eec48962e3c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br><img src="https://upload-images.jianshu.io/upload_images/9169686-fba67d9cb33e7799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br><strong>说明经旋转变换C &#x3D; R A RT后，C的对角线元素平方和比A的对角线元素平方和增加了2apq^2。而C的非对角元素平方和比A的非对角元素平方和减少了2apq^2。如果不断的变换下去，则最后非对角元素可趋于0，即可通过一系列旋转变换，使A与一对角阵相似。</strong></p><p><strong>注意：某步化为0的元素在后续的步骤中可能又非0。但只要不断重复化0过程，则当K→∞时，非对角元素必趋于0。</strong></p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>将实对称矩阵A经一系列正交相似变换约化为一个近似的对角阵，从而该对角阵的对角元就是A的近似特征值，由各个正交变换矩阵乘积的转置可得对应的特征向量。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-e0518723e55d179d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><p><strong>旋转阵Rk+1(k&#x3D;0,1,2,…)的确定：</strong><br><img src="https://upload-images.jianshu.io/upload_images/9169686-88dfd7e3b60d8b83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><p><strong>θ的计算</strong><br><img src="https://upload-images.jianshu.io/upload_images/9169686-e6c4b735d40db590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><p><strong>特征向量的计算</strong><br><img src="https://upload-images.jianshu.io/upload_images/9169686-429c21abcfae7887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "><br>说明H的第i列就是A对应λi的标准正交特征向量的近似值。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-768b8726c9b407ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><p><strong>Ak+1的计算</strong><br><img src="https://upload-images.jianshu.io/upload_images/9169686-13a88eeaa4a5f7c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><h4 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h4><p><img src="https://upload-images.jianshu.io/upload_images/9169686-477f121b545152f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><h4 id="Jacobi法的收敛性"><a href="#Jacobi法的收敛性" class="headerlink" title="Jacobi法的收敛性"></a>Jacobi法的收敛性</h4><p><img src="https://upload-images.jianshu.io/upload_images/9169686-17f982c1b61fdd00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><h3 id="C代码实现"><a href="#C代码实现" class="headerlink" title="C代码实现"></a>C代码实现</h3><p>基于前面的<a href="https://www.mrbluyee.com/2018/09/16/C%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%A1%E7%AE%97/">C实现矩阵数据结构与计算</a>里构造的矩阵数据结构与相应函数,用C实现了雅可比(Jacobi)迭代法求实对称矩阵的特征值与特征向量。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a> 文件夹为Matrix，主要有两个文件：Matrix.c 、Matrix.h</p><p>设要求的矩阵为n阶的实对称矩阵，则相应的参数如下：</p><ul><li>设定最多的迭代次数为n*n*30，若迭代次数超过限制则退出迭代。</li><li>设定精度要求为1e-10，若精度符合要求，也不再迭代。</li><li>计算后得到的结果为n+1 X n 的矩阵对象，其中第一行为特征向量，每一个特征向量对应的下面的剩余的列为其特征向量。</li></ul><p>相应代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">//雅克比(Jacobi)方法实现实对称矩阵的特征值和特征向量的求解</span><br><span class="line">//返回矩阵第一行为特征值，特征值下面的列为对应的特征向量</span><br><span class="line">Matrix *getSymmetricMatrixEigen(Matrix *m)&#123;</span><br><span class="line">    Matrix *resultm = NULL;</span><br><span class="line">    Matrix *tempm = NULL;</span><br><span class="line">    int nCount = 0,i,j;</span><br><span class="line">    if(isSymmetricMatrix(m) == 0) return NULL;</span><br><span class="line">    tempm = copyMatrix(m);</span><br><span class="line">    if(!tempm) return NULL;</span><br><span class="line">    resultm = creatIdentitySecondOrderMatrix(m-&gt;dshape);</span><br><span class="line">    if(!resultm) return NULL;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        double dbMax = *(tempm-&gt;array + 1);</span><br><span class="line">        int nRow = 0;</span><br><span class="line">        int nCol = 1;</span><br><span class="line">        for(i=0;i&lt;tempm-&gt;dshape.shape[2];i++)&#123; //在矩阵非对角线上找到最大的元素</span><br><span class="line">            for(j=0;j&lt;tempm-&gt;dshape.shape[3];j++)&#123;</span><br><span class="line">                if(i != j)&#123;</span><br><span class="line">                    double d = fabs(*(tempm-&gt;array + i*tempm-&gt;dshape.shape[3] + j)); </span><br><span class="line">                    if(d &gt; dbMax)&#123;</span><br><span class="line">                        dbMax = d;</span><br><span class="line">                        nRow = i;</span><br><span class="line">                        nCol = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dbMax &lt; 1e-10) break; //精度符合要求，不再迭代</span><br><span class="line">        if(nCount &gt; tempm-&gt;dshape.shape[3] * tempm-&gt;dshape.shape[3] * 30) break; //迭代次数超过限制</span><br><span class="line">        nCount++;</span><br><span class="line">        double dbApp = *(tempm-&gt;array + nRow*tempm-&gt;dshape.shape[3] + nRow);</span><br><span class="line">        double dbApq = *(tempm-&gt;array + nRow*tempm-&gt;dshape.shape[3] + nCol);</span><br><span class="line">        double dbAqq = *(tempm-&gt;array + nCol*tempm-&gt;dshape.shape[3] + nCol);</span><br><span class="line">        </span><br><span class="line">        //计算旋转角度</span><br><span class="line">        double dbAngle = 0.5*atan2(-2*dbApq,dbAqq-dbApp);</span><br><span class="line">        double dbSinTheta = sin(dbAngle);</span><br><span class="line">        double dbCosTheta = cos(dbAngle);</span><br><span class="line">        double dbSin2Theta = sin(2*dbAngle);</span><br><span class="line">        double dbCos2Theta = cos(2*dbAngle);</span><br><span class="line">        </span><br><span class="line">        *(tempm-&gt;array + nRow*tempm-&gt;dshape.shape[3] + nRow) = dbApp*dbCosTheta*dbCosTheta + </span><br><span class="line">            dbAqq*dbSinTheta*dbSinTheta + 2*dbApq*dbCosTheta*dbSinTheta;</span><br><span class="line">        *(tempm-&gt;array + nCol*tempm-&gt;dshape.shape[3] + nCol) = dbApp*dbSinTheta*dbSinTheta + </span><br><span class="line">            dbAqq*dbCosTheta*dbCosTheta - 2*dbApq*dbCosTheta*dbSinTheta;</span><br><span class="line">        *(tempm-&gt;array + nRow*tempm-&gt;dshape.shape[3] + nCol) = 0.5*(dbAqq-dbApp)*dbSin2Theta + dbApq*dbCos2Theta;</span><br><span class="line">        *(tempm-&gt;array + nCol*tempm-&gt;dshape.shape[3] + nRow) = *(tempm-&gt;array + nRow*tempm-&gt;dshape.shape[3] + nCol);</span><br><span class="line">        </span><br><span class="line">        for(i=0;i&lt;tempm-&gt;dshape.shape[3];i++)&#123;</span><br><span class="line">            if((i!=nCol)&amp;&amp;(i!=nRow))&#123;</span><br><span class="line">                int u = i*tempm-&gt;dshape.shape[3] + nRow; // p</span><br><span class="line">                int w = i*tempm-&gt;dshape.shape[3] + nCol; //q</span><br><span class="line">                dbMax = *(tempm-&gt;array + u);</span><br><span class="line">                *(tempm-&gt;array + u) = *(tempm-&gt;array + w) * dbSinTheta + dbMax * dbCosTheta; </span><br><span class="line">                *(tempm-&gt;array + w) = *(tempm-&gt;array + w) * dbCosTheta - dbMax * dbSinTheta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=0;j&lt;tempm-&gt;dshape.shape[3];j++)&#123;</span><br><span class="line">            if((j!=nCol)&amp;&amp;(j!=nRow))&#123;</span><br><span class="line">                int u = nRow*tempm-&gt;dshape.shape[3] + j; //p</span><br><span class="line">                int w = nCol*tempm-&gt;dshape.shape[3] + j; //q</span><br><span class="line">                dbMax = *(tempm-&gt;array + u);</span><br><span class="line">                *(tempm-&gt;array + u) = *(tempm-&gt;array + w) * dbSinTheta + dbMax * dbCosTheta; </span><br><span class="line">                *(tempm-&gt;array + w) = *(tempm-&gt;array + w) * dbCosTheta - dbMax * dbSinTheta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //计算特征向量</span><br><span class="line">        for(i=0;i&lt;resultm-&gt;dshape.shape[3];i++)&#123;</span><br><span class="line">            int u = i*resultm-&gt;dshape.shape[3] + nRow; // p</span><br><span class="line">            int w = i*resultm-&gt;dshape.shape[3] + nCol; //q</span><br><span class="line">            dbMax = *(resultm-&gt;array + u);</span><br><span class="line">            *(resultm-&gt;array + u) = *(resultm-&gt;array + w) * dbSinTheta + dbMax*dbCosTheta; </span><br><span class="line">            *(resultm-&gt;array + w) = *(resultm-&gt;array + w) * dbCosTheta - dbMax*dbSinTheta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix *eigenVal = (Matrix *)malloc(sizeof(Matrix));</span><br><span class="line">    if(!eigenVal) return NULL;</span><br><span class="line">    eigenVal-&gt;dshape.shape[0] = 0;</span><br><span class="line">    eigenVal-&gt;dshape.shape[1] = 0;</span><br><span class="line">    eigenVal-&gt;dshape.shape[2] = 0;</span><br><span class="line">    eigenVal-&gt;dshape.shape[3] = tempm-&gt;dshape.shape[3];</span><br><span class="line">    eigenVal-&gt;length = tempm-&gt;dshape.shape[3];</span><br><span class="line">    eigenVal-&gt;size = eigenVal-&gt;length;</span><br><span class="line">    eigenVal-&gt;array = (double *)malloc(eigenVal-&gt;size*sizeof(double));</span><br><span class="line">    if(!eigenVal-&gt;array)&#123;</span><br><span class="line">        free(eigenVal);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;resultm-&gt;dshape.shape[3];i++)&#123;</span><br><span class="line">        *(eigenVal-&gt;array + i) = *(tempm-&gt;array + i*tempm-&gt;dshape.shape[3] + i);</span><br><span class="line">    &#125;</span><br><span class="line">    spliceSecondOrderMatrixRow(eigenVal,resultm);</span><br><span class="line">    destroyMatrix(tempm);</span><br><span class="line">    destroyMatrix(resultm);</span><br><span class="line">    return eigenVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h3><p>注意，待求的矩阵必须是实对称矩阵。<br>testMatrix.c文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;Matrix.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    Matrix *m = NULL;</span><br><span class="line">    Matrix *m2 = NULL;</span><br><span class="line"></span><br><span class="line">    int a[]=&#123;0,0,3,3&#125;;</span><br><span class="line">    double data[] = &#123;1,1,1,1,2,10,1,10,100&#125;;</span><br><span class="line"></span><br><span class="line">    Dshape dshape;</span><br><span class="line">    initDshape(&amp;dshape,a);</span><br><span class="line">    </span><br><span class="line">    m = creatMatrixFromDatas(data,9,dshape);</span><br><span class="line">    printarray(m);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    m2 = getSymmetricMatrixEigen(m);</span><br><span class="line">    printarray(m2);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    destroyMatrix(m);</span><br><span class="line">    destroyMatrix(m2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc Matrix.c Matrix.h testMatrix.c -o testMatrix</span><br></pre></td></tr></table></figure><p>执行testMatrix，输出：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-b1195622bcf629b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"><br>即矩阵m的特征向量为<br>λ1 &#x3D; 0.0946051, 对应的特征向量为:<br>[0.70746, -0.703906, 0.063376] T<br>λ2 &#x3D; 1.8834,对应的特征向量为:<br>[0.706669, 0.703135, -0.0788656] T<br>λ3 &#x3D; 101.022,对应的特征向量为:<br>[0.0109521, 0.10058, 0.994869] T</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再论数组</title>
      <link href="/2018/09/22/%E5%86%8D%E8%AE%BA%E6%95%B0%E7%BB%84/"/>
      <url>/2018/09/22/%E5%86%8D%E8%AE%BA%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>在前面着重说明了数组和指针并不一致的绝大多数情形<a href="https://www.mrbluyee.com/2018/07/30/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84/">C语言数组与指针的不同之处</a><br>在实际应用中，数组和指针可以互换的情形要比两者不可互换的情形更为常见，数组下标表达式总是可以改写为带偏移量的指针表达式。</p><span id="more"></span><h3 id="什么时候数组与指针相同"><a href="#什么时候数组与指针相同" class="headerlink" title="什么时候数组与指针相同"></a>什么时候数组与指针相同</h3><p>让我们分别考虑声明和使用这两种情况。</p><p>声明本身还可以进一步分成3种情况：</p><ul><li>外部数组（external array）的声明。</li><li>数组的定义（定义是声明的一种特殊情况，它分配内存空间，并可能提供一个初始值）。</li><li>函数参数的声明。</li></ul><p><strong>所有作为函数参数的数组名总是可以通过编译器转换为指针。</strong><br>当一个数组名出现在一个表达式中时，它会被转换为一个指向该数组第一个元素的指针。<br>在其他所有情况下（最有趣的情况就是“在一个文件中定义为数组，在另一个文件中声明为指针”），数组的声明就是数组，指针的声明就是指针，两者不能混淆。</p><p>但在使用数组（在语句或表达式中引用）时，数组总是可以写成指针的形式，两者可以互换。<br>下表对这些情况做了一个总结：</p><table><thead><tr><th>数组</th><th>使用数组时</th></tr></thead><tbody><tr><td>声明</td><td>extern,如extern char a[];不能改写成指针的形式</td></tr><tr><td></td><td>定义，如，char a[10];不能改写成指针的形式</td></tr><tr><td></td><td>函数的参数，如func(char a[]);你可以随自己喜欢，选择数组形式或者指针形式</td></tr><tr><td>在表达式中使用</td><td>如c &#x3D; a[i];你可以随自己喜欢，选择数组形式或者是指针形式</td></tr></tbody></table><p>然而，数组和指针在编译器处理时是不同的，在运行时的表示形式也是不一样的，并可能产生不同的代码。对编译器而言，一个数组就是一个地址，一个指针就是一个地址的地址。</p><p>什么时候数组和指针是相同的，C语言标准对此作了如下说明：</p><ul><li>规则1：表达式中的数组名（与声明不同）被编译器当作一个指向该数组第一个元素的指针。</li><li>规则2：下标总是与指针的偏移量相同。</li><li>规则3：在函数参数的声明中，数组名被编译器当作指向该数组第一个元素的指针。</li></ul><p>下面几个小细节将详细描述这几个规则的实际含义。</p><h4 id="规则1"><a href="#规则1" class="headerlink" title="规则1"></a>规则1</h4><p><strong>“表达式中的数组名”就是指针</strong><br>上面的规则1和规则2合在一起理解，就是对数组下标的应用总是可以写成“一个指向数组的起始地址的指针加上偏移量”。例如，假如我们声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[10], *p ,i = 2;</span><br></pre></td></tr></table></figure><p>就可以通过以下任何一种方法来访问a[i]:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">p = a;</span><br><span class="line">p[i];</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">p = a;</span><br><span class="line">*(p + i);</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">p = a + i;</span><br><span class="line">*p;</span><br></pre></td></tr></table></figure><p>事实上，可以采用的方法更多。对数组的引用如a[i]在编译时总是被编译器改写*(a + i)的形式。C语言标准要求编译器必须具备这个概念性的行为。也许遵循这个规则的捷径就是记住方括号[]表示一个取下标操作符，就像加号表示一个加法运算符一样。取下标操作符取一个整数和一个指向类型T的指针，所产生的结果类型就是T，一个在表达式中的数组名于是就成了指针。</p><p>你只要记住：在表达式中，指针和数组是可以互换的，因为它们在编译器里的最终形式都是指针，并且都可以进行取下标操作。编译器自动把下标值得步长调整到数组元素的大小。如果整型数的长度是4个字节，那么a[i+1]和a[i]在内存中的距离就是4（而不是1）。对起始地址执行加法操作之前，编译器会负责计算每次增加的步长。这就是为什么指针总有类型限制，每个指针只能指向一种类型的原因所在——因为编译器需要知道对指针进行解除引用操作时应该取几个字节，以及每个下标的步长应取几个字节。</p><h4 id="规则2"><a href="#规则2" class="headerlink" title="规则2"></a>规则2</h4><p><strong>C语言把数组下标作为指针的偏移量</strong><br>在人们的常规思维中，在运行时增加对C语言下标的范围检查是不切实际的。因为取下标操作只是表示将要访问该数组，但并不保证一定要访问。而且，程序员完全可以使用指针来访问数组，从而绕过下标操作符。在这种情况下，数组下标范围检测并不能检测所有对数组的访问的情况。事实上，下标范围检测被认为并不值得加入到C语言中。</p><p>还有一种说法是，在编写数组算法时，使用指针比使用数组更有效率。这个颇为人们接受的说法在通常情况下是错误的。使用现代的产品质量优化的编译器，一维数组和指针引用所产生的代码并不具有显著的差别。不管怎样，数组下标是定义在指针的基础上的，所以优化器常常可以把它转换为更有效率的指针表达形式，并生成相同的机器指令。用指针迭代一个一维数组常常也并不比直接使用下标迭代一个一维数组来的更快。不论是指针还是数组，在连续的内存地址上移动时，编译器都必须计算每次前进的步长。计算的方法是偏移量乘以每个数组元素占用的字节数，计算结果就是偏移数组起始地址的实际字节数。步长因子常常是2的乘方（如int是4个字节，double是8个字节等），这样编译器在计算时就可以使用快速的左移位运算，而不是相对缓慢的加法运算。一个二进制数左移3位相当于它乘以8，如果数组中的元素大小不是2的乘方（如数组的元素类型是一个结构体），那就不能使用这个技巧了。</p><p>然而，迭代一个int数组是人们最容易想到的。如果一个经过良好优化的编译器进行代码分析，并把基本变量放在高速的寄存器中来确认循环是否继续，那么最终在循环中访问指针和数组所产生的代码很可能是相同的。</p><p>在处理一维数组时，指针并不见得比数组更快。C语言把数组下标改写成指针偏移量的根本原因是指针和偏移量是底层硬件所使用的基本模型。</p><h4 id="规则3"><a href="#规则3" class="headerlink" title="规则3"></a>规则3</h4><p><strong>“作为函数参数的数组名”等同于指针</strong><br>规则3也需要进行解释。首先回顾一下形参、实参的术语：</p><table><thead><tr><th>术语</th><th>定义</th><th>例子</th></tr></thead><tbody><tr><td>形参（parameter）</td><td>它是一个变量，在函数定义或函数声明的原型中定义。又称为“形式参数（formal parameter）”</td><td>int power(int base,int n); base 和 n都是形参</td></tr><tr><td>实参（argument）</td><td>在实际调用一个函数时所传递给函数的值。又称为“实际参数（actual parameter）”</td><td>i &#x3D; power(10, j); 10和j都是实参。在同一个函数的多次调用时，实参可以不同。</td></tr></tbody></table><p>标准规定作为“类型的数组”的形参的声明应该调整为“类型的指针”。在函数形参定义这个特殊情况下，编译器必须把数组形式改写成指向数组第一个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝。不过，现在让我们重点观察一下数组，隐形转换意味着三种形式是完全等同的。因此，在my_function()的调用上，无论实参是数组还是真的指针都是合法的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_function(int *turnip) &#123;...&#125;</span><br><span class="line">my_function(int turnip[]) &#123;...&#125;</span><br><span class="line">my_function(int turnip[200]) &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么会发生混淆"><a href="#为什么会发生混淆" class="headerlink" title="为什么会发生混淆"></a>为什么会发生混淆</h3><p>当人们学习编程时，一开始总是把所有的代码都放到一个函数里。随着水平的进步,他们把代码分别放到几个函数中。在水平继续提高后，他们最终学会了如何用几个文件来构造一个程序。在这个过程中，他们可以看到大量的作为函数参数的数组和指针，在这种情况下，两者是可以完全互换的，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char my_array[10];</span><br><span class="line">char *my_ptr;</span><br><span class="line">...</span><br><span class="line">i = strlen(my_array);</span><br><span class="line">j = strlen(my_ptr);</span><br></pre></td></tr></table></figure><p>程序员们还可以看到许多类似下面的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s %s&quot;, my_ptr, my_array);</span><br></pre></td></tr></table></figure><p>它清楚的展示了数组和指针的可互换性。人们很容易忽视这只是发生在一种特定的上下文环境中，也就是它们作为一个函数调用的参数使用。更糟的是，你可以如下编写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;array at location %x holds string %s&quot;, a, a);</span><br></pre></td></tr></table></figure><p>在同一条语句中，既把数组名作为一个地址（指针），又把它作一个字符数组。这条语句之所以可行是因为printf是一个函数，所以数组实际上是作为指针来传递的。我们也习惯了在main函数的参数中看到char **argv或char *argv[]这样的形式，它们也是可以互换的。同样，这个之所以成立是因为argv是一个函数的参数。</p><h3 id="为什么C语言把数组形参当作指针"><a href="#为什么C语言把数组形参当作指针" class="headerlink" title="为什么C语言把数组形参当作指针"></a>为什么C语言把数组形参当作指针</h3><p>把作为形参的数组和指针等同起来是出于效率原因的考虑。在C语言中，所有非数组形式的数据实参均以传值形式（对实参作一份拷贝并传递给调用的函数，函数不能修改作为实参的实际变量的值，而只能修改传递给它的那份拷贝）调用。然而，如果要拷贝整个数组，无论在时间上还是在内存空间上的开销都可能是非常大的。而且在绝大部分情况下，你其实并不需要整个数组的拷贝，你只想告诉函数在那个时刻对哪个特定的数组感兴趣。要达到这个目的，可以考虑的方法是在形参上增加一个存储说明符（storage specifier），表示它是传值调用还是传址调用。如果采用“所有的数组在作为参数传递时都转为指向数组起始地址的指针，而其他的参数均采用传值调用”的约定，就可以简化编译器。类似的，函数的返回值绝不能是一个函数、数组，而只能是指向数组或函数的指针。</p><p>有些人喜欢把它理解成除数组和函数之外的所有的C语言参数在缺省情况下都是传值调用，数组和函数则是传址调用。数据也可以使用传址调用，只要在它的前面加上取地址操作符（&amp;），这样传递给函数的是实参的地址而不是实参的拷贝。事实上，取地址操作符的主要用途就是实现传址调用。“传址调用”这个说法从严格意义上说并不十分准确，因为编译器的机制非常清楚——在被调用的函数中，你只拥有一个指向变量的指针而不是变量本身。如果你取实参的地址或对它进行拷贝，就能体会到两者的差别。</p><h3 id="数组形参是如何被引用的"><a href="#数组形参是如何被引用的" class="headerlink" title="数组形参是如何被引用的"></a>数组形参是如何被引用的</h3><p>C语言允许程序员把形参声明为数组（程序员打算传递给函数的东西）或者指针（函数实际所接收到的东西）。编译器知道何时形参是作为数组声明的，但事实上在函数内部，编译器始终把它当作一个指向数组第i个元素（元素长度未知）的指针。这样，编译器可以产生正确的代码，并不需要对数组和指针这两种情况作仔细区分。</p><p>不管程序员实际所写的是哪种形式，函数并不自动知道指针所指的数组共有多少个元素，所以必须要有个约定，如数组以NULL结尾或者另有一个附加的参数表示数组的范围。<br>在下列定义中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func(int *turnip) &#123;...&#125;</span><br><span class="line">func(int turnip[]) &#123;...&#125;</span><br><span class="line">func(int turnip[200]) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">int my_int; //数据定义</span><br><span class="line">int *my_int_ptr;</span><br><span class="line">int my_int_array[10];</span><br></pre></td></tr></table></figure><p>你可以合法的使用下列任何一个实参来调用上面任何一个原型函数。它们常常用于不同的目的：</p><table><thead><tr><th>调用时的实参</th><th>类型</th><th>通常目的</th></tr></thead><tbody><tr><td>func(&amp;my_int);</td><td>一个整型数的地址</td><td>一个int参数的传址调用</td></tr><tr><td>func(my_int_ptr);</td><td>指向整型数的指针</td><td>传递一个指针</td></tr><tr><td>func(my_int_array);</td><td>整型数组</td><td>传递一个数组</td></tr><tr><td>func(&amp;my_int_array[i]);</td><td>一个整型数组某个元素的地址</td><td>传递数组的一部分</td></tr></tbody></table><p>相反，如果处于func()函数内部，就没有一种容易的方法分辨这些不同的实参，因此也无法知道调用该函数是出于何种目的。所有属于函数实参的数组在编译时被编译器改写为指针。因此，在函数内部对数组参数的任何引用都将产生一个对指针的引用。</p><p>因此，很有意思的是，没有办法把数组本身传递给一个函数，因为它总是被自动转换为指向数组的指针。当然，在函数内部使用指针，所能进行的对数组的操作几乎跟传递原原本本的数组没有差别。只不过想用sizeof(实参)来获得数组的长度，所得到的结果不正确而已。</p><p>这样，在声明这样一个函数时，你就有了选择的余地。可以把形参定义成数组，也可以定义成指针。不论你选择什么，编译器都会注意到该对象是一个函数参数的特殊情况，它会产生代码对该指针进行解除引用操作。</p><p>如果你想让代码看上去清楚明白，就必须遵循一定的规则！我们倾向于始终把参数定义为指针，因为这是编译器内部所使用的形式。但从另一方面看，有些人觉得int table[]比int *\table更能表达程序员的意图。table[]这种记法清楚的表明了table内有好几个元素，提示函数会对它们都进行处理。</p><p>注意，有一样操作只能在指针里进行而无法在数组中进行，那就是修改它的值。数组名是不可修改的左值，它的值是不能改变的。</p><h3 id="数组和指针可交换性的总结"><a href="#数组和指针可交换性的总结" class="headerlink" title="数组和指针可交换性的总结"></a>数组和指针可交换性的总结</h3><ul><li>1.用a[i]这样的形式对数组进行访问总是被编译器”改写”或解释为像*(a+i)这样的指针访问。</li><li>2.指针始终就是指针。它绝不可以改写成数组。你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。</li><li>3.在特定的上下文中，也就是它作为函数的参数（也只有这种情况），一个数组的声明可以看作一个指针。作为函数参数的数组（就是在一个函数调用中）始终会被编译器修改成为指向数组第一个元素的指针。</li><li>4.因此，当把一个数组定义为函数的参数时，可以选择把它定义为数组，也可以定义指针。不管选择哪种方法，在函数内部事实上获得的都是一个指针。</li><li>5.在其他所有情况中，定义与声明必须匹配。如果定义了一个数组，在其他文件对它进行声明时也必须把它声明为数组，指针也是如此。</li></ul><h3 id="C语言的多维数组"><a href="#C语言的多维数组" class="headerlink" title="C语言的多维数组"></a>C语言的多维数组</h3><h4 id="数组的数组"><a href="#数组的数组" class="headerlink" title="数组的数组"></a>数组的数组</h4><p>有人声称C语言没有多维数组，这是不对的。ANSI C标准在第6.5.4.2节以及第69号脚注上表示：</p><blockquote><p>当几个[]修饰符连续出现时（方括号里面是数组的范围），就是定义一个多维数组。</p></blockquote><p>那些人的意思是C语言没有像其他语言一样的多维数组，所有其他语言都把这称为数组的数组。C语言的方法多少有点独特：定义和引用多维数组唯一的办法就是使用数组的数组。尽管C语言把数组的数组当作是多维数组，但不能把几个下标范围如[i][j][k]这样的下标形式合并成风格如[i,j,k]这样的。如果你清楚的明白自己在做什么，也介意产生不合规范的程序，可以把[i][j][k]这样的下标值计算为相应的偏移量，然后只用单一的下标[z]来引用数组。当然这不是一种值得推荐的做法。同样糟糕的是，像[i,j,k]这样的下标形式（由逗号分离）是C语言合法的表达形式，只是它并非同时引用这几个下标（它实际上所引用的下标值是k，也就是逗号表达式的值）。C语言支持其他语言一般称作数组的数组的东西，但却称它为多维数组，这样就模糊了两者的边界，使许多人对两者混淆不清。</p><p>在C语言中，可以像下面这样声明一个10X20的多维字符数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char carrot[10][20];</span><br></pre></td></tr></table></figure><p>或者声明一种看上去更像数组的数组形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef char vegetable[20];</span><br><span class="line">vegetable carrot[10];</span><br></pre></td></tr></table></figure><p>不论哪种情况，访问单个字符都是通过carrot[i][j]的形式，编译器在编译时会把它解析为*(*(carrot+i)+j)的形式。</p><p>当提到C语言中的数组时，就把它看作是一种向量（vector），也就是某种对象的一维数组，数组的元素可以是另一个数组。</p><h4 id="内存中数组是如何布局的"><a href="#内存中数组是如何布局的" class="headerlink" title="内存中数组是如何布局的"></a>内存中数组是如何布局的</h4><p>在C语言的多维数组中，最右边的下标是最先变化的，这个约定被称为“行主序”。由于“行&#x2F;列主序”这个术语只适用于恰好是二维的多维数组，所以更确切的术语是“最右的下标先变化“。<br>C语言中多维数组最大的用途是存储多个字符串。有人指出”最右边的下标先变化”在这方面具有优势（每个字符串中相邻的字符在内存中也相邻存储）。</p><h4 id="如何对数组进行初始化"><a href="#如何对数组进行初始化" class="headerlink" title="如何对数组进行初始化"></a>如何对数组进行初始化</h4><p>在最简单的情况下，一维数组可以通过把初始值都放在一堆花括号内来完成初始化。如果在数组的定义里未标明它的长度，C语言约定按照初始化值得个数来确定数组得长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float a[5] = &#123;0.0, 1.0, 2.72, 3.14, 25.625&#125;;</span><br><span class="line">float b[] = &#123;0.0, 1.0, 2.72, 3.14, 25.625&#125;;</span><br></pre></td></tr></table></figure><p>只能够在数组声明时对它进行整体得初始化。之所以存在这个限制，并没过硬的理由。<br>多维数组可以通过嵌套的花括号进行初始化，可以在最后一个初始化值的后面加一个逗号，也可以省略它。同时，也可以省略最左边下标的长度（也只能是最左边的下标），编译器会根据初始化值的个数推断出它的长度。</p><p>如果数组的长度比所提供的初始化值的个数要多，剩余的几个元素会自动设置为0。如果元素的类型是指针，那么它们被初始化为NULL；如果元素类型是float，那么它们被初始化为0.0。</p><p>下面是一种初始化二维字符串数组的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char vegetables[][9] = &#123;</span><br><span class="line">    &quot;beet&quot;,</span><br><span class="line">    &quot;barley&quot;,</span><br><span class="line">    &quot;basil&quot;,</span><br><span class="line">    &quot;broccoli&quot;,</span><br><span class="line">    &quot;beans&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一种有用的方法是建立指针数组。字符串常量可以作数组初始化值，编译器会正确的把各个字符存储于数组中的地址。因此：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char *vegetables[] = &#123;</span><br><span class="line">    &quot;carrot&quot;,</span><br><span class="line">    &quot;celery&quot;,</span><br><span class="line">    &quot;corn&quot;,</span><br><span class="line">    &quot;cilantro&quot;,</span><br><span class="line">    &quot;crispy fried potatos&quot;</span><br><span class="line">&#125;; //没问题</span><br></pre></td></tr></table></figure><p>注意它的初始化部分与字符数组的数组初始化部分是一样的。只有字符串常量才可以初始化指针数组。指针数组不能由非字符串的类型直接初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *weights[] = &#123;</span><br><span class="line">    &#123;1,2,3,4,5&#125;,</span><br><span class="line">    &#123;6,7&#125;,</span><br><span class="line">    &#123;8,9,10&#125;</span><br><span class="line">&#125;; //无法成功编译</span><br></pre></td></tr></table></figure><p>如果想用这种方法对数组进行初始化，可以创建几个单独的数组，然后用这些数组名来初始化原先的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int row_1[] = &#123;1,2,3,4,5,-1&#125;; // -1作为行结束标志</span><br><span class="line">int row_2[] = &#123;6,7,-1&#125;;</span><br><span class="line">int row_3[] = &#123;8,9,10,-1&#125;;</span><br><span class="line"></span><br><span class="line">int *weights[] = &#123;</span><br><span class="line">    row_1,</span><br><span class="line">    row_2,</span><br><span class="line">    row_3</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对内存的思考</title>
      <link href="/2018/09/18/%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/09/18/%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h3 id="内存的历史"><a href="#内存的历史" class="headerlink" title="内存的历史"></a>内存的历史</h3><p>现代的intel处理器可以追溯到最早期的intel芯片。<br>1.8085处理器充分利用了芯片整合技术，它将三块芯片组合成一块。在本质上，它是把8080处理器、8224时钟驱动器和8228控制器整合到一块芯片上。虽然它内部的数据总线宽度仍然是8位，但它使用了16位的地址总线，所以能够访问2^16也就是64KB的内存。</p><p>2.8086处理器于1978年诞生，它对8085作了改进，允许16位的数据总线和20位的地址总线，可以访问多大1MB的内存。它通过重叠两个16位的字来形成20位的地址，而不是通过简单的链接两个字来形成32位的地址。第一个16位值称为偏移量，第二个16位字经过移位后称为段，8086芯片有4个段寄存器，用于存储段地址的值，并能自动进入移位和加法操作来产生20位的地址。8086有代码寄存器CS，数据寄存器DS和堆栈寄存器SS，分别存放代码段、数据段和堆栈段的首地址，另外还有一个附加段ES。</p><p>3.80826差不多就是80186，只是内置了一些微不足道的外设端口支持，但它第一次试图扩展内存地址空间。它把内存控制器移到处理器芯片的外面，并提供了一种内存模式，称为虚拟模式（virtual mode）。在虚拟模式中，段寄存器并不与偏移地址相加，而是为一个存放实际段地址的表提供索引。这种地址模式也被称作保护模式（protected mode），它依然是16位的。</p><p>4.80386在80286的基础上增加了两种新的地址模式：32位的保护模式和虚拟的8086模式。Microsoft的windows NT操作系统以及增强模式下的windows都采用了32位的保护模式。这就是为什么windos NT至少需要386才能运行的原因。另一种内存模式，虚拟8086模式，可以创建一种内存空间为1MB的8086虚拟机,几个虚拟机可以同时运行，从而支持MS-DOS的虚拟多任务系统。</p><p>5.80486是一种经过重新包装的80386，它的速度更快一些，因为总线缺乏允许安装协处理器的状态。486适当的增加了一些指令，并在处理器内部集成了cache（高速的处理器内存）。</p><h3 id="intel-80x86内存模型以及它的工作原理"><a href="#intel-80x86内存模型以及它的工作原理" class="headerlink" title="intel 80x86内存模型以及它的工作原理"></a>intel 80x86内存模型以及它的工作原理</h3><p>段（segment）这个术语至少有两种不同的含义：<br>在UNIX中，段就是一块以二进制形式出现的相关内容。<br>在intel 80x86内存模型中，段是内存模型设计的结果，在80x86内存模型中，各处理器的地址空间并不一致，但它们都被分割成以64K为单位的区域，每个这样的区域便称为段。</p><p>作为80x86内存模型最基本的形式，8086中的段是一块64k的内存区域，由一个段寄存器所指向。内存地址的形成过程是：取得段寄存器得值，左移4位，然后就是16位得偏移地址，它表示段内得地址。如果把段寄存器的值（经过移位）加上偏移地址，就得到最终的地址。这就意味着许多不同的段地址&#x2F;偏移地址组合可能指向同一个内存地址。</p><p>今天，计算机系统结构的真正挑战不在于内存的容量，而是内存的速度。在巨型地址空间的机器中，主存访问时间的重要性将进一步凸现。当访问海量数据时，它所耗费的内存访问时间将左右软件的性能。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>很早的时候，在计算机领域中人们就提出了虚拟内存的概念。它的基本思路是利用廉价但缓慢的磁盘来扩充内存。在任一给定时刻，程序实际需要使用的虚拟内存区段的内容就被载入物理内存中。当物理内存中的数据有一段时间未被使用，它们就可能被转移到硬盘中，节省下来的物理内存空间用于载入需要使用的其他数据。</p><p>在计算机领域的早期，把未使用的部分数据从内存转移到磁盘的任务是由程序员手工完成的。程序员必须花费极大的精力追踪任一时刻哪些数据是在物理内存中，并根据需要在段之间来回切换。这种方法实在是太过时了，它对于当代的程序员而言根本不具备可操作性。</p><p>多层存储是一个类似的概念，我们可以在一台计算机中到处看到它的存在（如寄存器 vs 主存）。从理论上说，内存的每个位置都可以用寄存器来代替，但在实际上，这样做的成本将是不切实际的昂贵，所以必须牺牲一些访问速度来大幅降低存储系统的实现成本。虚拟内存只是对多层存储进行扩充，使用磁盘而不是主存来保存运行进程的映像，所以说它们实际上是同一种策略。</p><p>SunOS中的进程执行于32位地址空间。操作系统负责具体细节，使每个进程都以为自己拥有整个地址空间的独家访问权。这个幻觉是通过虚拟内存实现的，所有进程共享机器的物理内存，当内存用完时就用磁盘保存数据。在进程运行时，数据在磁盘和内存之间来回移动。内存管理硬件负责把虚拟地址翻译为物理地址，并让一个进程始终运行于系统的真正内存中。应用程序程序员只看到虚拟地址，并不知道自己的进程在磁盘和内存之间来回切换，除非他们观察运行时间或者查看诸如ps之类的系统指令。</p><p>虚拟内存通过“页”的形式组织。页就是操作系统在磁盘和内存之间移来移去或进行保护的单位，一般为几K字节。可以通过键入&#x2F;usr&#x2F;ucb&#x2F;pagesize来观察系统中的页面大小。当内存的映像在磁盘和物理内存间来回移动时，称它们是page in（移入内存）或page out（移到磁盘）。</p><p>从潜在的可能性上说，与进程有关的所有内存都将被系统所使用。如果该进程可能不会马上运行（可能它的优先级低，也可能是它处于睡眠状态），操作系统可以暂时取回所有分配给它的物理内存资源，将该进程的所有相关信息都备份到磁盘上。这样，这个进程就被“换出”。在磁盘中有一个特殊的交换区，用于保存从内存中被换出的进程。在一台机器中，交换区的大小一般是物理内存的几倍。只有用户进程才会被换进换出，SunOS内核常驻于内存中。</p><p>进程只能操作位于物理内存中的页。当进程引用一个不在物理内存中的页面时，MMU就会产生一个页错误。内核对此事件做出响应，并判断该引用是否有效。如果无效，内核向进程发出一个“segmentation violation（段违规）”的信号。如果有效，内核从磁盘取回该页，换入到内存中。一旦页进入内存，进程便被解锁，可以重新运行——进程本身并不知道它曾经因为页换入事件等待了一会。</p><p>SunOS对于磁盘的文件系统和主存有一种统一的观点。操作系统使用相同的底层数据结构(vnode<br>,或称虚拟结点)来操纵这两者。所有的虚拟内存操作都出于同样的设计哲学，就是把文件区域映射到内存区域中。这可以提高性能，并允许可观的代码复用。你可能听说过“hat layer（帽子层）“——就是驱动MMU的”硬件地址翻译“软件。它极度依赖硬件，每出现一个新的计算机架构，它都必须重新改写。</p><p>虚拟内存现在已成为一项操作系统中不可或缺的技术，它允许多个进程运行于较小的物理内存中。</p><h3 id="Cache存储器"><a href="#Cache存储器" class="headerlink" title="Cache存储器"></a>Cache存储器</h3><p>Cache存储器是多层存储概念的更深扩展。它的特点是容量小、价格高、速度快。Cache位于CPU和内存之间，是一种极快的存储缓冲区。从内存管理单元(MMU)的角度看，有些机器的Cache是属于CPU一侧的。在这种情况下，Cache使用的是虚拟地址，在每次进程切换时，它的内容必须进行刷新。也有一些机器的Cache从MMU的角度看是属于物理内存一侧的。在这种情况下，Cache使用的是物理地址，这就容易使多处理器CPU共享同一个Cache。</p><p>所有的现代处理器都使用了Cache存储器。当数据从内存读入时，整行（一般16或者32个字节）的数据被装入Cache。如果程序具有良好的地址引用局部性（如：它顺序浏览一个字符串），那么CPU以后对邻近数据的引用就可以从快速的Cache读取，而不用从缓慢的内存中读取。Cache操作的速度与系统的周期时间相同。与常规的内存相比，Cache要贵的多，所以在系统中我们把它作为存储系统的附加部分，而不是把它作为唯一的存储形式。</p><p>Cache包含一个地址的列表以及它们的内容。随着处理器不断引用新的存储地址，Cache的地址列表也一直处于变化中。所有对内存的读取和写入操作都要经过Cache。当处理器需要从一个特定的地址提取数据时，这个请求首先递交给Cache。如果数据已经存在于Cache中，它就可以立即被提取，否则，Cache向内存传递这个请求，于是就要进行缓慢的访问内存操作。内存读取的数据以行为单位，在读取的同时也装入到Cache中。</p><p>如果你的程序的行为颇为怪异，以致每次都无法命中Cache，那么，程序的性能比不采用Cache还要差。因为每次判断Cache是否命中的额外逻辑需要时间。</p><p>Sun使用两种类型的Cache：</p><ul><li>全写法(write-through)Cache——每次写入Cache时总是同时写入到内存中，使内存和Cache始终保持一致。</li><li>写回法(write-back)Cache——当第一次写入时，只对Cache进行写入。如果已经写入过的Cache行再次需要写入时，此时第一次写入的结果尚未保存，所以要先把它写入到内存中。当内核切换进程时，Cache中的所有数据也都要先写入到内存中。</li></ul><p>在两种情况下，一旦对Cache的访问结束，指令流都将继续执行，不用等待缓慢的内存操作全部完成。</p><p>如果处理器使用内存映射（memory-mapped）的I&#x2F;O,可能会出现提供I&#x2F;O总线使用的Cache。而且现在经常出现分离的指令Cache和数据Cache。事实上还可能出现多层的Cache，而且Cache可以出现在任何存在快速&#x2F;慢速设备的接口上（如磁盘和内存）。PC经常使用由主存构成的Cache来提高速度较慢的磁盘的存取速度。在UNIX中，内存就是磁盘的Cache，因此切断机器电源前如果不使用sync命令把Cache(内存)的内容刷新到磁盘中，文件系统就有可能损坏。</p><p>对于编写应用程序的程序员而言，Cache和虚拟内存都是透明的，但知道它们所提供的好处以及它们可以影响系统性能的行为是非常重要的。</p><p>Cache的组成：</p><table><thead><tr><th>术语</th><th>定义</th></tr></thead><tbody><tr><td><strong>行(line)</strong></td><td>行就是对Cache进行访问的单位。每行由两部分组成：一个数据部分以及一个标签，用于指定它所代表的地址。</td></tr><tr><td><strong>块(block)</strong></td><td>一个Cache行内的数据被称作块。块保存来回移动于Cache行和内存之间的字节数据，一个典型的块为32字节。</td></tr><tr><td></td><td>一个Cache行的内容代表特定的内存块，如果处理器试图访问属于该块地址范围的内存，它就会作出反应，速度自然要比访问内存快的多。</td></tr><tr><td></td><td>在计算机行业中，对大多数人而言，”块“和”行“的概念分的并不特别清，两者常常可以交换使用。</td></tr><tr><td><strong>Cache</strong></td><td>一个Cache（一般为64K到1M之间，也可能更多）由许多行组成。有时也使用相关的硬件来加速对标签的访问。为了提高速度，Cache的位置离Cache很近，而且内存系统和总线经过高度优化，尽可能的提高大小等于Cache块的数据块的移动速度。</td></tr></tbody></table><h3 id="数据段和堆"><a href="#数据段和堆" class="headerlink" title="数据段和堆"></a>数据段和堆</h3><p>我们已经讨论了跟系统相关的内存话题的背景信息，现在是重新访问每个进程内部的内存布局的时候了。</p><p>就像堆栈段能够根据需要自动增长一样，数据段也包含了一个对象，用于完成这项工作，这就是堆（heap）。堆的结构如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-f76d2c8ab60539ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆的位置"><br>堆区域用于动态分配的存储，也就是通过malloc（内存分配）函数获得的内存，并通过指针访问。堆中的所有东西都是匿名的——不能按名字直接访问，只能通过指针间接访问。从堆中获取内存的唯一办法就是通过调用malloc（以及同类的calloc、realloc等）库函数。calloc函数与malloc类似，但它在返回指针之前先把分配好的内存的内容都清空为0，不要以为calloc函数中的c跟C语言编程有关——它的意思是”分配清零后的内存“。realloc函数改变一个指针所指向的内存块的大小，既可以将其扩大，也可以把它缩小，它经常把内存拷贝到别的地方然后将指向新地址的指针返回给你，这在动态增长表的大小时很有用。</p><p>堆内存的回收不必与它所分配的顺序一致（它甚至可以不回收），所以无序的malloc&#x2F;free最终会产生堆碎片。堆对它的每块区域都需要密切留心，哪些是已经分配了的，哪些是尚未分配的。其中一种策略就是建立一个可用块（”自由存储区“）的链表，每块由malloc分配的内存块都在自己的前面标明自己的大小。有些人用arena这个术语描述由内存分配器（memory allocator）管理的内存块的集合（在SunOS中，就是从当前break的位置到数据段结尾之间的区域）。</p><p>被分配的内存总是经过对齐，以适合机器上最大尺寸的原子访问，一个malloc请求申请的内存大小为方便起见一般被规整为2的乘方。回收的内存可供重新使用，但并没有（方便的）办法把它从你的进程移出交还给操作系统。</p><p>堆的末端由一个称为break的指针来标识，当堆管理器需要更多内存时，它可以通过系统调用brk和sbrk来移动break指针。一般情况下，不必由自己显示的调用brk，如果分配的内存容量很大，brk最终会被自动调用。</p><p>用于管理内存的调用是：</p><ul><li>malloc和free——从堆中获得内存以及把内存返回给堆。</li><li>brk和sbrk——调整数据段的大小至一个绝对值（通过某个增量）。</li></ul><p>警告：你的程序可能无法同时调用malloc()和brk()。如果你使用malloc，malloc希望当你调用brk和sbrk时，它具有唯一的控制权。由于sbrk向进程提供了唯一的方法将数据段内存返回给系统内核，所以如果使用了malloc，就有效的防止了程序的数据段缩小的可能性。要想获得以后能够返回给系统内核的内存，可以使用mmap系统调用来映射&#x2F;dev&#x2F;zero文件。需要返回这种内存时，可以使用munmap系统调用。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>由于C语言通常并不使用垃圾收集器（自动确认并回收不再使用的内存块），在使用malloc()和free()时不得不非常慎重。堆经常会出现两种类型的问题：</p><ul><li>释放或改写仍在使用的内存（称为”内存损坏“）。</li><li>未释放不再使用的内存（称为”内存泄漏“）。</li></ul><p>这是最难被调试发现的问题之一。如果每次已分配的内存块不再使用而程序员并不释放它们，进程就会一边分配越来越多的内存，一边却并不释放不再使用的那部分内存。我们使用”内存泄漏”这个词是因为一种稀有的资源正被一个进程榨干。内存泄漏的主要可见症状就是罪魁进程的速度会减慢。原因是体积大的进程更有可能被系统换出，让别的进程运行，而且大的进程在换进换出时花费的时间也更多。</p><p>即使（从定义上说）泄漏的内存本身并不被引用，但它仍可能存在于页中（内容自然是垃圾），这样就增加了进程的工作页数量，降低了性能。另外需要注意的一点是，泄漏的内存往往比忘记释放的数据结构要大，在资源有限的情况下，即使引起内存泄漏的进程并不运行，整个系统的运行速度也会被拖慢。</p><h3 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h3><p>每次当调用malloc分配内存时，注意在以后要调用相应的free来释放它。</p><p>如果不知道如何调用free与先前的malloc相对应，那么很可能已经造成了内存泄漏。</p><p>一种简单的方法就是在可能的时候使用alloca()来分配动态内存，以避免上述情况。当离开调用alloca的函数时，它所分配的内存会被自动释放。显然，这并不适用于那些比创建它们的函数生命期更长的结构。但如果对象的生命期在该函数结束前便已终止，这种建立在堆栈上的动态内存分配是一种开销很小的选择。有些人不提倡使用alloca，因为它并不是一种可移植的方法。如果处理器在硬件上不支持堆栈，alloca()就很难高效的实现。</p><h3 id="如何检测内存泄漏"><a href="#如何检测内存泄漏" class="headerlink" title="如何检测内存泄漏"></a>如何检测内存泄漏</h3><p>观察内存泄漏是一个两步骤的过程。<br>首先，使用free命令观察还有多少可用的交换空间：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-0d472a015dfb8f16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可用的交换空间"><br>在一两分钟内键入该命令三到四次，看看可用的交换区是否在减少。还可以使用其他一些&#x2F;usr&#x2F;bin&#x2F;*stat工具如netstat、vmstat等。如果发现不断有内存被分配且从不释放，一个可能的解释就是有个进程出现了内存泄漏。</p><p>操作系统同时动态管理它的内存使用。内核中的许多数据表是动态分配的，所以预先没有固定的限制。如果一个内核程序错误引起内存泄漏，机器的速度便会慢下来，有时机器干脆挂起或甚至不知所措。如果出现内存泄漏，最终可能导致可以分配的内存无法满足内核的需要，结果每个内核程序都无限制的等待——于是机器便被挂起。内核中的内存泄漏往往很快便被发现，因为绝大多数内核程序的使用都相当频繁。</p><h3 id="总线错误与段错误"><a href="#总线错误与段错误" class="headerlink" title="总线错误与段错误"></a>总线错误与段错误</h3><p>在UNIX上编程时，两个常见的运行时错误：<br>bus error(core dumped) 总线错误（信息已转储）<br>segmentation fault(core dumped) 段错误（信息已转储）<br>错误信息对引起这两种错误的源代码错误并没有作简单的解释，上面的信息并未提供如何从代码中寻找错误的线索，而且两者之间的区别也并不是十分清楚。</p><p>大多数的问题都是出于这样一个事实：错误就是操作系统所检测到的异常，而这个异常是尽可能的以操作系统方便的原则来报告的。总线错误和段错误的准确原因在不同的操作系统版本上各不相同。这里，描述的是运行于SPARC架构的SunOS出现的这两类错误以及产生错误的原因：</p><p>当硬件告诉操作系统一个有问题的内存引用时，就会出现这两种错误。操作系统通过向出错的进程发送一个信号与之交流。信号就是一种事件通知或一个软件中断，在UNIX系统编程中使用很广。在缺省情况下，进程在收到“总线错误”或“段错误”信号后将进行信息转储并终止。不过可以为这些信号设置一个信号处理程序（signal handler），用于修改进程的缺省反应。</p><h4 id="总线错误"><a href="#总线错误" class="headerlink" title="总线错误"></a>总线错误</h4><p>事实上，总线错误几乎都是由于<strong>未对齐的读或写</strong>引起的。它之所以称为总线错误，是因为出现未对齐的内存访问请求时，被堵塞的组件就是地址总线。对齐（alignment）的意思就是数据项只能存储在地址是数据项大小的整数倍的内存位置上。在现代的计算机架构中，尤其是RISC架构，都需要数据对齐，因为与任意的对齐有关的额外逻辑会使整个内存系统更大且更慢。通过迫使每个内存访问局限在一个Cache行或一个单独的页面内，可以极大的简化（并加速）如Cache控制器和内存管理单元这样的硬件。</p><p>我们表达“数据项不能跨越页面或Cache边界”规则的方法多少有些间接，因为我们用地址对齐这个术语来称述这个问题，而不是直截了当说是禁止内存跨页访问，但它们说的是同一回事。例如，访问一个8字节的double数据时，地址只允许是8的整数倍。所以一个double数据可以存储于地址24、8008或32768，但不能存储于地址1006（因为它无法被8整除）。页和Cache的大小是经过精心设计的，这样只要遵守对齐规则就可以保证一个原子数据项不会跨越一个页或Cache块的边界。<br>一个会引起总线错误的代码是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    char a[10];</span><br><span class="line">    int i;</span><br><span class="line">&#125;u;</span><br><span class="line"></span><br><span class="line">int *p = (int *)&amp;(u.a[1]);</span><br><span class="line">*p = 17; </span><br></pre></td></tr></table></figure><p>因为数组和int的联合确保数组a是按照int的4字节对齐的，所以“a+1”的地址肯定未按int对齐。然后我们试图往这个地址存储4个字节的数据，但这个访问只是按照单字节的char对齐，这就违反了规则。一个好的编译器发现不对齐的情况时会发出警告，但它并不能检测到所有不对齐的情况。</p><h4 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h4><p>段错误或段违规(segmentation violation)应该已经很清楚，因为前面对段模型已经作了解释。在Sun的硬件中，段错误是由于内存管理单元（负责支持虚拟内存的硬件）的异常所致，而该异常则通常是由于解除引用一个未初始化或非法值得指针引起的。如果指针引用一个并不位于你的地址空间中的地址，操作系统便会对此进行干涉。</p><p>一个会引起段错误的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p = 0;</span><br><span class="line">*p = 17;</span><br></pre></td></tr></table></figure><p>一个微妙之处是，导致指针具有非法的值通常是由于不同的编程错误所引起的。和总线错误不同，段错误更像是一个间接的症状而不是引起错误的原因。</p><p>一个更糟糕的微妙之处是，如果未初始化的指针恰好具有未对齐的值（对于指针所要访问的数据而言），它将会产生总线错误，而不是段错误。对于绝大多数架构的计算机而言确实如此，因为CPU先看到地址，然后再把它发送给MMU。</p><p>在你的代码中，对非法指针值得解引用操作可能会像上面这样显式得的出现，也可能在库函数中出现（传递给它一个非法值）。令人不快的是，你的程序如果进行了修改（如在调试状态下编译或增加额外的调试语句），内存的内容便很容易改变，于是这个问题被转移到别处或干脆消失。段错误是非常难于解决的，而且只有非常顽固的段错误才会一直存在。</p><p>通常导致段错误的几个直接原因：</p><ul><li>解除引用一个包含非法值的指针。</li><li>解除引用一个空指针（常常由于从系统程序中返回空指针，并未检查就使用）。</li><li>在未得到正确的权限时进行访问。例如，试图往一个只读的文本段存储值就会引起段错误。</li><li>用完了堆栈或堆空间（虚拟内存虽然巨大但绝非无限）。</li></ul><p>下面这个说法可能过于简单，但在绝大多数架构的绝大多数情况下，<strong>总线错误意味着CPU对进程引用内存的一些做法不满，而段错误则是MMU对进程引用内存的一些情况发出抱怨。</strong></p><p>以发生频率为序，最终可能导致段错误的常见编程错误是：</p><ul><li><strong>指针值错误：</strong> 在指针初始化之前就用它来引用内存（野指针），或者向库函数传送一个野指针（如果调试器显式系统程序中出现了段错误，并不是因为系统程序引起了段错误，问题很可能还存在于自己的代码中）；对指针进行释放之后再访问它的内容（空悬指针）(可以在free语句后再将指针置为空值)。</li><li><strong>改写(overwrite)错误：</strong> 越过数组边界写入数据，在动态分配的内存两端之外写入数据，或改写一些堆管理数据结构（在动态分配的内存之前的区域写入数据就很容易发生这种情况）。</li><li><strong>指针释放引起的错误：</strong> 释放同一个内存块两次，或释放一块未曾使用malloc分配的内存，或释放仍在使用中的内存，或释放一个无效的指针。一个极为常见的与释放内存有关的错误就是在for(p&#x3D;start;p;p&#x3D;p-&gt;next)这样的循环中迭代一个链表，并在循环体内使用free(p)语句。这样，在下一次循环迭代时，程序就会对已经释放的指针进行解除引用操作，从而导致不可预料的结果。</li></ul><p>当程序出现坏指针值时（野指针、空悬指针），什么样的结果都有可能发生。一种广被接受的说法是，如果你走运，指针将指向你的地址空间之外，这样第一次使用该指针时就会使程序进行信息转储后终止。如果你不走运，指针将指向你的地址空间之内，并损坏（改写）它所指向的内存的任何信息。这将引起隐晦的BUG，非常难以捕捉。</p><h3 id="虚拟内存规则总结"><a href="#虚拟内存规则总结" class="headerlink" title="虚拟内存规则总结"></a>虚拟内存规则总结</h3><p>规则：</p><ul><li>1.每个进程拥有很多的<strong>字节</strong>。</li><li>2.字节存放于<strong>页</strong>中，每页4096个字节。位于同一页上的字节具有<strong>本地引用</strong>关系。</li><li>3.页可以存放在内存中，也可以存放在磁盘中。内存一般不够大，无法容纳所有的页。</li><li>4.总共只有一块内存，但可以有几个磁盘，所有进程共享内存和磁盘。</li><li>5.每个字节都有自己的<strong>虚拟地址</strong>。</li><li>6.进程可以对一个字节进行<strong>引用操作</strong>。每个进程轮流进行引用操作。</li><li>7.每个进程只能引用自己的字节，不能引用其它进程的字节。</li><li>8.字节只有当它们位于内存中时才能被引用。</li><li>9.只有<strong>虚拟内存管理器</strong>知道某个字节位于内存还是位于磁盘。</li><li>10.一个字节不被引用的时间越长，它就被称为越“旧”。</li><li>11.进程必须通过虚拟内存管理器得到字节。它所给的字节数量是2的倍数或乘方数，这有助于减少开销。</li><li>12.进程引用字节的方法就是给出它的虚拟地址。如果进程所给出的虚拟地址恰好位于内存中，那么进程就可以立即引用它。如果它位于磁盘中，虚拟内存管理器会把包含该字节的页移入到内存中。如果内存空间已满，它就寻找内存中最旧的页（可能是该进程自己的，也可能是其他进程的），把它换到磁盘中，腾出来的空间就存放包含你需要字节的页。然后，进程就可以引用该字节，但进程并不知道该页原先位于磁盘中。</li><li>13.每个进程拥有的字节的虚拟地址与其他进程一样。虚拟内存管理器始终知道谁拥有哪个字节以及该轮到谁进行引用操作，所以一个进程不会无意引用其他进程的字节，即使两者的虚拟地址相同。</li></ul><p> 说明：</p><ul><li>1.根据传统，虚拟内存管理器使用一张很大且分段的表，另外还有<strong>页表</strong>用于记住所有字节的位置以及它们的主人。</li><li>2.规则13的一个结果就是各次运行中每位进程的虚拟地址都类似，即使进程的数量有所变化。</li><li>3.虚拟内存管理器也拥有自己的一些字节，它们中的有些也和一般进程的字节一样在内存和磁盘中移来移去。但是，它的有些字节使用频率非常之高，所以常驻内存。</li><li>4.按照上述规则，经常被引用的字节更有可能被存放在内存中，而不太被引用的字节则更可能被存放在磁盘中，这可以提高内存的使用效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现矩阵数据结构与计算</title>
      <link href="/2018/09/16/C%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
      <url>/2018/09/16/C%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>用C实现矩阵写的不像前面的链表等数据结构写的顺利，因为矩阵里面的内容多的多，特别是计算部分，着实花了几天时间。目前还有一小部分算法还没有实现，后续会补上。<br><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a> 文件夹为Matrix，主要有两个文件：Matrix.c 、Matrix.h</p><span id="more"></span><h4 id="矩阵的数据结构的设计"><a href="#矩阵的数据结构的设计" class="headerlink" title="矩阵的数据结构的设计"></a>矩阵的数据结构的设计</h4><p>矩阵是存储的一组或多组数据，所以毫无疑问，应使用顺序存储的方式存储数据元素。矩阵最直观的表示方式是用多维数组来表示，缺点在于不够活，使用前必须确定其长度，而且维度变换时十分麻烦。综合了诸多因素，我设计如下的主要使用堆的动态的矩阵数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Dshape&#123;</span><br><span class="line">    int shape[4]; //最多四维</span><br><span class="line">&#125;Dshape;</span><br><span class="line"></span><br><span class="line">typedef struct Matrix&#123;</span><br><span class="line">    double *array;  </span><br><span class="line">    Dshape dshape; //数组结构</span><br><span class="line">    int length; //长度</span><br><span class="line">    int size; //空间大小</span><br><span class="line">&#125;Matrix;</span><br></pre></td></tr></table></figure><p>我们看结构体Matrix，里面首先是一个double型的指针*array，这用于指向的矩阵元素存储块的首地址。在刚开始的设计版本中，我把指针的类型设置为void型，这样*array可以指向任何类型的数据块，但是在存取时需要类型判断和转换，比较麻烦，而且在后面矩阵的一些算法如求行列式等就更为麻烦，所以最终设定Matrix的元素类型为double型。<br>Dshape dshape定义了矩阵的结构，可以看到struct Dshape里定义的是一个int型的大小为4的数组，这个数组用来存储矩阵的结构信息，4个int型代表维数，最多支持4维。例如，一个2X2（二行二列）的二维矩阵的dshape为{0，0，2，2}。要注意的是一个设定：一维矩阵，即只有一行，假设这一行的元素有3个，那么该一维矩阵的dshape为{0，0，0，3}，而不是{0，0，1，3}。还有一种情况，一列元素，假设有n个，那么，该列的dshape为{0，0，n，1}。把int型数组用struct包装一下，这是一个小技巧，好处是struct可以直接整体赋值，在代码中就会简洁一些，不必再用循环依次对数组赋值。存放多维矩阵元素只用一块连续的存储区域，而矩阵的结构由dshape来决定，最大的好处在于，更改数组的维数、结构非常的容易，不需要改矩阵元素的存储区域，只要改一下dshape的值就可以了。<br>int length保存了矩阵*array里数据元素的长度， int size则保存了矩阵*array所占空间的大小。大部分情况下，这两个值是相等的，但在有些时候，不相等，比如说做删除矩阵里的元素操作时，我只改变了length的大小，而size不变。</p><h4 id="矩阵的创建"><a href="#矩阵的创建" class="headerlink" title="矩阵的创建"></a>矩阵的创建</h4><p>矩阵创建时首先要确定dshape，dshape有三种初始化方式：<br>例如要创建的矩阵的结构为4行5列的二维矩阵，<br>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dshape dshape；</span><br><span class="line">dshape.shape[0] = 0;</span><br><span class="line">dshape.shape[1] = 0;</span><br><span class="line">dshape.shape[2] = 4;</span><br><span class="line">dshape.shape[3] = 5;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[]=&#123;0,0,4,5&#125;;</span><br><span class="line">Dshape dshape;</span><br><span class="line">initDshape(&amp;dshape,a);</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix *a; //a已是一个4行5列的二维矩阵</span><br><span class="line">Dshape dshape;</span><br><span class="line">dshape = a-&gt;dshape;</span><br></pre></td></tr></table></figure><p>矩阵的创建构造了以下函数：<br>1.从数据创建数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatAsMatrixFromDatas(double *data,int data_len, Dshape dshape);</span><br></pre></td></tr></table></figure><p>浅拷贝，数据不开辟新的内存空间，array的地址就指向data的地址。</p><p>2.从数据创建数组,深拷贝，数据开辟新的内存空间，从data复制一份数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatMatrixFromDatas(double *data,int data_len, Dshape dshape);</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Matrix *m = NULL;</span><br><span class="line">m = creatMatrixFromDatas(data,data_len,dshape);</span><br></pre></td></tr></table></figure><p>3.创建一个单一值的矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatMatrixFromValue(double value, Dshape dshape);</span><br></pre></td></tr></table></figure><p>4.指定初始值和步长，创建等间隔值的矩阵，结束的值根据矩阵的大小变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatMatrixFromArange(double startVal, double stepVal,Dshape dshape);</span><br></pre></td></tr></table></figure><p>5.指定初始值和结束值，创建等间隔的矩阵，间隔根据矩阵的大小变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatMatrixFromLinspace(double startVal, double endVal,Dshape dshape);</span><br></pre></td></tr></table></figure><p>6.创建全0矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatZerosMatrix(Dshape dshape);</span><br></pre></td></tr></table></figure><p>7.创建全1矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatOnesMatrix(Dshape dshape);</span><br></pre></td></tr></table></figure><p>8.创建二维单位矩阵，要求dshape里行数与列数相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *creatIdentitySecondOrderMatrix(Dshape dshape);</span><br></pre></td></tr></table></figure><h4 id="矩阵的shape相关的函数"><a href="#矩阵的shape相关的函数" class="headerlink" title="矩阵的shape相关的函数"></a>矩阵的shape相关的函数</h4><p>1.初始化dshape</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void initDshape(Dshape *dshape,int *shapeval);</span><br></pre></td></tr></table></figure><p>2.修改dshape</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int reshape(Matrix *m,Dshape dshape);</span><br></pre></td></tr></table></figure><p>3.获取矩阵的维数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getMatrixNdim(Matrix *m);</span><br></pre></td></tr></table></figure><h4 id="矩阵打印的函数"><a href="#矩阵打印的函数" class="headerlink" title="矩阵打印的函数"></a>矩阵打印的函数</h4><p>1.打印矩阵的shape</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void printShape(Matrix *m);</span><br></pre></td></tr></table></figure><p>2.打印矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void printarray(Matrix *m);</span><br></pre></td></tr></table></figure><h4 id="矩阵的清空与销毁函数"><a href="#矩阵的清空与销毁函数" class="headerlink" title="矩阵的清空与销毁函数"></a>矩阵的清空与销毁函数</h4><p>1.清空矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void clearMatrix(Matrix *m);</span><br></pre></td></tr></table></figure><p>2.销毁矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void destroyMatrix(Matrix *m);</span><br></pre></td></tr></table></figure><h4 id="获取矩阵的元素"><a href="#获取矩阵的元素" class="headerlink" title="获取矩阵的元素"></a>获取矩阵的元素</h4><p>1.获取矩阵的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getMatrixElem(Matrix *m,int dimen0,int dimen1,int dimen2,int dimen3,double *elem);</span><br></pre></td></tr></table></figure><p>dimen表示维数，例如要获取3X3的二维矩阵m中第(1,1)个元素（下标从0开始计算）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double elem;</span><br><span class="line">getMatrixElem(m,0,0,1,1,&amp;elem);</span><br></pre></td></tr></table></figure><p>函数返回的int为状态指示用的，一般都设定为返回0为操作成功，返回-1为操作失败。</p><p>2.修改矩阵的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int modifyMatrixElem(Matrix *m,int dimen0,int dimen1,int dimen2,int dimen3,double elem);</span><br></pre></td></tr></table></figure><p>3.获取矩阵的连续几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *getSecondOrderMatrixRows(Matrix *m,int startRow,int endRow);</span><br></pre></td></tr></table></figure><p>下标从0开始计算，返回一个新的矩阵，用法示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Matrix *n = NULL;</span><br><span class="line">n = getSecondOrderMatrixRows(m,0,1); //获取矩阵m的第一行</span><br></pre></td></tr></table></figure><p>4.获取矩阵的连续几列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *getSecondOrderMatrixColumes(Matrix *m,int startColume,int endColume);</span><br></pre></td></tr></table></figure><p>5.获取矩阵的子矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *getSecondOrderSubMatrix(Matrix *m,int startRow,int startColume,int endRow,int endColume);</span><br></pre></td></tr></table></figure><p>6.获取矩阵删除指定一行和一列之后的子矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *getSecondOrderLeftSubMatrix(Matrix *m,int row,int colume);</span><br></pre></td></tr></table></figure><h4 id="矩阵的基本操作"><a href="#矩阵的基本操作" class="headerlink" title="矩阵的基本操作"></a>矩阵的基本操作</h4><p>1.复制矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *copyMatrix(Matrix *m);</span><br></pre></td></tr></table></figure><p>2.转置矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int transposeSecondOrderMatrix(Matrix *m);</span><br></pre></td></tr></table></figure><p>3.求二维矩阵的迹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double getSecondOrderMatrixTrace(Matrix *m);</span><br></pre></td></tr></table></figure><p>4.交换二维矩阵的两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int swapSecondOrderMatrixRow(Matrix *m, int row1,int row2);</span><br></pre></td></tr></table></figure><p>5.交换二维矩阵的两列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int swapSecondOrderMatrixColume(Matrix *m, int colume1,int colume2);</span><br></pre></td></tr></table></figure><p>6.二维矩阵的指定一行加、减、乘、除一个系数k</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int kAddSecondOrderMatrixRow(Matrix *m, int row,double k);</span><br><span class="line">int kSubSecondOrderMatrixRow(Matrix *m, int row,double k);</span><br><span class="line">int kMulSecondOrderMatrixRow(Matrix *m, int row,double k);</span><br><span class="line">int kDivSecondOrderMatrixRow(Matrix *m, int row,double k);</span><br></pre></td></tr></table></figure><p>7.二维矩阵的指定一列加、减、乘、除一个系数k</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int kAddSecondOrderMatrixColume(Matrix *m, int colume,double k);</span><br><span class="line">int kSubSecondOrderMatrixColume(Matrix *m, int colume,double k);</span><br><span class="line">int kMulSecondOrderMatrixColume(Matrix *m, int colume,double k);</span><br><span class="line">int kDivSecondOrderMatrixColume(Matrix *m, int colume,double k);</span><br></pre></td></tr></table></figure><p>8.二维矩阵的指定两行元素一一对应相加减乘除:row1 &#x3D; row1 +-*&#x2F; row2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int addSecondOrderMatrixRows(Matrix *m, int row1,int row2);</span><br><span class="line">int subSecondOrderMatrixRows(Matrix *m, int row1,int row2);</span><br><span class="line">int mulSecondOrderMatrixRows(Matrix *m, int row1,int row2);</span><br><span class="line">int divSecondOrderMatrixRows(Matrix *m, int row1,int row2);</span><br></pre></td></tr></table></figure><p>9.二维矩阵的指定两列元素一一对应相加减乘除:colume1 &#x3D; colume1 +-*&#x2F; colume2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int addSecondOrderMatrixColumes(Matrix *m, int colume1, int colume2);</span><br><span class="line">int subSecondOrderMatrixColumes(Matrix *m, int colume1, int colume2);</span><br><span class="line">int mulSecondOrderMatrixColumes(Matrix *m, int colume1, int colume2);</span><br><span class="line">int divSecondOrderMatrixColumes(Matrix *m, int colume1, int colume2);</span><br></pre></td></tr></table></figure><p>10.删除二维矩阵的指定行数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int deleteSecondOrderMatrixRows(Matrix *m,int startRow,int endRow);</span><br></pre></td></tr></table></figure><p>11.删除二维矩阵的指定列数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int deleteSecondOrderMatrixColumes(Matrix *m,int startColume,int endColume);</span><br></pre></td></tr></table></figure><p>12.删除二维矩阵的指定一行和一列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int deleteSecondOrderMatrixRowAndColume(Matrix *m,int row,int colume);</span><br></pre></td></tr></table></figure><p>13.按行拼接两个矩阵，要求两个矩阵一行的元素数目要相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int spliceSecondOrderMatrixRow(Matrix *m1,Matrix *m2);</span><br></pre></td></tr></table></figure><p>14.按列拼接两个矩阵，要求两个矩阵一列的元素数目要相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int spliceSecondOrderMatrixColume(Matrix *m1,Matrix *m2);</span><br></pre></td></tr></table></figure><p>15.二维矩阵整体加、减、乘、除一个系数k</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int kAddMatrix(Matrix *m,double k);</span><br><span class="line">int kSubMatrix(Matrix *m,double k);</span><br><span class="line">int kMulMatrix(Matrix *m,double k);</span><br><span class="line">int kDivMatrix(Matrix *m,double k);</span><br></pre></td></tr></table></figure><p>16.两个矩阵相加，得到一个新的矩阵，要求两个矩阵的shape要一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *addSecondOrderMatrixs(Matrix *m1,Matrix *m2);</span><br></pre></td></tr></table></figure><p>17.两个矩阵相减，得到一个新的矩阵，要求两个矩阵的shape要一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *subSecondOrderMatrixs(Matrix *m1,Matrix *m2);</span><br></pre></td></tr></table></figure><p>18.两个矩阵求点乘，得到一个新的矩阵，要求两个矩阵的shape要一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *dotSecondOrderMatrixs(Matrix *m1,Matrix *m2);</span><br></pre></td></tr></table></figure><p>19.两个矩阵求叉乘，m1为m X n矩阵，m2为n X p矩阵，乘积返回一个m X p矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *mulSecondOrderMatrixs(Matrix *m1,Matrix *m2);</span><br></pre></td></tr></table></figure><h4 id="矩阵的高级操作"><a href="#矩阵的高级操作" class="headerlink" title="矩阵的高级操作"></a>矩阵的高级操作</h4><p>1.求一个二维方阵的行列式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int detSquareMatrixs(Matrix *m,double *result);</span><br></pre></td></tr></table></figure><p>2.求二维方阵中指定元素的代数余子式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getSquareMatrixElemAlgebraicComplement(Matrix *m,int row,int colume,double *result);</span><br></pre></td></tr></table></figure><p>3.求二维方阵中指定一行元素的代数余子式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *getSquareMatrixRawAlgebraicComplement(Matrix *m,int row);</span><br></pre></td></tr></table></figure><p>4.求二维方阵的伴随矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *getSquareMatrixAdjointMatrix(Matrix *m);</span><br></pre></td></tr></table></figure><p>5.求解二维方阵的逆矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *invSquareMatrix(Matrix *m);</span><br></pre></td></tr></table></figure><p>6.求二维矩阵的最简阶梯阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *getEchelonMatrix(Matrix *m);</span><br></pre></td></tr></table></figure><p>7.求二维矩阵的秩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getSecondOrderMatrixRank(Matrix *m ,int *rank);</span><br></pre></td></tr></table></figure><p>8.求齐次线性方程组AX&#x3D;0的解,结果为全0矩阵或基础解系构成的矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *solveHomoLinearEquations(Matrix *A);</span><br></pre></td></tr></table></figure><p>9.求非齐次线性方程组AX&#x3D;B的解，返回NULL表示无解；一列矩阵表示唯一解；多列矩阵中，除了最后一列为特解，前面几列为基础解系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix *solveNonHomoLinearEquations(Matrix *A, Matrix *B);</span><br></pre></td></tr></table></figure><p>10.求矩阵的无穷范数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double getMatrixInfNorm(Matrix *m);</span><br></pre></td></tr></table></figure><p>11.求矩阵的L0范数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double getMatrixL0Norm(Matrix *m);</span><br></pre></td></tr></table></figure><p>12.求矩阵的L1范数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double getMatrixL1Norm(Matrix *m);</span><br></pre></td></tr></table></figure><p>13.求矩阵的L2范数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double getMatrixL2Norm(Matrix *m);</span><br></pre></td></tr></table></figure><p>14.求矩阵的L21范数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double getMatrixL21Norm(Matrix *m);</span><br></pre></td></tr></table></figure><h4 id="To-do-list"><a href="#To-do-list" class="headerlink" title="To do list"></a>To do list</h4><p>1.求特征值与特征向量<br>2.奇异值分解(SVD)<br>3.QR分解<br>4.最小二乘解<br>5.矩阵的核范数</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的void类型</title>
      <link href="/2018/09/11/C%E8%AF%AD%E8%A8%80%E7%9A%84void%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/09/11/C%E8%AF%AD%E8%A8%80%E7%9A%84void%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h3><p>void的字面意思是“无类型”，void * 则为无类型指针，void *可以指向任何类型的数据。<br>void几乎只有“注释”和限制程序的作用。<br>void a；这行语句编译时会出错，提示”illegal use of type ‘void’”。不过，即使void a的编译不会出错，它也没有任何实际意义。</p><span id="more"></span><p>void真正发挥作用在于：</p><h4 id="1-对函数返回的限定："><a href="#1-对函数返回的限定：" class="headerlink" title="1.对函数返回的限定："></a>1.对函数返回的限定：</h4><p>如果函数没有返回值，那么应声明为void类型。<br>在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理：不加返回值说明的函数返回int型。不能寄希望于编译器会做严格的类型检查，为了避免混乱，我们在编写C&#x2F;C 程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为void类<br>型。这既是程序良好可读性的需要，也是编程规范性的要求。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。 </p><h4 id="2-对函数参数的限定："><a href="#2-对函数参数的限定：" class="headerlink" title="2.对函数参数的限定："></a>2.对函数参数的限定：</h4><p>如果函数无参数,那么应声明其参数为void。<br>在C中，函数参数为void的意思是这个函数不接受任何参数。若函数不接受任何参数，一定要指明参数为void。 </p><h4 id="3-void型指针："><a href="#3-void型指针：" class="headerlink" title="3.void型指针："></a>3.void型指针：</h4><p>因为void *可以指向任何类型的数据，所以void指针一般被称为通用指针或者泛指针,或者叫做万能指针。<br>定义形式：void *p;<br>在C语言中在任何时候都可以用void类型的指针来代替其他类型的指针，void指针可以指向任何数据类型的变量。</p><h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h3><p>使用void类型指针要注意的几条规则：</p><h4 id="void-类型只有地址信息没有类型信息，所以不能计算偏移。"><a href="#void-类型只有地址信息没有类型信息，所以不能计算偏移。" class="headerlink" title="void*类型只有地址信息没有类型信息，所以不能计算偏移。"></a>void*类型只有地址信息没有类型信息，所以不能计算偏移。</h4><p>C&#x2F;C++中的指针通常来说有两个属性：<br>1.指向变量<br>2.指向对象的地址和长度<br>指针其实就是存储被指向变量的地址，并不保存其长度；<br>而且存的这个地址仅是变量的首地址，并不是该变量占据内存的所有地址空间。如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=3;</span><br><span class="line">int *p=&amp;a;</span><br></pre></td></tr></table></figure><p>目前大多数的C&#x2F;C++编译环境中，整型int数据占4个字节的空间，所以指针p存储的地址（即指向的a的地址）为4个字节空间的首地址。<br>当需要读取一个例如int型数据时，编译器根据指针的类型从指针指向的地址开始向后寻址。指针类型不同则寻址范围也不同，比如:<br>int*从指定地址向后寻找4字节作为变量的存储单元；<br>double*从指定地址向后寻找8字节作为变量的存储单元。</p><p>说到这里可能大家就会有一个问题：由于计算机内部的地址是整型数字，那么为什么不干脆用一个整型变量存储地址，还要发明指针变量呢？<br>如果我们从指针实现的角度讲，指针就是一个整型变量，它存储的是一个地址值，没有任何附加信息。目前为止貌似没有什么问题，其实不然。<br>就拿上述的代码：如果用一个整型变量b存储a的地址，即int b&#x3D;&amp;a。当对b加1时，得到的新的地址相当于对a的首地址加1，即&amp;a+1，由于int占连续的四个存储单元（默认），此时b存储的是第二块存储单元的地址，所以根据变量b存储的地址，将无法完整的读出变量a的值，导致错误。而通过指针变量，可以解决这类问题：如果对上述代码中的指针p加1的话，实际上是p+sizeof(int)，一次性增加了4个存储单元。而void*是一种特别的指针，因为它没有指向的类型，或者说不能根据这个类型判断出指向对象的长度。</p><h4 id="任何指针-包括函数指针-都可以赋值给void指针。"><a href="#任何指针-包括函数指针-都可以赋值给void指针。" class="headerlink" title="任何指针(包括函数指针)都可以赋值给void指针。"></a>任何指针(包括函数指针)都可以赋值给void指针。</h4><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *vp;</span><br><span class="line">type *p;</span><br><span class="line">vp=p;</span><br></pre></td></tr></table></figure><p>特点：<br>1.不需要类型转换<br>2.只获得变量&#x2F;对象地址而不获得大小。</p><h4 id="void指针赋值给其他类型的指针时都要进行转换。"><a href="#void指针赋值给其他类型的指针时都要进行转换。" class="headerlink" title="void指针赋值给其他类型的指针时都要进行转换。"></a>void指针赋值给其他类型的指针时都要进行转换。</h4><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *vp;</span><br><span class="line">type *p;</span><br><span class="line">p=(type *)vp;</span><br></pre></td></tr></table></figure><p>特点：<br>1.转换类型也就是获得指向变量&#x2F;对象大小</p><h4 id="void指针在强制转换成具体类型前，不能解引用。"><a href="#void指针在强制转换成具体类型前，不能解引用。" class="headerlink" title="void指针在强制转换成具体类型前，不能解引用。"></a>void指针在强制转换成具体类型前，不能解引用。</h4><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *vp;</span><br><span class="line">*vp; //这是错误的用法</span><br></pre></td></tr></table></figure><p>原因：<br>void指针只知道指向变量&#x2F;对象的起始地址，而不知道指向变量&#x2F;对象的大小(占几个字节)所以无法正确引用。 </p><h4 id="void指针不能参与指针运算，除非进行转换。"><a href="#void指针不能参与指针运算，除非进行转换。" class="headerlink" title="void指针不能参与指针运算，除非进行转换。"></a>void指针不能参与指针运算，除非进行转换。</h4><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *vp;</span><br><span class="line">type *p;</span><br><span class="line">(type *)vp++;</span><br></pre></td></tr></table></figure><p>说明：<br>(type *)vp++ 等价于 vp&#x3D;vp+sizeof(type) </p><h3 id="void指针的应用场合"><a href="#void指针的应用场合" class="headerlink" title="void指针的应用场合"></a>void指针的应用场合</h3><p>void指针有以下几种应用场合：</p><h4 id="当进行纯粹的内存操作的时候，可以使用void指针。"><a href="#当进行纯粹的内存操作的时候，可以使用void指针。" class="headerlink" title="当进行纯粹的内存操作的时候，可以使用void指针。"></a>当进行纯粹的内存操作的时候，可以使用void指针。</h4><p>典型的如内存操作函数memcpy和memset的函数原型分别为： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void * memcpy(void *dest, const void *src, size_t len); </span><br><span class="line">void * memset ( void * buffer, int c, size_t num ); </span><br></pre></td></tr></table></figure><p>这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。</p><h4 id="当传递一个指向未定类型的指针时候，可以使用void指针。"><a href="#当传递一个指向未定类型的指针时候，可以使用void指针。" class="headerlink" title="当传递一个指向未定类型的指针时候，可以使用void指针。"></a>当传递一个指向未定类型的指针时候，可以使用void指针。</h4><p>可以作为函数模板，链表等参数的通用参数。在使用时，只需要强制类型转换就可以。</p><h4 id="指向0的地址。"><a href="#指向0的地址。" class="headerlink" title="指向0的地址。"></a>指向0的地址。</h4><p>(void *)0，指向全是0的地址，相当于NULL。</p><h4 id="数据指针。"><a href="#数据指针。" class="headerlink" title="数据指针。"></a>数据指针。</h4><p>数据指针的概念：<br>在嵌入式编程当中，可能在特定的内存但愿读写内容，汇编有对应的MOV命令，而除了C&#x2F;C++以外的编程语言基本上没有直接访问内存的能力。利用数据指针可直接通过内存地址操作特定的内存。<br>例：在地址0XFF00FF00对应的内存单元中写入11：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int *p = (unsigned int *)0XFF00FF00;</span><br><span class="line">*p = 11;</span><br></pre></td></tr></table></figure><p>数据指针操作特定的内存的时候一定要谨慎，不是所有内存都可以操作，必须要对硬件比较了解后，才能进行操作（可能会出现段错误）。</p><p>以上内容整理自:<br><a href="https://www.cnblogs.com/pengyingh/articles/2407267.html">void类型及void指针</a><br><a href="https://blog.csdn.net/qq_29924041/article/details/54882135">C语言指针高级部分:void指针和数据指针</a><br><a href="https://blog.csdn.net/playboy_lei/article/details/50560786">无类型指针void*的学习与使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的模式匹配算法</title>
      <link href="/2018/09/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="求子串位置的定位函数index"><a href="#求子串位置的定位函数index" class="headerlink" title="求子串位置的定位函数index"></a>求子串位置的定位函数index</h4><p>子串的定位操作通常称作串的模式匹配，是各种串处理系统中最重要的操作之一。<br>一个最简单的匹配方法是：<br>从左到右一个个匹配，如果这个过程中有某个字符不匹配，就跳回去，将模式串向右移动一位。</p><span id="more"></span><p><img src="https://upload-images.jianshu.io/upload_images/9169686-1d45be6b1e946f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="匹配字符串"><br>初始化：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-f97df470ab1221e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化"><br>之后我们只需要比较i指针指向的字符和j指针指向的字符是否一致。如果一致就都向后移动，如果不一致，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-29b769f83b7bd17c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较字符是否一致"><br>A和E不相等，那就把i指针移回第1位（假设下标从0开始），j移动到模式串的第0位，然后又重新开始这个步骤：<img src="https://upload-images.jianshu.io/upload_images/9169686-a923c51670bbac98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="把i指针移回第1位重新开始查找"><br>算法实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int indexSubStr(MyString *S,MyString *substr,int pos)&#123;</span><br><span class="line">    int i = pos,j = 0;</span><br><span class="line">    while(i &lt; S-&gt;length &amp;&amp; j &lt; substr-&gt;length)&#123;</span><br><span class="line">        if(*(S-&gt;str + i) == *(substr-&gt;str + j))&#123;</span><br><span class="line">            i++; </span><br><span class="line">            j++; </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i = i - j + 1;</span><br><span class="line">            j = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j == substr-&gt;length)&#123;</span><br><span class="line">        return i - j;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法的匹配过程易于理解，且在某些应用场合，如文本编辑等，效率也较高。较好的情况下，此算法的时间复杂度为O(n+m)。然而在有些情况下，该算法的效率却很低。例如，当模式串为“00000001”，而主串为“00000000000000000000000000000001”时，每趟比较都在模式的最后一个字符出现不等，此时需要将指针i重新回溯到i-6的位置上，并从模式的第一个字符开始重新比较，则最坏的情况下的时间复杂度为O(n*m)。</p><h4 id="模式匹配的一种改进算法——KMP算法"><a href="#模式匹配的一种改进算法——KMP算法" class="headerlink" title="模式匹配的一种改进算法——KMP算法"></a>模式匹配的一种改进算法——KMP算法</h4><p>这种改进算法是D.E.Knuth与V.R.Pratt和J.H.Morris同时发现的，因此人们称它为KMP算法。此算法可以在O(n+m)的时间数量级上完成串的模式匹配操作。</p><p>其改进在于：每一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的部分匹配的结果，将模式串向右滑动尽可能远的一段距离后，继续进行比较。<br>如：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-e9a1c17e971fc5be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较字符发现不一致"><br>此时，移动j到一个合适的位置k继续比较：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-ac84b47e3dafc54f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移动j到一个合适的位置k"><br>如下图也是一样的情况：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-fc34332c909cc73e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较字符发现不一致"><br>此时，移动j到一个合适的位置k继续比较：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-ee43352e4fcb1d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移动j到一个合适的位置k"><br>至此我们可以大概看出一点端倪，当匹配失败时，j要移动的下一个位置k。存在着这样的性质：<strong>最前面的k个字符和j之前的最后k个字符是一样的。</strong>如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-067a8f928f53413f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最前面的k个字符和j之前的最后k个字符是一样的"></p><p>下面讨论一般情况。假设主串为“s1s2….sn”,模式串为“p1p2…pm”,从上例的分析可知，为了实现改进算法，需要解决下述问题：当匹配过程中产生“失配”（即si≠pj）时，模式串“向右滑动”可行的距离多远，换句话说，当主串中第i个字符与模式中第j个字符“失配”时，主串中第i个字符（i指针不回溯）应与模式串中哪个字符再比较？</p><p>假设此时应与模式中第k（k&lt;j）个字符继续比较，则模式中前k-1个字符的子串必须满足下列关系式，且不可能存在k’&gt;k满足下列关系式：<br>“p1 p2 … pk-1” &#x3D; “si-k+1 si-k+2 … si-1”<br>即下图蓝框圈起的上下两部分：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-3e0450485555e877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝框圈起的上下两部分"></p><p>而已经得到的部分匹配的结果是：<br>“pj-k+1 pj-k+2 … pj-1” &#x3D; “si-k+1 si-k+2 … si-1”<br>即下图蓝框圈起的上下两部分：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-0c582fbd7b60ffc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝框圈起的上下两部分"></p><p>那么可以推得下列等式：<br>“p1 p2 … pk-1” &#x3D; “pj-k+1 pj-k+2 … pj-1” 。<br>即下图表示的两边相等的部分：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-f694005ea545fcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="k两边相等的部分"></p><p>即，若模式中存在满足上式的两个子串，则当匹配过程中，主串中第i个字符与模式中第j个字符比较不等时，仅需将模式串向右滑动至模式中第k个字符和主串中第i个字符对齐，此时，模式中前k-1个字符的子串“p1 p2 … pk-1”必定与主串中第i个字符之前长度为k-1的子串“si-k+1 si-k+2 … si-1”相等，由此，匹配仅需从模式中第k个字符与主串中第i个字符比较起继续进行。</p><p><strong>因为在p的每一个位置都可能发生不匹配，也就是说我们要计算每一个位置j对应的k，所以用一个数组next来保存，next[j] &#x3D; k，表示当s[i] !&#x3D; p[j]时，j指针的下一个位置。</strong>由此可引出模式串的next函数的定义：</p><table><thead><tr><th>next[j]&#x3D;</th><th>-1</th><th>当j &#x3D; 0时</th></tr></thead><tbody><tr><td></td><td>Max{k丨0&lt;k&lt;j且“p0 p1 … pk-1” &#x3D; “pj-k pj-k+1 … pj-1”}</td><td>当此集合不空时</td></tr><tr><td></td><td>0</td><td>其他情况</td></tr></tbody></table><p>求得模式串的next函数之后，匹配可如下进行：<br>假设以指针i和j分别指示主串和模式中正待比较的字符，令i的初值为pos，j的初值为0。<br>若在匹配的过程中s[i]&#x3D;p[j]，则i，j分别增1，继续比较；<br>若s[i]≠p[j]，则i不变，而j退到next[j]的位置再比较，若相等，则指针各自增1，否则j再退到next[j]的位置再比较，以此类推；<br>若j退到值为0，则此时需将模式串继续向右滑动一个位置，即从主串的下一个字符si+1起和模式串重新开始匹配。</p><p>KMP算法实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int myStringIndexSubString(MyString *S,MyString *substr,int pos)&#123; //KMP算法</span><br><span class="line">    int i = pos,j = 0;</span><br><span class="line">    if(!S || !substr || pos &gt; S-&gt;length) return -1;</span><br><span class="line">    int *nextval = getKMPNext(substr);</span><br><span class="line">    if(!nextval) return -1;</span><br><span class="line">    while(i &lt; S-&gt;length &amp;&amp; j &lt; substr-&gt;length)&#123;</span><br><span class="line">        if(*(S-&gt;str + i) == *(substr-&gt;str + j))&#123;</span><br><span class="line">            i++; </span><br><span class="line">            j++; </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            j = *(nextval+j); //i不需要回溯，j回到指定位置</span><br><span class="line">            if(j == -1)&#123;</span><br><span class="line">                i++; //当j为-1时，要移动的是i</span><br><span class="line">                j++; //j归0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(nextval);</span><br><span class="line">    if(j == substr-&gt;length)&#123;</span><br><span class="line">        return i - j;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP的算法是在已知模式串的next函数值的基础上执行的，那么，如何求得模式串的next函数值是很重要的。<br>从上述讨论可见，此函数值仅取决于模式串本身而和相匹配的主串无关。我们可以从分析其定义出发用递推的方法求得next函数值。</p><p>先来看第一个：当j为0时，如果这时候不匹配，怎么办？<br><img src="https://upload-images.jianshu.io/upload_images/9169686-a03a271401248197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当j为0时就不匹配"><br>像上图这种情况，j已经在最左边了，不可能再移动了，这时候要应该是i指针后移。所以在代码中才会有next[0] &#x3D; -1这个初始化。如果是当j为1的时候呢？<br><img src="https://upload-images.jianshu.io/upload_images/9169686-5f88759d53e845d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当j为1的时候不匹配"><br>显然，j指针一定是后移到0位置的。因为它前面也就只有这一个位置了，next[1] &#x3D;0。</p><p>当{0&lt;k&lt;j且“p0 p1 … pk-1” &#x3D; “pj-k pj-k+1 … pj-1”}集合不空时，设next[j] &#x3D; k,这表明在模式串中存在下列关系：<br>“p0 p1 … pk-1” &#x3D; “pj-k pj-k+1 … pj-1”，其中k为满足0&lt;k&lt;j的某个值，并且不可能存在k’&gt;k满足前面的等式。<br>此时next[j+1] &#x3D;？可能有两种情况：<br>1.p[k] &#x3D; p[j],如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-7aec8d41bb336541.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p[k] = p[j]"><br>前面next[j] &#x3D; k时，已经存在“p0 p1 … pk-1” &#x3D; “pj-k pj-k+1 … pj-1”这一等式，若p[k] &#x3D; p[j]，则很容易的得出：<br>“p0 p1 … pk” &#x3D; “pj-k pj-k+1 … pj”，<br>即在此基础上两边加上相等的p[k]、 p[j]，<br>则next[j+1] &#x3D; k+1，即next[j+1]&#x3D;next[j] +1。</p><p>2.p[k] !&#x3D; p[j]，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-b34565a37d31f2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p[k] != p[j]"><br>此时“p0 p1 … pk” !&#x3D; “pj-k pj-k+1 … pj”，可以把求next函数值的问题看成是一个模式匹配的问题，整个模式串既是主串又是模式串，而当前在匹配过程中，已有“p0 p1 … pk-1” &#x3D; “pj-k pj-k+1 … pj-1”这一等式，则当p[k] !&#x3D; p[j]时应将模式串向右滑动至以模式串中的第next[k]个字符和主串中的第j个字符相比较，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-f0f0f8f002a50d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第next[k]个字符和主串中的第j个字符相比较"><br>这就是为什么代码中为k &#x3D; *(nextval+k)</p><p>当其他情况时，next[j] &#x3D;0，这表明模式串从头开始比较。</p><p>getKMPNext函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int *getKMPNext(MyString *substr)&#123;</span><br><span class="line">    int *nextval = (int *)malloc((substr-&gt;length)*sizeof(int));</span><br><span class="line">    int j=0,k=-1;</span><br><span class="line">    if(nextval)&#123;</span><br><span class="line">        *nextval = -1;</span><br><span class="line">        while(j&lt;substr-&gt;length)&#123;</span><br><span class="line">            if(k == -1 || *(substr-&gt;str+j) == *(substr-&gt;str+k))&#123;</span><br><span class="line">                if(*(substr-&gt;str+(++j)) == *(substr-&gt;str+(++k)))&#123; //两个字符相等时跳过</span><br><span class="line">                    *(nextval+j) = *(nextval+k);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    *(nextval+j) = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                k = *(nextval+k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nextval;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的getKMPNext函数中还修正了next的值。前面定义的Next表达式有一个小缺陷，看一个例子：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-5701a60ccdc91e62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="例子"><br>显然，根据Next表达式得到的next数组应该是[ -1，0，0，1 ]，所以下一步我们应该是把j移动到第1个元素：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-996a6065623b3263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="把j移动到第1个元素"><br>不难发现，这一步是完全没有意义的。因为后面的B已经不匹配了，那前面的B也一定是不匹配的，同样的情况其实还发生在第2个元素A上。<br>发生问题的原因在于P[j] &#x3D;&#x3D; P[next[j]]。<br>所以在getKMPNext函数中添加一个判断条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(*(substr-&gt;str+(++j)) == *(substr-&gt;str+(++k)))&#123; //两个字符相等时跳过</span><br></pre></td></tr></table></figure><p>修正后的next数组是[ -1，0，0，0 ]。</p><p>getKMPNext函数的时间复杂度为O(m)。通常，模式串的长度m比主串的长度n要小的多，因此，对整个匹配算法来说，所增加的这点时间是值得的。</p><p>最前面介绍的匹配算法的时间复杂度是O(n*m),但在一般情况下，其实际的执行时间近似于O(n+m),因此至今仍被采用。KMP算法仅当模式串与主串之间存在许多“部分匹配”的情况下才显得比这个算法快得多。但是KMP算法的最大特点是指示主串的指针不需要回溯，整个匹配过程中，对主串仅需从头至尾扫描一遍，这对处理从外设输入的庞大文件很有效，可以边读入边匹配，而无需回头重读。</p><p>KMP算法的实现基于之前的C封装字符串、字符串数组对象内容：<a href="https://www.jianshu.com/p/b2b808091851">C封装字符串、字符串数组对象</a></p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="testMyString-c文件："><a href="#testMyString-c文件：" class="headerlink" title="testMyString.c文件："></a>testMyString.c文件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;MyString.h&quot;</span><br><span class="line"></span><br><span class="line">int printMyString(MyString *str)&#123;</span><br><span class="line">    printf(&quot;%s, &quot;,str-&gt;str);</span><br><span class="line">    printf(&quot;length :%d\n&quot;,str-&gt;length);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int printMyStringElem(MyString **str)&#123;</span><br><span class="line">    printf(&quot;%s &quot;,(*str)-&gt;str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char words[] = &#123;&quot;without new experiences, something inside of us sleeps.&quot;&#125;;</span><br><span class="line">    MyString *str_a = NULL;</span><br><span class="line">    MyString *str_b = NULL;</span><br><span class="line">    MyString *str_c = NULL;</span><br><span class="line">    MyStringArray *str_array = NULL;</span><br><span class="line"></span><br><span class="line">    str_a = myStringAssign(&quot;hello &quot;);</span><br><span class="line">    str_c = myStringAssign(&quot;hello &quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;str_a :&quot;);</span><br><span class="line">    printMyString(str_a);</span><br><span class="line"></span><br><span class="line">    printf(&quot;is MyString empty: %d\n&quot;,isMyStringEmpty(str_a));</span><br><span class="line"></span><br><span class="line">    if(compareMyString(str_a,str_c)==0)&#123;</span><br><span class="line">        printf(&quot;str_a equals str_c\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;str_a is not equal str_c\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearMyString(str_a);</span><br><span class="line"></span><br><span class="line">    printf(&quot;is MyString empty: %d\n&quot;,isMyStringEmpty(str_a));</span><br><span class="line"></span><br><span class="line">    if(compareMyString(str_a,str_c)==0)&#123;</span><br><span class="line">        printf(&quot;str_a equals str_c\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;str_a is not equal str_c\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    destroyMyString(str_a);</span><br><span class="line">    str_a = copyMyString(str_c);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    str_b = myStringAssign(&quot;Mr Bluyee&quot;);</span><br><span class="line">    printf(&quot;str_b :&quot;);</span><br><span class="line">    printMyString(str_b);</span><br><span class="line"></span><br><span class="line">    destroyMyString(str_c);</span><br><span class="line">    str_c = concatMyString(str_a,str_b);</span><br><span class="line">    printf(&quot;str_c :&quot;);</span><br><span class="line">    printMyString(str_c);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;the MyString : Mr Bluyee index: &quot;);</span><br><span class="line">    i = myStringIndexSubString(str_c,str_b,0);</span><br><span class="line">    printf(&quot;%d\n&quot;, i);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;the char \&#x27;B\&#x27; index: %d\n&quot;, myStringIndexChar(str_c,&#x27;B&#x27;,0));</span><br><span class="line"></span><br><span class="line">    insertMyString(str_a,str_b,str_a-&gt;length);</span><br><span class="line">    printf(&quot;str_a :&quot;);</span><br><span class="line">    printMyString(str_a);</span><br><span class="line"></span><br><span class="line">    destroyMyString(str_c);</span><br><span class="line">    str_c = substrMyString(str_a,0,5);</span><br><span class="line">    printf(&quot;str_c :&quot;);</span><br><span class="line">    printMyString(str_c);</span><br><span class="line"></span><br><span class="line">    destroyMyString(str_c);</span><br><span class="line">    str_c = myStringAssign(words);</span><br><span class="line">    str_array = splitMyString(str_c,&#x27; &#x27;);</span><br><span class="line">    str_array-&gt;traverse(str_array,printMyStringElem);</span><br><span class="line"></span><br><span class="line">    destroyMyString(str_a);</span><br><span class="line">    destroyMyString(str_b);</span><br><span class="line">    destroyMyString(str_c);</span><br><span class="line">    DestroyMyStringArray(str_array);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP匹配的调用的代码段是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;the MyString : Mr Bluyee index: &quot;);</span><br><span class="line">i = myStringIndexSubString(str_c,str_b,0);</span><br><span class="line">printf(&quot;%d\n&quot;, i);</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc MyString.c MyString.h MyStringArray.c MyStringArray.h testMyString.c -o testMyString</span><br></pre></td></tr></table></figure><p>运行testMyString：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str_a :hello , length :6</span><br><span class="line">is MyString empty: 0</span><br><span class="line">str_a equals str_c</span><br><span class="line">is MyString empty: 1</span><br><span class="line">str_a is not equal str_c</span><br><span class="line">str_b :Mr Bluyee, length :9</span><br><span class="line">str_c :hello Mr Bluyee, length :15</span><br><span class="line">the MyString : Mr Bluyee index: 6</span><br><span class="line">the char &#x27;B&#x27; index: 9</span><br><span class="line">str_a :hello Mr Bluyee, length :15</span><br><span class="line">str_c :hello, length :5</span><br><span class="line">without new experiences, something inside of us sleeps.</span><br></pre></td></tr></table></figure><p>本篇文章部分内容整理自：<a href="https://www.cnblogs.com/yjiyjige/p/3263858.html">（原创）详解KMP算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装字符串、字符串数组对象</title>
      <link href="/2018/09/05/C%E5%B0%81%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/09/05/C%E5%B0%81%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>计算机上的非数值处理的对象基本上是字符串数据。字符串(String)是由零个或you’x多个字符组成的有限序列，一般记为：<br>s &#x3D; “a1a2…an” (n&gt;&#x3D;0)</p><span id="more"></span><p>其中s是串的名，引号内是字符串的值；<br>ai可以是字母、数字或其他字符；<br>串中字符数目n称为串的长度，0个字符的串称为空串，它的长度为0；<br>串中任意个连续的字符组成的子序列称为该串的子串；<br>包含子串的串相应的称为主串；<br>字符在序列中的序号称为该字符在串中的位置；<br>子串在主串中的位置则以子串的第一个字符在主串中的位置来表示；<br>称两个串相等，当且仅当两个串的长度相等，并且各个对应位置的字符都相等时才相等。</p><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象，例如在线性表中查找某个元素、求取某个元素、在某个位置上插入一个元素和删除一个元素等；而在串的基本操作中，通常以“串的整体”作为操作对象，例如在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。</p><p>字符串有3种机内表示方法：<br><strong>方法一：定长顺序存储表示</strong><br>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述之。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSTRLEN 255 //最大串长不超过255</span><br><span class="line">typedef unsigned char String[MAXSTRLEN + 1] //0号单元存放字符串的长度</span><br></pre></td></tr></table></figure><p>串的实际长度可在这预定义长度的范围内随意，超过预定义长度的串值则被舍去，称之为“截断”。<br>对串长有两种表示方法：一是如上述定义描述的那样，以下标为0的数组分量存放串的实际长度；二是在串值后面加一个不计入串长的结束标记字符，如在C语言中以“\0”表示串值的终结。此时的串长为隐含值。<br>定长顺序存储表示的缺点在于，出现字符串长度超过上界MAXSTRLEN时，一般用截尾法处理，但是这种情况不仅在求联接字符串时可能发生，在串的其他操作中，如插入、置换也可能发生。克服这个弊病惟有不限定串长的最大长度，即动态分配串值的存储空间。<br><strong>方法二：堆分配存储表示</strong><br>这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。在C语言中，存在一个称之为“堆”的自由存储区，并由C语言的动态分配函数malloc()和free()来管理。利用函数malloc为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时，为了以后处理方便，约定串长也作为存储结构的一部分。<br><strong>本章封装的字符串对象即用堆分配存储方法存储</strong><br>定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MyString&#123;</span><br><span class="line">    char *str;  </span><br><span class="line">    int length;</span><br><span class="line">&#125;MyString;</span><br></pre></td></tr></table></figure><p>这种存储结构表示时的串操作仍是基于“字符序列的复制”进行的。<br><strong>方法三：串的块链存储表示</strong><br>和线性表的链式存储结构相类似，也可以采用链表方式存储串值。由于串结构的特殊性——结构中的每个数据元素是一个字符，则用链表存储字符串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。</p><p>由于在一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。</p><p>为了便于串的操作，当以链表存储串值时，除头指针外还可以附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。</p><p>在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多，这要求我们考虑串值的存储密度。存储密度可定义为：<br>存储密度 &#x3D; 串值所占的存储位 &#x2F; 实际分配的存储位<br>显然，存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大。如果在串处理过程中需要进行内、外存交换的话，则会因为内外存交换操作过多而影响处理的总效率。</p><p>应该看到，串的字符集的大小也是一个重要因素，一般的，字符集小，则字符的机内编码就短，这也影响串值的存储方式的选区。</p><p>串值的链式存储结构对某些串操作，如联接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。</p><p><strong>本章封装的字符串数组对象即用块链存储方法存储</strong><br>定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MyStringArray_P</span><br><span class="line">&#123;</span><br><span class="line">    MyString *mystring;</span><br><span class="line">    struct MyStringArray_P *next;</span><br><span class="line">&#125;MyStringArray_P;</span><br><span class="line"></span><br><span class="line">typedef struct MyStringArray&#123;</span><br><span class="line">    MyStringArray_P *This;</span><br><span class="line">    MyStringArray_P *front;</span><br><span class="line">    MyStringArray_P *tear;</span><br><span class="line">    void (*clear)(struct MyStringArray *This);</span><br><span class="line">    int (*isEmpty)(struct MyStringArray *This);</span><br><span class="line">    int (*length)(struct MyStringArray *This);</span><br><span class="line">    int (*index)(struct MyStringArray *This, MyString *e);</span><br><span class="line">    int (*get)(struct MyStringArray *This, int index, MyString **e);</span><br><span class="line">    int (*getFront)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*getTear)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*modify)(struct MyStringArray *This, int index, MyString *e);</span><br><span class="line">    int (*insert)(struct MyStringArray *This, int index, MyString *e);</span><br><span class="line">    int (*delete)(struct MyStringArray *This, int index, MyString **e);</span><br><span class="line">    int (*tearPush)(struct MyStringArray *This, MyString *e);</span><br><span class="line">    int (*tearPop)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*frontPush)(struct MyStringArray *This, MyString *e);</span><br><span class="line">    int (*frontPop)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*traverse)(struct MyStringArray *This,int (*visit)(MyString **e));</span><br><span class="line">&#125;MyStringArray;</span><br></pre></td></tr></table></figure><p>目前实现了的字符串操作函数有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyString *myStringAssign(char *str);</span><br><span class="line">int myStringLength(MyString *S);</span><br><span class="line">int isMyStringEmpty(MyString *S);</span><br><span class="line">int clearMyString(MyString *S);</span><br><span class="line">void destroyMyString(MyString *S);</span><br><span class="line">int compareMyString(MyString *S1,MyString *S2);</span><br><span class="line">MyString *copyMyString(MyString *S);</span><br><span class="line">MyString *concatMyString(MyString *S1,MyString *S2);</span><br><span class="line">int myStringIndexChar(MyString *S,char indexElem,int pos);</span><br><span class="line">int insertMyString(MyString *S1,MyString *S2,int pos);</span><br><span class="line">MyString *substrMyString(MyString *S,int start,int end);</span><br><span class="line">MyStringArray *splitMyString(MyString *S,char splitElem);</span><br></pre></td></tr></table></figure><h4 id="MyString-c文件"><a href="#MyString-c文件" class="headerlink" title="MyString.c文件"></a>MyString.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;MyString.h&quot;</span><br><span class="line"></span><br><span class="line">MyString *myStringAssign(char *str)&#123;</span><br><span class="line">    int i,str_length = 0;</span><br><span class="line">    MyString *S = (MyString *)malloc(sizeof(MyString));</span><br><span class="line">    if(!S) return NULL;</span><br><span class="line">    while(*(str+str_length) != &#x27;\0&#x27;)&#123;</span><br><span class="line">        str_length++;</span><br><span class="line">    &#125;</span><br><span class="line">    str_length++;</span><br><span class="line">    S-&gt;str = (char *)malloc(str_length*sizeof(char));</span><br><span class="line">    if(!S-&gt;str)&#123;</span><br><span class="line">        free(S);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;length = str_length - 1; </span><br><span class="line">    for(i=0;i&lt;str_length;i++)&#123;</span><br><span class="line">        *(S-&gt;str + i) = *(str + i);</span><br><span class="line">    &#125;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int myStringLength(MyString *S)&#123;</span><br><span class="line">    return S-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int isMyStringEmpty(MyString *S)&#123;</span><br><span class="line">    if(S-&gt;length)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int clearMyString(MyString *S)&#123;</span><br><span class="line">    if(S-&gt;str)&#123;</span><br><span class="line">        free(S-&gt;str);</span><br><span class="line">        S-&gt;str = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;length = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void destroyMyString(MyString *S)&#123;</span><br><span class="line">    free(S-&gt;str);</span><br><span class="line">    S-&gt;str = NULL;</span><br><span class="line">    free(S);</span><br><span class="line">    S = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int compareMyString(MyString *S1,MyString *S2)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for(i=0;i&lt;S1-&gt;length &amp;&amp; i&lt;S2-&gt;length;i++)&#123;</span><br><span class="line">        if(*(S1-&gt;str+i) != *(S2-&gt;str+i))&#123;</span><br><span class="line">            result = *(S1-&gt;str+i) - *(S2-&gt;str+i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(result == 0)&#123;</span><br><span class="line">        result = S1-&gt;length - S2-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString *copyMyString(MyString *S)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(!S-&gt;str) return NULL;</span><br><span class="line">    MyString *temp = (MyString *)malloc(sizeof(MyString));</span><br><span class="line">    if(!temp) return NULL;</span><br><span class="line">    temp-&gt;str = (char *)malloc((S-&gt;length+1)*sizeof(char));</span><br><span class="line">    if(!temp-&gt;str)&#123;</span><br><span class="line">        free(temp);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;length = S-&gt;length; </span><br><span class="line">    for(i=0;i&lt;S-&gt;length+1;i++)&#123;</span><br><span class="line">        *(temp-&gt;str + i) = *(S-&gt;str + i);</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString *concatMyString(MyString *S1,MyString *S2)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(!S1-&gt;str || !S2-&gt;str) return NULL;</span><br><span class="line">    MyString *temp = (MyString *)malloc(sizeof(MyString));</span><br><span class="line">    if(!temp) return NULL;</span><br><span class="line">    temp-&gt;str = (char *)malloc((S1-&gt;length + S2-&gt;length + 1)*sizeof(char));</span><br><span class="line">    if(!temp-&gt;str)&#123;</span><br><span class="line">        free(temp);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;S1-&gt;length;i++)&#123;</span><br><span class="line">        *(temp-&gt;str + i) = *(S1-&gt;str + i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;S2-&gt;length+1;i++)&#123;</span><br><span class="line">        *(temp-&gt;str + S1-&gt;length + i) = *(S2-&gt;str + i);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;length = S1-&gt;length + S2-&gt;length;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int myStringIndexChar(MyString *S,char indexElem,int pos)&#123;</span><br><span class="line">    int index = -1;</span><br><span class="line">    int i;</span><br><span class="line">    if(!S) return -1;</span><br><span class="line">    for(i=pos;i&lt;S-&gt;length;i++)&#123;</span><br><span class="line">        if(*(S-&gt;str + i) == indexElem)&#123;</span><br><span class="line">            index = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int insertMyString(MyString *S1,MyString *S2,int pos)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(!S2-&gt;str) return -1;</span><br><span class="line">    if(pos &lt; 0 || pos &gt; S1-&gt;length) return -1;</span><br><span class="line">    S1-&gt;str = (char *)realloc(S1-&gt;str,(S1-&gt;length + S2-&gt;length + 1)*sizeof(char));</span><br><span class="line">    if(!S1-&gt;str) return -1;</span><br><span class="line">    for(i=S1-&gt;length;i&gt;=pos;i--)&#123;</span><br><span class="line">        *(S1-&gt;str + S2-&gt;length + i) = *(S1-&gt;str + i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;S2-&gt;length;i++)&#123;</span><br><span class="line">        *(S1-&gt;str + pos + i) = *(S2-&gt;str + i);</span><br><span class="line">    &#125;</span><br><span class="line">    S1-&gt;length += S2-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString *substrMyString(MyString *S,int start,int end)&#123;</span><br><span class="line">    int i,length;</span><br><span class="line">    if(start &lt; 0 || start &gt;= S-&gt;length || end &lt;= 0 || end &gt; S-&gt;length || end &lt;= start) return NULL;</span><br><span class="line">    MyString *temp = (MyString *)malloc(sizeof(MyString));</span><br><span class="line">    if(!temp) return NULL;</span><br><span class="line">    length = end - start;</span><br><span class="line">    temp-&gt;str = (char *)malloc((length+1)*sizeof(char));</span><br><span class="line">    if(!temp-&gt;str)&#123;</span><br><span class="line">        free(temp);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">        *(temp-&gt;str + i) = *(S-&gt;str + start + i);</span><br><span class="line">    &#125;</span><br><span class="line">    *(temp-&gt;str + length) = &#x27;\0&#x27;;</span><br><span class="line">    temp-&gt;length = length;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyStringArray *splitMyString(MyString *S,char splitElem)&#123;</span><br><span class="line">    int start = 0,end = 0,index = 0;</span><br><span class="line">    MyStringArray *strarray = NULL;</span><br><span class="line">    MyString *strtemp = NULL;</span><br><span class="line">    index = myStringIndexChar(S,splitElem,0);</span><br><span class="line">    if(index == -1) return NULL;</span><br><span class="line">    strarray = InitMyStringArray();</span><br><span class="line">    end = index;</span><br><span class="line">    if(end != start)&#123;</span><br><span class="line">        strtemp = substrMyString(S,start,end);</span><br><span class="line">        strarray-&gt;tearPush(strarray,strtemp);</span><br><span class="line">        destroyMyString(strtemp);</span><br><span class="line">        if(end == S-&gt;length)&#123;</span><br><span class="line">            return strarray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    start = index;</span><br><span class="line">    while(index &gt; 0)&#123;</span><br><span class="line">        index = myStringIndexChar(S,splitElem,index);</span><br><span class="line">        if(index != -1)&#123;</span><br><span class="line">            end = index;</span><br><span class="line">            strtemp = substrMyString(S,start,end);</span><br><span class="line">            strarray-&gt;tearPush(strarray,strtemp);</span><br><span class="line">            destroyMyString(strtemp);</span><br><span class="line">            if(end == S-&gt;length)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            start = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(end != S-&gt;length)&#123;</span><br><span class="line">        end = S-&gt;length;</span><br><span class="line">        strtemp = substrMyString(S,start,end);</span><br><span class="line">        strarray-&gt;tearPush(strarray,strtemp);</span><br><span class="line">        destroyMyString(strtemp);</span><br><span class="line">    &#125;</span><br><span class="line">    return strarray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MyString-h文件"><a href="#MyString-h文件" class="headerlink" title="MyString.h文件"></a>MyString.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _MYSTRING_H</span><br><span class="line">#define _MYSTRING_H</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">typedef struct MyString&#123;</span><br><span class="line">    char *str;  </span><br><span class="line">    int length;</span><br><span class="line">&#125;MyString;</span><br><span class="line"></span><br><span class="line">typedef struct MyStringArray_P</span><br><span class="line">&#123;</span><br><span class="line">    MyString *mystring;</span><br><span class="line">    struct MyStringArray_P *next;</span><br><span class="line">&#125;MyStringArray_P;</span><br><span class="line"></span><br><span class="line">typedef struct MyStringArray&#123;</span><br><span class="line">    MyStringArray_P *This;</span><br><span class="line">    MyStringArray_P *front;</span><br><span class="line">    MyStringArray_P *tear;</span><br><span class="line">    void (*clear)(struct MyStringArray *This);</span><br><span class="line">    int (*isEmpty)(struct MyStringArray *This);</span><br><span class="line">    int (*length)(struct MyStringArray *This);</span><br><span class="line">    int (*index)(struct MyStringArray *This, MyString *e);</span><br><span class="line">    int (*get)(struct MyStringArray *This, int index, MyString **e);</span><br><span class="line">    int (*getFront)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*getTear)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*modify)(struct MyStringArray *This, int index, MyString *e);</span><br><span class="line">    int (*insert)(struct MyStringArray *This, int index, MyString *e);</span><br><span class="line">    int (*delete)(struct MyStringArray *This, int index, MyString **e);</span><br><span class="line">    int (*tearPush)(struct MyStringArray *This, MyString *e);</span><br><span class="line">    int (*tearPop)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*frontPush)(struct MyStringArray *This, MyString *e);</span><br><span class="line">    int (*frontPop)(struct MyStringArray *This, MyString **e);</span><br><span class="line">    int (*traverse)(struct MyStringArray *This,int (*visit)(MyString **e));</span><br><span class="line">&#125;MyStringArray;</span><br><span class="line"></span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">#include &quot;MyStringArray.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyString *myStringAssign(char *str);</span><br><span class="line">int myStringLength(MyString *S);</span><br><span class="line">int isMyStringEmpty(MyString *S);</span><br><span class="line">int clearMyString(MyString *S);</span><br><span class="line">void destroyMyString(MyString *S);</span><br><span class="line">int compareMyString(MyString *S1,MyString *S2);</span><br><span class="line">MyString *copyMyString(MyString *S);</span><br><span class="line">MyString *concatMyString(MyString *S1,MyString *S2);</span><br><span class="line">int myStringIndexChar(MyString *S,char indexElem,int pos);</span><br><span class="line">int insertMyString(MyString *S1,MyString *S2,int pos);</span><br><span class="line">MyString *substrMyString(MyString *S,int start,int end);</span><br><span class="line">MyStringArray *splitMyString(MyString *S,char splitElem);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="MyStringArray-c文件"><a href="#MyStringArray-c文件" class="headerlink" title="MyStringArray.c文件"></a>MyStringArray.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;MyStringArray.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(MyStringArray *This);</span><br><span class="line">static int isEmpty(MyStringArray *This);</span><br><span class="line">static int length(MyStringArray *This);</span><br><span class="line">static int index(MyStringArray *This, MyString *e);</span><br><span class="line">static int get(MyStringArray *This, int index, MyString **e);</span><br><span class="line">static int getFront(MyStringArray *This, MyString **e);</span><br><span class="line">static int getTear(MyStringArray *This, MyString **e);</span><br><span class="line">static int modify(MyStringArray *This, int index, MyString *e);</span><br><span class="line">static int insert(MyStringArray *This, int index, MyString *e);</span><br><span class="line">static int delete(MyStringArray *This, int index, MyString **e);</span><br><span class="line">static int tearPush(MyStringArray *This, MyString *e);</span><br><span class="line">static int tearPop(MyStringArray *This, MyString **e);</span><br><span class="line">static int frontPush(MyStringArray *This, MyString *e);</span><br><span class="line">static int frontPop(MyStringArray *This, MyString **e);</span><br><span class="line">static int traverse(MyStringArray *This,int (*visit)(MyString **e));</span><br><span class="line"></span><br><span class="line">MyStringArray *InitMyStringArray()&#123;</span><br><span class="line">    MyStringArray *strArray = (MyStringArray *)malloc(sizeof(MyStringArray));</span><br><span class="line">    MyStringArray_P *p = (MyStringArray_P *)malloc(sizeof(MyStringArray_P));</span><br><span class="line">    strArray-&gt;This = p;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    strArray-&gt;front = p;</span><br><span class="line">    strArray-&gt;tear = strArray-&gt;front;</span><br><span class="line">    strArray-&gt;clear = clear;</span><br><span class="line">    strArray-&gt;isEmpty = isEmpty;</span><br><span class="line">    strArray-&gt;length = length;</span><br><span class="line">    strArray-&gt;index = index;</span><br><span class="line">    strArray-&gt;get = get;</span><br><span class="line">    strArray-&gt;getFront = getFront;</span><br><span class="line">    strArray-&gt;getTear = getTear;</span><br><span class="line">    strArray-&gt;modify = modify;</span><br><span class="line">    strArray-&gt;insert = insert;</span><br><span class="line">    strArray-&gt;delete = delete;</span><br><span class="line">    strArray-&gt;tearPush = tearPush;</span><br><span class="line">    strArray-&gt;tearPop = tearPop;</span><br><span class="line">    strArray-&gt;frontPush = frontPush;</span><br><span class="line">    strArray-&gt;frontPop = frontPop;</span><br><span class="line">    strArray-&gt;traverse = traverse;</span><br><span class="line">    return strArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyMyStringArray(MyStringArray *strArray)&#123;</span><br><span class="line">    strArray-&gt;clear(strArray);</span><br><span class="line">    free(strArray-&gt;This);</span><br><span class="line">    strArray-&gt;This = NULL;</span><br><span class="line">    free(strArray);</span><br><span class="line">    strArray = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(MyStringArray *This)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This-&gt;next;</span><br><span class="line">    MyStringArray_P *temp = NULL;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp-&gt;mystring-&gt;str);</span><br><span class="line">        temp-&gt;mystring-&gt;str = NULL;</span><br><span class="line">        free(temp);</span><br><span class="line">        temp = NULL;</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;This;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    This-&gt;front = p;</span><br><span class="line">    This-&gt;tear = This-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(MyStringArray *This)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(MyStringArray *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int index(MyStringArray *This, MyString *e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This-&gt;next;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    if(!e) return -1;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(compareMyString(p-&gt;mystring,e) == 0)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int get(MyStringArray *This, int index, MyString **e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    *e = copyMyString(p-&gt;mystring);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getFront(MyStringArray *This, MyString **e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;front-&gt;next;</span><br><span class="line">    *e = copyMyString(p-&gt;mystring);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getTear(MyStringArray *This, MyString **e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;tear;</span><br><span class="line">    *e = copyMyString(p-&gt;mystring);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int modify(MyStringArray *This, int index, MyString *e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This-&gt;next;</span><br><span class="line">    if(!e) return -1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    free(p-&gt;mystring);</span><br><span class="line">    p-&gt;mystring = copyMyString(e);</span><br><span class="line">    if(p-&gt;mystring)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int insert(MyStringArray *This, int index, MyString *e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This;</span><br><span class="line">    int j = 0;</span><br><span class="line">    if(!e) return -1;</span><br><span class="line">    MyStringArray_P *temp = (MyStringArray_P *)malloc(sizeof(MyStringArray_P));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    temp-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    temp-&gt;mystring = copyMyString(e);</span><br><span class="line">    if(!temp-&gt;mystring)&#123;</span><br><span class="line">        free(temp);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int delete(MyStringArray *This, int index, MyString **e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This;</span><br><span class="line">    MyStringArray_P *temp = NULL;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p-&gt;next &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p-&gt;next || j &gt; index) return -1;</span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    *e = copyMyString(temp-&gt;mystring);</span><br><span class="line">    free(temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int tearPush(MyStringArray *This, MyString *e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This;</span><br><span class="line">    if(!e) return -1;</span><br><span class="line">    MyStringArray_P *temp = (MyStringArray_P *)malloc(sizeof(MyStringArray_P));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    temp-&gt;mystring = copyMyString(e);</span><br><span class="line">    if(temp-&gt;mystring)&#123;</span><br><span class="line">        if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">            p-&gt;next = temp;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            This-&gt;tear-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = NULL;</span><br><span class="line">        This-&gt;tear = temp;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        free(temp);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int tearPop(MyStringArray *This, MyString **e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This;</span><br><span class="line">    MyStringArray_P *temp = NULL;</span><br><span class="line">    while(p-&gt;next-&gt;next)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    This-&gt;tear = p;</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    *e = copyMyString(temp-&gt;mystring);</span><br><span class="line">    free(temp);</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int frontPush(MyStringArray *This, MyString *e)&#123;</span><br><span class="line">    MyStringArray_P *p = This-&gt;This;</span><br><span class="line">    if(!e) return -1;</span><br><span class="line">    MyStringArray_P *temp = (MyStringArray_P *)malloc(sizeof(MyStringArray_P));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    temp-&gt;mystring = copyMyString(e);</span><br><span class="line">    if(temp-&gt;mystring)&#123;</span><br><span class="line">        temp-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp;</span><br><span class="line">        if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">            This-&gt;tear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        free(temp);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int frontPop(MyStringArray *This, MyString **e)&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        e = NULL;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    MyStringArray_P *p = This-&gt;front-&gt;next;</span><br><span class="line">    *e = copyMyString(p-&gt;mystring);</span><br><span class="line">    This-&gt;front-&gt;next = p-&gt;next; </span><br><span class="line">    if(This-&gt;tear == p) This-&gt;tear = This-&gt;front;</span><br><span class="line">    free(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int traverse(MyStringArray *This,int (*visit)(MyString **e))&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    MyStringArray_P *temp = This-&gt;front-&gt;next;</span><br><span class="line">    while(temp)&#123;</span><br><span class="line">        if(visit(&amp;(temp-&gt;mystring)) != 0) break;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MyStringArray-h文件"><a href="#MyStringArray-h文件" class="headerlink" title="MyStringArray.h文件"></a>MyStringArray.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _MYSTRINGARRAY_H</span><br><span class="line">#define _MYSTRINGARRAY_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">#include &quot;MyString.h&quot;</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">MyStringArray *InitMyStringArray();</span><br><span class="line">void DestroyMyStringArray(MyStringArray *strArray);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testMyStringArray-c文件"><a href="#testMyStringArray-c文件" class="headerlink" title="testMyStringArray.c文件"></a>testMyStringArray.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;MyStringArray.h&quot;</span><br><span class="line"></span><br><span class="line">char name[][14] = &#123;&quot;without &quot;,&quot;new &quot;,&quot;experiences, &quot;,&quot;something &quot;,&quot;inside &quot;,&quot;of &quot;,&quot;us &quot;,&quot;sleeps.&quot;&#125;;</span><br><span class="line"></span><br><span class="line">int printMyString(MyString **str)&#123;</span><br><span class="line">    printf(&quot;%s&quot;,(*str)-&gt;str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    MyStringArray *strarray = InitMyStringArray();</span><br><span class="line">    MyString *string = NULL;</span><br><span class="line">    printf(&quot;MyStringArray is empty:%d\n&quot;,strarray-&gt;isEmpty(strarray));</span><br><span class="line">    for(i=0;i&lt;8;i++)&#123;</span><br><span class="line">        string = myStringAssign(name[i]);</span><br><span class="line">        strarray-&gt;frontPush(strarray,string);</span><br><span class="line">        destroyMyString(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;MyStringArray: &quot;);</span><br><span class="line">    strarray-&gt;traverse(strarray,printMyString);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;MyStringArray is empty:%d\n&quot;,strarray-&gt;isEmpty(strarray));</span><br><span class="line">    printf(&quot;MyStringArray length:%d\n&quot;,strarray-&gt;length(strarray));</span><br><span class="line"></span><br><span class="line">    strarray-&gt;clear(strarray);</span><br><span class="line">    printf(&quot;MyStringArray is empty:%d\n&quot;,strarray-&gt;isEmpty(strarray));</span><br><span class="line">    printf(&quot;MyStringArray length:%d\n&quot;,strarray-&gt;length(strarray));</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;8;i++)&#123;</span><br><span class="line">        string = myStringAssign(name[i]);</span><br><span class="line">        strarray-&gt;tearPush(strarray,string);</span><br><span class="line">        destroyMyString(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;MyStringArray: &quot;);</span><br><span class="line">    strarray-&gt;traverse(strarray,printMyString);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    strarray-&gt;get(strarray,3,&amp;string);</span><br><span class="line">    printf(&quot;the MyString of index 3 is: &quot;);</span><br><span class="line">    printMyString(&amp;string);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    destroyMyString(string);</span><br><span class="line"></span><br><span class="line">    strarray-&gt;getTear(strarray,&amp;string);</span><br><span class="line">    printf(&quot;the tear MyString is: &quot;);</span><br><span class="line">    printMyString(&amp;string);</span><br><span class="line">    printf(&quot; ,index is: %d\n&quot;,strarray-&gt;index(strarray,string));</span><br><span class="line">    destroyMyString(string);</span><br><span class="line"></span><br><span class="line">    strarray-&gt;getFront(strarray,&amp;string);</span><br><span class="line">    printf(&quot;the front MyString is: &quot;);</span><br><span class="line">    printMyString(&amp;string);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    destroyMyString(string);</span><br><span class="line"></span><br><span class="line">    string = myStringAssign(&quot;me &quot;);</span><br><span class="line">    strarray-&gt;modify(strarray,6,string);</span><br><span class="line">    destroyMyString(string);</span><br><span class="line">    printf(&quot;MyStringArray: &quot;);</span><br><span class="line">    strarray-&gt;traverse(strarray,printMyString);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    string = myStringAssign(&quot;you and &quot;);</span><br><span class="line">    strarray-&gt;insert(strarray,6,string);</span><br><span class="line">    destroyMyString(string);</span><br><span class="line">    printf(&quot;MyStringArray: &quot;);</span><br><span class="line">    strarray-&gt;traverse(strarray,printMyString);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    strarray-&gt;delete(strarray,6,&amp;string);</span><br><span class="line">    printf(&quot;MyStringArray: &quot;);</span><br><span class="line">    strarray-&gt;traverse(strarray,printMyString);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printMyString(&amp;string);</span><br><span class="line">    printf(&quot; deleted!\n&quot;);</span><br><span class="line">    destroyMyString(string);</span><br><span class="line"></span><br><span class="line">    strarray-&gt;tearPop(strarray,&amp;string);</span><br><span class="line">    printf(&quot;MyStringArray: &quot;);</span><br><span class="line">    strarray-&gt;traverse(strarray,printMyString);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printMyString(&amp;string);</span><br><span class="line">    printf(&quot; tear poped!\n&quot;);</span><br><span class="line">    destroyMyString(string);    </span><br><span class="line"></span><br><span class="line">    strarray-&gt;frontPop(strarray,&amp;string);</span><br><span class="line">    printf(&quot;MyStringArray: &quot;);</span><br><span class="line">    strarray-&gt;traverse(strarray,printMyString);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printMyString(&amp;string);</span><br><span class="line">    printf(&quot; front poped!\n&quot;);</span><br><span class="line">    destroyMyString(string);    </span><br><span class="line"></span><br><span class="line">    DestroyMyStringArray(strarray);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译testMyStringArray-c文件："><a href="#编译testMyStringArray-c文件：" class="headerlink" title="编译testMyStringArray.c文件："></a>编译testMyStringArray.c文件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc MyString.c MyString.h MyStringArray.c MyStringArray.h testMyStringArray.c -o testMyStringArray</span><br></pre></td></tr></table></figure><p>执行testMyStringArray：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MyStringArray is empty:1</span><br><span class="line">MyStringArray: sleeps.us of inside something experiences, new without</span><br><span class="line">MyStringArray is empty:0</span><br><span class="line">MyStringArray length:8</span><br><span class="line">MyStringArray is empty:1</span><br><span class="line">MyStringArray length:0</span><br><span class="line">MyStringArray: without new experiences, something inside of us sleeps.</span><br><span class="line">the MyString of index 3 is: something</span><br><span class="line">the tear MyString is: sleeps. ,index is: 7</span><br><span class="line">the front MyString is: without</span><br><span class="line">MyStringArray: without new experiences, something inside of me sleeps.</span><br><span class="line">MyStringArray: without new experiences, something inside of you and me sleeps.</span><br><span class="line">MyStringArray: without new experiences, something inside of me sleeps.</span><br><span class="line">you and  deleted!</span><br><span class="line">MyStringArray: without new experiences, something inside of me</span><br><span class="line">sleeps. tear poped!</span><br><span class="line">MyStringArray: new experiences, something inside of me</span><br><span class="line">without  front poped!</span><br></pre></td></tr></table></figure><h4 id="编译testMyString-c文件："><a href="#编译testMyString-c文件：" class="headerlink" title="编译testMyString.c文件："></a>编译testMyString.c文件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc MyString.c MyString.h MyStringArray.c MyStringArray.h testMyString.c -o testMyString</span><br></pre></td></tr></table></figure><p>执行testMyString：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str_a :hello , length :6</span><br><span class="line">is MyString empty: 0</span><br><span class="line">str_a equals str_c</span><br><span class="line">is MyString empty: 1</span><br><span class="line">str_a is not equal str_c</span><br><span class="line">str_b :Mr Bluyee, length :9</span><br><span class="line">str_c :hello Mr Bluyee, length :15</span><br><span class="line">the char &#x27;B&#x27; index: 9</span><br><span class="line">str_a :hello Mr Bluyee, length :15</span><br><span class="line">str_c :hello, length :5</span><br><span class="line">without new experiences, something inside of us sleeps.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的malloc</title>
      <link href="/2018/09/05/C%E8%AF%AD%E8%A8%80%E7%9A%84malloc/"/>
      <url>/2018/09/05/C%E8%AF%AD%E8%A8%80%E7%9A%84malloc/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么C语言要有malloc"><a href="#为什么C语言要有malloc" class="headerlink" title="为什么C语言要有malloc"></a>为什么C语言要有malloc</h4><p>malloc就是memory allocate动态分配内存,malloc的出现时为了弥补静态内存分配的缺点，静态分配内存有如下缺点：</p><span id="more"></span><p>1、比如说，传统的一维数组，如int a[5]，使用传统的一维数组需要事先指定数组的长度，而且数组的长度必须是一个常量（宏定义的 常量）</p><p>2、传统数组(静态分配),不能手动释放，只能等待系统释放，静态分配的变量在该函数内运行的时候有效，当静态分配的变量所在函数运行完之后，该内存会自动释放。静态分配的内存，是在栈中分配的，其实在C语言中的函数调用也是通过栈来实现的，栈这种数据结构的一个特点就是（先进后出），所以，在调用函数的时候，都是先压入栈中，然后，再从最上面的函数开始执行，最后，执行到main函数结束。动态分配通过malloc分配，是在堆中分配的，堆不是一种数据结构，它是一种排序方式，堆排序。</p><p>3、传统数组的长度一旦定义之后，就不能更改，比如说，如果我有一个业务在这之前给分配的大小为100，但是，我现在由于业务数量的增长，原来的大小就无法满足。</p><p>4、静态分配不能跨函数调用，就是无法在另一个函数中，来管理一个函数中的内存。静态分配，只在当前函数有效，当，静态分配所在的函数运行完之后，该变量就不能被其他的函数所调用。</p><h4 id="malloc是什么"><a href="#malloc是什么" class="headerlink" title="malloc是什么"></a>malloc是什么</h4><p>malloc其实就是一个可以动态分配内存的函数，从而可以很好的弥补上面静态分配的缺点。</p><h4 id="malloc怎么用"><a href="#malloc怎么用" class="headerlink" title="malloc怎么用"></a>malloc怎么用</h4><p>1、使用malloc函数的时候，需要包含一个头文件#include &lt;malloc.h&gt;</p><p>2、malloc函数只接受一个形参如，int *p &#x3D; (int *)malloc(sizeof(int)).先来解释下这句话的含义,int* p代表一个以int类型地址为内容的指针变量,p这个变量占4个字节（某些计算机）,这个p变量是静态分配的一个变量。</p><p>在某些计算机的前提下，指针变量所占的大小都是一样的，无论是char * 还是long *，因为，这些指针变量里面存放的是一个8位16进制的地址，所以占四个字节，当然这些都是在某些计算机的前提下，并不是所有的都是这样的。</p><p>说道地址的话，就和计算机的地址总线有关，如果计算机的地址总线是32根，每根地址总线只有两种状态(1或0)，32根地址线的话，如果全为1的话，刚好就是一个8位十六进制，一位十六进制等于四个二进制(2^4&#x3D;16)。32根地址总线可以 表示2^10*2^10*2^10*2^2种状态,可以表示的最大内存为4G,也就是说32根地址总线（也就是四个字节 的指针变量）最大可以表示4G内存。</p><p>malloc函数会返回开辟空间的首地址，加(int *)的目的是让计算机知道，如何去划分这个开辟的空间，因为char、int 、long这些类型的字节大小是不一样的,我们知道了首地址，还要知道是以几个字节为单元。所以，这句话一共开辟了8个字节(某些计算机上)，这也是为什么我写sizeof(int)，而不是直接写4的原因。</p><p>3、malloc开辟空间所返回的首地址是动态分配的。</p><h4 id="malloc使用需要注意的地方"><a href="#malloc使用需要注意的地方" class="headerlink" title="malloc使用需要注意的地方"></a>malloc使用需要注意的地方</h4><p>1、申请了内存空间后，必须检查是否分配成功。</p><p>2、当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。</p><p>3、这两个函数应该是配对。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。</p><p>4、虽然malloc()函数的类型是(void *),任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。</p><h4 id="malloc从哪里得来了内存空间"><a href="#malloc从哪里得来了内存空间" class="headerlink" title="malloc从哪里得来了内存空间"></a>malloc从哪里得来了内存空间</h4><p>1、malloc()到底从哪里得到了内存空间？答案是从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p><p>2、什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</p><p>什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS&#x2F;ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p><p>通过上面对概念的描述，可以知道：</p><p>栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以我想再强调一次，记得要释放！<br>举个例子，如果你在函数上面定义了一个指针变量，然后在这个函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了！这绝对是错误的！因为申请的内存在堆上，而函数所在的栈被销毁跟堆完全没有啥关系。</p><h4 id="free-到底释放了什么"><a href="#free-到底释放了什么" class="headerlink" title="free()到底释放了什么"></a>free()到底释放了什么</h4><p>free()释放的是指针指向的内存，不是指针。指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在。<br><strong>野指针(wild pointer)：</strong><br>野指针指的是还没有初始化的指针。严格地说，编程语言中每个指针在初始化前都是野指针。一般于未初始化时便使用指针就会产生问题。大多数的编译器都能检测到这一问题并警告用户。<br><strong>悬空指针(dangling pointer)：</strong><br>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称悬空指针。若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的悬空指针，则将产生无法预料的后果。因为此时悬空指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往悬空指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。这种类型的程序错误，不容易找到问题的原因，通常会导致段错误(Linux系统中)和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。</p><p>无论是野指针还是悬空指针，都是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针。 访问”不安全可控”(invalid)的内存区域将导致”Undefined Behavior”。也就是说：任何可能都会发生。要么编译失败，要么执行得不正确(崩溃(e.g. segmentation fault)或者悄无声息地产生不正确的执行结果)，或者偶尔会正确地产生程序员希望运行的结果。</p><h4 id="如何避免使用野指针和悬空指针"><a href="#如何避免使用野指针和悬空指针" class="headerlink" title="如何避免使用野指针和悬空指针"></a>如何避免使用野指针和悬空指针</h4><p>对于野指针：养成在定义指针后且在使用之前完成初始化的习惯就好。<br>对于悬空指针：一个避免这个错误的方法是在释放它的引用后将该指针的值重置为NULL。</p><h4 id="在子函数中调用malloc申请内存的方法"><a href="#在子函数中调用malloc申请内存的方法" class="headerlink" title="在子函数中调用malloc申请内存的方法"></a>在子函数中调用malloc申请内存的方法</h4><p>方法一：函数返回<br>将malloc得到的内存首地址通过函数的返回值返回到主函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char* test()</span><br><span class="line">&#123;</span><br><span class="line">    char *p;</span><br><span class="line">    p = (char*)malloc(10 * sizeof(char));</span><br><span class="line">    strcpy(p, &quot;123456789&quot; );</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str = NULL ;</span><br><span class="line">    str = test();</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line">    free(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：二级指针<br>将malloc得到的内存首地址通过二级指针返回到主函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void test(char **p)</span><br><span class="line">&#123;</span><br><span class="line">    *p = (char*)malloc(10 * sizeof(char));</span><br><span class="line">    strcpy(*p, &quot;123456789&quot; );   </span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str = NULL ;</span><br><span class="line">    test(&amp;str);</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line">    free(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见误区：<br>错误一：使用一级指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void test(char *p) </span><br><span class="line">&#123;</span><br><span class="line">    p = (char*)malloc(10 * sizeof(char));</span><br><span class="line">    strcpy(*p, &quot;123456789&quot; );   </span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str = NULL ;</span><br><span class="line">    test(str);</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line">    free(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去合情合理，把malloc得的地址赋给指针p，这样我们传入的str就指向申请的内存了。但事实是，str的值并没有变化。我们可以先看下方的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void test(char c)</span><br><span class="line">&#123;</span><br><span class="line">    c = &#x27;B&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    char ch = &#x27;A&#x27; ;</span><br><span class="line">    test(ch);</span><br><span class="line">    printf(&quot;%c\n&quot;, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用test()后，主函数里面的ch值还是’A’,而不是’B’。这是因为在调用函数的时候，char c 事实上是被复制进函数内部的，函数内的操作不会影响到原值。 指针也是一样的道理。传入一个一级指针，只能修改它指向的数据，而不能修改它指向的地址。所以我们应该传入一个二级指针，这个指针指向一级指针。这样我们就能修改位于二级指针指向的数据，即一级指针指向的地址了。<br>错误二：二级指针未指向存在的一级指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void test(char **p)</span><br><span class="line">&#123;</span><br><span class="line">    *p = (char*)malloc(10 * sizeof(char));</span><br><span class="line">    strcpy(*p, &quot;123456789&quot; );   </span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    char **str = NULL ; //原代码：char *str = NULL;</span><br><span class="line">    test(str);          //       test(&amp;str);</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line">    free(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么我使用了二级指针，仍然是错误的呢？对比下正确的代码，就一目了然了。正确代码中，通过对一级指针str进行取址，得到指向str的二级指针，在子函数中就可以操作str的值了。而错误代码中，二级指针的值为NULL，这样的话，子函数中操作的是地址为NULL的内存，这当然是不对的。</p><p>以上内容整理于：<br><a href="https://blog.csdn.net/sinat_29957455/article/details/60883355">C语言指针之二malloc的用法及详解</a><br><a href="https://www.cnblogs.com/shiweihappy/p/4246372.html">C语言中 malloc函数用法</a><br><a href="https://blog.csdn.net/HuffieWang/article/details/51744043">C语言在子函数中调用malloc申请内存的方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装单链循环队列对象</title>
      <link href="/2018/09/03/C%E5%B0%81%E8%A3%85%E5%8D%95%E9%93%BE%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/09/03/C%E5%B0%81%E8%A3%85%E5%8D%95%E9%93%BE%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="SingleCircularLinkedListQueue单链循环队列"><a href="#SingleCircularLinkedListQueue单链循环队列" class="headerlink" title="SingleCircularLinkedListQueue单链循环队列"></a>SingleCircularLinkedListQueue单链循环队列</h4><p>单链循环队列用单向循环链表实现。<br><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><span id="more"></span><h4 id="SingleCircularLinkedListQueue-c文件"><a href="#SingleCircularLinkedListQueue-c文件" class="headerlink" title="SingleCircularLinkedListQueue.c文件"></a>SingleCircularLinkedListQueue.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleCircularLinkedListQueue.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(SingleCircularLinkedListQueue *This);</span><br><span class="line">static int isEmpty(SingleCircularLinkedListQueue *This);</span><br><span class="line">static int length(SingleCircularLinkedListQueue *This);</span><br><span class="line">static QNode *getHead(SingleCircularLinkedListQueue *This);</span><br><span class="line">static int enQueue(SingleCircularLinkedListQueue *This,QNode *n);</span><br><span class="line">static int deQueue(SingleCircularLinkedListQueue *This,QNode *n);</span><br><span class="line">static int traverse(SingleCircularLinkedListQueue *This,int (*visit)(QNode *n),int circular);</span><br><span class="line"></span><br><span class="line">SingleCircularLinkedListQueue *InitSingleCircularLinkedListQueue()&#123;</span><br><span class="line">    SingleCircularLinkedListQueue *Q = (SingleCircularLinkedListQueue *)malloc(sizeof(SingleCircularLinkedListQueue));</span><br><span class="line">    QNode *p = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">    Q-&gt;This = p;</span><br><span class="line">    Q-&gt;front = p;</span><br><span class="line">    Q-&gt;tear = Q-&gt;front;</span><br><span class="line">    p-&gt;next = p;</span><br><span class="line">    Q-&gt;clear = clear;</span><br><span class="line">    Q-&gt;isEmpty = isEmpty;</span><br><span class="line">    Q-&gt;length = length;</span><br><span class="line">    Q-&gt;getHead = getHead;</span><br><span class="line">    Q-&gt;enQueue = enQueue;</span><br><span class="line">    Q-&gt;deQueue = deQueue;</span><br><span class="line">    Q-&gt;traverse = traverse;</span><br><span class="line">    return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroySingleCircularLinkedListQueue(SingleCircularLinkedListQueue *Q)&#123;</span><br><span class="line">    Q-&gt;clear(Q);</span><br><span class="line">    free(Q-&gt;This);</span><br><span class="line">    free(Q);</span><br><span class="line">    Q = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(SingleCircularLinkedListQueue *This)&#123;</span><br><span class="line">    QNode *head = This-&gt;This;</span><br><span class="line">    QNode *p = This-&gt;This-&gt;next;</span><br><span class="line">    QNode *temp = NULL;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;This;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    This-&gt;front = p;</span><br><span class="line">    This-&gt;tear = This-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(SingleCircularLinkedListQueue *This)&#123;</span><br><span class="line">    QNode *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next == p)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(SingleCircularLinkedListQueue *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    QNode *head = This-&gt;This;</span><br><span class="line">    QNode *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static QNode *getHead(SingleCircularLinkedListQueue *This)&#123;</span><br><span class="line">    return This-&gt;front-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int enQueue(SingleCircularLinkedListQueue *This,QNode *n)&#123;</span><br><span class="line">    QNode *head = This-&gt;This;</span><br><span class="line">    if(!n) return -1;</span><br><span class="line">    This-&gt;tear-&gt;next = n;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">    This-&gt;tear = n;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deQueue(SingleCircularLinkedListQueue *This,QNode *n)&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        n = NULL;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    QNode *temp = This-&gt;front-&gt;next;</span><br><span class="line">    *n = *(temp);</span><br><span class="line">    This-&gt;front-&gt;next = temp-&gt;next; </span><br><span class="line">    if(This-&gt;tear == temp) This-&gt;tear = This-&gt;front;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int traverse(SingleCircularLinkedListQueue *This,int (*visit)(QNode *n),int circular)&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    QNode *head = This-&gt;front;</span><br><span class="line">    QNode *temp = This-&gt;front-&gt;next;</span><br><span class="line">    if(circular)&#123;</span><br><span class="line">        while(temp)&#123;</span><br><span class="line">            if(temp != head)&#123;</span><br><span class="line">                if(visit(temp) != 0) break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        while(temp != head)&#123;</span><br><span class="line">            if(visit(temp) != 0) break;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SingleCircularLinkedListQueue-h文件"><a href="#SingleCircularLinkedListQueue-h文件" class="headerlink" title="SingleCircularLinkedListQueue.h文件"></a>SingleCircularLinkedListQueue.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _SINGLECIRCULARLINKEDLISTQUEUE_H</span><br><span class="line">#define _SINGLECIRCULARLINKEDLISTQUEUE_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef struct QElemType&#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">&#125;QElemType;     </span><br><span class="line"></span><br><span class="line">typedef struct QNode&#123;</span><br><span class="line">    QElemType elem;  //存储空间</span><br><span class="line">    struct QNode *next;</span><br><span class="line">&#125;QNode,*Queueptr;</span><br><span class="line"></span><br><span class="line">typedef struct SingleCircularLinkedListQueue&#123;</span><br><span class="line">    QNode *This;</span><br><span class="line">    Queueptr front; //队头</span><br><span class="line">    Queueptr tear; //队尾</span><br><span class="line">    void (*clear)(struct SingleCircularLinkedListQueue *This);</span><br><span class="line">    int (*isEmpty)(struct SingleCircularLinkedListQueue *This);</span><br><span class="line">    int (*length)(struct SingleCircularLinkedListQueue *This);</span><br><span class="line">    QNode *(*getHead)(struct SingleCircularLinkedListQueue *This);</span><br><span class="line">    int (*enQueue)(struct SingleCircularLinkedListQueue *This,QNode *n);</span><br><span class="line">    int (*deQueue)(struct SingleCircularLinkedListQueue *This,QNode *n);</span><br><span class="line">    int (*traverse)(struct SingleCircularLinkedListQueue *This,int (*visit)(QNode *n),int circular);</span><br><span class="line">&#125;SingleCircularLinkedListQueue;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">SingleCircularLinkedListQueue *InitSingleCircularLinkedListQueue();</span><br><span class="line">void DestroySingleCircularLinkedListQueue(SingleCircularLinkedListQueue *Q);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testSingleCircularLinkedListQueue-c文件"><a href="#testSingleCircularLinkedListQueue-c文件" class="headerlink" title="testSingleCircularLinkedListQueue.c文件"></a>testSingleCircularLinkedListQueue.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleCircularLinkedListQueue.h&quot;</span><br><span class="line"></span><br><span class="line">char name[][3] = &#123;&quot;xw&quot;,&quot;xh&quot;,&quot;xm&quot;,&quot;xg&quot;,&quot;xl&quot;,&quot;xz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">void strCopy(char *str_a,char *str_b)&#123;</span><br><span class="line">    while(*str_b != &#x27;\0&#x27;)&#123;</span><br><span class="line">        *str_a++ = *str_b++;</span><br><span class="line">    &#125;</span><br><span class="line">    *str_a = &#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int printQnode(QNode *node)&#123;</span><br><span class="line">    printf(&quot;id:%d,name:%s\n&quot;,node-&gt;elem.id,node-&gt;elem.name);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    QNode *node = NULL;</span><br><span class="line">    SingleCircularLinkedListQueue *queue = InitSingleCircularLinkedListQueue();</span><br><span class="line">    printf(&quot;queue is empty:%d\n&quot;,queue-&gt;isEmpty(queue));</span><br><span class="line">    for(i=0;i&lt;6;i++)&#123;</span><br><span class="line">        node = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">        node-&gt;elem.id = i;</span><br><span class="line">        strCopy(node-&gt;elem.name,name[i]);</span><br><span class="line">        queue-&gt;enQueue(queue,node);</span><br><span class="line">    &#125;</span><br><span class="line">    queue-&gt;traverse(queue,printQnode,0);</span><br><span class="line">    printf(&quot;queue is empty:%d\n&quot;,queue-&gt;isEmpty(queue));</span><br><span class="line">    printf(&quot;queue length:%d\n&quot;,queue-&gt;length(queue));</span><br><span class="line">    while(queue-&gt;length(queue))&#123;</span><br><span class="line">        node = queue-&gt;getHead(queue);</span><br><span class="line">        printf(&quot;present client: id=%d, name=%s\n&quot;,node-&gt;elem.id,node-&gt;elem.name);</span><br><span class="line">        node = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">        queue-&gt;deQueue(queue,node);</span><br><span class="line">        printf(&quot;client :id=%d,name=%s finish!\n&quot;,node-&gt;elem.id,node-&gt;elem.name);</span><br><span class="line">        free(node);</span><br><span class="line">        node = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    queue-&gt;clear(queue);</span><br><span class="line">    for (i = 10; i &lt; 16; i++)&#123;</span><br><span class="line">        node = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">        node-&gt;elem.id = i;</span><br><span class="line">        strCopy(node-&gt;elem.name,name[i-10]);</span><br><span class="line">        queue-&gt;enQueue(queue,node);</span><br><span class="line">    &#125;   </span><br><span class="line">    queue-&gt;traverse(queue,printQnode,1);</span><br><span class="line">    DestroySingleCircularLinkedListQueue(queue);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc SingleCircularLinkedListQueue.c SingleCircularLinkedListQueue.h testSingleCircularLinkedListQueue.c -o testSingleCircularLinkedListQueue</span><br></pre></td></tr></table></figure><p>运行testSingleCircularLinkedListQueue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">queue is empty:0</span><br><span class="line">id:0,name:xw</span><br><span class="line">id:1,name:xh</span><br><span class="line">id:2,name:xm</span><br><span class="line">id:3,name:xg</span><br><span class="line">id:4,name:xl</span><br><span class="line">id:5,name:xz</span><br><span class="line">queue is empty:1</span><br><span class="line">queue length:6</span><br><span class="line">present client: id=0, name=xw</span><br><span class="line">client :id=0,name=xw finish!</span><br><span class="line">present client: id=1, name=xh</span><br><span class="line">client :id=1,name=xh finish!</span><br><span class="line">present client: id=2, name=xm</span><br><span class="line">client :id=2,name=xm finish!</span><br><span class="line">present client: id=3, name=xg</span><br><span class="line">client :id=3,name=xg finish!</span><br><span class="line">present client: id=4, name=xl</span><br><span class="line">client :id=4,name=xl finish!</span><br><span class="line">present client: id=5, name=xz</span><br><span class="line">client :id=5,name=xz finish!</span><br><span class="line">id:10,name:xw</span><br><span class="line">id:11,name:xh</span><br><span class="line">id:12,name:xm</span><br><span class="line">id:13,name:xg</span><br><span class="line">id:14,name:xl</span><br><span class="line">id:15,name:xz</span><br><span class="line">id:10,name:xw</span><br><span class="line">id:11,name:xh</span><br><span class="line">id:12,name:xm</span><br><span class="line">id:13,name:xg</span><br><span class="line">id:14,name:xl</span><br><span class="line">id:15,name:xz</span><br><span class="line">id:10,name:xw</span><br><span class="line">id:11,name:xh</span><br><span class="line">id:12,name:xm</span><br><span class="line">id:13,name:xg</span><br><span class="line">id:14,name:xl</span><br><span class="line">id:15,name:xz</span><br><span class="line">id:10,name:xw</span><br><span class="line">id:11,name:xh</span><br><span class="line">id:12,name:xm</span><br><span class="line">id:13,name:xg</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>queue-&gt;traverse(queue,printQnode,0);<br>int circular &#x3D; 0 表示队列只从头到尾遍历Qnode一遍；<br>int circular &#x3D; 1 表示队列循环遍历Qnode，所以上面程序运行最后进入循环，不断遍历Qnode。<br>在实现的visit函数中，返回值如果不为0则退出遍历。<br>上述代码实现的visit函数为printQnode，返回值为0；</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用单链表表示的链队列</title>
      <link href="/2018/09/03/%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E9%93%BE%E9%98%9F%E5%88%97/"/>
      <url>/2018/09/03/%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E9%93%BE%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>和栈相反，队列（Queue）是一种先进先出（First In First Out，缩写为FIFO）的线性表。</p><span id="more"></span><p>它只允许在表的一端进行插入，而在另一端删除元素。这和我们日常生活中的排队是一致的，最早进入队列的元素最早离开。队列在程序设计中也经常出现。一个最典型的例子就是操作系统中的作业排队。在允许多道程序运行的计算机系统中，同时有几个作业运行。如果运行的结果都需要通过通道输出，那就要按请求输出的先后次序排队。每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出输出操作。凡是申请输出的作业都从队尾进入队列。</p><p>在队列中，允许插入的一端叫队尾（rear），允许删除的一端则称为队头（front）。</p><p>除了栈和队列之外，还有一种限定性数据结构是<strong>双端队列（Deque）</strong>。<br>双端队列是限定插入和删除操作在表的两端进行的线性表。<br>在实际使用中，还可以有输出受限的双端队列（即一个端点允许插入和删除，另一个端点只允许插入的双端队列）和输入受限的双端队列（即一个端点允许插入和删除，另一个端点只允许删除的双端队列）。<br>而如果限定双端队列从某个端点插入的元素只能从该端点删除，则双端队列就蜕变为两个栈底相邻的栈了。</p><p>尽管双端队列看起来似乎比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="SingleLinkedListQueue-c文件"><a href="#SingleLinkedListQueue-c文件" class="headerlink" title="SingleLinkedListQueue.c文件"></a>SingleLinkedListQueue.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleLinkedListQueue.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(SingleLinkedListQueue *This);</span><br><span class="line">static int isEmpty(SingleLinkedListQueue *This);</span><br><span class="line">static int length(SingleLinkedListQueue *This);</span><br><span class="line">static QNode *getHead(SingleLinkedListQueue *This);</span><br><span class="line">static int enQueue(SingleLinkedListQueue *This,QNode *n);</span><br><span class="line">static int deQueue(SingleLinkedListQueue *This,QNode *n);</span><br><span class="line">static int traverse(SingleLinkedListQueue *This,int (*visit)(QNode *n));</span><br><span class="line"></span><br><span class="line">SingleLinkedListQueue *InitSingleLinkedListQueue()&#123;</span><br><span class="line">    SingleLinkedListQueue *Q = (SingleLinkedListQueue *)malloc(sizeof(SingleLinkedListQueue));</span><br><span class="line">    QNode *p = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">    Q-&gt;This = p;</span><br><span class="line">    Q-&gt;front = p;</span><br><span class="line">    Q-&gt;tear = Q-&gt;front;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    Q-&gt;clear = clear;</span><br><span class="line">    Q-&gt;isEmpty = isEmpty;</span><br><span class="line">    Q-&gt;length = length;</span><br><span class="line">    Q-&gt;getHead = getHead;</span><br><span class="line">    Q-&gt;enQueue = enQueue;</span><br><span class="line">    Q-&gt;deQueue = deQueue;</span><br><span class="line">    Q-&gt;traverse = traverse;</span><br><span class="line">    return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroySingleLinkedListQueue(SingleLinkedListQueue *Q)&#123;</span><br><span class="line">    Q-&gt;clear(Q);</span><br><span class="line">    free(Q-&gt;This);</span><br><span class="line">    free(Q);</span><br><span class="line">    Q = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(SingleLinkedListQueue *This)&#123;</span><br><span class="line">    QNode *p = This-&gt;This-&gt;next;</span><br><span class="line">    QNode *temp = NULL;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;This;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    This-&gt;front = p;</span><br><span class="line">    This-&gt;tear = This-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(SingleLinkedListQueue *This)&#123;</span><br><span class="line">    QNode *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(SingleLinkedListQueue *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    QNode *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static QNode *getHead(SingleLinkedListQueue *This)&#123;</span><br><span class="line">    return This-&gt;front-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int enQueue(SingleLinkedListQueue *This,QNode *n)&#123;</span><br><span class="line">    if(!n) return -1;</span><br><span class="line">    This-&gt;tear-&gt;next = n;</span><br><span class="line">    n-&gt;next = NULL;</span><br><span class="line">    This-&gt;tear = n;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deQueue(SingleLinkedListQueue *This,QNode *n)&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        n = NULL;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    QNode *temp = This-&gt;front-&gt;next;</span><br><span class="line">    *n = *(temp);</span><br><span class="line">    This-&gt;front-&gt;next = temp-&gt;next; </span><br><span class="line">    if(This-&gt;tear == temp) This-&gt;tear = This-&gt;front;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int traverse(SingleLinkedListQueue *This,int (*visit)(QNode *n))&#123;</span><br><span class="line">    if(This-&gt;front == This-&gt;tear)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    QNode *temp = This-&gt;front-&gt;next;</span><br><span class="line">    while(temp)&#123;</span><br><span class="line">        if(visit(temp) != 0) break;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SingleLinkedListQueue-h文件"><a href="#SingleLinkedListQueue-h文件" class="headerlink" title="SingleLinkedListQueue.h文件"></a>SingleLinkedListQueue.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef _SINGLELINKEDLISTQUEUE_H</span><br><span class="line">#define _SINGLELINKEDLISTQUEUE_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef struct QElemType&#123;</span><br><span class="line">    int id;</span><br><span class="line">    char name[20];</span><br><span class="line">&#125;QElemType;     </span><br><span class="line"></span><br><span class="line">typedef struct QNode&#123;</span><br><span class="line">    QElemType elem;  //存储空间</span><br><span class="line">    struct QNode *next;</span><br><span class="line">&#125;QNode,*Queueptr;</span><br><span class="line"></span><br><span class="line">typedef struct SingleLinkedListQueue&#123;</span><br><span class="line">    QNode *This;</span><br><span class="line">    Queueptr front; //队头</span><br><span class="line">    Queueptr tear; //队尾</span><br><span class="line">    void (*clear)(struct SingleLinkedListQueue *This);</span><br><span class="line">    int (*isEmpty)(struct SingleLinkedListQueue *This);</span><br><span class="line">    int (*length)(struct SingleLinkedListQueue *This);</span><br><span class="line">    QNode *(*getHead)(struct SingleLinkedListQueue *This);</span><br><span class="line">    int (*enQueue)(struct SingleLinkedListQueue *This,QNode *n);</span><br><span class="line">    int (*deQueue)(struct SingleLinkedListQueue *This,QNode *n);</span><br><span class="line">    int (*traverse)(struct SingleLinkedListQueue *This,int (*visit)(QNode *n));</span><br><span class="line">&#125;SingleLinkedListQueue;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">SingleLinkedListQueue *InitSingleLinkedListQueue();</span><br><span class="line">void DestroySingleLinkedListQueue(SingleLinkedListQueue *Q);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testSingleLinkedListQueue-c文件"><a href="#testSingleLinkedListQueue-c文件" class="headerlink" title="testSingleLinkedListQueue.c文件"></a>testSingleLinkedListQueue.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleLinkedListQueue.h&quot;</span><br><span class="line"></span><br><span class="line">char name[][3] = &#123;&quot;xw&quot;,&quot;xh&quot;,&quot;xm&quot;,&quot;xg&quot;,&quot;xl&quot;,&quot;xz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">void strCopy(char *str_a,char *str_b)&#123;</span><br><span class="line">    while(*str_b != &#x27;\0&#x27;)&#123;</span><br><span class="line">        *str_a++ = *str_b++;</span><br><span class="line">    &#125;</span><br><span class="line">    *str_a = &#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int printQnode(QNode *node)&#123;</span><br><span class="line">    printf(&quot;id:%d,name:%s\n&quot;,node-&gt;elem.id,node-&gt;elem.name);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    QNode *node = NULL;</span><br><span class="line">    SingleLinkedListQueue *queue = InitSingleLinkedListQueue();</span><br><span class="line">    printf(&quot;queue is empty:%d\n&quot;,queue-&gt;isEmpty(queue));</span><br><span class="line">    for(i=0;i&lt;6;i++)&#123;</span><br><span class="line">        node = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">        node-&gt;elem.id = i;</span><br><span class="line">        strCopy(node-&gt;elem.name,name[i]);</span><br><span class="line">        queue-&gt;enQueue(queue,node);</span><br><span class="line">    &#125;</span><br><span class="line">    queue-&gt;traverse(queue,printQnode);</span><br><span class="line">    printf(&quot;queue is empty:%d\n&quot;,queue-&gt;isEmpty(queue));</span><br><span class="line">    printf(&quot;queue length:%d\n&quot;,queue-&gt;length(queue));</span><br><span class="line">    queue-&gt;clear(queue);</span><br><span class="line">    for (i = 10; i &lt; 16; i++)&#123;</span><br><span class="line">        node = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">        node-&gt;elem.id = i;</span><br><span class="line">        strCopy(node-&gt;elem.name,name[i-10]);</span><br><span class="line">        queue-&gt;enQueue(queue,node);</span><br><span class="line">    &#125;   </span><br><span class="line">    queue-&gt;traverse(queue,printQnode);</span><br><span class="line">    while(queue-&gt;length(queue))&#123;</span><br><span class="line">        node = queue-&gt;getHead(queue);</span><br><span class="line">        printf(&quot;present client: id=%d, name=%s\n&quot;,node-&gt;elem.id,node-&gt;elem.name);</span><br><span class="line">        node = (QNode *)malloc(sizeof(QNode));</span><br><span class="line">        queue-&gt;deQueue(queue,node);</span><br><span class="line">        printf(&quot;client :id=%d,name=%s finish!\n&quot;,node-&gt;elem.id,node-&gt;elem.name);</span><br><span class="line">        free(node);</span><br><span class="line">        node = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    DestroySingleLinkedListQueue(queue);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc SingleLinkedListQueue.c SingleLinkedListQueue.h testSingleLinkedListQueue.c -o testSingleLinkedListQueue</span><br></pre></td></tr></table></figure><p>运行testSingleLinkedListQueue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">queue is empty:1</span><br><span class="line">id:0,name:xw</span><br><span class="line">id:1,name:xh</span><br><span class="line">id:2,name:xm</span><br><span class="line">id:3,name:xg</span><br><span class="line">id:4,name:xl</span><br><span class="line">id:5,name:xz</span><br><span class="line">queue is empty:0</span><br><span class="line">queue length:6</span><br><span class="line">id:10,name:xw</span><br><span class="line">id:11,name:xh</span><br><span class="line">id:12,name:xm</span><br><span class="line">id:13,name:xg</span><br><span class="line">id:14,name:xl</span><br><span class="line">id:15,name:xz</span><br><span class="line">present client: id=10, name=xw</span><br><span class="line">client :id=10,name=xw finish!</span><br><span class="line">present client: id=11, name=xh</span><br><span class="line">client :id=11,name=xh finish!</span><br><span class="line">present client: id=12, name=xm</span><br><span class="line">client :id=12,name=xm finish!</span><br><span class="line">present client: id=13, name=xg</span><br><span class="line">client :id=13,name=xg finish!</span><br><span class="line">present client: id=14, name=xl</span><br><span class="line">client :id=14,name=xl finish!</span><br><span class="line">present client: id=15, name=xz</span><br><span class="line">client :id=15,name=xz finish!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与递归的实现</title>
      <link href="/2018/09/02/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/02/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h4><p>栈还有一个重要应用是在程序设计语言中实现递归。一个直接调用自己或通过一系列的调用语句间接的调用自己的函数，称为递归函数。</p><span id="more"></span><p>递归是程序设计中一个强有力的工具。<br>其一，有很多数学函数是递归定义的，如大家熟悉的阶乘函数：</p><table><thead><tr><th>Fact(n)&#x3D;</th><th>1</th><th>若n&#x3D;0</th></tr></thead><tbody><tr><td></td><td>n*Fact(n-1)</td><td>若n&gt;0</td></tr></tbody></table><p>2阶Fibonacci数列：</p><table><thead><tr><th>Fib(n)&#x3D;</th><th>0</th><th>若n&#x3D;0</th></tr></thead><tbody><tr><td></td><td>1</td><td>若n&#x3D;1</td></tr><tr><td></td><td>Fib(n-1) + Fibz(n - 2)</td><td>其他情形</td></tr></tbody></table><p>Ackerman函数：</p><table><thead><tr><th>Ack(m,n)&#x3D;</th><th>n+1</th><th>若m&#x3D;0</th></tr></thead><tbody><tr><td></td><td>Ack(m-1,1)</td><td>若n&#x3D;0</td></tr><tr><td></td><td>Ack(m-1,Ack(m,n-1))</td><td>其他情形</td></tr></tbody></table><p>其二，有的数据结构，如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归的描述；<br>其三，还有一类问题，虽然问题本身没有明显的递归结构，但用递归求解比迭代求解更简单，如八皇后问题、Hanoi塔问题。</p><p>n阶Hanoi塔问题：<br>假设有3个分别命名为X、Y、Z的塔座，在塔座X上插有n个直径大小各不同、依小到大编号为1，2，…，n的圆盘。现要求将X轴上的n个圆盘移至塔座Z上并仍按同样顺序叠排，圆盘移动时必须遵循下列规则：<br>1.每次只能移动一个圆盘<br>2.圆盘可以插在X 、Y、Z中的任一塔座上<br>3.任何时刻都不能将一个较大的圆盘压在较小的圆盘上。</p><p>如何实现移动圆盘的操作呢?<br>当n&#x3D;1时，问题比较简单，只要将编号为1的圆盘从塔座X直接移至塔座Z上即可；</p><p>当n&gt;1时，需利用塔座Y作为辅助塔，若能设法将压在编号为n的圆盘之上的n-1个圆盘从塔座X移至塔座Y上，则可先将编号为n的圆盘从塔座X移至塔座Z上，然后再将塔座Y上的n-1个圆盘移至塔座Z上。</p><p>而如何将n-1个圆盘从一个塔座移至另一个塔座的问题是一个和原问题具有相同特征属性的问题，只是问题的规模小1，因此可以用同样的方法求解。</p><p>TowerOfHanoi.c利用了前面的C封装的顺序栈对象    <a href="https://www.jianshu.com/p/a035666f4bed">用线性表表示的顺序栈</a><br>实现了Hanoi塔递归移动的过程，每一步执行的过程以及x、y、z三个轴的状态均可以看到。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="TowerOfHanoi-c文件"><a href="#TowerOfHanoi-c文件" class="headerlink" title="TowerOfHanoi.c文件"></a>TowerOfHanoi.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line"></span><br><span class="line">void hanoi(int n,LinearListStack *x,LinearListStack *y,LinearListStack *z)&#123;</span><br><span class="line">    char elem;</span><br><span class="line">    if(n == 1)&#123;</span><br><span class="line">        x-&gt;pop(x,&amp;elem);</span><br><span class="line">        z-&gt;push(z,&amp;elem); //将编号为1的圆盘从x移到z</span><br><span class="line">        //******************************打印步骤需要，非执行过程*********************</span><br><span class="line">        printf(&quot;move %c from %c to %c\n&quot;,elem,*(x-&gt;This-&gt;base),*(z-&gt;This-&gt;base));</span><br><span class="line">        x-&gt;risePrint(x);</span><br><span class="line">        y-&gt;risePrint(y);</span><br><span class="line">        z-&gt;risePrint(z);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        //***************************************************************************</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        hanoi(n-1,x,z,y);//将x上编号为1至n-1的圆盘移到y，z做辅助塔</span><br><span class="line">        x-&gt;pop(x,&amp;elem);</span><br><span class="line">        z-&gt;push(z,&amp;elem);//将编号为n的圆盘从x移到z</span><br><span class="line">        //******************************打印步骤需要，非执行过程*********************</span><br><span class="line">        printf(&quot;move %c from %c to %c\n&quot;,elem,*(x-&gt;This-&gt;base),*(z-&gt;This-&gt;base));</span><br><span class="line">        x-&gt;risePrint(x);</span><br><span class="line">        y-&gt;risePrint(y);</span><br><span class="line">        z-&gt;risePrint(z);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        //***************************************************************************</span><br><span class="line">        hanoi(n-1,y,x,z);//将y上编号为1至n-1的圆盘移到z，x做辅助塔</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char elem;</span><br><span class="line">    LinearListStack *x = InitLinearListStack();</span><br><span class="line">    LinearListStack *y = InitLinearListStack();</span><br><span class="line">    LinearListStack *z = InitLinearListStack();</span><br><span class="line">    elem = &#x27;x&#x27;;</span><br><span class="line">    x-&gt;push(x,&amp;elem);</span><br><span class="line">    elem = &#x27;:&#x27;;</span><br><span class="line">    x-&gt;push(x,&amp;elem);</span><br><span class="line">    elem = &#x27;y&#x27;;</span><br><span class="line">    y-&gt;push(y,&amp;elem);</span><br><span class="line">    elem = &#x27;:&#x27;;</span><br><span class="line">    y-&gt;push(y,&amp;elem);</span><br><span class="line">    elem = &#x27;z&#x27;;</span><br><span class="line">    z-&gt;push(z,&amp;elem);</span><br><span class="line">    elem = &#x27;:&#x27;;</span><br><span class="line">    z-&gt;push(z,&amp;elem);</span><br><span class="line">    for(i=9;i&gt;0;i--)&#123;</span><br><span class="line">        elem = i+0x30;</span><br><span class="line">        x-&gt;push(x,&amp;elem);</span><br><span class="line">    &#125;</span><br><span class="line">    hanoi(9,x,y,z);</span><br><span class="line">    DestroyLinearListStack(x);</span><br><span class="line">    DestroyLinearListStack(y);</span><br><span class="line">    DestroyLinearListStack(z);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearListStack.c LinearListStack.h TowerOfHanoi.c -o TowerOfHanoi</span><br></pre></td></tr></table></figure><p>运行TowerOfHanoi：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br><span class="line">2237</span><br><span class="line">2238</span><br><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br><span class="line">2257</span><br><span class="line">2258</span><br><span class="line">2259</span><br><span class="line">2260</span><br><span class="line">2261</span><br><span class="line">2262</span><br><span class="line">2263</span><br><span class="line">2264</span><br><span class="line">2265</span><br><span class="line">2266</span><br><span class="line">2267</span><br><span class="line">2268</span><br><span class="line">2269</span><br><span class="line">2270</span><br><span class="line">2271</span><br><span class="line">2272</span><br><span class="line">2273</span><br><span class="line">2274</span><br><span class="line">2275</span><br><span class="line">2276</span><br><span class="line">2277</span><br><span class="line">2278</span><br><span class="line">2279</span><br><span class="line">2280</span><br><span class="line">2281</span><br><span class="line">2282</span><br><span class="line">2283</span><br><span class="line">2284</span><br><span class="line">2285</span><br><span class="line">2286</span><br><span class="line">2287</span><br><span class="line">2288</span><br><span class="line">2289</span><br><span class="line">2290</span><br><span class="line">2291</span><br><span class="line">2292</span><br><span class="line">2293</span><br><span class="line">2294</span><br><span class="line">2295</span><br><span class="line">2296</span><br><span class="line">2297</span><br><span class="line">2298</span><br><span class="line">2299</span><br><span class="line">2300</span><br><span class="line">2301</span><br><span class="line">2302</span><br><span class="line">2303</span><br><span class="line">2304</span><br><span class="line">2305</span><br><span class="line">2306</span><br><span class="line">2307</span><br><span class="line">2308</span><br><span class="line">2309</span><br><span class="line">2310</span><br><span class="line">2311</span><br><span class="line">2312</span><br><span class="line">2313</span><br><span class="line">2314</span><br><span class="line">2315</span><br><span class="line">2316</span><br><span class="line">2317</span><br><span class="line">2318</span><br><span class="line">2319</span><br><span class="line">2320</span><br><span class="line">2321</span><br><span class="line">2322</span><br><span class="line">2323</span><br><span class="line">2324</span><br><span class="line">2325</span><br><span class="line">2326</span><br><span class="line">2327</span><br><span class="line">2328</span><br><span class="line">2329</span><br><span class="line">2330</span><br><span class="line">2331</span><br><span class="line">2332</span><br><span class="line">2333</span><br><span class="line">2334</span><br><span class="line">2335</span><br><span class="line">2336</span><br><span class="line">2337</span><br><span class="line">2338</span><br><span class="line">2339</span><br><span class="line">2340</span><br><span class="line">2341</span><br><span class="line">2342</span><br><span class="line">2343</span><br><span class="line">2344</span><br><span class="line">2345</span><br><span class="line">2346</span><br><span class="line">2347</span><br><span class="line">2348</span><br><span class="line">2349</span><br><span class="line">2350</span><br><span class="line">2351</span><br><span class="line">2352</span><br><span class="line">2353</span><br><span class="line">2354</span><br><span class="line">2355</span><br><span class="line">2356</span><br><span class="line">2357</span><br><span class="line">2358</span><br><span class="line">2359</span><br><span class="line">2360</span><br><span class="line">2361</span><br><span class="line">2362</span><br><span class="line">2363</span><br><span class="line">2364</span><br><span class="line">2365</span><br><span class="line">2366</span><br><span class="line">2367</span><br><span class="line">2368</span><br><span class="line">2369</span><br><span class="line">2370</span><br><span class="line">2371</span><br><span class="line">2372</span><br><span class="line">2373</span><br><span class="line">2374</span><br><span class="line">2375</span><br><span class="line">2376</span><br><span class="line">2377</span><br><span class="line">2378</span><br><span class="line">2379</span><br><span class="line">2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br><span class="line">2386</span><br><span class="line">2387</span><br><span class="line">2388</span><br><span class="line">2389</span><br><span class="line">2390</span><br><span class="line">2391</span><br><span class="line">2392</span><br><span class="line">2393</span><br><span class="line">2394</span><br><span class="line">2395</span><br><span class="line">2396</span><br><span class="line">2397</span><br><span class="line">2398</span><br><span class="line">2399</span><br><span class="line">2400</span><br><span class="line">2401</span><br><span class="line">2402</span><br><span class="line">2403</span><br><span class="line">2404</span><br><span class="line">2405</span><br><span class="line">2406</span><br><span class="line">2407</span><br><span class="line">2408</span><br><span class="line">2409</span><br><span class="line">2410</span><br><span class="line">2411</span><br><span class="line">2412</span><br><span class="line">2413</span><br><span class="line">2414</span><br><span class="line">2415</span><br><span class="line">2416</span><br><span class="line">2417</span><br><span class="line">2418</span><br><span class="line">2419</span><br><span class="line">2420</span><br><span class="line">2421</span><br><span class="line">2422</span><br><span class="line">2423</span><br><span class="line">2424</span><br><span class="line">2425</span><br><span class="line">2426</span><br><span class="line">2427</span><br><span class="line">2428</span><br><span class="line">2429</span><br><span class="line">2430</span><br><span class="line">2431</span><br><span class="line">2432</span><br><span class="line">2433</span><br><span class="line">2434</span><br><span class="line">2435</span><br><span class="line">2436</span><br><span class="line">2437</span><br><span class="line">2438</span><br><span class="line">2439</span><br><span class="line">2440</span><br><span class="line">2441</span><br><span class="line">2442</span><br><span class="line">2443</span><br><span class="line">2444</span><br><span class="line">2445</span><br><span class="line">2446</span><br><span class="line">2447</span><br><span class="line">2448</span><br><span class="line">2449</span><br><span class="line">2450</span><br><span class="line">2451</span><br><span class="line">2452</span><br><span class="line">2453</span><br><span class="line">2454</span><br><span class="line">2455</span><br><span class="line">2456</span><br><span class="line">2457</span><br><span class="line">2458</span><br><span class="line">2459</span><br><span class="line">2460</span><br><span class="line">2461</span><br><span class="line">2462</span><br><span class="line">2463</span><br><span class="line">2464</span><br><span class="line">2465</span><br><span class="line">2466</span><br><span class="line">2467</span><br><span class="line">2468</span><br><span class="line">2469</span><br><span class="line">2470</span><br><span class="line">2471</span><br><span class="line">2472</span><br><span class="line">2473</span><br><span class="line">2474</span><br><span class="line">2475</span><br><span class="line">2476</span><br><span class="line">2477</span><br><span class="line">2478</span><br><span class="line">2479</span><br><span class="line">2480</span><br><span class="line">2481</span><br><span class="line">2482</span><br><span class="line">2483</span><br><span class="line">2484</span><br><span class="line">2485</span><br><span class="line">2486</span><br><span class="line">2487</span><br><span class="line">2488</span><br><span class="line">2489</span><br><span class="line">2490</span><br><span class="line">2491</span><br><span class="line">2492</span><br><span class="line">2493</span><br><span class="line">2494</span><br><span class="line">2495</span><br><span class="line">2496</span><br><span class="line">2497</span><br><span class="line">2498</span><br><span class="line">2499</span><br><span class="line">2500</span><br><span class="line">2501</span><br><span class="line">2502</span><br><span class="line">2503</span><br><span class="line">2504</span><br><span class="line">2505</span><br><span class="line">2506</span><br><span class="line">2507</span><br><span class="line">2508</span><br><span class="line">2509</span><br><span class="line">2510</span><br><span class="line">2511</span><br><span class="line">2512</span><br><span class="line">2513</span><br><span class="line">2514</span><br><span class="line">2515</span><br><span class="line">2516</span><br><span class="line">2517</span><br><span class="line">2518</span><br><span class="line">2519</span><br><span class="line">2520</span><br><span class="line">2521</span><br><span class="line">2522</span><br><span class="line">2523</span><br><span class="line">2524</span><br><span class="line">2525</span><br><span class="line">2526</span><br><span class="line">2527</span><br><span class="line">2528</span><br><span class="line">2529</span><br><span class="line">2530</span><br><span class="line">2531</span><br><span class="line">2532</span><br><span class="line">2533</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539</span><br><span class="line">2540</span><br><span class="line">2541</span><br><span class="line">2542</span><br><span class="line">2543</span><br><span class="line">2544</span><br><span class="line">2545</span><br><span class="line">2546</span><br><span class="line">2547</span><br><span class="line">2548</span><br><span class="line">2549</span><br><span class="line">2550</span><br><span class="line">2551</span><br><span class="line">2552</span><br><span class="line">2553</span><br><span class="line">2554</span><br></pre></td><td class="code"><pre><span class="line">move 1 from x to z</span><br><span class="line">x:98765432</span><br><span class="line">y:</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:9876543</span><br><span class="line">z:1</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:9876543</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:987654</span><br><span class="line">y:21</span><br><span class="line">z:3</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:3</span><br><span class="line">x:9876541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:9876541</span><br><span class="line">z:32</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:987654</span><br><span class="line">y:</span><br><span class="line">z:321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:98765</span><br><span class="line">z:321</span><br><span class="line">y:4</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:32</span><br><span class="line">x:98765</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:3</span><br><span class="line">y:41</span><br><span class="line">x:987652</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:3</span><br><span class="line">x:9876521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:</span><br><span class="line">x:9876521</span><br><span class="line">y:43</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:987652</span><br><span class="line">y:43</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:98765</span><br><span class="line">z:1</span><br><span class="line">y:432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:98765</span><br><span class="line">y:4321</span><br><span class="line"></span><br><span class="line">move 5 from x to z</span><br><span class="line">x:9876</span><br><span class="line">y:4321</span><br><span class="line">z:5</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:432</span><br><span class="line">z:5</span><br><span class="line">x:98761</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:43</span><br><span class="line">x:98761</span><br><span class="line">z:52</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9876</span><br><span class="line">y:43</span><br><span class="line">z:521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:521</span><br><span class="line">x:98763</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:52</span><br><span class="line">x:98763</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:5</span><br><span class="line">y:41</span><br><span class="line">x:987632</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:5</span><br><span class="line">x:9876321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:</span><br><span class="line">x:9876321</span><br><span class="line">z:54</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:987632</span><br><span class="line">y:</span><br><span class="line">z:541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:98763</span><br><span class="line">z:541</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:54</span><br><span class="line">x:98763</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:9876</span><br><span class="line">y:21</span><br><span class="line">z:543</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:543</span><br><span class="line">x:98761</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:98761</span><br><span class="line">z:5432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9876</span><br><span class="line">y:</span><br><span class="line">z:54321</span><br><span class="line"></span><br><span class="line">move 6 from x to y</span><br><span class="line">x:987</span><br><span class="line">z:54321</span><br><span class="line">y:6</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:5432</span><br><span class="line">x:987</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:543</span><br><span class="line">y:61</span><br><span class="line">x:9872</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:543</span><br><span class="line">x:98721</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:54</span><br><span class="line">x:98721</span><br><span class="line">y:63</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9872</span><br><span class="line">y:63</span><br><span class="line">z:541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:987</span><br><span class="line">z:541</span><br><span class="line">y:632</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:54</span><br><span class="line">x:987</span><br><span class="line">y:6321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:5</span><br><span class="line">y:6321</span><br><span class="line">x:9874</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:632</span><br><span class="line">z:5</span><br><span class="line">x:98741</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:63</span><br><span class="line">x:98741</span><br><span class="line">z:52</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9874</span><br><span class="line">y:63</span><br><span class="line">z:521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:521</span><br><span class="line">x:98743</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:52</span><br><span class="line">x:98743</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:5</span><br><span class="line">y:61</span><br><span class="line">x:987432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:5</span><br><span class="line">x:9874321</span><br><span class="line"></span><br><span class="line">move 5 from z to y</span><br><span class="line">z:</span><br><span class="line">x:9874321</span><br><span class="line">y:65</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:987432</span><br><span class="line">y:65</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:98743</span><br><span class="line">z:1</span><br><span class="line">y:652</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:98743</span><br><span class="line">y:6521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:9874</span><br><span class="line">y:6521</span><br><span class="line">z:3</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:652</span><br><span class="line">z:3</span><br><span class="line">x:98741</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:65</span><br><span class="line">x:98741</span><br><span class="line">z:32</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9874</span><br><span class="line">y:65</span><br><span class="line">z:321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:987</span><br><span class="line">z:321</span><br><span class="line">y:654</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:32</span><br><span class="line">x:987</span><br><span class="line">y:6541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:3</span><br><span class="line">y:6541</span><br><span class="line">x:9872</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:654</span><br><span class="line">z:3</span><br><span class="line">x:98721</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:</span><br><span class="line">x:98721</span><br><span class="line">y:6543</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9872</span><br><span class="line">y:6543</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:987</span><br><span class="line">z:1</span><br><span class="line">y:65432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:987</span><br><span class="line">y:654321</span><br><span class="line"></span><br><span class="line">move 7 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:654321</span><br><span class="line">z:7</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:65432</span><br><span class="line">z:7</span><br><span class="line">x:981</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:6543</span><br><span class="line">x:981</span><br><span class="line">z:72</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:6543</span><br><span class="line">z:721</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:654</span><br><span class="line">z:721</span><br><span class="line">x:983</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:72</span><br><span class="line">x:983</span><br><span class="line">y:6541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:7</span><br><span class="line">y:6541</span><br><span class="line">x:9832</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:654</span><br><span class="line">z:7</span><br><span class="line">x:98321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:65</span><br><span class="line">x:98321</span><br><span class="line">z:74</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9832</span><br><span class="line">y:65</span><br><span class="line">z:741</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:983</span><br><span class="line">z:741</span><br><span class="line">y:652</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:74</span><br><span class="line">x:983</span><br><span class="line">y:6521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:6521</span><br><span class="line">z:743</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:652</span><br><span class="line">z:743</span><br><span class="line">x:981</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:65</span><br><span class="line">x:981</span><br><span class="line">z:7432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:65</span><br><span class="line">z:74321</span><br><span class="line"></span><br><span class="line">move 5 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:74321</span><br><span class="line">x:985</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7432</span><br><span class="line">x:985</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:743</span><br><span class="line">y:61</span><br><span class="line">x:9852</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:743</span><br><span class="line">x:98521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:74</span><br><span class="line">x:98521</span><br><span class="line">y:63</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9852</span><br><span class="line">y:63</span><br><span class="line">z:741</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:985</span><br><span class="line">z:741</span><br><span class="line">y:632</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:74</span><br><span class="line">x:985</span><br><span class="line">y:6321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:7</span><br><span class="line">y:6321</span><br><span class="line">x:9854</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:632</span><br><span class="line">z:7</span><br><span class="line">x:98541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:63</span><br><span class="line">x:98541</span><br><span class="line">z:72</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9854</span><br><span class="line">y:63</span><br><span class="line">z:721</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:721</span><br><span class="line">x:98543</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:72</span><br><span class="line">x:98543</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:7</span><br><span class="line">y:61</span><br><span class="line">x:985432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:7</span><br><span class="line">x:9854321</span><br><span class="line"></span><br><span class="line">move 6 from y to z</span><br><span class="line">y:</span><br><span class="line">x:9854321</span><br><span class="line">z:76</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:985432</span><br><span class="line">y:</span><br><span class="line">z:761</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:98543</span><br><span class="line">z:761</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:76</span><br><span class="line">x:98543</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:9854</span><br><span class="line">y:21</span><br><span class="line">z:763</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:763</span><br><span class="line">x:98541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:98541</span><br><span class="line">z:7632</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9854</span><br><span class="line">y:</span><br><span class="line">z:76321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:985</span><br><span class="line">z:76321</span><br><span class="line">y:4</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7632</span><br><span class="line">x:985</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:763</span><br><span class="line">y:41</span><br><span class="line">x:9852</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:763</span><br><span class="line">x:98521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:76</span><br><span class="line">x:98521</span><br><span class="line">y:43</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9852</span><br><span class="line">y:43</span><br><span class="line">z:761</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:985</span><br><span class="line">z:761</span><br><span class="line">y:432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:76</span><br><span class="line">x:985</span><br><span class="line">y:4321</span><br><span class="line"></span><br><span class="line">move 5 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:4321</span><br><span class="line">z:765</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:432</span><br><span class="line">z:765</span><br><span class="line">x:981</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:43</span><br><span class="line">x:981</span><br><span class="line">z:7652</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:43</span><br><span class="line">z:76521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:76521</span><br><span class="line">x:983</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7652</span><br><span class="line">x:983</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:765</span><br><span class="line">y:41</span><br><span class="line">x:9832</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:765</span><br><span class="line">x:98321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:</span><br><span class="line">x:98321</span><br><span class="line">z:7654</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9832</span><br><span class="line">y:</span><br><span class="line">z:76541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:983</span><br><span class="line">z:76541</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7654</span><br><span class="line">x:983</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:21</span><br><span class="line">z:76543</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:76543</span><br><span class="line">x:981</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:981</span><br><span class="line">z:765432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:98</span><br><span class="line">y:</span><br><span class="line">z:7654321</span><br><span class="line"></span><br><span class="line">move 8 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:7654321</span><br><span class="line">y:8</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:765432</span><br><span class="line">x:9</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:76543</span><br><span class="line">y:81</span><br><span class="line">x:92</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:76543</span><br><span class="line">x:921</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:7654</span><br><span class="line">x:921</span><br><span class="line">y:83</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:92</span><br><span class="line">y:83</span><br><span class="line">z:76541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:76541</span><br><span class="line">y:832</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7654</span><br><span class="line">x:9</span><br><span class="line">y:8321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:765</span><br><span class="line">y:8321</span><br><span class="line">x:94</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:832</span><br><span class="line">z:765</span><br><span class="line">x:941</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:83</span><br><span class="line">x:941</span><br><span class="line">z:7652</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:94</span><br><span class="line">y:83</span><br><span class="line">z:76521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:76521</span><br><span class="line">x:943</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7652</span><br><span class="line">x:943</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:765</span><br><span class="line">y:81</span><br><span class="line">x:9432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:765</span><br><span class="line">x:94321</span><br><span class="line"></span><br><span class="line">move 5 from z to y</span><br><span class="line">z:76</span><br><span class="line">x:94321</span><br><span class="line">y:85</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9432</span><br><span class="line">y:85</span><br><span class="line">z:761</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:943</span><br><span class="line">z:761</span><br><span class="line">y:852</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:76</span><br><span class="line">x:943</span><br><span class="line">y:8521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:94</span><br><span class="line">y:8521</span><br><span class="line">z:763</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:852</span><br><span class="line">z:763</span><br><span class="line">x:941</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:85</span><br><span class="line">x:941</span><br><span class="line">z:7632</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:94</span><br><span class="line">y:85</span><br><span class="line">z:76321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:76321</span><br><span class="line">y:854</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7632</span><br><span class="line">x:9</span><br><span class="line">y:8541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:763</span><br><span class="line">y:8541</span><br><span class="line">x:92</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:854</span><br><span class="line">z:763</span><br><span class="line">x:921</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:76</span><br><span class="line">x:921</span><br><span class="line">y:8543</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:92</span><br><span class="line">y:8543</span><br><span class="line">z:761</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:761</span><br><span class="line">y:85432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:76</span><br><span class="line">x:9</span><br><span class="line">y:854321</span><br><span class="line"></span><br><span class="line">move 6 from z to x</span><br><span class="line">z:7</span><br><span class="line">y:854321</span><br><span class="line">x:96</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:85432</span><br><span class="line">z:7</span><br><span class="line">x:961</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8543</span><br><span class="line">x:961</span><br><span class="line">z:72</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:96</span><br><span class="line">y:8543</span><br><span class="line">z:721</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:854</span><br><span class="line">z:721</span><br><span class="line">x:963</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:72</span><br><span class="line">x:963</span><br><span class="line">y:8541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:7</span><br><span class="line">y:8541</span><br><span class="line">x:9632</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:854</span><br><span class="line">z:7</span><br><span class="line">x:96321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:85</span><br><span class="line">x:96321</span><br><span class="line">z:74</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9632</span><br><span class="line">y:85</span><br><span class="line">z:741</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:963</span><br><span class="line">z:741</span><br><span class="line">y:852</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:74</span><br><span class="line">x:963</span><br><span class="line">y:8521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:96</span><br><span class="line">y:8521</span><br><span class="line">z:743</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:852</span><br><span class="line">z:743</span><br><span class="line">x:961</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:85</span><br><span class="line">x:961</span><br><span class="line">z:7432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:96</span><br><span class="line">y:85</span><br><span class="line">z:74321</span><br><span class="line"></span><br><span class="line">move 5 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:74321</span><br><span class="line">x:965</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:7432</span><br><span class="line">x:965</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:743</span><br><span class="line">y:81</span><br><span class="line">x:9652</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:743</span><br><span class="line">x:96521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:74</span><br><span class="line">x:96521</span><br><span class="line">y:83</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9652</span><br><span class="line">y:83</span><br><span class="line">z:741</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:965</span><br><span class="line">z:741</span><br><span class="line">y:832</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:74</span><br><span class="line">x:965</span><br><span class="line">y:8321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:7</span><br><span class="line">y:8321</span><br><span class="line">x:9654</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:832</span><br><span class="line">z:7</span><br><span class="line">x:96541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:83</span><br><span class="line">x:96541</span><br><span class="line">z:72</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9654</span><br><span class="line">y:83</span><br><span class="line">z:721</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:721</span><br><span class="line">x:96543</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:72</span><br><span class="line">x:96543</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:7</span><br><span class="line">y:81</span><br><span class="line">x:965432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:7</span><br><span class="line">x:9654321</span><br><span class="line"></span><br><span class="line">move 7 from z to y</span><br><span class="line">z:</span><br><span class="line">x:9654321</span><br><span class="line">y:87</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:965432</span><br><span class="line">y:87</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:96543</span><br><span class="line">z:1</span><br><span class="line">y:872</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:96543</span><br><span class="line">y:8721</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:9654</span><br><span class="line">y:8721</span><br><span class="line">z:3</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:872</span><br><span class="line">z:3</span><br><span class="line">x:96541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:87</span><br><span class="line">x:96541</span><br><span class="line">z:32</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9654</span><br><span class="line">y:87</span><br><span class="line">z:321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:965</span><br><span class="line">z:321</span><br><span class="line">y:874</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:32</span><br><span class="line">x:965</span><br><span class="line">y:8741</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:3</span><br><span class="line">y:8741</span><br><span class="line">x:9652</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:874</span><br><span class="line">z:3</span><br><span class="line">x:96521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:</span><br><span class="line">x:96521</span><br><span class="line">y:8743</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9652</span><br><span class="line">y:8743</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:965</span><br><span class="line">z:1</span><br><span class="line">y:87432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:965</span><br><span class="line">y:874321</span><br><span class="line"></span><br><span class="line">move 5 from x to z</span><br><span class="line">x:96</span><br><span class="line">y:874321</span><br><span class="line">z:5</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87432</span><br><span class="line">z:5</span><br><span class="line">x:961</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8743</span><br><span class="line">x:961</span><br><span class="line">z:52</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:96</span><br><span class="line">y:8743</span><br><span class="line">z:521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:874</span><br><span class="line">z:521</span><br><span class="line">x:963</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:52</span><br><span class="line">x:963</span><br><span class="line">y:8741</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:5</span><br><span class="line">y:8741</span><br><span class="line">x:9632</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:874</span><br><span class="line">z:5</span><br><span class="line">x:96321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:87</span><br><span class="line">x:96321</span><br><span class="line">z:54</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9632</span><br><span class="line">y:87</span><br><span class="line">z:541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:963</span><br><span class="line">z:541</span><br><span class="line">y:872</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:54</span><br><span class="line">x:963</span><br><span class="line">y:8721</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:96</span><br><span class="line">y:8721</span><br><span class="line">z:543</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:872</span><br><span class="line">z:543</span><br><span class="line">x:961</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:87</span><br><span class="line">x:961</span><br><span class="line">z:5432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:96</span><br><span class="line">y:87</span><br><span class="line">z:54321</span><br><span class="line"></span><br><span class="line">move 6 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:54321</span><br><span class="line">y:876</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:5432</span><br><span class="line">x:9</span><br><span class="line">y:8761</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:543</span><br><span class="line">y:8761</span><br><span class="line">x:92</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:876</span><br><span class="line">z:543</span><br><span class="line">x:921</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:54</span><br><span class="line">x:921</span><br><span class="line">y:8763</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:92</span><br><span class="line">y:8763</span><br><span class="line">z:541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:541</span><br><span class="line">y:87632</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:54</span><br><span class="line">x:9</span><br><span class="line">y:876321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:5</span><br><span class="line">y:876321</span><br><span class="line">x:94</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87632</span><br><span class="line">z:5</span><br><span class="line">x:941</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8763</span><br><span class="line">x:941</span><br><span class="line">z:52</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:94</span><br><span class="line">y:8763</span><br><span class="line">z:521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:876</span><br><span class="line">z:521</span><br><span class="line">x:943</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:52</span><br><span class="line">x:943</span><br><span class="line">y:8761</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:5</span><br><span class="line">y:8761</span><br><span class="line">x:9432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:876</span><br><span class="line">z:5</span><br><span class="line">x:94321</span><br><span class="line"></span><br><span class="line">move 5 from z to y</span><br><span class="line">z:</span><br><span class="line">x:94321</span><br><span class="line">y:8765</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:9432</span><br><span class="line">y:8765</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:943</span><br><span class="line">z:1</span><br><span class="line">y:87652</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:943</span><br><span class="line">y:876521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:94</span><br><span class="line">y:876521</span><br><span class="line">z:3</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87652</span><br><span class="line">z:3</span><br><span class="line">x:941</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8765</span><br><span class="line">x:941</span><br><span class="line">z:32</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:94</span><br><span class="line">y:8765</span><br><span class="line">z:321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:321</span><br><span class="line">y:87654</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:32</span><br><span class="line">x:9</span><br><span class="line">y:876541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:3</span><br><span class="line">y:876541</span><br><span class="line">x:92</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87654</span><br><span class="line">z:3</span><br><span class="line">x:921</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:</span><br><span class="line">x:921</span><br><span class="line">y:876543</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:92</span><br><span class="line">y:876543</span><br><span class="line">z:1</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:9</span><br><span class="line">z:1</span><br><span class="line">y:8765432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:</span><br><span class="line">x:9</span><br><span class="line">y:87654321</span><br><span class="line"></span><br><span class="line">move 9 from x to z</span><br><span class="line">x:</span><br><span class="line">y:87654321</span><br><span class="line">z:9</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8765432</span><br><span class="line">z:9</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:876543</span><br><span class="line">x:1</span><br><span class="line">z:92</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:876543</span><br><span class="line">z:921</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:87654</span><br><span class="line">z:921</span><br><span class="line">x:3</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:92</span><br><span class="line">x:3</span><br><span class="line">y:876541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:9</span><br><span class="line">y:876541</span><br><span class="line">x:32</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87654</span><br><span class="line">z:9</span><br><span class="line">x:321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:8765</span><br><span class="line">x:321</span><br><span class="line">z:94</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:32</span><br><span class="line">y:8765</span><br><span class="line">z:941</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:3</span><br><span class="line">z:941</span><br><span class="line">y:87652</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:94</span><br><span class="line">x:3</span><br><span class="line">y:876521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:</span><br><span class="line">y:876521</span><br><span class="line">z:943</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87652</span><br><span class="line">z:943</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8765</span><br><span class="line">x:1</span><br><span class="line">z:9432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:8765</span><br><span class="line">z:94321</span><br><span class="line"></span><br><span class="line">move 5 from y to x</span><br><span class="line">y:876</span><br><span class="line">z:94321</span><br><span class="line">x:5</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9432</span><br><span class="line">x:5</span><br><span class="line">y:8761</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:943</span><br><span class="line">y:8761</span><br><span class="line">x:52</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:876</span><br><span class="line">z:943</span><br><span class="line">x:521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:94</span><br><span class="line">x:521</span><br><span class="line">y:8763</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:52</span><br><span class="line">y:8763</span><br><span class="line">z:941</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:5</span><br><span class="line">z:941</span><br><span class="line">y:87632</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:94</span><br><span class="line">x:5</span><br><span class="line">y:876321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:9</span><br><span class="line">y:876321</span><br><span class="line">x:54</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87632</span><br><span class="line">z:9</span><br><span class="line">x:541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8763</span><br><span class="line">x:541</span><br><span class="line">z:92</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:54</span><br><span class="line">y:8763</span><br><span class="line">z:921</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:876</span><br><span class="line">z:921</span><br><span class="line">x:543</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:92</span><br><span class="line">x:543</span><br><span class="line">y:8761</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:9</span><br><span class="line">y:8761</span><br><span class="line">x:5432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:876</span><br><span class="line">z:9</span><br><span class="line">x:54321</span><br><span class="line"></span><br><span class="line">move 6 from y to z</span><br><span class="line">y:87</span><br><span class="line">x:54321</span><br><span class="line">z:96</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:5432</span><br><span class="line">y:87</span><br><span class="line">z:961</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:543</span><br><span class="line">z:961</span><br><span class="line">y:872</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:96</span><br><span class="line">x:543</span><br><span class="line">y:8721</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:54</span><br><span class="line">y:8721</span><br><span class="line">z:963</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:872</span><br><span class="line">z:963</span><br><span class="line">x:541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:87</span><br><span class="line">x:541</span><br><span class="line">z:9632</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:54</span><br><span class="line">y:87</span><br><span class="line">z:96321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:5</span><br><span class="line">z:96321</span><br><span class="line">y:874</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9632</span><br><span class="line">x:5</span><br><span class="line">y:8741</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:963</span><br><span class="line">y:8741</span><br><span class="line">x:52</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:874</span><br><span class="line">z:963</span><br><span class="line">x:521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:96</span><br><span class="line">x:521</span><br><span class="line">y:8743</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:52</span><br><span class="line">y:8743</span><br><span class="line">z:961</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:5</span><br><span class="line">z:961</span><br><span class="line">y:87432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:96</span><br><span class="line">x:5</span><br><span class="line">y:874321</span><br><span class="line"></span><br><span class="line">move 5 from x to z</span><br><span class="line">x:</span><br><span class="line">y:874321</span><br><span class="line">z:965</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:87432</span><br><span class="line">z:965</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8743</span><br><span class="line">x:1</span><br><span class="line">z:9652</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:8743</span><br><span class="line">z:96521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:874</span><br><span class="line">z:96521</span><br><span class="line">x:3</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9652</span><br><span class="line">x:3</span><br><span class="line">y:8741</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:965</span><br><span class="line">y:8741</span><br><span class="line">x:32</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:874</span><br><span class="line">z:965</span><br><span class="line">x:321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:87</span><br><span class="line">x:321</span><br><span class="line">z:9654</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:32</span><br><span class="line">y:87</span><br><span class="line">z:96541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:3</span><br><span class="line">z:96541</span><br><span class="line">y:872</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9654</span><br><span class="line">x:3</span><br><span class="line">y:8721</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:</span><br><span class="line">y:8721</span><br><span class="line">z:96543</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:872</span><br><span class="line">z:96543</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:87</span><br><span class="line">x:1</span><br><span class="line">z:965432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:87</span><br><span class="line">z:9654321</span><br><span class="line"></span><br><span class="line">move 7 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:9654321</span><br><span class="line">x:7</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:965432</span><br><span class="line">x:7</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:96543</span><br><span class="line">y:81</span><br><span class="line">x:72</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:96543</span><br><span class="line">x:721</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:9654</span><br><span class="line">x:721</span><br><span class="line">y:83</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:72</span><br><span class="line">y:83</span><br><span class="line">z:96541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:7</span><br><span class="line">z:96541</span><br><span class="line">y:832</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9654</span><br><span class="line">x:7</span><br><span class="line">y:8321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:965</span><br><span class="line">y:8321</span><br><span class="line">x:74</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:832</span><br><span class="line">z:965</span><br><span class="line">x:741</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:83</span><br><span class="line">x:741</span><br><span class="line">z:9652</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:74</span><br><span class="line">y:83</span><br><span class="line">z:96521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:96521</span><br><span class="line">x:743</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9652</span><br><span class="line">x:743</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:965</span><br><span class="line">y:81</span><br><span class="line">x:7432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:965</span><br><span class="line">x:74321</span><br><span class="line"></span><br><span class="line">move 5 from z to y</span><br><span class="line">z:96</span><br><span class="line">x:74321</span><br><span class="line">y:85</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7432</span><br><span class="line">y:85</span><br><span class="line">z:961</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:743</span><br><span class="line">z:961</span><br><span class="line">y:852</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:96</span><br><span class="line">x:743</span><br><span class="line">y:8521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:74</span><br><span class="line">y:8521</span><br><span class="line">z:963</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:852</span><br><span class="line">z:963</span><br><span class="line">x:741</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:85</span><br><span class="line">x:741</span><br><span class="line">z:9632</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:74</span><br><span class="line">y:85</span><br><span class="line">z:96321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:7</span><br><span class="line">z:96321</span><br><span class="line">y:854</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9632</span><br><span class="line">x:7</span><br><span class="line">y:8541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:963</span><br><span class="line">y:8541</span><br><span class="line">x:72</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:854</span><br><span class="line">z:963</span><br><span class="line">x:721</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:96</span><br><span class="line">x:721</span><br><span class="line">y:8543</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:72</span><br><span class="line">y:8543</span><br><span class="line">z:961</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:7</span><br><span class="line">z:961</span><br><span class="line">y:85432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:96</span><br><span class="line">x:7</span><br><span class="line">y:854321</span><br><span class="line"></span><br><span class="line">move 6 from z to x</span><br><span class="line">z:9</span><br><span class="line">y:854321</span><br><span class="line">x:76</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:85432</span><br><span class="line">z:9</span><br><span class="line">x:761</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:8543</span><br><span class="line">x:761</span><br><span class="line">z:92</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:76</span><br><span class="line">y:8543</span><br><span class="line">z:921</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:854</span><br><span class="line">z:921</span><br><span class="line">x:763</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:92</span><br><span class="line">x:763</span><br><span class="line">y:8541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:9</span><br><span class="line">y:8541</span><br><span class="line">x:7632</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:854</span><br><span class="line">z:9</span><br><span class="line">x:76321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:85</span><br><span class="line">x:76321</span><br><span class="line">z:94</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7632</span><br><span class="line">y:85</span><br><span class="line">z:941</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:763</span><br><span class="line">z:941</span><br><span class="line">y:852</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:94</span><br><span class="line">x:763</span><br><span class="line">y:8521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:76</span><br><span class="line">y:8521</span><br><span class="line">z:943</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:852</span><br><span class="line">z:943</span><br><span class="line">x:761</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:85</span><br><span class="line">x:761</span><br><span class="line">z:9432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:76</span><br><span class="line">y:85</span><br><span class="line">z:94321</span><br><span class="line"></span><br><span class="line">move 5 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:94321</span><br><span class="line">x:765</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9432</span><br><span class="line">x:765</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:943</span><br><span class="line">y:81</span><br><span class="line">x:7652</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:943</span><br><span class="line">x:76521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:94</span><br><span class="line">x:76521</span><br><span class="line">y:83</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7652</span><br><span class="line">y:83</span><br><span class="line">z:941</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:765</span><br><span class="line">z:941</span><br><span class="line">y:832</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:94</span><br><span class="line">x:765</span><br><span class="line">y:8321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:9</span><br><span class="line">y:8321</span><br><span class="line">x:7654</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:832</span><br><span class="line">z:9</span><br><span class="line">x:76541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:83</span><br><span class="line">x:76541</span><br><span class="line">z:92</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7654</span><br><span class="line">y:83</span><br><span class="line">z:921</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:921</span><br><span class="line">x:76543</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:92</span><br><span class="line">x:76543</span><br><span class="line">y:81</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:9</span><br><span class="line">y:81</span><br><span class="line">x:765432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:8</span><br><span class="line">z:9</span><br><span class="line">x:7654321</span><br><span class="line"></span><br><span class="line">move 8 from y to z</span><br><span class="line">y:</span><br><span class="line">x:7654321</span><br><span class="line">z:98</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:765432</span><br><span class="line">y:</span><br><span class="line">z:981</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:76543</span><br><span class="line">z:981</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:98</span><br><span class="line">x:76543</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:7654</span><br><span class="line">y:21</span><br><span class="line">z:983</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:983</span><br><span class="line">x:76541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:76541</span><br><span class="line">z:9832</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7654</span><br><span class="line">y:</span><br><span class="line">z:98321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:765</span><br><span class="line">z:98321</span><br><span class="line">y:4</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9832</span><br><span class="line">x:765</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:983</span><br><span class="line">y:41</span><br><span class="line">x:7652</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:983</span><br><span class="line">x:76521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:98</span><br><span class="line">x:76521</span><br><span class="line">y:43</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7652</span><br><span class="line">y:43</span><br><span class="line">z:981</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:765</span><br><span class="line">z:981</span><br><span class="line">y:432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:98</span><br><span class="line">x:765</span><br><span class="line">y:4321</span><br><span class="line"></span><br><span class="line">move 5 from x to z</span><br><span class="line">x:76</span><br><span class="line">y:4321</span><br><span class="line">z:985</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:432</span><br><span class="line">z:985</span><br><span class="line">x:761</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:43</span><br><span class="line">x:761</span><br><span class="line">z:9852</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:76</span><br><span class="line">y:43</span><br><span class="line">z:98521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:98521</span><br><span class="line">x:763</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9852</span><br><span class="line">x:763</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:985</span><br><span class="line">y:41</span><br><span class="line">x:7632</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:985</span><br><span class="line">x:76321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:</span><br><span class="line">x:76321</span><br><span class="line">z:9854</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7632</span><br><span class="line">y:</span><br><span class="line">z:98541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:763</span><br><span class="line">z:98541</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9854</span><br><span class="line">x:763</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:76</span><br><span class="line">y:21</span><br><span class="line">z:98543</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:98543</span><br><span class="line">x:761</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:761</span><br><span class="line">z:985432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:76</span><br><span class="line">y:</span><br><span class="line">z:9854321</span><br><span class="line"></span><br><span class="line">move 6 from x to y</span><br><span class="line">x:7</span><br><span class="line">z:9854321</span><br><span class="line">y:6</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:985432</span><br><span class="line">x:7</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:98543</span><br><span class="line">y:61</span><br><span class="line">x:72</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:98543</span><br><span class="line">x:721</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:9854</span><br><span class="line">x:721</span><br><span class="line">y:63</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:72</span><br><span class="line">y:63</span><br><span class="line">z:98541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:7</span><br><span class="line">z:98541</span><br><span class="line">y:632</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9854</span><br><span class="line">x:7</span><br><span class="line">y:6321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:985</span><br><span class="line">y:6321</span><br><span class="line">x:74</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:632</span><br><span class="line">z:985</span><br><span class="line">x:741</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:63</span><br><span class="line">x:741</span><br><span class="line">z:9852</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:74</span><br><span class="line">y:63</span><br><span class="line">z:98521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:98521</span><br><span class="line">x:743</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9852</span><br><span class="line">x:743</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:985</span><br><span class="line">y:61</span><br><span class="line">x:7432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:985</span><br><span class="line">x:74321</span><br><span class="line"></span><br><span class="line">move 5 from z to y</span><br><span class="line">z:98</span><br><span class="line">x:74321</span><br><span class="line">y:65</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:7432</span><br><span class="line">y:65</span><br><span class="line">z:981</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:743</span><br><span class="line">z:981</span><br><span class="line">y:652</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:98</span><br><span class="line">x:743</span><br><span class="line">y:6521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:74</span><br><span class="line">y:6521</span><br><span class="line">z:983</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:652</span><br><span class="line">z:983</span><br><span class="line">x:741</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:65</span><br><span class="line">x:741</span><br><span class="line">z:9832</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:74</span><br><span class="line">y:65</span><br><span class="line">z:98321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:7</span><br><span class="line">z:98321</span><br><span class="line">y:654</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9832</span><br><span class="line">x:7</span><br><span class="line">y:6541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:983</span><br><span class="line">y:6541</span><br><span class="line">x:72</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:654</span><br><span class="line">z:983</span><br><span class="line">x:721</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:98</span><br><span class="line">x:721</span><br><span class="line">y:6543</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:72</span><br><span class="line">y:6543</span><br><span class="line">z:981</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:7</span><br><span class="line">z:981</span><br><span class="line">y:65432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:98</span><br><span class="line">x:7</span><br><span class="line">y:654321</span><br><span class="line"></span><br><span class="line">move 7 from x to z</span><br><span class="line">x:</span><br><span class="line">y:654321</span><br><span class="line">z:987</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:65432</span><br><span class="line">z:987</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:6543</span><br><span class="line">x:1</span><br><span class="line">z:9872</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:6543</span><br><span class="line">z:98721</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:654</span><br><span class="line">z:98721</span><br><span class="line">x:3</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9872</span><br><span class="line">x:3</span><br><span class="line">y:6541</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:987</span><br><span class="line">y:6541</span><br><span class="line">x:32</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:654</span><br><span class="line">z:987</span><br><span class="line">x:321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:65</span><br><span class="line">x:321</span><br><span class="line">z:9874</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:32</span><br><span class="line">y:65</span><br><span class="line">z:98741</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:3</span><br><span class="line">z:98741</span><br><span class="line">y:652</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9874</span><br><span class="line">x:3</span><br><span class="line">y:6521</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:</span><br><span class="line">y:6521</span><br><span class="line">z:98743</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:652</span><br><span class="line">z:98743</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:65</span><br><span class="line">x:1</span><br><span class="line">z:987432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:65</span><br><span class="line">z:9874321</span><br><span class="line"></span><br><span class="line">move 5 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:9874321</span><br><span class="line">x:5</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:987432</span><br><span class="line">x:5</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:98743</span><br><span class="line">y:61</span><br><span class="line">x:52</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:98743</span><br><span class="line">x:521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:9874</span><br><span class="line">x:521</span><br><span class="line">y:63</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:52</span><br><span class="line">y:63</span><br><span class="line">z:98741</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:5</span><br><span class="line">z:98741</span><br><span class="line">y:632</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9874</span><br><span class="line">x:5</span><br><span class="line">y:6321</span><br><span class="line"></span><br><span class="line">move 4 from z to x</span><br><span class="line">z:987</span><br><span class="line">y:6321</span><br><span class="line">x:54</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:632</span><br><span class="line">z:987</span><br><span class="line">x:541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:63</span><br><span class="line">x:541</span><br><span class="line">z:9872</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:54</span><br><span class="line">y:63</span><br><span class="line">z:98721</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:98721</span><br><span class="line">x:543</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9872</span><br><span class="line">x:543</span><br><span class="line">y:61</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:987</span><br><span class="line">y:61</span><br><span class="line">x:5432</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:6</span><br><span class="line">z:987</span><br><span class="line">x:54321</span><br><span class="line"></span><br><span class="line">move 6 from y to z</span><br><span class="line">y:</span><br><span class="line">x:54321</span><br><span class="line">z:9876</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:5432</span><br><span class="line">y:</span><br><span class="line">z:98761</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:543</span><br><span class="line">z:98761</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9876</span><br><span class="line">x:543</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:54</span><br><span class="line">y:21</span><br><span class="line">z:98763</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:98763</span><br><span class="line">x:541</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:541</span><br><span class="line">z:987632</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:54</span><br><span class="line">y:</span><br><span class="line">z:9876321</span><br><span class="line"></span><br><span class="line">move 4 from x to y</span><br><span class="line">x:5</span><br><span class="line">z:9876321</span><br><span class="line">y:4</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:987632</span><br><span class="line">x:5</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:98763</span><br><span class="line">y:41</span><br><span class="line">x:52</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:98763</span><br><span class="line">x:521</span><br><span class="line"></span><br><span class="line">move 3 from z to y</span><br><span class="line">z:9876</span><br><span class="line">x:521</span><br><span class="line">y:43</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:52</span><br><span class="line">y:43</span><br><span class="line">z:98761</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:5</span><br><span class="line">z:98761</span><br><span class="line">y:432</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:9876</span><br><span class="line">x:5</span><br><span class="line">y:4321</span><br><span class="line"></span><br><span class="line">move 5 from x to z</span><br><span class="line">x:</span><br><span class="line">y:4321</span><br><span class="line">z:98765</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:432</span><br><span class="line">z:98765</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:43</span><br><span class="line">x:1</span><br><span class="line">z:987652</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:43</span><br><span class="line">z:9876521</span><br><span class="line"></span><br><span class="line">move 3 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:9876521</span><br><span class="line">x:3</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:987652</span><br><span class="line">x:3</span><br><span class="line">y:41</span><br><span class="line"></span><br><span class="line">move 2 from z to x</span><br><span class="line">z:98765</span><br><span class="line">y:41</span><br><span class="line">x:32</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:4</span><br><span class="line">z:98765</span><br><span class="line">x:321</span><br><span class="line"></span><br><span class="line">move 4 from y to z</span><br><span class="line">y:</span><br><span class="line">x:321</span><br><span class="line">z:987654</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:32</span><br><span class="line">y:</span><br><span class="line">z:9876541</span><br><span class="line"></span><br><span class="line">move 2 from x to y</span><br><span class="line">x:3</span><br><span class="line">z:9876541</span><br><span class="line">y:2</span><br><span class="line"></span><br><span class="line">move 1 from z to y</span><br><span class="line">z:987654</span><br><span class="line">x:3</span><br><span class="line">y:21</span><br><span class="line"></span><br><span class="line">move 3 from x to z</span><br><span class="line">x:</span><br><span class="line">y:21</span><br><span class="line">z:9876543</span><br><span class="line"></span><br><span class="line">move 1 from y to x</span><br><span class="line">y:2</span><br><span class="line">z:9876543</span><br><span class="line">x:1</span><br><span class="line"></span><br><span class="line">move 2 from y to z</span><br><span class="line">y:</span><br><span class="line">x:1</span><br><span class="line">z:98765432</span><br><span class="line"></span><br><span class="line">move 1 from x to z</span><br><span class="line">x:</span><br><span class="line">y:</span><br><span class="line">z:987654321</span><br></pre></td></tr></table></figure><p>显然这是一个递归函数，在函数的执行函数中，需多次进行自我调用。那么，这个递归函数是如何执行的？</p><p>先看任意两个函数之间进行调用的情形：<br>与汇编程序中主程序和子程序之间的链接及信息交换相类似，在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需通过栈来执行。</p><p>通常，当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成3件事：<br>1.将所有的实在参数、返回地址等信息传递给被调用函数保存。<br>2.为被调用函数的局部变量分配存储区。<br>3.将控制转移到被调函数入口。</p><p>而从被调用函数返回调用函数之前，系统也完成3件事：<br>1.保存被调函数的计算结果。<br>2.释放被调函数的数据区。<br>3.依照被调函数保存的返回地址将控制转移到调用函数。</p><p>当有多个函数构成嵌套调用时，按照“后调用先返回”的原则，上述函数之间的信息传递和控制转移必须通过”栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，每当从一个函数退出时，就释放它的存储区，则当前正运行的函数的数据区必在栈顶。</p><p>以下代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int first(int s, int t);</span><br><span class="line">int second(int d);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int m,n;</span><br><span class="line">    ...</span><br><span class="line">    first(m,n);</span><br><span class="line">    1:...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int first(int s, int t)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ...</span><br><span class="line">    second(i);</span><br><span class="line">    2:...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int second(int d)&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数main中调用了函数first，而在函数first中又调用了函数second，<br>下图展示了当前正在执行函数second中某个语句时栈的状态，图中1，2表示返回地址：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-a2fc8210454137f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>下图展示了从函数second退出之后正执行函数first中某个语句时栈的状态，图中1表示返回地址：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-779ec3b0326d0479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数，因此，和每次调用相关的一个重要概念是递归函数运行的“层次”：<br>假设调用该递归函数的主函数为第0层，<br>则从主函数调用递归函数为进入第1层；<br>从第i层递归调用本函数为进入“下一层”，即第i+1层。<br>反之，退出第i层递归应返回至上一层。</p><p>为了保证递归函数正确执行，系统需设立一个”递归工作栈”作为整个递归函数运行期间使用的数据存储区。<br>每一层递归所需信息构成一个“工作记录”，其中包括所有的实在参数、所有的局部变量以及上一层返回的地址。<br>每进入一层递归，就产生一个新的工作记录压入栈顶。<br>每退出一层递归，就从栈顶弹出一个工作记录，则当前执行层的工作记录必是递归工作栈栈顶的工作记录，称这个记录为“活动记录”，并称指示活动记录的栈顶指针为“当前环境指针”。</p><p>由于递归函数结构清晰，程序易读，而且它的正确性容易得到证明，因此，利用允许递归调用的语言进行程序设计时，给用户编制程序带来很大方便。因为对这样一类递归问题编程时，不需要用户自己而由系统来管理递归工作栈。</p><h4 id="理解递归"><a href="#理解递归" class="headerlink" title="理解递归"></a>理解递归</h4><p>在初学递归的时候, 看到一个递归实现, 我们总是难免陷入不停的回溯验证之中, 因为回溯就像反过来思考迭代, 这是我们习惯的思维方式, 但是实际上递归不需要这样来验证。<br>比如, 阶乘的计算：<br>阶乘的定义: “一个正整数的阶乘（英语：factorial）是所有小于或等于该数的正整数的积，并且0的阶乘为1。”<br>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Fact(int n)&#123;</span><br><span class="line">    if(n&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return n * Fact(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们怎么判断这个阶乘的递归计算是否是正确的呢?<br>回溯的思考方式是这么验证的, 比如当n &#x3D; 4时, 那么Fact(4)等于4 *Fact(3), 而Fact(3)等于3 * Fact(2), Fact(2)等于2 * Fact(1), 等于2 * 1, 所以Fact(4)等于4 * 3 * 2 * 1. 这个结果正好等于阶乘4的迭代定义。<br>用回溯的方式思考虽然可以验证当n &#x3D; 某个较小数值是否正确, 但是其实无益于理解。</p><p>Paul Graham提到一种验证方法：<br><strong>当n&#x3D;0, 1的时候, 结果正确，<br>假设函数对于n是正确的, 函数对n+1结果也正确，<br>如果这两点是成立的，我们知道这个函数对于所有可能的n都是正确的。</strong><br>这种方法很像数学归纳法, 也是递归正确的思考方式。</p><h4 id="如何找到一个适用递归算法的问题"><a href="#如何找到一个适用递归算法的问题" class="headerlink" title="如何找到一个适用递归算法的问题"></a>如何找到一个适用递归算法的问题</h4><p>上面讲了怎么理解递归是正确的, 同时可以看到在有递归算法描述后, 其实程序很容易写, 那么最关键的问题就是, 我们怎么找到一个问题的递归算法呢?</p><p>Paul Graham提到, 你只需要做两件事情:<br><strong>你必须要示范如何解决问题的一般情况, 通过将问题切分成有限小并更小的子问题。<br>你必须要示范如何通过有限的步骤, 来解决最小的问题(基本用例)。</strong><br>如果这两件事完成了, 那问题就解决了。因为递归每次都将问题变得更小, 而一个有限的问题终究会被解决的, 而最小的问题仅需几个有限的步骤就能解决。</p><h4 id="在什么情况下用递归"><a href="#在什么情况下用递归" class="headerlink" title="在什么情况下用递归"></a>在什么情况下用递归</h4><p>递归并不一定适用所有情况, 很多情况用迭代远远比用递归好了解；其次, 相对来说, 递归的效率往往要低于迭代的实现，同时, 内存消耗也会更大。</p><p>以上面的阶乘算法为例，如果n &#x3D; 100，很显然这段程序需要递归地调用自身100次。这样调用深度至少就到了100。栈的大小是有限的，当n变的更大时，有朝一日总会使得栈溢出，从而程序崩溃。除此之外，每次函数调用的开销会导致程序变慢。所以说这段程序十分不好。</p><p>什么是好的递归：<strong>如果递归能够将问题的规模缩小，那就是好的递归。</strong></p><p>怎样才算是规模缩小了呢。举个例子，比如要在一个有序数组中查找一个数，最简单直观的算法就是从头到尾遍历一遍数组，这样一定可以找到那个数。如果数组的大小是N，那么我们最坏情况下需要比较N次，所以这个算法的复杂度记为O(N)。有一个大名鼎鼎的算法叫二分法，它的表达也很简单，由于数组是有序的，那么找的时候就从数组的中间开始找，如果要找的数比中间的数大，那么接着查找数组的后半部分(如果是升序的话)，以此类推，知道最后找到我们要找的数。稍微思考一下可以发现，如果数组的大小是N，那么最坏情况下我们需要比较logN次(计算机世界中log的底几乎总是2)，所以这个算法的复杂度为O(logN)。</p><p>简单的分析一下二分法为什么会快。可以发现二分法在每次比较之后都帮我们排除了一半的错误答案，接下去的一次只需要搜索剩下的一半，这就是说问题的规模缩小了一半。而在直观的算法中，每次比较后最多排除了一个错误的答案，问题的规模几乎没有缩小(仅仅减少了1)。这样的递归就稍微像样点了。</p><p>重新看阶乘的递归，每次递归后问题并没有本质上的减小(仅仅减小1)，这和简单的循环没有区别，但循环没有函数调用的开销，也不会导致栈溢出。所以结论是如果仅仅用递归来达到循环的效果，那还是改用循环吧。</p><p>总结一下，递归的意义就在于将问题的规模缩小，并且缩小后问题并没有发生变化(二分法中，缩小后依然是从数组中寻找某一个数)，这样就可以继续调用自身来完成接下来的任务。我们不用写很长的程序，就能得到一个十分优雅快速的实现。</p><h4 id="如何写递归"><a href="#如何写递归" class="headerlink" title="如何写递归"></a>如何写递归</h4><p>以二分查找算法为例子，首先给出函数原型，返回值是元素在数组中的位置，如果查找失败返回-1。：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int *array,int start,int end,int num_wanted)</span><br></pre></td></tr></table></figure><p><strong>1.基准情况</strong><br>基准情况其实就是递归的终止条件。其实在实际中，这是十分容易确定的。例如在二分查找中，终止条件就是找到了我们想要的数或者搜索完了整个数组(查找失败)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(end &lt; start)&#123;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;else if(num_wanted == array[middle])&#123;</span><br><span class="line">    return middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.不断演进</strong><br>演进的过程就是我们思考的过程，二分查找中，就是继续查找剩下的一半数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(num_wanted &gt; array[middle])&#123;</span><br><span class="line">    index = binarySearch(array,middle + 1,end,num_wanted);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    index = binarySearch(array,start,middle - 1,num_wanted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.用人的思考方式设计</strong><br>这条法则我认为是非常重要的，它不会出现在编码中，但却是理解递归的一条捷径。它的意思是说，在一般的编程实践中，我们通常需要用大脑模拟电脑执行每一条语句，从而确定编码的正确性，然而在递归编码中这是不需要的。递归编码的过程中，只需要知道前两条法则就够了。之后我们就会看到这条法则的如何工作的了。<br><strong>4. 不要做重复的事情</strong><br>在任何编码中，这都是不应该出现的事情，但是在递归中这更加可怕，可能由于一次多余的递归使得算法增加数级复杂度。</p><p>完整的二分法的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int *array,int start,int end,int num_wanted)&#123;</span><br><span class="line">    int middle = (end - start)/2 + start; //1</span><br><span class="line">    int index;</span><br><span class="line">    if(end &lt; start)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else if(num_wanted == array[middle])&#123;</span><br><span class="line">        return middle;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num_wanted &gt; array[middle])&#123;</span><br><span class="line">        index = binarySearch(array,middle + 1,end,num_wanted); //2</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        index = binarySearch(array,start,middle - 1,num_wanted); //3</span><br><span class="line">    &#125;</span><br><span class="line">    return index; //4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中除了1和4都已经在前两条法则的实现中了。<br>1不必多说，4是一个比较关键的步骤，经常容易被忘记。<br>这里就用到第3条法则，编写的时候只要认为2或者3一定会正确运行，并且立刻返回，<br>不要考虑2和3内部是如何运行的，因为这就是你现在在编写的。<br>这样4该如何处理就是显而易见的了，在这里只需要将找到的index返回就可以了。</p><p>第4条法则在这个例子里并没有出现，我们可以看一下斐波那契数列的递归实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long int fib(int n)&#123;</span><br><span class="line">    if(n &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return fib(n-1) + fib(n-2); // 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看之下，这段程序很精练，它也是一段正确的递归程序，有基准条件、不断推进。但是如果仔细分析一下它的复杂度可以发现，如果我们取n&#x3D;N，那么每次fib调用会增加额外的2次fib调用(在1处)，即fib的运行时间T(N) &#x3D; T(N-1) + T(N-2)，可以得到其复杂度是O(2^N)，几乎是可见的复杂度最大的程序了。</p><p>所以如果在一个递归程序中重复多次地调用自身，又不缩小问题的规模，通常不是个好主意。</p><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>到此其实你已经可以写出任何一个完整的递归程序了，虽然上面的例子比较简单，但是方法总是这样的。</p><p>不过我们可以对递归程序再进一步分析。二分查找的递归算法中我们注意到<strong>在递归调用之后仅仅是返回了其返回值</strong>，这样的递归称作<strong>尾递归</strong>。</p><p>尽管在编写的时候不必考虑递归的调用顺序，但真正运行的时候，递归的函数调用过程可以分为递和归两部分。<br>在递归调用之前的部分称作递，调用之后的部分称作归。</p><p>而尾递归在归的过程中实际上不做任何事情，对于这种情况可以很方便的将这个递归程序转化为非递归程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int *array,int start,int end,int num_wanted)&#123;</span><br><span class="line">    int middle;</span><br><span class="line">search:</span><br><span class="line">    middle = (end - start)/2 + start;</span><br><span class="line">    if(end &lt; start)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else if(num_wanted == array[middle])&#123;</span><br><span class="line">        return middle;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num_wanted &gt; array[middle])&#123;</span><br><span class="line">        start = middle+1;</span><br><span class="line">        end = end;</span><br><span class="line">        goto search;</span><br><span class="line">        //index = binary_search(array, middle+1, end, num_wanted);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        start = start;</span><br><span class="line">        end = middle-1;</span><br><span class="line">        goto search;</span><br><span class="line">        //index = binary_search(array, start, middle-1, num_wanted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是去除递归后的二分查找的程序，我们只需要在程序开头处加上一个标号，在原本递归调用处修改参数的值并goto到标号就能完成这个工作。</p><p>事实上，如果你写出了一个尾递归程序，在编译的时候编译器很可能就这样帮你优化了。当然这样的程序非常不符合我们的习惯，它实际上是将递归转化为了循环。</p><p>循环还是应当使用while或者for实现，仔细地将上面这段程序改成while循环就成了这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int *array,int start,int end,int num_wanted)&#123;</span><br><span class="line">    int middle = (end - start)/2 + start;</span><br><span class="line">    while(end &gt;= start &amp;&amp; num_wanted != array[middle])&#123;</span><br><span class="line">        if(num_wanted &gt; array[middle])&#123;</span><br><span class="line">            start = middle+1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            end = middle-1;</span><br><span class="line">        &#125;</span><br><span class="line">        middle = (end - start)/2 + start;</span><br><span class="line">    &#125;</span><br><span class="line">    if(end &lt; start)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return middle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就更加符合我们的习惯了，它比递归的版本速度略有提高，最重要的是不会导致栈溢出。</p><p>部分内容摘自<a href="https://blog.csdn.net/u010697982/article/details/45875913">怎么写一个递归程序</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈的应用五：表达式求值</title>
      <link href="/2018/09/01/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%BA%94%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2018/09/01/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%BA%94%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>这里介绍一种简单直观的“算符优先法”。</p><p>要对一个表达式求值，首先要能够正确解释表达式。<br>例如，要求对下面的算术表达式求值：<br>4+2*3-10&#x2F;5</p><span id="more"></span><p>首先要了解算术四则运算的规则。即：<br>(1)先乘除，后加减<br>(2)从左算到右<br>(3)先括号内，后括号外。</p><p>由此，这个算术表达式的计算顺序应为：<br>4 + 2 * 3 - 10 &#x2F; 5 &#x3D; 4 + 6 - 10 &#x2F; 5 &#x3D; 10 - 10 &#x2F; 5 &#x3D; 10 - 2 &#x3D;8</p><p>算符优先法就是根据这个运算关系的规定来实现对表达式的编译或解释执行的。<br>任何一个表达式都是由操作数(operand)、运算符(operator)和界限符(delimiter)组成的。<br>一般的，操作数既可以是常数也可以是被说明为变量或常量的标识符；<br>运算符可以分为算术运算符、关系运算符和逻辑运算符3类；<br>基本界限符有左右括号和表达式结束符等。</p><p>我们把运算符和界限符统称为算符，他们构成的集合命名为OP。根据上述3条运算规则，在运算的每一步中，任意两个相继出现的算符a和b之间的优先关系至多是下面三种关系之一：<br>a&lt;b：a的优先级低于b<br>a&#x3D;b：a的优先级等于b<br>a&gt;b：a的优先级大于b</p><p>下表给出了部分a、b运算符之间的优先级关系（列为a运算符，行为b运算符）：</p><table><thead><tr><th></th><th>+</th><th>-</th><th>*</th><th>&#x2F;</th><th>%</th><th>(</th><th>)</th></tr></thead><tbody><tr><td>+</td><td>&gt;</td><td>&gt;</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&gt;</td></tr><tr><td>-</td><td>&gt;</td><td>&gt;</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&gt;</td></tr><tr><td>*</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&lt;</td><td>&gt;</td></tr><tr><td>&#x2F;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&lt;</td><td>&gt;</td></tr><tr><td>%</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&lt;</td><td>&gt;</td></tr><tr><td>(</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&lt;</td><td>&#x3D;</td></tr><tr><td>)</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>&gt;</td><td>N</td><td>N</td></tr></tbody></table><p>表达式中的‘&#x3D;’表示当左右括号相遇时，括号内的运算完成，此时要把左右括号从表达式中及时脱离。<br>表达式中的’N’表示这种状态如果出现了，则表达式格式有误，一定是左右括号不匹配。</p><p>在代码中，我给出了上述7种运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char opetr_char[7]=&#123;&#x27;+&#x27;,&#x27;-&#x27;,&#x27;*&#x27;,&#x27;/&#x27;,&#x27;%&#x27;,&#x27;(&#x27;,&#x27;)&#x27;&#125;;</span><br></pre></td></tr></table></figure><p>首先是要判断一个字符属不属于运算符，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int isOpetrChar(char ch)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;7;i++)&#123;</span><br><span class="line">        if(ch ==  opetr_char[i]) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上表的优先级用一个char型的二维数组直观表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char opetr_priority[7][7]=&#123;</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;N&#x27;,&#x27;N&#x27;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么，比较两个运算符的优先级可以简单得出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char getOpetrPrior(char a,char b)&#123;</span><br><span class="line">    int i = isOpetrChar(a);</span><br><span class="line">    int j = isOpetrChar(b);</span><br><span class="line">    return opetr_priority[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现算符优先算法，可以使用两个栈，一个optr_stack，用于存放运算符，一个opnd_stack，用于存放操作数。<br>算法的核心思想是，依次读入表达式中每个字符，若是操作数则进opnd_stack，若是运算符则与optr_stack的栈顶操作符比较优先权后作相应操作，直至整个表达式求值完毕。</p><p>EvaluateExpression.c利用了前面的C封装的顺序栈对象    <a href="https://www.jianshu.com/p/a035666f4bed">用线性表表示的顺序栈</a></p><p>实现了输入表达式，显示每一步的计算过程，并输出最终结果的功能。<br>且支持表达式格式检测，支持多重括号结构、负数运算（‘-’号既可能为减号，也可能为负号）。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="EvaluateExpression-c文件"><a href="#EvaluateExpression-c文件" class="headerlink" title="EvaluateExpression.c文件"></a>EvaluateExpression.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line"></span><br><span class="line">char opetr_char[7]=&#123;&#x27;+&#x27;,&#x27;-&#x27;,&#x27;*&#x27;,&#x27;/&#x27;,&#x27;%&#x27;,&#x27;(&#x27;,&#x27;)&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">//operational character priority (a,b),operational character b after a.</span><br><span class="line">//   b: +  -  *  /  %  (  )</span><br><span class="line">// a:</span><br><span class="line">// +    &gt;  &gt;  &lt;  &lt;  &lt;  &lt;  &gt;</span><br><span class="line">// -    &gt;  &gt;  &lt;  &lt;  &lt;  &lt;  &gt;</span><br><span class="line">// *    &gt;  &gt;  &gt;  &gt;  &gt;  &lt;  &gt;</span><br><span class="line">// /    &gt;  &gt;  &gt;  &gt;  &gt;  &lt;  &gt;</span><br><span class="line">// %    &gt;  &gt;  &gt;  &gt;  &gt;  &lt;  &gt;</span><br><span class="line">// (    &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  =</span><br><span class="line">// )    &gt;  &gt;  &gt;  &gt;  &gt;  N  N</span><br><span class="line"></span><br><span class="line">char opetr_priority[7][7]=&#123;</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;&gt;&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;&gt;&#x27;,&#x27;N&#x27;,&#x27;N&#x27;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int isOpetrChar(char ch)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;7;i++)&#123;</span><br><span class="line">        if(ch ==  opetr_char[i]) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char getOpetrPrior(char a,char b)&#123;</span><br><span class="line">    int i = isOpetrChar(a);</span><br><span class="line">    int j = isOpetrChar(b);</span><br><span class="line">    return opetr_priority[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double my_pow(double a,int b)&#123;</span><br><span class="line">    int s = 0,i;</span><br><span class="line">    double r = 1;</span><br><span class="line">    if(b == 0) return 1;</span><br><span class="line">    if(b&lt;0)&#123;</span><br><span class="line">        b*=-1;</span><br><span class="line">        s = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0; i &lt; b; i++)&#123;</span><br><span class="line">        r *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    if(s) r = 1/r;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getOpndNumFromStack(LinearListStack *opnd_stack)&#123;</span><br><span class="line">    int num = 0,i = 0;</span><br><span class="line">    char elem;</span><br><span class="line">    if(opnd_stack-&gt;length(opnd_stack))&#123;</span><br><span class="line">        opnd_stack-&gt;pop(opnd_stack,&amp;elem);</span><br><span class="line">        if(elem == &#x27; &#x27;)&#123;</span><br><span class="line">            while(elem == &#x27; &#x27;)&#123;</span><br><span class="line">                if(opnd_stack-&gt;length(opnd_stack) == 0) break;//确保不会pop空栈</span><br><span class="line">                opnd_stack-&gt;pop(opnd_stack,&amp;elem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(elem != &#x27; &#x27;)&#123; //两个判断必须分开来写</span><br><span class="line">            while(elem != &#x27; &#x27; &amp;&amp; elem != &#x27;-&#x27;)&#123;</span><br><span class="line">                num += my_pow(10,i)*(elem - 0x30);</span><br><span class="line">                if(opnd_stack-&gt;length(opnd_stack) == 0) break; //确保不会pop空栈</span><br><span class="line">                opnd_stack-&gt;pop(opnd_stack,&amp;elem);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(elem == &#x27;-&#x27;)&#123; //如果是负号</span><br><span class="line">                num = -num;</span><br><span class="line">            &#125;else if(elem == &#x27; &#x27;)&#123;  //将移出的空格间隔符再补进去</span><br><span class="line">                opnd_stack-&gt;push(opnd_stack,&amp;elem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int operate(int number_a,char opetr_char,int number_b)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    switch(opetr_char)&#123;</span><br><span class="line">        case &#x27;+&#x27;:</span><br><span class="line">            result = number_a + number_b;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;-&#x27;:</span><br><span class="line">            result = number_a - number_b;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;*&#x27;:</span><br><span class="line">            result = number_a * number_b;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;/&#x27;:</span><br><span class="line">            result = number_a / number_b;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;%&#x27;:</span><br><span class="line">            result = number_a % number_b;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            result = number_b;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void pushResultToStack(LinearListStack *opnd_stack, int result)&#123;</span><br><span class="line">    char elem[10],n_elem;</span><br><span class="line">    int i = 0,index = 0;</span><br><span class="line">    if(result &lt; 0)&#123;</span><br><span class="line">        result = - result;</span><br><span class="line">        n_elem = &#x27;-&#x27;;</span><br><span class="line">        opnd_stack-&gt;push(opnd_stack,&amp;n_elem);</span><br><span class="line">    &#125;else if(result == 0)&#123;</span><br><span class="line">        n_elem = &#x27;0&#x27;;</span><br><span class="line">        opnd_stack-&gt;push(opnd_stack,&amp;n_elem);</span><br><span class="line">    &#125;</span><br><span class="line">    while(result &gt; 0)&#123;</span><br><span class="line">        elem[index] = (result % 10) + 0x30;</span><br><span class="line">        result /= 10;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=index;i&gt;0;i--)&#123;</span><br><span class="line">        opnd_stack-&gt;push(opnd_stack,&amp;elem[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinearListStack *evaluateExpression(char *str)&#123;</span><br><span class="line">    char elem,opetr_prior,opetr_char;</span><br><span class="line">    int cal_result = 0,number_a,number_b;</span><br><span class="line">    int num_before_flag = 0;</span><br><span class="line">    LinearListStack *optr_stack = InitLinearListStack(); //运算符栈</span><br><span class="line">    LinearListStack *opnd_stack = InitLinearListStack(); //操作数栈</span><br><span class="line">    while(*str != &#x27;\0&#x27;)&#123;</span><br><span class="line">        if(isOpetrChar(*str) != -1)&#123;</span><br><span class="line">            if(optr_stack-&gt;length(optr_stack))&#123;</span><br><span class="line">                optr_stack-&gt;getTop(optr_stack,&amp;elem);</span><br><span class="line">                opetr_prior = getOpetrPrior(elem,*str);</span><br><span class="line">                switch(opetr_prior)&#123;</span><br><span class="line">                    case &#x27;&lt;&#x27;: //栈顶运算符优先级低</span><br><span class="line">                        if(num_before_flag == 0)&#123; //前一个入栈的是符号</span><br><span class="line">                            if(*str == &#x27;-&#x27;)&#123; //此时&#x27;-&#x27;号表示为负号</span><br><span class="line">                                opnd_stack-&gt;push(opnd_stack,str);//&#x27;-&#x27;号加入操作数栈</span><br><span class="line">                                num_before_flag = 1; //加入的是数字</span><br><span class="line">                            &#125;else if(elem == &#x27;(&#x27; || *str == &#x27;(&#x27;)&#123; //多个括号与操作符相邻的情况</span><br><span class="line">                                optr_stack-&gt;push(optr_stack,str);  </span><br><span class="line">                                elem = &#x27; &#x27;; //数字字符加入空格间隔符</span><br><span class="line">                                opnd_stack-&gt;push(opnd_stack,&amp;elem);</span><br><span class="line">                                num_before_flag = 0;//加入运算符</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                printf(&quot;Expression format error!&quot;);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;else&#123; //前面有数字入栈</span><br><span class="line">                            optr_stack-&gt;push(optr_stack,str);  </span><br><span class="line">                            elem = &#x27; &#x27;; //数字字符加入空格间隔符</span><br><span class="line">                            opnd_stack-&gt;push(opnd_stack,&amp;elem);</span><br><span class="line">                            num_before_flag = 0;//加入运算符</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;=&#x27;:</span><br><span class="line">                        optr_stack-&gt;pop(optr_stack,&amp;elem);//脱括号</span><br><span class="line">                        num_before_flag = 1; //脱括号等效为加入的是数字</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;&gt;&#x27;: //栈顶运算符优先级高</span><br><span class="line">                        if(num_before_flag == 0)&#123; //前一个入栈的是符号</span><br><span class="line">                            if(*str == &#x27;-&#x27;)&#123; //此时&#x27;-&#x27;号表示为负号</span><br><span class="line">                                opnd_stack-&gt;push(opnd_stack,str);//&#x27;-&#x27;号加入操作数栈</span><br><span class="line">                                num_before_flag = 1; //加入的是数字</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                printf(&quot;Expression format error!&quot;);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;else&#123; //前一个入栈的是数字</span><br><span class="line">                            optr_stack-&gt;pop(optr_stack,&amp;opetr_char);//取运算符</span><br><span class="line">                            number_b = getOpndNumFromStack(opnd_stack);</span><br><span class="line">                            number_a = getOpndNumFromStack(opnd_stack);</span><br><span class="line">                            cal_result = operate(number_a,opetr_char,number_b);</span><br><span class="line">                            printf(&quot;%d&quot;,number_a);</span><br><span class="line">                            printf(&quot; %c &quot;,opetr_char);</span><br><span class="line">                            printf(&quot;%d = &quot;,number_b);</span><br><span class="line">                            printf(&quot;%d\n&quot;,cal_result);</span><br><span class="line">                            pushResultToStack(opnd_stack, cal_result);</span><br><span class="line">                            num_before_flag = 1; //加入的是数字</span><br><span class="line">                            str--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //第一个运算符，此时运算符栈是空的</span><br><span class="line">                if(num_before_flag == 0)&#123; //前面没有数字入栈</span><br><span class="line">                    if(*str == &#x27;-&#x27;)&#123; //此时&#x27;-&#x27;号表示为负号</span><br><span class="line">                        opnd_stack-&gt;push(opnd_stack,str);//&#x27;-&#x27;号加入操作数栈</span><br><span class="line">                        num_before_flag = 1; //加入的是数字</span><br><span class="line">                    &#125;else if(*str == &#x27;(&#x27;)&#123;</span><br><span class="line">                        optr_stack-&gt;push(optr_stack,str);  </span><br><span class="line">                        elem = &#x27; &#x27;; //数字字符加入空格间隔符</span><br><span class="line">                        opnd_stack-&gt;push(opnd_stack,&amp;elem);</span><br><span class="line">                        num_before_flag = 0;//加入运算符</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        printf(&quot;Expression format error!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123; //前面有数字入栈</span><br><span class="line">                    optr_stack-&gt;push(optr_stack,str);  </span><br><span class="line">                    elem = &#x27; &#x27;; //数字字符加入空格间隔符</span><br><span class="line">                    opnd_stack-&gt;push(opnd_stack,&amp;elem);</span><br><span class="line">                    num_before_flag = 0;//加入运算符</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(*str &gt;= 0x30 &amp;&amp; *str &lt;= 0x39)&#123;</span><br><span class="line">                opnd_stack-&gt;push(opnd_stack,str);</span><br><span class="line">                num_before_flag = 1; //加入的是数字</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*str == &#x27;\0&#x27;)&#123; //输入完成</span><br><span class="line">        while(optr_stack-&gt;length(optr_stack))&#123;</span><br><span class="line">            optr_stack-&gt;pop(optr_stack,&amp;opetr_char);//取运算符</span><br><span class="line">            if(isOpetrChar(opetr_char)&lt;5)&#123;</span><br><span class="line">                number_b = getOpndNumFromStack(opnd_stack);</span><br><span class="line">                number_a = getOpndNumFromStack(opnd_stack);</span><br><span class="line">                cal_result = operate(number_a,opetr_char,number_b);</span><br><span class="line">                printf(&quot;%d&quot;,number_a);</span><br><span class="line">                printf(&quot; %c &quot;,opetr_char);</span><br><span class="line">                printf(&quot;%d = &quot;,number_b);</span><br><span class="line">                printf(&quot;%d\n&quot;,cal_result);</span><br><span class="line">                pushResultToStack(opnd_stack, cal_result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(optr_stack);</span><br><span class="line">    return opnd_stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char string[1000];</span><br><span class="line">    LinearListStack *optr_result = NULL;</span><br><span class="line">    printf(&quot;please enter a expression:&quot;);</span><br><span class="line">    gets(string);</span><br><span class="line">    optr_result = evaluateExpression(string);</span><br><span class="line">    printf(&quot;%s = &quot;,string);</span><br><span class="line">    optr_result-&gt;risePrint(optr_result);</span><br><span class="line">    DestroyLinearListStack(optr_result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearListStack.c LinearListStack.h EvaluateExpression.c -o EvaluateExpression</span><br></pre></td></tr></table></figure><p>运行EvaluateExpression：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">please enter a expression:3+3+(4*5）</span><br><span class="line">3 + 3 = 6</span><br><span class="line">4 * 5 = 20</span><br><span class="line">6 + 20 = 26</span><br><span class="line">3+3+(4*5） = 26</span><br><span class="line"></span><br><span class="line">please enter a expression:-2+3+4*5</span><br><span class="line">-2 + 3 = 1</span><br><span class="line">4 * 5 = 20</span><br><span class="line">1 + 20 = 21</span><br><span class="line">-2+3+4*5 = 21</span><br><span class="line"></span><br><span class="line">please enter a expression:-2+(3+4)*-5</span><br><span class="line">3 + 4 = 7</span><br><span class="line">7 * -5 = -35</span><br><span class="line">-2 + -35 = -37</span><br><span class="line">-2+(3+4)*-5 = -37</span><br><span class="line"></span><br><span class="line">please enter a expression:3+3+((4*5))</span><br><span class="line">3 + 3 = 6</span><br><span class="line">4 * 5 = 20</span><br><span class="line">6 + 20 = 26</span><br><span class="line">3+3+((4*5)) = 26</span><br><span class="line"></span><br><span class="line">please enter a expression:-2+(3/4)*-5</span><br><span class="line">3 / 4 = 0</span><br><span class="line">0 * -5 = 0</span><br><span class="line">-2 + 0 = -2</span><br><span class="line">-2+(3/4)*-5 = -2</span><br><span class="line"></span><br><span class="line">please enter a expression:-2+(3%4)*-5</span><br><span class="line">3 % 4 = 3</span><br><span class="line">3 * -5 = -15</span><br><span class="line">-2 + -15 = -17</span><br><span class="line">-2+(3%4)*-5 = -17</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈的应用四：求解迷宫路径</title>
      <link href="/2018/08/31/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9B%9B%EF%BC%9A%E6%B1%82%E8%A7%A3%E8%BF%B7%E5%AE%AB%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/08/31/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9B%9B%EF%BC%9A%E6%B1%82%E8%A7%A3%E8%BF%B7%E5%AE%AB%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h4 id="迷宫求解"><a href="#迷宫求解" class="headerlink" title="迷宫求解"></a>迷宫求解</h4><p>求迷宫中从入口到出口的所有路径是一个典型的程序设计问题。由于计算机解迷宫时，通常用的是”穷举求解“的方法，即从入口出发，顺某一方向向前探索，若能走通，则继续往前走；否则沿原路退回，换一个方向再继续探索，直至所有可能的通路都探索到为止。</p><span id="more"></span><p>为了保证在任何位置上都能沿原路退回，显然需要用一个后进先出的结构来保存从入口到当前位置的路径。因此，在求迷宫通路的算法中应用’栈’也就是自然而然的事了。</p><p>迷宫在计算机中可以用一个二维数组来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int labyrinth[10][10]=&#123;</span><br><span class="line">    &#123;1,1,1,1,1,1,1,1,1,1&#125;,</span><br><span class="line">    &#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">    &#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">    &#123;1,0,0,0,0,1,1,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,1,1,1,0,0,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,0,0,1,0,0,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,1,0,0,0,1,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,1,1,1,0,1,1,0,1&#125;,</span><br><span class="line">    &#123;1,1,0,0,0,0,0,0,0,1&#125;,</span><br><span class="line">    &#123;1,1,1,1,1,1,1,1,1,1&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面给出的是一个10*10的二维数组，表示迷宫的长宽分别为10。其中，1表示墙，0表示通道。<br>(1,1)为起点，(8,8)为终点。我们可以在命令行中打印出迷宫的图形：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%c%c&quot;,0xa8, 0x80); //打印白色方块，表示墙</span><br><span class="line">printf(&quot;  &quot;);//打印空格，表示通道</span><br></pre></td></tr></table></figure><p>则上述的数组打印出迷宫为：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-1f4aebb323315929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="迷宫图形"></p><p>在迷宫中有上下左右四个方向，在此，我们以逆时针方向设定一个寻向的优先级：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>向下</td><td>向右</td><td>向上</td><td>向左</td></tr></tbody></table><p>LabyrinthAnalyze.c利用了前面的C封装的顺序栈对象    <a href="https://www.jianshu.com/p/a035666f4bed">用线性表表示的顺序栈</a></p><p>实现了上图展示的迷宫的路径求解问题，并把每一步都打印了出来。</p><p>在打印的迷宫图中，<br>**表示起点与终点；<br>oo表示足迹；<br>xx表示走过的死路的足迹。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="LabyrinthAnalyze-c文件"><a href="#LabyrinthAnalyze-c文件" class="headerlink" title="LabyrinthAnalyze.c文件"></a>LabyrinthAnalyze.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line"></span><br><span class="line">int labyrinth[10][10]=&#123;</span><br><span class="line">    &#123;1,1,1,1,1,1,1,1,1,1&#125;,</span><br><span class="line">    &#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">    &#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">    &#123;1,0,0,0,0,1,1,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,1,1,1,0,0,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,0,0,1,0,0,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,1,0,0,0,1,0,0,1&#125;,</span><br><span class="line">    &#123;1,0,1,1,1,0,1,1,0,1&#125;,</span><br><span class="line">    &#123;1,1,0,0,0,0,0,0,0,1&#125;,</span><br><span class="line">    &#123;1,1,1,1,1,1,1,1,1,1&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">void copyArray(int a[][10],int b[][10])&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;10;j++)&#123;</span><br><span class="line">            a[i][j] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printLabyrinth(int labyrinth[][10])&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    printf(&quot;The labyrinth is:\n\n&quot;);</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;10;j++)&#123;</span><br><span class="line">            if((i == 1 &amp;&amp; j == 1)||(i == 8 &amp;&amp; j == 8))&#123;</span><br><span class="line">                printf(&quot;**&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(labyrinth[i][j] == 1)&#123; </span><br><span class="line">                    printf(&quot;%c%c&quot;,0xa8, 0x80);</span><br><span class="line">                &#125;else if(labyrinth[i][j] == 0)&#123;</span><br><span class="line">                    printf(&quot;  &quot;);</span><br><span class="line">                &#125;else if(labyrinth[i][j] == 2)&#123;</span><br><span class="line">                    printf(&quot;oo&quot;);</span><br><span class="line">                &#125;else if(labyrinth[i][j] == 3)&#123;</span><br><span class="line">                    printf(&quot;xx&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void labyrinthPath(int labyrinth[][10])&#123;</span><br><span class="line">    int labyrinthpath[10][10]; //轨迹图</span><br><span class="line">    int current_step = 0; //当前步数</span><br><span class="line">    int start_i = 1,start_j = 1; //开始位置</span><br><span class="line">    int end_i = 8,end_j = 8; //结束位置</span><br><span class="line">    int current_i = start_i,current_j = start_j; //当前位置</span><br><span class="line">    int current_direction = 0; //0:向下、1：向右、2：向上、3：向左  逆时针旋转方向，数值小的优先级高</span><br><span class="line">    char stack_temp;</span><br><span class="line">    char stack_history_i,stack_history_j;</span><br><span class="line">    LinearListStack *stack_i = InitLinearListStack();</span><br><span class="line">    LinearListStack *stack_j = InitLinearListStack();</span><br><span class="line">    copyArray(labyrinthpath,labyrinth);</span><br><span class="line">    do&#123;</span><br><span class="line">        if(labyrinthpath[current_i][current_j] == 0)&#123; //未走过,且可以走</span><br><span class="line">            labyrinthpath[current_i][current_j] = 2; //留下足迹</span><br><span class="line">            stack_temp = (char)(current_i+0x30);</span><br><span class="line">            stack_i-&gt;push(stack_i,&amp;stack_temp);</span><br><span class="line">            stack_temp = (char)(current_j+0x30);</span><br><span class="line">            stack_j-&gt;push(stack_j,&amp;stack_temp);//加入路径</span><br><span class="line">            current_step ++;</span><br><span class="line">            printLabyrinth(labyrinthpath);</span><br><span class="line">            if(current_i == end_i &amp;&amp; current_j == end_j) break;//到达终点</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(stack_i-&gt;length(stack_i))&#123;</span><br><span class="line">                switch(current_direction)&#123;</span><br><span class="line">                    case 0: </span><br><span class="line">                        if(labyrinthpath[current_i + 1][current_j] == 0)&#123;</span><br><span class="line">                            stack_i-&gt;getTop(stack_i,&amp;stack_history_i);</span><br><span class="line">                            stack_j-&gt;getTop(stack_j,&amp;stack_history_j);</span><br><span class="line">                            if((stack_history_i != current_i+0x30)||(stack_history_j != current_j+0x30))&#123;</span><br><span class="line">                                stack_temp = (char)(current_i+0x30);</span><br><span class="line">                                stack_i-&gt;push(stack_i,&amp;stack_temp);</span><br><span class="line">                                stack_temp = (char)(current_j+0x30);</span><br><span class="line">                                stack_j-&gt;push(stack_j,&amp;stack_temp);//将移出的重新加入路径</span><br><span class="line">                            &#125;</span><br><span class="line">                            current_i++;//向下找</span><br><span class="line">                            current_direction = 0;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            current_direction = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case 1:</span><br><span class="line">                        if(labyrinthpath[current_i][current_j + 1] == 0)&#123;</span><br><span class="line">                            stack_i-&gt;getTop(stack_i,&amp;stack_history_i);</span><br><span class="line">                            stack_j-&gt;getTop(stack_j,&amp;stack_history_j);</span><br><span class="line">                            if((stack_history_i != current_i+0x30)||(stack_history_j != current_j+0x30))&#123;</span><br><span class="line">                                stack_temp = (char)(current_i+0x30);</span><br><span class="line">                                stack_i-&gt;push(stack_i,&amp;stack_temp);</span><br><span class="line">                                stack_temp = (char)(current_j+0x30);</span><br><span class="line">                                stack_j-&gt;push(stack_j,&amp;stack_temp);//将移出的重新加入路径</span><br><span class="line">                            &#125;</span><br><span class="line">                            current_j++; //向右找</span><br><span class="line">                            current_direction = 0;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            current_direction = 2;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case 2:</span><br><span class="line">                        if(labyrinthpath[current_i - 1][current_j] == 0)&#123;</span><br><span class="line">                            stack_i-&gt;getTop(stack_i,&amp;stack_history_i);</span><br><span class="line">                            stack_j-&gt;getTop(stack_j,&amp;stack_history_j);</span><br><span class="line">                            if((stack_history_i != current_i+0x30)||(stack_history_j != current_j+0x30))&#123;</span><br><span class="line">                                stack_temp = (char)(current_i+0x30);</span><br><span class="line">                                stack_i-&gt;push(stack_i,&amp;stack_temp);</span><br><span class="line">                                stack_temp = (char)(current_j+0x30);</span><br><span class="line">                                stack_j-&gt;push(stack_j,&amp;stack_temp);//将移出的重新加入路径</span><br><span class="line">                            &#125;</span><br><span class="line">                            current_i--;//向上找</span><br><span class="line">                            current_direction = 0;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            current_direction = 3;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case 3:</span><br><span class="line">                        if(labyrinthpath[current_i][current_j - 1] == 0)&#123;</span><br><span class="line">                            stack_i-&gt;getTop(stack_i,&amp;stack_history_i);</span><br><span class="line">                            stack_j-&gt;getTop(stack_j,&amp;stack_history_j);</span><br><span class="line">                            if((stack_history_i != current_i+0x30)||(stack_history_j != current_j+0x30))&#123;</span><br><span class="line">                                stack_temp = (char)(current_i+0x30);</span><br><span class="line">                                stack_i-&gt;push(stack_i,&amp;stack_temp);</span><br><span class="line">                                stack_temp = (char)(current_j+0x30);</span><br><span class="line">                                stack_j-&gt;push(stack_j,&amp;stack_temp);//将移出的重新加入路径</span><br><span class="line">                            &#125;</span><br><span class="line">                            current_j--;//向左找</span><br><span class="line">                            current_direction = 0;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            current_direction = 4;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    case 4://四周均不通</span><br><span class="line">                        if(labyrinthpath[current_i][current_j] != 1)&#123;</span><br><span class="line">                            labyrinthpath[current_i][current_j] = 3; //死路标记</span><br><span class="line">                            printLabyrinth(labyrinthpath);</span><br><span class="line">                        &#125;</span><br><span class="line">                        stack_i-&gt;pop(stack_i,&amp;stack_temp);</span><br><span class="line">                        current_i = (int)stack_temp-0x30;</span><br><span class="line">                        stack_j-&gt;pop(stack_j,&amp;stack_temp);</span><br><span class="line">                        current_j = (int)stack_temp-0x30;</span><br><span class="line">                        current_direction = 0;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;while(stack_i-&gt;length(stack_i));</span><br><span class="line">    if(stack_i-&gt;length(stack_i))&#123;</span><br><span class="line">        printf(&quot;Maze path:\n&quot;);</span><br><span class="line">        printf(&quot;i:&quot;);</span><br><span class="line">        stack_i-&gt;risePrint(stack_i);</span><br><span class="line">        printf(&quot;j:&quot;);</span><br><span class="line">        stack_j-&gt;risePrint(stack_j);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;No path found!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(stack_i);</span><br><span class="line">    DestroyLinearListStack(stack_j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    labyrinthPath(labyrinth);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearListStack.c LinearListStack.h LabyrinthAnalyze.c -o LabyrinthAnalyze</span><br></pre></td></tr></table></figure><p>运行LabyrinthAnalyze：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-6ecbbeb3184dfaf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第1步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-ffe66af74d604baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第2步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-b02d4c802fa21e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第3步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-5919ad9b8ebb87d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第4步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-6fc18bd6437607bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第5步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-9d54be185cc9ad32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第6步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-f397ae468452f316.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第7步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-f66171e77c3029ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第8步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-72345d526253bfa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第9步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-c808955308cbedfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第10步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-20fa193652f5cd40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第11步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-0d775f875ce1c66e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第12步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-f36ee749bbe47e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第13步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-ae4c2d2ab8eeb372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第14步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-53f0641f840bfe54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第15步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-ec7b75d38cdf68de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第16步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-9583b321177b3fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第17步"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-fbacefaceee9997b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第18步"><br>最后输出迷宫的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Maze path:</span><br><span class="line">i:123455566678888</span><br><span class="line">j:111112334555678</span><br></pre></td></tr></table></figure><p>i，j表示二维数组的下标[i][j],<br>该路径可以表示为：<br>(i,j):(1,1)-&gt;(2,1)-&gt;(3,1)-&gt;(4,1)-&gt;(5,1)-&gt;(5,2)-&gt;(5,3)-&gt;(6,3)-&gt;(6,4)-&gt;(6,5)-&gt;(7,5)-&gt;(8,5)-&gt;(8,6)-&gt;(8,7)-&gt;(8,8)</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈的应用三：行编辑</title>
      <link href="/2018/08/31/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%89%EF%BC%9A%E8%A1%8C%E7%BC%96%E8%BE%91/"/>
      <url>/2018/08/31/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%89%EF%BC%9A%E8%A1%8C%E7%BC%96%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h4 id="行编辑程序"><a href="#行编辑程序" class="headerlink" title="行编辑程序"></a>行编辑程序</h4><p>一个简单的行编辑程序的功能是：接收用户从终端输入的程序或数据，并存入用户的数据区。由于用户在终端上进行输入时，不能保证不出差错，因此若在编辑程序中，”每接收一个字符即存入用户数据区“的做法显然不是最恰当的。</p><span id="more"></span><p>较好的做法是，设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正，</p><p>例如，当用户发现刚刚键入的一个字符是错的时，可补进一个退格符‘#’，以表示前一个字符无效；如果发现当前键入的行内差错较多或难以补救，则可以键入一个退行符‘@’，以表示当前行中的字符均无效。</p><p>例如，假设从终端接收了这样两行字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whli##ilr#e(s#*s)</span><br><span class="line">  outcha@  putchar(*s=#++);</span><br></pre></td></tr></table></figure><p>则实际有效的是下列两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while(*s)</span><br><span class="line">  putchar(*s++);</span><br></pre></td></tr></table></figure><p>为此，可设这个输入缓冲区为一个栈结构，每当从终端接受了一个字符之后先作如下判别：<br>如果它既不是退格符‘#’，也不是退行符‘@’，则将该字符压入栈顶；<br>如果是一个退格符，则从栈顶删去一个字符；<br>如果是一个退行符，则将字符栈清为空栈。</p><p>LineEdit.c利用了前面的C封装的顺序栈对象    <a href="https://www.jianshu.com/p/a035666f4bed">用线性表表示的顺序栈</a><br>实现了简单的行编辑功能。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="LineEdit-c文件"><a href="#LineEdit-c文件" class="headerlink" title="LineEdit.c文件"></a>LineEdit.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line"></span><br><span class="line">void lineEdit()&#123;</span><br><span class="line">    char elem,ch;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    ch = getchar();</span><br><span class="line">    while(ch != EOF)&#123;</span><br><span class="line">        while(ch != EOF &amp;&amp; ch != &#x27;\n&#x27;)&#123;</span><br><span class="line">            switch(ch)&#123;</span><br><span class="line">                case &#x27;#&#x27;:</span><br><span class="line">                    if(stack-&gt;length(stack))&#123;</span><br><span class="line">                        stack-&gt;pop(stack,&amp;elem);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#x27;@&#x27;:</span><br><span class="line">                    stack-&gt;clear(stack);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    stack-&gt;push(stack,&amp;ch);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        stack-&gt;risePrint(stack);</span><br><span class="line">        stack-&gt;clear(stack);</span><br><span class="line">        if(ch != EOF) ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    lineEdit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearListStack.c LinearListStack.h LineEdit.c -o LineEdit</span><br></pre></td></tr></table></figure><p>运行LineEdit，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">whli##ilr#e(s# *s)</span><br><span class="line">while( *s)</span><br><span class="line">        put###outcha@   putchar( * s++);</span><br><span class="line">        putchar( * s++);</span><br><span class="line">hello@world</span><br><span class="line">world</span><br><span class="line">yhankou@123456##]</span><br><span class="line">1234]</span><br></pre></td></tr></table></figure><p>程序输入回车后进行下一行的输入，要想结束程序，需要输入EOF结束符。<br>在windows平台，EOF的输入是在一个新行的开头输入ctrl + z；<br>在unix环境下，EOF的输入是在一个新行的开头输入ctrl + d。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈的应用二：括号匹配的检验</title>
      <link href="/2018/08/31/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%BA%8C%EF%BC%9A%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E7%9A%84%E6%A3%80%E9%AA%8C/"/>
      <url>/2018/08/31/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%BA%8C%EF%BC%9A%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E7%9A%84%E6%A3%80%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>假设表达式中允许包含三种括号：圆括号( )、方括号[ ]和花括号{ }，其嵌套的顺序随意。<br>{ ( [ ] ( ) ) }或[ { ( [ ] [ ] ) } ]等为正确的格式，[ ( ] 、( [ ( ) ) 、( ( ) ]均为不正确的格式。</p><span id="more"></span><p>检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述。<br>例如考虑下列括号序列：</p><table><thead><tr><th>[</th><th>(</th><th>[</th><th>]</th><th>[</th><th>]</th><th>)</th><th>]</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr></tbody></table><p>当计算机接受了第一个括号后，它期待着与其匹配的第八个括号的出现，然而等来的却是第二个括号，此时第一个括号‘[’只能暂时靠边，而迫切等待与第二个括号相匹配的、第七个括号‘)’的出现…这个处理的过程与栈的特点相吻合。</p><p>由此，在算法中设置一个栈，每读入一个括号，若是右括号，则使置于栈顶的最急迫的期待得以消解，若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。另外，在算法的开始和结束时，栈都应该是空的。</p><p>BracketMatching.c利用了前面的C封装的顺序栈对象    <a href="https://www.jianshu.com/p/a035666f4bed">用线性表表示的顺序栈</a><br>实现了输入任意一串字符串，检测字符串中三种括号是否匹配的功能。</p><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="BracketMatching-c文件"><a href="#BracketMatching-c文件" class="headerlink" title="BracketMatching.c文件"></a>BracketMatching.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line"></span><br><span class="line">int bracketMatching(char *str)&#123;</span><br><span class="line">    char elem;</span><br><span class="line">    int result = 0;</span><br><span class="line">    int bracket_contained = 0;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    while(*str != &#x27;\0&#x27;)&#123;</span><br><span class="line">        if(*str == &#x27;&#123;&#x27; || *str == &#x27;[&#x27; || *str == &#x27;(&#x27;)&#123;</span><br><span class="line">            bracket_contained = 1;</span><br><span class="line">            stack-&gt;push(stack,str);</span><br><span class="line">        &#125;else if(*str == &#x27;&#125;&#x27;)&#123;</span><br><span class="line">            bracket_contained = 1;</span><br><span class="line">            if(stack-&gt;length(stack))&#123;</span><br><span class="line">                stack-&gt;getTop(stack,&amp;elem);</span><br><span class="line">                if(elem == &#x27;&#123;&#x27;)&#123;</span><br><span class="line">                    stack-&gt;pop(stack,&amp;elem);</span><br><span class="line">                &#125;else if(elem == &#x27;(&#x27;)&#123;</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;)\&#x27; expected! \n&quot;);</span><br><span class="line">                    DestroyLinearListStack(stack);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;else if(elem == &#x27;[&#x27;)&#123;</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;]\&#x27; expected! \n&quot;);</span><br><span class="line">                    DestroyLinearListStack(stack);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;Bracket matching failed : \&#x27;&#123;\&#x27; expected! \n&quot;);</span><br><span class="line">                DestroyLinearListStack(stack);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(*str == &#x27;]&#x27;)&#123;</span><br><span class="line">            bracket_contained = 1;</span><br><span class="line">            if(stack-&gt;length(stack))&#123;</span><br><span class="line">                stack-&gt;getTop(stack,&amp;elem);</span><br><span class="line">                if(elem == &#x27;[&#x27;)&#123;</span><br><span class="line">                    stack-&gt;pop(stack,&amp;elem);</span><br><span class="line">                &#125;else if(elem == &#x27;&#123;&#x27;)&#123;</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;&#125;\&#x27; expected! \n&quot;);</span><br><span class="line">                    DestroyLinearListStack(stack);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;else if(elem == &#x27;(&#x27;)&#123;</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;)\&#x27; expected! \n&quot;);</span><br><span class="line">                    DestroyLinearListStack(stack);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;Bracket matching failed : \&#x27;[\&#x27; expected! \n&quot;);</span><br><span class="line">                DestroyLinearListStack(stack);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(*str == &#x27;)&#x27;)&#123;</span><br><span class="line">            bracket_contained = 1;</span><br><span class="line">            if(stack-&gt;length(stack))&#123;</span><br><span class="line">                stack-&gt;getTop(stack,&amp;elem);</span><br><span class="line">                if(elem == &#x27;(&#x27;)&#123;</span><br><span class="line">                    stack-&gt;pop(stack,&amp;elem);</span><br><span class="line">                &#125;else if(elem == &#x27;[&#x27;)&#123;</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;]\&#x27; expected! \n&quot;);</span><br><span class="line">                    DestroyLinearListStack(stack);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;else if(elem == &#x27;&#123;&#x27;)&#123;</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;&#125;\&#x27; expected! \n&quot;);</span><br><span class="line">                    DestroyLinearListStack(stack);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;Bracket matching failed : \&#x27;(\&#x27; expected! \n&quot;);</span><br><span class="line">                DestroyLinearListStack(stack);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(bracket_contained)&#123;</span><br><span class="line">        if(stack-&gt;length(stack) == 0)&#123;</span><br><span class="line">            printf(&quot;Bracket matching successed\n&quot;);</span><br><span class="line">            result = 1; </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            stack-&gt;getTop(stack,&amp;elem);</span><br><span class="line">            switch(elem)&#123;</span><br><span class="line">                case &#x27;&#123;&#x27;:</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;&#125;\&#x27; expected! \n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case &#x27;[&#x27;:</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;]\&#x27; expected! \n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case &#x27;(&#x27;:</span><br><span class="line">                    printf(&quot;Bracket matching failed : \&#x27;)\&#x27; expected! \n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            result = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;String doesn&#x27;t contain bracket!\n&quot;);</span><br><span class="line">        result = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char str[100];</span><br><span class="line">    printf(&quot;please enter a string!\n&quot;);</span><br><span class="line">    gets(str);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    bracketMatching(str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearListStack.c LinearListStack.h BracketMatching.c -o BracketMatching</span><br></pre></td></tr></table></figure><p>运行BracketMatching,显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">please enter a string!</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">DestroyLinearListStack(stack);</span><br><span class="line">Bracket matching successed</span><br><span class="line">输入：</span><br><span class="line">if(stack-&gt;length(stack) == 0)&#123;</span><br><span class="line">Bracket matching failed : &#x27;&#125;&#x27; expected!</span><br><span class="line">输入：</span><br><span class="line">if(stack-&gt;length(stack))</span><br><span class="line">Bracket matching successed</span><br><span class="line">输入：</span><br><span class="line">([())</span><br><span class="line">Bracket matching failed : &#x27;]&#x27; expected!</span><br><span class="line">输入：</span><br><span class="line">(()]</span><br><span class="line">Bracket matching failed : &#x27;)&#x27; expected!</span><br><span class="line">输入：</span><br><span class="line">if(elem == &#x27;(&#x27;)</span><br><span class="line">Bracket matching failed : &#x27;)&#x27; expected!</span><br><span class="line">输入：</span><br><span class="line">[([][])]</span><br><span class="line">Bracket matching successed</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈的应用一：数制转换</title>
      <link href="/2018/08/30/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/08/30/%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h4><p>十进制数N与其他d进制的转换一个简单的算法是：<br>N &#x3D; (N&#x2F;d)*d + N%d</p><span id="more"></span><p>对应代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line">while(num)&#123;</span><br><span class="line">    item = num % d;</span><br><span class="line">    stack-&gt;push(d);</span><br><span class="line">    num /= d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将栈内的数从栈顶到栈底输出即为转换后的进制数。</p><p>NumberConversion.c利用了前面的C封装的顺序栈对象    <a href="https://www.jianshu.com/p/a035666f4bed">用线性表表示的顺序栈</a><br>实现了输入一个十六进制&#x2F;十进制&#x2F;八进制&#x2F;二进制的正数&#x2F;负数，输出十六进制&#x2F;十进制&#x2F;八进制&#x2F;二进制对应的数值，达到数制转换的效果。<br><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="NumberConversion-c文件"><a href="#NumberConversion-c文件" class="headerlink" title="NumberConversion.c文件"></a>NumberConversion.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line"></span><br><span class="line">int strlen(char *str)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(*(str+i) != &#x27;\0&#x27;)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double my_pow(double a,int b)&#123;</span><br><span class="line">    int s = 0,i;</span><br><span class="line">    double r = 1;</span><br><span class="line">    if(b == 0) return 1;</span><br><span class="line">    if(b&lt;0)&#123;</span><br><span class="line">        b*=-1;</span><br><span class="line">        s = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0; i &lt; b; i++)&#123;</span><br><span class="line">        r *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    if(s) r = 1/r;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinearListStack *intToHex(int num)&#123;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    char item;</span><br><span class="line">    if(num &lt; 0)&#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;else if(num == 0)&#123;</span><br><span class="line">        item = 0x30;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">    while(num)&#123;</span><br><span class="line">        item = num % 16;</span><br><span class="line">        if(item &lt;= 9)&#123;</span><br><span class="line">            item += 0x30;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            item += 0x37;</span><br><span class="line">        &#125;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">        num /= 16;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinearListStack *intToDec(int num)&#123;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    char item;</span><br><span class="line">    if(num &lt; 0)&#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;else if(num == 0)&#123;</span><br><span class="line">        item = 0x30;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">    while(num)&#123;</span><br><span class="line">        item = num % 10;</span><br><span class="line">        item += 0x30;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">        num /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinearListStack *intToOct(int num)&#123;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    char item;</span><br><span class="line">    if(num &lt; 0)&#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;else if(num == 0)&#123;</span><br><span class="line">        item = 0x30;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">    while(num)&#123;</span><br><span class="line">        item = num % 8;</span><br><span class="line">        item += 0x30;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">        num /= 8;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinearListStack *intToBin(int num)&#123;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    char item;</span><br><span class="line">    if(num &lt; 0)&#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;else if(num == 0)&#123;</span><br><span class="line">        item = 0x30;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">    while(num)&#123;</span><br><span class="line">        item = num % 2;</span><br><span class="line">        item += 0x30;</span><br><span class="line">        stack-&gt;push(stack,&amp;item);</span><br><span class="line">        num /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void displayConvert(int num)&#123;</span><br><span class="line">    int negative = 0;</span><br><span class="line">    LinearListStack *stack = NULL;;</span><br><span class="line">    negative = num &lt; 0 ? 1 : 0;</span><br><span class="line">    stack = intToDec(num);</span><br><span class="line">    negative ? printf(&quot;DEC: -&quot;) : printf(&quot;DEC: &quot;);</span><br><span class="line">    stack-&gt;downPrint(stack);</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    stack = intToHex(num);</span><br><span class="line">    negative ? printf(&quot;HEX: -0X&quot;) : printf(&quot;HEX: 0X&quot;);</span><br><span class="line">    stack-&gt;downPrint(stack);</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    if(negative)&#123;</span><br><span class="line">        stack = intToHex(0XFFFF + num + 1);</span><br><span class="line">        printf(&quot;HEX negative number saved form: 0X&quot;);</span><br><span class="line">        stack-&gt;downPrint(stack);</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    stack = intToOct(num);</span><br><span class="line">    negative ? printf(&quot;OCT: -o&quot;) : printf(&quot;OCT: o&quot;);</span><br><span class="line">    stack-&gt;downPrint(stack);</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">        if(negative)&#123;</span><br><span class="line">        stack = intToOct(0XFFFF + num + 1);</span><br><span class="line">        printf(&quot;OCT negative number saved form: o&quot;);</span><br><span class="line">        stack-&gt;downPrint(stack);</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    stack = intToBin(num);</span><br><span class="line">    negative ? printf(&quot;BIN: -b&quot;) : printf(&quot;BIN: b&quot;);</span><br><span class="line">    stack-&gt;downPrint(stack);</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    if(negative)&#123;</span><br><span class="line">        stack = intToBin(0XFFFF + num + 1);</span><br><span class="line">        printf(&quot;BIN negative number saved form: b&quot;);</span><br><span class="line">        stack-&gt;downPrint(stack);</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int stringToInt(char *str)&#123;</span><br><span class="line">    int basenum = 0,i = 0,num = 0;</span><br><span class="line">    int stack_length = 0;</span><br><span class="line">    int start_save = 0;</span><br><span class="line">    int negative = 0;</span><br><span class="line">    char item;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    while(*str != &#x27;\0&#x27;)&#123;</span><br><span class="line">        if(start_save != 1)&#123;</span><br><span class="line">            if(*str == &#x27;-&#x27;)&#123;</span><br><span class="line">                negative = 1;</span><br><span class="line">            &#125;else if(*str == &#x27;o&#x27; || *str == &#x27;O&#x27;)&#123;</span><br><span class="line">                start_save = 1;</span><br><span class="line">                basenum = 8;</span><br><span class="line">            &#125;else if(*str == &#x27;b&#x27; || *str == &#x27;B&#x27;)&#123;</span><br><span class="line">                start_save = 1;</span><br><span class="line">                basenum = 2;</span><br><span class="line">            &#125;else if(*str == &#x27;d&#x27; || *str == &#x27;D&#x27;)&#123;</span><br><span class="line">                start_save = 1;</span><br><span class="line">                basenum = 10;</span><br><span class="line">            &#125;else if(*str == &#x27;x&#x27; || *str == &#x27;X&#x27;)&#123;</span><br><span class="line">                if(start_save == 2)&#123;</span><br><span class="line">                    start_save = 1;</span><br><span class="line">                    basenum = 16;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(*str == &#x27;0&#x27;)&#123;</span><br><span class="line">                start_save = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(start_save == 1)&#123;</span><br><span class="line">            stack-&gt;push(stack,str);</span><br><span class="line">        &#125;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    stack_length = stack-&gt;length(stack);</span><br><span class="line">    for(i=0;i&lt;stack_length;i++)&#123;</span><br><span class="line">        stack-&gt;pop(stack,&amp;item);</span><br><span class="line">        if(item &gt;= 0x30 &amp;&amp; item &lt;= 0x39)&#123;</span><br><span class="line">            item -= 0x30;</span><br><span class="line">        &#125;else if(item &gt;= 0x41 &amp;&amp; item &lt;= 0x46)&#123;</span><br><span class="line">            if(basenum == 16)&#123;</span><br><span class="line">                item -= 0x37;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;Num string formal error!\n&quot;);</span><br><span class="line">                DestroyLinearListStack(stack);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(item &gt;= 0x61 &amp;&amp; item &lt;= 0x66)&#123;</span><br><span class="line">            if(basenum == 16)&#123;</span><br><span class="line">                item -= 0x57;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;Num string formal error!\n&quot;);</span><br><span class="line">                DestroyLinearListStack(stack);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                printf(&quot;Num string formal error!\n&quot;);</span><br><span class="line">                DestroyLinearListStack(stack);</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        num += my_pow(basenum,i)*item;</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    if(negative) num = -num;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char str[100];</span><br><span class="line">    printf(&quot;please enter a num!\n&quot;);</span><br><span class="line">    printf(&quot;num format just like these:\n&quot;);</span><br><span class="line">    printf(&quot;HEX: -0X1F -0x1F 0x1F 0X1F\n&quot;);</span><br><span class="line">    printf(&quot;DEC: -D11 -d11 D11 d11\n&quot;);</span><br><span class="line">    printf(&quot;OCT: -O11 -o11 O11 o11\n&quot;);</span><br><span class="line">    printf(&quot;BIN: -B10 -b10 B10 b10\n&quot;);</span><br><span class="line">    printf(&quot;Enter:\n&quot;);</span><br><span class="line">    gets(str);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    num = stringToInt(str);</span><br><span class="line">    displayConvert(num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearListStack.c LinearListStack.h NumberConversion.c -o NumberConversion</span><br></pre></td></tr></table></figure><p>运行NumberConversion,显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">please enter a num!</span><br><span class="line">num format just like these:</span><br><span class="line">HEX: -0X1F -0x1F 0x1F 0X1F</span><br><span class="line">DEC: -D11 -d11 D11 d11</span><br><span class="line">OCT: -O11 -o11 O11 o11</span><br><span class="line">BIN: -B10 -b10 B10 b10</span><br><span class="line">Enter:</span><br></pre></td></tr></table></figure><p>例1：<br>输入：d123<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEC: 123</span><br><span class="line">HEX: 0X7B</span><br><span class="line">OCT: o173</span><br><span class="line">BIN: b1111011</span><br></pre></td></tr></table></figure><p>例2：<br>输入：-0x2df3<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEC: -11763</span><br><span class="line">HEX: -0X2DF3</span><br><span class="line">HEX negative number saved form: 0XD20D</span><br><span class="line">OCT: -o26763</span><br><span class="line">OCT negative number saved form: o151015</span><br><span class="line">BIN: -b10110111110011</span><br><span class="line">BIN negative number saved form: b1101001000001101</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用线性表表示的顺序栈</title>
      <link href="/2018/08/29/%E7%94%A8%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
      <url>/2018/08/29/%E7%94%A8%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="LinearListStack-线性表栈"><a href="#LinearListStack-线性表栈" class="headerlink" title="LinearListStack(线性表栈)"></a>LinearListStack(线性表栈)</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>特点：<br>1.从数据结构角度看，栈也是线性表，其特殊性在于栈的基本操作是线性表操作的子集，是操作受限的线性表。但是从数据类型角度看，栈是和线性表大不相同的两类抽象数据类型。</p><span id="more"></span><p>2.栈（stack）是限定仅在表尾进行插入或删除操作的线性表，因此，对栈来说，表尾端有其特殊含义，称为栈顶（top），表头端称为栈底（bottom）。<br>3.栈的修改是按后进先出的原则进行的，因此，栈又称为后进先出（Last in First out）的线性表（简称LIFO结构）。<br>4.和线性表类似，栈也有两种存储表示方法，顺序栈和链栈。<br>顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。<br>5.由于栈在使用过程中所需最大空间的大小很难估计，因此一般情况下，在初始化设置空栈时不应限定栈的最大容量。对于顺序栈，一个较合理的做法是，先为顺序栈分配一个基本容量，然后在应用过程中，当栈的空间不足够使用时再逐步扩大。为此，可设定两个常量：STACK_INIT_SIZE(存储空间初始分配量)和STACKINCREMENT(存储空间分配增量)。</p><h4 id="LinearListStack-c文件"><a href="#LinearListStack-c文件" class="headerlink" title="LinearListStack.c文件"></a>LinearListStack.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line">//线性表栈</span><br><span class="line"></span><br><span class="line">static void clear(LinearListStack *This);</span><br><span class="line">static int isEmpty(LinearListStack *This);</span><br><span class="line">static int length(LinearListStack *This);</span><br><span class="line">static void risePrint(LinearListStack *This);</span><br><span class="line">static void downPrint(LinearListStack *This);</span><br><span class="line">static int getTop(LinearListStack *This,ElemType* e);</span><br><span class="line">static int push(LinearListStack *This,ElemType* e);</span><br><span class="line">static int pop(LinearListStack *This, ElemType* e);</span><br><span class="line"></span><br><span class="line">LinearListStack *InitLinearListStack()&#123;</span><br><span class="line">    LinearListStack *L = (LinearListStack *)malloc(sizeof(LinearListStack));</span><br><span class="line">    LinearListStack_P *p = (LinearListStack_P *)malloc(sizeof(LinearListStack_P));</span><br><span class="line">    p-&gt;base = (ElemType *)malloc(STACK_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">    p-&gt;top = p-&gt;base;</span><br><span class="line">    p-&gt;length = 0; //当前长度</span><br><span class="line">    p-&gt;size = STACK_INIT_SIZE; //当前分配量</span><br><span class="line">    L-&gt;This = p;</span><br><span class="line">    L-&gt;clear = clear;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;risePrint = risePrint;</span><br><span class="line">    L-&gt;downPrint = downPrint;</span><br><span class="line">    L-&gt;getTop = getTop;</span><br><span class="line">    L-&gt;push = push;</span><br><span class="line">    L-&gt;pop = pop;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyLinearListStack(LinearListStack *L)&#123;</span><br><span class="line">    free(L-&gt;This);</span><br><span class="line">    free(L);</span><br><span class="line">    L = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(LinearListStack *This)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    p-&gt;top = p-&gt;base;</span><br><span class="line">    p-&gt;length = 0; //当前长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(LinearListStack *This)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    return (p-&gt;length == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(LinearListStack *This)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    return p-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void risePrint(LinearListStack *This)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i &lt; p-&gt;length; i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;, *(p-&gt;base + i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void downPrint(LinearListStack *This)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i &lt; p-&gt;length; i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;, *(p-&gt;top - 1 - i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getTop(LinearListStack *This,ElemType* e)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    if (p-&gt;top == p-&gt;base) return -1;</span><br><span class="line">    *e = *(p-&gt;top-1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int push(LinearListStack *This,ElemType* e)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    if (p-&gt;top - p-&gt;base &gt;= p-&gt;size)&#123; //判断存储空间是否够用</span><br><span class="line">        ElemType *newbase = (ElemType *)realloc(p-&gt;base, (p-&gt;size + STACKINCREMENT)*sizeof(ElemType));</span><br><span class="line">        if (!newbase) return -1;//存储空间分配失败</span><br><span class="line">        p-&gt;base = newbase;//新基址</span><br><span class="line">        p-&gt;top = p-&gt;base + p-&gt;size;</span><br><span class="line">        p-&gt;size += STACKINCREMENT;//增加存储容量</span><br><span class="line">    &#125;</span><br><span class="line">    *((p-&gt;top)++) = *e;</span><br><span class="line">    ++p-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int pop(LinearListStack *This, ElemType* e)&#123;</span><br><span class="line">    LinearListStack_P *p = This-&gt;This;</span><br><span class="line">    if (p-&gt;top == p-&gt;base) return -1;</span><br><span class="line">    *e = *(p-&gt;top-1);</span><br><span class="line">    p-&gt;top--;</span><br><span class="line">    p-&gt;length--;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinearListStack-h文件"><a href="#LinearListStack-h文件" class="headerlink" title="LinearListStack.h文件"></a>LinearListStack.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef __LINEARLISTSTACK_H</span><br><span class="line">#define __LINEARLISTSTACK_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef char ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct LinearListStack_P&#123;</span><br><span class="line">    ElemType *base;  </span><br><span class="line">    ElemType *top;   //栈顶指针</span><br><span class="line">    int length;      //当前线性表栈的长度</span><br><span class="line">    int size;    //当前分配的存储容量</span><br><span class="line">&#125;LinearListStack_P;</span><br><span class="line"></span><br><span class="line">typedef struct LinearListStack&#123;</span><br><span class="line">    LinearListStack_P *This;  </span><br><span class="line">    void (*clear)(struct LinearListStack *This);</span><br><span class="line">    int (*isEmpty)(struct LinearListStack *This);</span><br><span class="line">    int (*length)(struct LinearListStack *This);</span><br><span class="line">    void (*risePrint)(struct LinearListStack *This);</span><br><span class="line">    void (*downPrint)(struct LinearListStack *This);</span><br><span class="line">    int (*getTop)(struct LinearListStack *This,ElemType* e);</span><br><span class="line">    int (*push)(struct LinearListStack *This,ElemType* e);</span><br><span class="line">    int (*pop)(struct LinearListStack *This, ElemType* e);</span><br><span class="line">&#125;LinearListStack;</span><br><span class="line"></span><br><span class="line">/* Exported define -----------------------------------------------------------*/</span><br><span class="line">#define STACK_INIT_SIZE 100 //线性表栈存储空间的初始分配量</span><br><span class="line">#define STACKINCREMENT 10   //线性表栈存储空间的分配增量(当存储空间不够时要用到)</span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">LinearListStack *InitLinearListStack();</span><br><span class="line">void DestroyLinearListStack(LinearListStack *L);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testLinearListStack-c文件"><a href="#testLinearListStack-c文件" class="headerlink" title="testLinearListStack.c文件"></a>testLinearListStack.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearListStack.h&quot;</span><br><span class="line"></span><br><span class="line">int strlen(char *str)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(*(str+i) != &#x27;\0&#x27;)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char string[] = &quot;abcdefgh&quot;;</span><br><span class="line">    int strlength = strlen(string);</span><br><span class="line">    ElemType elem;</span><br><span class="line">    LinearListStack *stack = InitLinearListStack();</span><br><span class="line">    printf(&quot;string length = %d\n&quot;,strlength);</span><br><span class="line">    printf(&quot;stack is empty:%d\n&quot;,stack-&gt;isEmpty(stack));</span><br><span class="line">    for (i = 0; i &lt; strlength; i++)&#123;</span><br><span class="line">        stack-&gt;push(stack,string+i);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;base to top: \n&quot;);</span><br><span class="line">    stack-&gt;risePrint(stack);</span><br><span class="line">    printf(&quot;top to base: \n&quot;);</span><br><span class="line">    stack-&gt;downPrint(stack);</span><br><span class="line">    printf(&quot;stack is empty:%d\n&quot;,stack-&gt;isEmpty(stack));</span><br><span class="line">    printf(&quot;stack length:%d\n&quot;,stack-&gt;length(stack));</span><br><span class="line">    for(i=0;i &lt; strlength; i++)&#123;</span><br><span class="line">        stack-&gt;getTop(stack,&amp;elem);</span><br><span class="line">        printf(&quot;get top elem:%c\n&quot;,elem);</span><br><span class="line">        stack-&gt;pop(stack,&amp;elem);</span><br><span class="line">        printf(&quot;pop elem:%c\n&quot;,elem);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;stack is empty:%d\n&quot;,stack-&gt;isEmpty(stack));</span><br><span class="line">    printf(&quot;stack length:%d\n&quot;,stack-&gt;length(stack));</span><br><span class="line">    stack-&gt;clear(stack);</span><br><span class="line">    DestroyLinearListStack(stack);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearListStack.c LinearListStack.h testLinearListStack.c -o testLinearListStack</span><br></pre></td></tr></table></figure><p>运行testLinearListStack<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">string length = 8</span><br><span class="line">stack is empty:1</span><br><span class="line">base to top:</span><br><span class="line">abcdefgh</span><br><span class="line">top to base:</span><br><span class="line">hgfedcba</span><br><span class="line">stack is empty:0</span><br><span class="line">stack length:8</span><br><span class="line">get top elem:h</span><br><span class="line">pop elem:h</span><br><span class="line">get top elem:g</span><br><span class="line">pop elem:g</span><br><span class="line">get top elem:f</span><br><span class="line">pop elem:f</span><br><span class="line">get top elem:e</span><br><span class="line">pop elem:e</span><br><span class="line">get top elem:d</span><br><span class="line">pop elem:d</span><br><span class="line">get top elem:c</span><br><span class="line">pop elem:c</span><br><span class="line">get top elem:b</span><br><span class="line">pop elem:b</span><br><span class="line">get top elem:a</span><br><span class="line">pop elem:a</span><br><span class="line">stack is empty:1</span><br><span class="line">stack length:0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装双向循环链表对象</title>
      <link href="/2018/08/29/C%E5%B0%81%E8%A3%85%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/29/C%E5%B0%81%E8%A3%85%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="DoubleCircularLinkedList-双向循环链表"><a href="#DoubleCircularLinkedList-双向循环链表" class="headerlink" title="DoubleCircularLinkedList(双向循环链表)"></a>DoubleCircularLinkedList(双向循环链表)</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>特点：</p><span id="more"></span><p>1.插入一个结点temp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next-&gt;prior = temp;</span><br><span class="line">temp-&gt;prior = p;</span><br><span class="line">temp-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = temp;</span><br></pre></td></tr></table></figure><p>2.删除一个结点n，时间复杂度O(1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n-&gt;prior-&gt;next = n-&gt;next;</span><br><span class="line">n-&gt;next-&gt;prior = n-&gt;prior;</span><br><span class="line">free(n);</span><br></pre></td></tr></table></figure><p>3.在末尾增加一个结点temp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp-&gt;elem = *e;</span><br><span class="line">temp-&gt;prior = p;</span><br><span class="line">temp-&gt;next =  head;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">head-&gt;prior = temp;</span><br></pre></td></tr></table></figure><p>4.getPriorNode、getNextNode的时间复杂度均为O(1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static Node *getPriorNode(Node *n)&#123;</span><br><span class="line">    return n-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Node *getNextNode(Node *n)&#123;</span><br><span class="line">    return n-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DoubleCircularLinkedList-c文件"><a href="#DoubleCircularLinkedList-c文件" class="headerlink" title="DoubleCircularLinkedList.c文件"></a>DoubleCircularLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DoubleCircularLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(DoubleCircularLinkedList *This);</span><br><span class="line">static int isEmpty(DoubleCircularLinkedList *This);</span><br><span class="line">static int length(DoubleCircularLinkedList *This);</span><br><span class="line">static void print(DoubleCircularLinkedList *This);</span><br><span class="line">static void circlePrint(DoubleCircularLinkedList *This,int times);</span><br><span class="line">static int indexElem(DoubleCircularLinkedList *This, ElemType* x);</span><br><span class="line">static int indexNode(DoubleCircularLinkedList *This, Node* n);</span><br><span class="line">static int getElem(DoubleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">static Node *getNode(DoubleCircularLinkedList *This, int index);</span><br><span class="line">static Node *getPriorNode(Node *n);</span><br><span class="line">static Node *getNextNode(Node *n);</span><br><span class="line">static int modifyElem(DoubleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int deleteElem(DoubleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int deleteNode(DoubleCircularLinkedList *This, Node* n);</span><br><span class="line">static int appendElem(DoubleCircularLinkedList *This, ElemType *e);</span><br><span class="line">static int insertElem(DoubleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">static int popElem(DoubleCircularLinkedList *This, ElemType* e);</span><br><span class="line"></span><br><span class="line">DoubleCircularLinkedList *InitDoubleCircularLinkedList()&#123;</span><br><span class="line">    DoubleCircularLinkedList *L = (DoubleCircularLinkedList *)malloc(sizeof(DoubleCircularLinkedList));</span><br><span class="line">    Node *p = (Node *)malloc(sizeof(Node));</span><br><span class="line">    L-&gt;This = p;</span><br><span class="line">    p-&gt;prior = p;</span><br><span class="line">    p-&gt;next = p;</span><br><span class="line">    L-&gt;clear = clear;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;print = print;</span><br><span class="line">    L-&gt;circlePrint = circlePrint;</span><br><span class="line">    L-&gt;indexElem = indexElem;</span><br><span class="line">    L-&gt;indexNode = indexNode;</span><br><span class="line">    L-&gt;getElem = getElem;</span><br><span class="line">    L-&gt;getNode = getNode;</span><br><span class="line">    L-&gt;getPriorNode = getPriorNode;</span><br><span class="line">    L-&gt;getNextNode = getNextNode;</span><br><span class="line">    L-&gt;modifyElem = modifyElem;</span><br><span class="line">    L-&gt;deleteElem = deleteElem;</span><br><span class="line">    L-&gt;deleteNode = deleteNode;</span><br><span class="line">    L-&gt;appendElem = appendElem;</span><br><span class="line">    L-&gt;insertElem = insertElem;</span><br><span class="line">    L-&gt;popElem = popElem;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyDoubleCircularLinkedList(DoubleCircularLinkedList *L)&#123;</span><br><span class="line">    L-&gt;clear(L);</span><br><span class="line">    free(L-&gt;This);</span><br><span class="line">    free(L);</span><br><span class="line">    L = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(DoubleCircularLinkedList *This)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;This;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    p-&gt;prior = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(DoubleCircularLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next == p)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(DoubleCircularLinkedList *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void print(DoubleCircularLinkedList *This)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void circlePrint(DoubleCircularLinkedList *This,int times)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    int i = 0;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    for(i = 0;i&lt;times;)&#123;</span><br><span class="line">        if(p == head)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexElem(DoubleCircularLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        if(*e == p-&gt;elem)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexNode(DoubleCircularLinkedList *This, Node* n)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        if(n == p)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getElem(DoubleCircularLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p == head || j &gt; index) return -1;</span><br><span class="line">    *e = p-&gt;elem;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Node *getNode(DoubleCircularLinkedList *This, int index)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p == head || j &gt; index) return NULL;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Node *getPriorNode(Node *n)&#123;</span><br><span class="line">    return n-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Node *getNextNode(Node *n)&#123;</span><br><span class="line">    return n-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int modifyElem(DoubleCircularLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p == head || j &gt; index) return -1;</span><br><span class="line">    p-&gt;elem = *e;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int insertElem(DoubleCircularLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p-&gt;next != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p-&gt;next == head || j &gt; index) return -1;</span><br><span class="line">    temp-&gt;elem = *e;</span><br><span class="line">    p-&gt;next-&gt;prior = temp;</span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line">    temp-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deleteNode(DoubleCircularLinkedList *This, Node* n)&#123;</span><br><span class="line">    if(indexNode(This, n)&gt;=0)&#123;</span><br><span class="line">        n-&gt;prior-&gt;next = n-&gt;next;</span><br><span class="line">        n-&gt;next-&gt;prior = n-&gt;prior;</span><br><span class="line">        free(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deleteElem(DoubleCircularLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p-&gt;next != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p-&gt;next == head || j &gt; index) return -1;</span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next-&gt;prior = p;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int appendElem(DoubleCircularLinkedList *This, ElemType *e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p-&gt;next != head)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    temp-&gt;elem = *e;</span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line">    temp-&gt;next =  head;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    head-&gt;prior = temp;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int popElem(DoubleCircularLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p-&gt;next-&gt;next != head)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    if(temp == head) return -1;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    head-&gt;prior = p;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DoubleCircularLinkedList-h文件"><a href="#DoubleCircularLinkedList-h文件" class="headerlink" title="DoubleCircularLinkedList.h文件"></a>DoubleCircularLinkedList.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef __DOUBLECIRCULARLINKEDLIST_H</span><br><span class="line">#define __DOUBLECIRCULARLINKEDLIST_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef int ElemType;      //数据元素的类型，假设是int型的</span><br><span class="line"></span><br><span class="line">typedef struct Node&#123;</span><br><span class="line">    ElemType elem;  //存储空间</span><br><span class="line">    struct Node *prior;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">typedef struct DoubleCircularLinkedList&#123;</span><br><span class="line">    Node *This;</span><br><span class="line">    void (*clear)(struct DoubleCircularLinkedList *This);</span><br><span class="line">    int (*isEmpty)(struct DoubleCircularLinkedList *This);</span><br><span class="line">    int (*length)(struct DoubleCircularLinkedList *This);</span><br><span class="line">    void (*print)(struct DoubleCircularLinkedList *This);</span><br><span class="line">    void (*circlePrint)(struct DoubleCircularLinkedList *This,int times);</span><br><span class="line">    int (*indexElem)(struct DoubleCircularLinkedList *This, ElemType* x);</span><br><span class="line">    int (*indexNode)(struct DoubleCircularLinkedList *This, Node* n);</span><br><span class="line">    int (*getElem)(struct DoubleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">    Node *(*getNode)(struct DoubleCircularLinkedList *This, int index);</span><br><span class="line">    Node *(*getPriorNode)(Node *n);</span><br><span class="line">    Node *(*getNextNode)(Node *n);</span><br><span class="line">    int (*modifyElem)(struct DoubleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*deleteElem)(struct DoubleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*deleteNode)(struct DoubleCircularLinkedList *This, Node* n);</span><br><span class="line">    int (*appendElem)(struct DoubleCircularLinkedList *This, ElemType *e);</span><br><span class="line">    int (*insertElem)(struct DoubleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">    int (*popElem)(struct DoubleCircularLinkedList *This, ElemType* e);</span><br><span class="line">&#125;DoubleCircularLinkedList;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">DoubleCircularLinkedList *InitDoubleCircularLinkedList();</span><br><span class="line">void DestroyDoubleCircularLinkedList(DoubleCircularLinkedList *L);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testDoubleCircularLinkedList-c文件"><a href="#testDoubleCircularLinkedList-c文件" class="headerlink" title="testDoubleCircularLinkedList.c文件"></a>testDoubleCircularLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DoubleCircularLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType elem,elem1;</span><br><span class="line">    Node *tempn;</span><br><span class="line">    Node *tempm;</span><br><span class="line">    DoubleCircularLinkedList *list = InitDoubleCircularLinkedList();</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    printf(&quot;list length:%d\n&quot;,list-&gt;length(list));</span><br><span class="line">    list-&gt;clear(list);</span><br><span class="line">    for (i = 10; i &lt; 20; i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;   </span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;the elem of index 3 is %d\n&quot;,elem1);</span><br><span class="line">    elem = 31;</span><br><span class="line">    list-&gt;modifyElem(list,3,&amp;elem);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;modify the elem of index 3 to %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 25;</span><br><span class="line">    list-&gt;insertElem(list,5,&amp;elem);</span><br><span class="line">    printf(&quot;insert elem %d to index 5\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;deleteElem(list,7,&amp;elem);</span><br><span class="line">    printf(&quot;delete elem %d of index 7\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 14;</span><br><span class="line">    printf(&quot;the index of 14 is %d\n&quot;,list-&gt;indexElem(list,&amp;elem));</span><br><span class="line">    list-&gt;popElem(list,&amp;elem);</span><br><span class="line">    printf(&quot;pop elem %d\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    printf(&quot;circle print 3 times:\n&quot;);</span><br><span class="line">    list-&gt;circlePrint(list,3);</span><br><span class="line">    tempn = list-&gt;getNode(list,5);</span><br><span class="line">    printf(&quot;get node of index 5: node elem = %d\n&quot;,tempn-&gt;elem);</span><br><span class="line">    printf(&quot;the index of node: %d\n&quot;,list-&gt;indexNode(list, tempn));</span><br><span class="line">    tempm = list-&gt;getPriorNode(tempn);</span><br><span class="line">    printf(&quot;get Prior node of index 5: Prior node elem = %d\n&quot;,tempm-&gt;elem);</span><br><span class="line">    tempm = list-&gt;getNextNode(tempn);</span><br><span class="line">    printf(&quot;get Next node of index 5: Next node elem = %d\n&quot;,tempm-&gt;elem);</span><br><span class="line">    list-&gt;deleteNode(list,tempn);</span><br><span class="line">    printf(&quot;delete node of index 5\n&quot;);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    DestroyDoubleCircularLinkedList(list);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc DoubleCircularLinkedList.c DoubleCircularLinkedList.h testDoubleCircularLinkedList.c -o testDoubleCircularLinkedList</span><br></pre></td></tr></table></figure><p>运行testDoubleCircularLinkedList<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">list is empty:0</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">list is empty:1</span><br><span class="line">list length:10</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">the elem of index 3 is 13</span><br><span class="line">modify the elem of index 3 to 31</span><br><span class="line">10 11 12 31 14 15 16 17 18 19</span><br><span class="line">insert elem 25 to index 5</span><br><span class="line">10 11 12 31 14 25 15 16 17 18 19</span><br><span class="line">delete elem 16 of index 7</span><br><span class="line">10 11 12 31 14 25 15 17 18 19</span><br><span class="line">the index of 14 is 4</span><br><span class="line">pop elem 19</span><br><span class="line">10 11 12 31 14 25 15 17 18</span><br><span class="line">circle print 3 times:</span><br><span class="line">10 11 12 31 14 25 15 17 18 10 11 12 31 14 25 15 17 18 10 11 12 31 14 25 15 17 18</span><br><span class="line">get node of index 5: node elem = 25</span><br><span class="line">the index of node: 5</span><br><span class="line">get Prior node of index 5: Prior node elem = 14</span><br><span class="line">get Next node of index 5: Next node elem = 15</span><br><span class="line">delete node of index 5</span><br><span class="line">10 11 12 31 14 15 17 18</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用单链表表示一元多项式及其简单计算</title>
      <link href="/2018/08/28/%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97/"/>
      <url>/2018/08/28/%E7%94%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><h4 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h4><p>在数学上，一个一元多项式Pn(x)可以按升幂写为：<br>Pn(x) &#x3D; p0 + p1x + p2x^2 + … + pnx^n<br>它由n+1个系数唯一确定，因此可用一个线性表P来表示。<br>P &#x3D; (p0,p1,p2,…,pn)<br>每一项的指数i隐含在其系数pi的序号里。</p><span id="more"></span><p>然而，在通常的应用中，多项式的次数可能很高且变化很大，使得顺序存储的最大长度很难确定。特别是在处理形如：<br>S(x) &#x3D; 1 + 3x^10000 + 2x^20000<br>的多项式时，就要使用一长度为20001的线性表来表示，表中仅有三个非零元素，这种对内存空间的浪费是应当避免的，但是如果只存非零系数项则显然必须同时存储相应的指数。<br>则存储可表示为（(p1,e1),(p2,e2),…(pn,en)）<br>显然，用链表来存储多项式参数更加灵活，节省空间。</p><h4 id="Polynomial-c文件"><a href="#Polynomial-c文件" class="headerlink" title="Polynomial.c文件"></a>Polynomial.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;Polynomial.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(Polynomial *This);</span><br><span class="line">static int isEmpty(Polynomial *This);</span><br><span class="line">static int length(Polynomial *This);</span><br><span class="line">static void print(Polynomial *This);</span><br><span class="line">static int appendElem(Polynomial *This, ElemType e);</span><br><span class="line"></span><br><span class="line">Polynomial *InitPolynomial()&#123;</span><br><span class="line">    Polynomial *L = (Polynomial *)malloc(sizeof(Polynomial));</span><br><span class="line">    Node *p = (Node *)malloc(sizeof(Node));</span><br><span class="line">    L-&gt;This = p;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    L-&gt;clear = clear;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;print = print;</span><br><span class="line">    L-&gt;appendElem = appendElem;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polynomial *CreatePolynomial(ElemType *params,int length)&#123;</span><br><span class="line">    Polynomial *L = InitPolynomial();</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">        L-&gt;appendElem(L, *(params+i));</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyPolynomial(Polynomial *L)&#123;</span><br><span class="line">    L-&gt;clear(L);</span><br><span class="line">    free(L-&gt;This);</span><br><span class="line">    free(L);</span><br><span class="line">    L = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(Polynomial *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;This;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(Polynomial *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(Polynomial *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void print(Polynomial *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    if(p)&#123;</span><br><span class="line">        printf(&quot;%fx^%f&quot;, p-&gt;elem.coefficient,p-&gt;elem.exponent);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        printf(&quot; + %fx^%f&quot;, p-&gt;elem.coefficient,p-&gt;elem.exponent);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int appendElem(Polynomial *This, ElemType e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(NULL == p-&gt;next)&#123;</span><br><span class="line">            temp-&gt;elem.coefficient = e.coefficient;</span><br><span class="line">            temp-&gt;elem.exponent = e.exponent;</span><br><span class="line">            p-&gt;next = temp;</span><br><span class="line">            temp-&gt;next =  NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polynomial *addPolynomial(Polynomial *pa,Polynomial *pb)&#123;</span><br><span class="line">    Polynomial *L = InitPolynomial();</span><br><span class="line">    ElemType a,b,sum;</span><br><span class="line">    Node *ha = pa-&gt;This-&gt;next;</span><br><span class="line">    Node *hb = pb-&gt;This-&gt;next;</span><br><span class="line">    while(ha&amp;&amp;hb)&#123;</span><br><span class="line">        a = ha-&gt;elem;</span><br><span class="line">        b = hb-&gt;elem;</span><br><span class="line">        if(a.exponent &gt; b.exponent)&#123;</span><br><span class="line">            L-&gt;appendElem(L, b);</span><br><span class="line">            hb = hb-&gt;next;</span><br><span class="line">        &#125;else if(a.exponent == b.exponent)&#123;</span><br><span class="line">            sum.exponent = a.exponent;</span><br><span class="line">            sum.coefficient = a.coefficient + b.coefficient;</span><br><span class="line">            if(sum.coefficient != 0)&#123;</span><br><span class="line">                L-&gt;appendElem(L, sum);</span><br><span class="line">            &#125;</span><br><span class="line">            ha = ha-&gt;next;</span><br><span class="line">            hb = hb-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            L-&gt;appendElem(L, a);</span><br><span class="line">            ha = ha-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(ha)&#123;</span><br><span class="line">        a = ha-&gt;elem;</span><br><span class="line">        L-&gt;appendElem(L, a);</span><br><span class="line">        ha = ha-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(hb)&#123;</span><br><span class="line">        b = hb-&gt;elem;</span><br><span class="line">        L-&gt;appendElem(L, b);</span><br><span class="line">        hb = hb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polynomial *subPolynomial(Polynomial *pa,Polynomial *pb)&#123;</span><br><span class="line">    Polynomial *L = InitPolynomial();</span><br><span class="line">    ElemType a,b,sub;</span><br><span class="line">    Node *ha = pa-&gt;This-&gt;next;</span><br><span class="line">    Node *hb = pb-&gt;This-&gt;next;</span><br><span class="line">    while(ha&amp;&amp;hb)&#123;</span><br><span class="line">        a = ha-&gt;elem;</span><br><span class="line">        b = hb-&gt;elem;</span><br><span class="line">        if(a.exponent &gt; b.exponent)&#123;</span><br><span class="line">            sub.exponent = b.exponent;</span><br><span class="line">            sub.coefficient = -b.coefficient;</span><br><span class="line">            L-&gt;appendElem(L, sub);</span><br><span class="line">            hb = hb-&gt;next;</span><br><span class="line">        &#125;else if(a.exponent == b.exponent)&#123;</span><br><span class="line">            sub.exponent = a.exponent;</span><br><span class="line">            sub.coefficient = a.coefficient - b.coefficient;</span><br><span class="line">            if(sub.coefficient != 0)&#123;</span><br><span class="line">                L-&gt;appendElem(L, sub);</span><br><span class="line">            &#125;</span><br><span class="line">            ha = ha-&gt;next;</span><br><span class="line">            hb = hb-&gt;next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            L-&gt;appendElem(L, a);</span><br><span class="line">            ha = ha-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(ha)&#123;</span><br><span class="line">        a = ha-&gt;elem;</span><br><span class="line">        L-&gt;appendElem(L, a);</span><br><span class="line">        ha = ha-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(hb)&#123;</span><br><span class="line">        b = hb-&gt;elem;</span><br><span class="line">        sub.exponent = b.exponent;</span><br><span class="line">        sub.coefficient = -b.coefficient;</span><br><span class="line">        L-&gt;appendElem(L, sub);</span><br><span class="line">        hb = hb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polynomial *kMulPolynomial(Polynomial *pa,ElemType a)&#123;</span><br><span class="line">    Polynomial *L = InitPolynomial();</span><br><span class="line">    Node *ha = pa-&gt;This-&gt;next;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    while(ha)&#123;</span><br><span class="line">        temp.exponent = ha-&gt;elem.exponent + a.exponent;</span><br><span class="line">        temp.coefficient = ha-&gt;elem.coefficient * a.coefficient;</span><br><span class="line">        L-&gt;appendElem(L, temp);</span><br><span class="line">        ha = ha-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polynomial *mulPolynomial(Polynomial *pa,Polynomial *pb)&#123;</span><br><span class="line">    Polynomial *temp = InitPolynomial();</span><br><span class="line">    Polynomial *temp1 = NULL,*temp2 = NULL;</span><br><span class="line">    Node *hb = pb-&gt;This-&gt;next;</span><br><span class="line">    while(hb)&#123;</span><br><span class="line">        temp1 = kMulPolynomial(pa,hb-&gt;elem);</span><br><span class="line">        temp2 = addPolynomial(temp1,temp);</span><br><span class="line">        DestroyPolynomial(temp1);   </span><br><span class="line">        DestroyPolynomial(temp);</span><br><span class="line">        temp = temp2;</span><br><span class="line">        hb = hb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Polynomial-h文件"><a href="#Polynomial-h文件" class="headerlink" title="Polynomial.h文件"></a>Polynomial.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef __POLYNOMIAL_H</span><br><span class="line">#define __POLYNOMIAL_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef struct ElemType&#123;</span><br><span class="line">    double coefficient; //系数</span><br><span class="line">    double exponent;//指数</span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct Node&#123;</span><br><span class="line">    ElemType elem;  //存储空间</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">typedef struct Polynomial&#123;</span><br><span class="line">    Node *This;</span><br><span class="line">    void (*clear)(struct Polynomial *This);</span><br><span class="line">    int (*isEmpty)(struct Polynomial *This);</span><br><span class="line">    int (*length)(struct Polynomial *This);</span><br><span class="line">    void (*print)(struct Polynomial *This);</span><br><span class="line">    int (*appendElem)(struct Polynomial *This, ElemType e);</span><br><span class="line">&#125;Polynomial;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">Polynomial *CreatePolynomial(ElemType *params,int length);</span><br><span class="line">void DestroyPolynomial(Polynomial *L);</span><br><span class="line">Polynomial *addPolynomial(Polynomial *pa,Polynomial *pb);</span><br><span class="line">Polynomial *subPolynomial(Polynomial *pa,Polynomial *pb);</span><br><span class="line">Polynomial *kMulPolynomial(Polynomial *pa,ElemType a);</span><br><span class="line">Polynomial *mulPolynomial(Polynomial *pa,Polynomial *pb);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>####testPolynomial.c文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;Polynomial.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    //7+3x+9X^8+5x^17</span><br><span class="line">    ElemType params_a[4]=&#123;&#123;7,0&#125;,&#123;3,1&#125;,&#123;9,8&#125;,&#123;5,17&#125;&#125;;</span><br><span class="line">    //8x+22x^7+-9x^8</span><br><span class="line">    ElemType params_b[3]=&#123;&#123;8,1&#125;,&#123;22,7&#125;,&#123;-9,8&#125;&#125;;</span><br><span class="line">    Polynomial *pa = CreatePolynomial(params_a,4);</span><br><span class="line">    Polynomial *pb = CreatePolynomial(params_b,3);</span><br><span class="line">    Polynomial *sum_ab,*sub_ab,*mul_ab,*kmul_a;</span><br><span class="line">    printf(&quot;pa = &quot;);</span><br><span class="line">    pa-&gt;print(pa);</span><br><span class="line">    printf(&quot;pb = &quot;);</span><br><span class="line">    pb-&gt;print(pb);</span><br><span class="line">    sum_ab = addPolynomial(pa,pb);</span><br><span class="line">    printf(&quot;pa + pb = &quot;);</span><br><span class="line">    sum_ab-&gt;print(sum_ab);</span><br><span class="line">    sub_ab = subPolynomial(pa,pb);</span><br><span class="line">    printf(&quot;pa - pb = &quot;);</span><br><span class="line">    sub_ab-&gt;print(sub_ab);</span><br><span class="line">    mul_ab = mulPolynomial(pa,pb);</span><br><span class="line">    printf(&quot;pa * pb = &quot;);</span><br><span class="line">    mul_ab-&gt;print(mul_ab);</span><br><span class="line">    kmul_a = kMulPolynomial(pa,params_b[0]);</span><br><span class="line">    printf(&quot;pa * 8x = &quot;);</span><br><span class="line">    kmul_a-&gt;print(kmul_a);</span><br><span class="line">    DestroyPolynomial(pa);</span><br><span class="line">    DestroyPolynomial(pb);</span><br><span class="line">    DestroyPolynomial(sum_ab);</span><br><span class="line">    DestroyPolynomial(mul_ab);</span><br><span class="line">    DestroyPolynomial(kmul_a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc Polynomial.c Polynomial.h testPolynomial.c -o testPolynomial</span><br></pre></td></tr></table></figure><p>运行testPolynomial<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pa = 7.000000x^0.000000 + 3.000000x^1.000000 + 9.000000x^8.000000 + 5.000000x^17.000000</span><br><span class="line">pb = 8.000000x^1.000000 + 22.000000x^7.000000 + -9.000000x^8.000000</span><br><span class="line">pa + pb = 7.000000x^0.000000 + 11.000000x^1.000000 + 22.000000x^7.000000 + 5.000000x^17.000000</span><br><span class="line">pa - pb = 7.000000x^0.000000 + -5.000000x^1.000000 + -22.000000x^7.000000 + 18.000000x^8.000000 + 5.000000x^17.000000</span><br><span class="line">pa * pb = 56.000000x^1.000000 + 24.000000x^2.000000 + 154.000000x^7.000000 + 3.000000x^8.000000 + 45.000000x^9.000000 + 198.000000x^15.000000 + -81.000000x^16.000000 + 40.000000x^18.000000 + 110.000000x^24.000000 + -45.000000x^25.000000</span><br><span class="line">pa * 8x = 56.000000x^1.000000 + 24.000000x^2.000000 + 72.000000x^9.000000 + 40.000000x^18.000000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装双向链表对象</title>
      <link href="/2018/08/28/C%E5%B0%81%E8%A3%85%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/28/C%E5%B0%81%E8%A3%85%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="DoubleLinkedList-双向链表"><a href="#DoubleLinkedList-双向链表" class="headerlink" title="DoubleLinkedList(双向链表)"></a>DoubleLinkedList(双向链表)</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>特点：<br>1.在单链表中，nextElem的执行时间为O(1),而priorElem的执行时间为O(n)。这是因为单链表只有一个指示直接后继的指针域。为克服单链表这种单向性的缺点，可以使用双向链表。<br>2.在双向链表的结点中有两个指针域，其中一指向直接后继，另一指向直接前驱。</p><span id="more"></span><p>3.在双向链表中，有些操作，如length、getElem、indexElem等仅需涉及一个方向的指针，则他们的算法和单链表的相同，在插入、删除时则有不同之处，需要同时修改两个方向上的指针。<br>4.在双向链表中插入节点temp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp-&gt;prior = p;</span><br><span class="line">temp-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">p-&gt;next-&gt;prior = temp;</span><br></pre></td></tr></table></figure><p>6.在双向链表中删除节点temp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp = p-&gt;next;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line">temp-&gt;next-&gt;prior = p;</span><br><span class="line">free(temp);</span><br></pre></td></tr></table></figure><h4 id="DoubleLinkedList-c文件"><a href="#DoubleLinkedList-c文件" class="headerlink" title="DoubleLinkedList.c文件"></a>DoubleLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DoubleLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(DoubleLinkedList *This);</span><br><span class="line">static int isEmpty(DoubleLinkedList *This);</span><br><span class="line">static int length(DoubleLinkedList *This);</span><br><span class="line">static void print(DoubleLinkedList *This);</span><br><span class="line">static int indexElem(DoubleLinkedList *This, ElemType* x);</span><br><span class="line">static int getElem(DoubleLinkedList *This, int index, ElemType *e);</span><br><span class="line">static int modifyElem(DoubleLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int deleteElem(DoubleLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int appendElem(DoubleLinkedList *This, ElemType *e);</span><br><span class="line">static int insertElem(DoubleLinkedList *This, int index, ElemType *e);</span><br><span class="line">static int popElem(DoubleLinkedList *This, ElemType* e);</span><br><span class="line"></span><br><span class="line">DoubleLinkedList *InitDoubleLinkedList()&#123;</span><br><span class="line">    DoubleLinkedList *L = (DoubleLinkedList *)malloc(sizeof(DoubleLinkedList));</span><br><span class="line">    Node *p = (Node *)malloc(sizeof(Node));</span><br><span class="line">    L-&gt;This = p;</span><br><span class="line">    p-&gt;prior = NULL;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    L-&gt;clear = clear;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;print = print;</span><br><span class="line">    L-&gt;indexElem = indexElem;</span><br><span class="line">    L-&gt;getElem = getElem;</span><br><span class="line">    L-&gt;modifyElem = modifyElem;</span><br><span class="line">    L-&gt;deleteElem = deleteElem;</span><br><span class="line">    L-&gt;appendElem = appendElem;</span><br><span class="line">    L-&gt;insertElem = insertElem;</span><br><span class="line">    L-&gt;popElem = popElem;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyDoubleLinkedList(DoubleLinkedList *L)&#123;</span><br><span class="line">    L-&gt;clear(L);</span><br><span class="line">    free(L-&gt;This);</span><br><span class="line">    free(L);</span><br><span class="line">    L = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(DoubleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;This;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(DoubleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(DoubleLinkedList *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void print(DoubleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexElem(DoubleLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(*e == p-&gt;elem)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getElem(DoubleLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    *e = p-&gt;elem;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int modifyElem(DoubleLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    p-&gt;elem = *e;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int insertElem(DoubleLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    temp-&gt;elem = *e;</span><br><span class="line">    p-&gt;next-&gt;prior = temp;</span><br><span class="line">    temp-&gt;prior = p;</span><br><span class="line">    temp-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deleteElem(DoubleLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p-&gt;next &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p-&gt;next || j &gt; index) return -1;</span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next-&gt;prior = p;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int appendElem(DoubleLinkedList *This, ElemType *e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(NULL == p-&gt;next)&#123;</span><br><span class="line">            temp-&gt;elem = *e;</span><br><span class="line">            p-&gt;next = temp;</span><br><span class="line">            temp-&gt;prior = p;</span><br><span class="line">            temp-&gt;next =  NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int popElem(DoubleLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p-&gt;next-&gt;next)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DoubleLinkedList-h文件"><a href="#DoubleLinkedList-h文件" class="headerlink" title="DoubleLinkedList.h文件"></a>DoubleLinkedList.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef __DOUBLELINKEDLIST_H</span><br><span class="line">#define __DOUBLELINKEDLIST_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef int ElemType;      //数据元素的类型，假设是int型的</span><br><span class="line"></span><br><span class="line">typedef struct Node&#123;</span><br><span class="line">    ElemType elem;  //存储空间</span><br><span class="line">    struct Node *prior;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">typedef struct DoubleLinkedList&#123;</span><br><span class="line">    Node *This;</span><br><span class="line">    void (*clear)(struct DoubleLinkedList *This);</span><br><span class="line">    int (*isEmpty)(struct DoubleLinkedList *This);</span><br><span class="line">    int (*length)(struct DoubleLinkedList *This);</span><br><span class="line">    void (*print)(struct DoubleLinkedList *This);</span><br><span class="line">    int (*indexElem)(struct DoubleLinkedList *This, ElemType* x);</span><br><span class="line">    int (*getElem)(struct DoubleLinkedList *This, int index, ElemType *e);</span><br><span class="line">    int (*modifyElem)(struct DoubleLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*deleteElem)(struct DoubleLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*appendElem)(struct DoubleLinkedList *This, ElemType *e);</span><br><span class="line">    int (*insertElem)(struct DoubleLinkedList *This, int index, ElemType *e);</span><br><span class="line">    int (*popElem)(struct DoubleLinkedList *This, ElemType* e);</span><br><span class="line">&#125;DoubleLinkedList;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">DoubleLinkedList *InitDoubleLinkedList();</span><br><span class="line">void DestroyDoubleLinkedList(DoubleLinkedList *L);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testDoubleLinkedList-c文件"><a href="#testDoubleLinkedList-c文件" class="headerlink" title="testDoubleLinkedList.c文件"></a>testDoubleLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;DoubleLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType elem,elem1;</span><br><span class="line">    DoubleLinkedList *list = InitDoubleLinkedList();</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    printf(&quot;list length:%d\n&quot;,list-&gt;length(list));</span><br><span class="line">    list-&gt;clear(list);</span><br><span class="line">    for (i = 10; i &lt; 20; i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;   </span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;the elem of index 3 is %d\n&quot;,elem1);</span><br><span class="line">    elem = 31;</span><br><span class="line">    list-&gt;modifyElem(list,3,&amp;elem);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;modify the elem of index 3 to %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 25;</span><br><span class="line">    list-&gt;insertElem(list,5,&amp;elem);</span><br><span class="line">    printf(&quot;insert elem %d to index 5\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;deleteElem(list,7,&amp;elem);</span><br><span class="line">    printf(&quot;delete elem %d of index 7\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 14;</span><br><span class="line">    printf(&quot;the index of 14 is %d\n&quot;,list-&gt;indexElem(list,&amp;elem));</span><br><span class="line">    list-&gt;popElem(list,&amp;elem);</span><br><span class="line">    printf(&quot;pop elem %d\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    DestroyDoubleLinkedList(list);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc DoubleLinkedList.c DoubleLinkedList.h testDoubleLinkedList.c -o testDoubleLinkedList</span><br></pre></td></tr></table></figure><p>运行testDoubleLinkedList<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list is empty:1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">list is empty:0</span><br><span class="line">list length:10</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">the elem of index 3 is 13</span><br><span class="line">modify the elem of index 3 to 31</span><br><span class="line">10 11 12 31 14 15 16 17 18 19</span><br><span class="line">insert elem 25 to index 5</span><br><span class="line">10 11 12 31 14 25 15 16 17 18 19</span><br><span class="line">delete elem 16 of index 7</span><br><span class="line">10 11 12 31 14 25 15 17 18 19</span><br><span class="line">the index of 14 is 4</span><br><span class="line">pop elem 19</span><br><span class="line">10 11 12 31 14 25 15 17 18</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装单向循环链表对象</title>
      <link href="/2018/08/28/C%E5%B0%81%E8%A3%85%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/28/C%E5%B0%81%E8%A3%85%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="SingleCircularLinkedList-单向循环链表"><a href="#SingleCircularLinkedList-单向循环链表" class="headerlink" title="SingleCircularLinkedList(单向循环链表)"></a>SingleCircularLinkedList(单向循环链表)</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>特点：<br>1.表中最后一个结点的指针指向头结点，整个链表形成一个环。由表中任一结点出发均可找到表中其他结点。<br>2.循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件不是p或p-&gt;next是否为空，而是他们是否等于头指针。</p><span id="more"></span><h4 id="SingleCircularLinkedList-c文件"><a href="#SingleCircularLinkedList-c文件" class="headerlink" title="SingleCircularLinkedList.c文件"></a>SingleCircularLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleCircularLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(SingleCircularLinkedList *This);</span><br><span class="line">static int isEmpty(SingleCircularLinkedList *This);</span><br><span class="line">static int length(SingleCircularLinkedList *This);</span><br><span class="line">static void print(SingleCircularLinkedList *This);</span><br><span class="line">static void circlePrint(SingleCircularLinkedList *This,int times);</span><br><span class="line">static int indexElem(SingleCircularLinkedList *This, ElemType* x);</span><br><span class="line">static int getElem(SingleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">static int modifyElem(SingleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int deleteElem(SingleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int appendElem(SingleCircularLinkedList *This, ElemType *e);</span><br><span class="line">static int insertElem(SingleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">static int popElem(SingleCircularLinkedList *This, ElemType* e);</span><br><span class="line"></span><br><span class="line">SingleCircularLinkedList *InitSingleCircularLinkedList()&#123;</span><br><span class="line">    SingleCircularLinkedList *L = (SingleCircularLinkedList *)malloc(sizeof(SingleCircularLinkedList));</span><br><span class="line">    Node *p = (Node *)malloc(sizeof(Node));</span><br><span class="line">    L-&gt;This = p;</span><br><span class="line">    p-&gt;next = p;</span><br><span class="line">    L-&gt;clear = clear;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;print = print;</span><br><span class="line">    L-&gt;circlePrint = circlePrint;</span><br><span class="line">    L-&gt;indexElem = indexElem;</span><br><span class="line">    L-&gt;getElem = getElem;</span><br><span class="line">    L-&gt;modifyElem = modifyElem;</span><br><span class="line">    L-&gt;deleteElem = deleteElem;</span><br><span class="line">    L-&gt;appendElem = appendElem;</span><br><span class="line">    L-&gt;insertElem = insertElem;</span><br><span class="line">    L-&gt;popElem = popElem;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroySingleCircularLinkedList(SingleCircularLinkedList *L)&#123;</span><br><span class="line">    L-&gt;clear(L);</span><br><span class="line">    free(L-&gt;This);</span><br><span class="line">    free(L);</span><br><span class="line">    L = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(SingleCircularLinkedList *This)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(SingleCircularLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next == p)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(SingleCircularLinkedList *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void print(SingleCircularLinkedList *This)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void circlePrint(SingleCircularLinkedList *This,int times)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    int i = 0;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    for(i = 0;i&lt;times;)&#123;</span><br><span class="line">        if(p == head)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexElem(SingleCircularLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head)&#123;</span><br><span class="line">        if(*e == p-&gt;elem)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getElem(SingleCircularLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p == head || j &gt; index) return -1;</span><br><span class="line">    *e = p-&gt;elem;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int modifyElem(SingleCircularLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p == head || j &gt; index) return -1;</span><br><span class="line">    p-&gt;elem = *e;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int insertElem(SingleCircularLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p-&gt;next != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p-&gt;next == head || j &gt; index) return -1;</span><br><span class="line">    temp-&gt;elem = *e;</span><br><span class="line">    temp-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deleteElem(SingleCircularLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p-&gt;next != head &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(p-&gt;next == head || j &gt; index) return -1;</span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int appendElem(SingleCircularLinkedList *This, ElemType *e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p-&gt;next != head)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    temp-&gt;elem = *e;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int popElem(SingleCircularLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *head = This-&gt;This;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p-&gt;next-&gt;next != head)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    if(temp == head) return -1;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SingleCircularLinkedList-h文件"><a href="#SingleCircularLinkedList-h文件" class="headerlink" title="SingleCircularLinkedList.h文件"></a>SingleCircularLinkedList.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef __SINGLECIRCULARLINKEDLIST_H</span><br><span class="line">#define __SINGLECIRCULARLINKEDLIST_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef int ElemType;      //数据元素的类型，假设是int型的</span><br><span class="line"></span><br><span class="line">typedef struct Node&#123;</span><br><span class="line">    ElemType elem;  //存储空间</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">typedef struct SingleCircularLinkedList&#123;</span><br><span class="line">    Node *This;</span><br><span class="line">    void (*clear)(struct SingleCircularLinkedList *This);</span><br><span class="line">    int (*isEmpty)(struct SingleCircularLinkedList *This);</span><br><span class="line">    int (*length)(struct SingleCircularLinkedList *This);</span><br><span class="line">    void (*print)(struct SingleCircularLinkedList *This);</span><br><span class="line">    void (*circlePrint)(struct SingleCircularLinkedList *This,int times);</span><br><span class="line">    int (*indexElem)(struct SingleCircularLinkedList *This, ElemType* x);</span><br><span class="line">    int (*getElem)(struct SingleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">    int (*modifyElem)(struct SingleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*deleteElem)(struct SingleCircularLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*appendElem)(struct SingleCircularLinkedList *This, ElemType *e);</span><br><span class="line">    int (*insertElem)(struct SingleCircularLinkedList *This, int index, ElemType *e);</span><br><span class="line">    int (*popElem)(struct SingleCircularLinkedList *This, ElemType* e);</span><br><span class="line">&#125;SingleCircularLinkedList;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">SingleCircularLinkedList *InitSingleCircularLinkedList();</span><br><span class="line">void DestroySingleCircularLinkedList(SingleCircularLinkedList *L);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testSingleCircularLinkedList-c文件"><a href="#testSingleCircularLinkedList-c文件" class="headerlink" title="testSingleCircularLinkedList.c文件"></a>testSingleCircularLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleCircularLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType elem,elem1;</span><br><span class="line">    SingleCircularLinkedList *list = InitSingleCircularLinkedList();</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    printf(&quot;list length:%d\n&quot;,list-&gt;length(list));</span><br><span class="line">    list-&gt;clear(list);</span><br><span class="line">    for (i = 10; i &lt; 20; i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;   </span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;the elem of index 3 is %d\n&quot;,elem1);</span><br><span class="line">    elem = 31;</span><br><span class="line">    list-&gt;modifyElem(list,3,&amp;elem);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;modify the elem of index 3 to %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 25;</span><br><span class="line">    list-&gt;insertElem(list,5,&amp;elem);</span><br><span class="line">    printf(&quot;insert elem %d to index 5\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;deleteElem(list,7,&amp;elem);</span><br><span class="line">    printf(&quot;delete elem %d of index 7\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 14;</span><br><span class="line">    printf(&quot;the index of 14 is %d\n&quot;,list-&gt;indexElem(list,&amp;elem));</span><br><span class="line">    list-&gt;popElem(list,&amp;elem);</span><br><span class="line">    printf(&quot;pop elem %d\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    printf(&quot;circle print 3 times:\n&quot;);</span><br><span class="line">    list-&gt;circlePrint(list,3);</span><br><span class="line">    DestroySingleCircularLinkedList(list);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc SingleCircularLinkedList.c SingleCircularLinkedList.h testSingleCircularLinkedList.c -o testSingleCircularLinkedList</span><br></pre></td></tr></table></figure><p>运行testSingleCircularLinkedList<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list is empty:0</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">list is empty:1</span><br><span class="line">list length:10</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">the elem of index 3 is 13</span><br><span class="line">modify the elem of index 3 to 31</span><br><span class="line">10 11 12 31 14 15 16 17 18 19</span><br><span class="line">insert elem 25 to index 5</span><br><span class="line">10 11 12 31 14 25 15 16 17 18 19</span><br><span class="line">delete elem 16 of index 7</span><br><span class="line">10 11 12 31 14 25 15 17 18 19</span><br><span class="line">the index of 14 is 4</span><br><span class="line">pop elem 19</span><br><span class="line">10 11 12 31 14 25 15 17 18</span><br><span class="line">circle print 3 times:</span><br><span class="line">10 11 12 31 14 25 15 17 18 10 11 12 31 14 25 15 17 18 10 11 12 31 14 25 15 17 18</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装单链表对象</title>
      <link href="/2018/08/28/C%E5%B0%81%E8%A3%85%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/28/C%E5%B0%81%E8%A3%85%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="SingleLinkedList-单链表"><a href="#SingleLinkedList-单链表" class="headerlink" title="SingleLinkedList(单链表)"></a>SingleLinkedList(单链表)</h4><p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>特点：<br>1.用一组任意的存储单元存储数据元素，逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此，这种存储结构为非顺序映像或链式映像。<br>2.存储节点包含两个域：其中存储数据元素信息的域称为数据域，存储直接后继存储位置的域称为指针域。</p><span id="more"></span><p>3.整个链表的存取必须从头指针开始，头指针表示链表中第一个节点的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为空（NULL）。<br>4.在单链表中，取得第i个元素必须从头指针出发寻找，因此单链表是非随机存取的存储结构。<br>5.在单链表中插入节点temp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = temp;</span><br></pre></td></tr></table></figure><p>6.在单链表中删除节点temp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = p-&gt;next;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line">free(temp);</span><br></pre></td></tr></table></figure><p>7.在单链表中插入或删除一个节点时，仅需修改指针而不需要移动元素。<br>8.单链表获取、插入、删除元素的时间复杂度均为O(n)，因为找到第i个结点都必须首先找到第i-1个结点，while循环环体中的语句频度与被查元素在表中位置有关，若1&lt;&#x3D;i&lt;&#x3D;n,则频度为i-1，否则频度为n。</p><h4 id="SingleLinkedList-c文件"><a href="#SingleLinkedList-c文件" class="headerlink" title="SingleLinkedList.c文件"></a>SingleLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">static void clear(SingleLinkedList *This);</span><br><span class="line">static int isEmpty(SingleLinkedList *This);</span><br><span class="line">static int length(SingleLinkedList *This);</span><br><span class="line">static void print(SingleLinkedList *This);</span><br><span class="line">static int indexElem(SingleLinkedList *This, ElemType* x);</span><br><span class="line">static int getElem(SingleLinkedList *This, int index, ElemType *e);</span><br><span class="line">static int modifyElem(SingleLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int deleteElem(SingleLinkedList *This, int index, ElemType* e);</span><br><span class="line">static int appendElem(SingleLinkedList *This, ElemType *e);</span><br><span class="line">static int insertElem(SingleLinkedList *This, int index, ElemType *e);</span><br><span class="line">static int popElem(SingleLinkedList *This, ElemType* e);</span><br><span class="line"></span><br><span class="line">SingleLinkedList *InitSingleLinkedList()&#123;</span><br><span class="line">    SingleLinkedList *L = (SingleLinkedList *)malloc(sizeof(SingleLinkedList));</span><br><span class="line">    Node *p = (Node *)malloc(sizeof(Node));</span><br><span class="line">    L-&gt;This = p;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    L-&gt;clear = clear;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;print = print;</span><br><span class="line">    L-&gt;indexElem = indexElem;</span><br><span class="line">    L-&gt;getElem = getElem;</span><br><span class="line">    L-&gt;modifyElem = modifyElem;</span><br><span class="line">    L-&gt;deleteElem = deleteElem;</span><br><span class="line">    L-&gt;appendElem = appendElem;</span><br><span class="line">    L-&gt;insertElem = insertElem;</span><br><span class="line">    L-&gt;popElem = popElem;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroySingleLinkedList(SingleLinkedList *L)&#123;</span><br><span class="line">    L-&gt;clear(L);</span><br><span class="line">    free(L-&gt;This);</span><br><span class="line">    free(L);</span><br><span class="line">    L = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(SingleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free(temp);</span><br><span class="line">    &#125; </span><br><span class="line">    p = This-&gt;This;</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(SingleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    if(p-&gt;next)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(SingleLinkedList *This)&#123;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void print(SingleLinkedList *This)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexElem(SingleLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(*e == p-&gt;elem)&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getElem(SingleLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    *e = p-&gt;elem;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int modifyElem(SingleLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This-&gt;next;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    p-&gt;elem = *e;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int insertElem(SingleLinkedList *This, int index, ElemType *e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    int j = 0;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p || j &gt; index) return -1;</span><br><span class="line">    temp-&gt;elem = *e;</span><br><span class="line">    temp-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deleteElem(SingleLinkedList *This, int index, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(p-&gt;next &amp;&amp; j &lt; index)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; </span><br><span class="line">    if(!p-&gt;next || j &gt; index) return -1;</span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    p-&gt;next = temp-&gt;next;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int appendElem(SingleLinkedList *This, ElemType *e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    while(p)&#123;</span><br><span class="line">        if(NULL == p-&gt;next)&#123;</span><br><span class="line">            temp-&gt;elem = *e;</span><br><span class="line">            p-&gt;next = temp;</span><br><span class="line">            temp-&gt;next =  NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int popElem(SingleLinkedList *This, ElemType* e)&#123;</span><br><span class="line">    Node *p = This-&gt;This;</span><br><span class="line">    Node *temp = NULL;</span><br><span class="line">    while(p-&gt;next-&gt;next)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; </span><br><span class="line">    temp = p-&gt;next;</span><br><span class="line">    if(!temp) return -1;</span><br><span class="line">    *e = temp-&gt;elem;</span><br><span class="line">    free(temp);</span><br><span class="line">    p-&gt;next = NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SingleLinkedList-h文件"><a href="#SingleLinkedList-h文件" class="headerlink" title="SingleLinkedList.h文件"></a>SingleLinkedList.h文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef __SINGLELINKEDLIST_H</span><br><span class="line">#define __SINGLELINKEDLIST_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef int ElemType;      //数据元素的类型，假设是int型的</span><br><span class="line"></span><br><span class="line">typedef struct Node&#123;</span><br><span class="line">    ElemType elem;  //存储空间</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">typedef struct SingleLinkedList&#123;</span><br><span class="line">    Node *This;</span><br><span class="line">    void (*clear)(struct SingleLinkedList *This);</span><br><span class="line">    int (*isEmpty)(struct SingleLinkedList *This);</span><br><span class="line">    int (*length)(struct SingleLinkedList *This);</span><br><span class="line">    void (*print)(struct SingleLinkedList *This);</span><br><span class="line">    int (*indexElem)(struct SingleLinkedList *This, ElemType* x);</span><br><span class="line">    int (*getElem)(struct SingleLinkedList *This, int index, ElemType *e);</span><br><span class="line">    int (*modifyElem)(struct SingleLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*deleteElem)(struct SingleLinkedList *This, int index, ElemType* e);</span><br><span class="line">    int (*appendElem)(struct SingleLinkedList *This, ElemType *e);</span><br><span class="line">    int (*insertElem)(struct SingleLinkedList *This, int index, ElemType *e);</span><br><span class="line">    int (*popElem)(struct SingleLinkedList *This, ElemType* e);</span><br><span class="line">&#125;SingleLinkedList;</span><br><span class="line"></span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">SingleLinkedList *InitSingleLinkedList();</span><br><span class="line">void DestroySingleLinkedList(SingleLinkedList *L);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="testSingleLinkedList-c文件"><a href="#testSingleLinkedList-c文件" class="headerlink" title="testSingleLinkedList.c文件"></a>testSingleLinkedList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;SingleLinkedList.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType elem,elem1;</span><br><span class="line">    SingleLinkedList *list = InitSingleLinkedList();</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    printf(&quot;list length:%d\n&quot;,list-&gt;length(list));</span><br><span class="line">    list-&gt;clear(list);</span><br><span class="line">    for (i = 10; i &lt; 20; i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;   </span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;the elem of index 3 is %d\n&quot;,elem1);</span><br><span class="line">    elem = 31;</span><br><span class="line">    list-&gt;modifyElem(list,3,&amp;elem);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;modify the elem of index 3 to %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 25;</span><br><span class="line">    list-&gt;insertElem(list,5,&amp;elem);</span><br><span class="line">    printf(&quot;insert elem %d to index 5\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;deleteElem(list,7,&amp;elem);</span><br><span class="line">    printf(&quot;delete elem %d of index 7\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 14;</span><br><span class="line">    printf(&quot;the index of 14 is %d\n&quot;,list-&gt;indexElem(list,&amp;elem));</span><br><span class="line">    list-&gt;popElem(list,&amp;elem);</span><br><span class="line">    printf(&quot;pop elem %d\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    DestroySingleLinkedList(list);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc SingleLinkedList.c SingleLinkedList.h testSingleLinkedList.c -o testSingleLinkedList</span><br></pre></td></tr></table></figure><p>运行testSingleLinkedList<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">list is empty:1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">list is empty:0</span><br><span class="line">list length:10</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">the elem of index 3 is 13</span><br><span class="line">modify the elem of index 3 to 31</span><br><span class="line">10 11 12 31 14 15 16 17 18 19</span><br><span class="line">insert elem 25 to index 5</span><br><span class="line">10 11 12 31 14 25 15 16 17 18 19</span><br><span class="line">delete elem 16 of index 7</span><br><span class="line">10 11 12 31 14 25 15 17 18 19</span><br><span class="line">the index of 14 is 4</span><br><span class="line">pop elem 19</span><br><span class="line">10 11 12 31 14 25 15 17 18</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C封装线性表对象</title>
      <link href="/2018/08/24/C%E5%B0%81%E8%A3%85%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/08/24/C%E5%B0%81%E8%A3%85%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a></p><span id="more"></span><h4 id="LinearList-c文件"><a href="#LinearList-c文件" class="headerlink" title="LinearList.c文件"></a>LinearList.c文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearList.h&quot;</span><br><span class="line">//线性表</span><br><span class="line"></span><br><span class="line">static void clear(LinearList *This);</span><br><span class="line">static int isEmpty(LinearList *This);</span><br><span class="line">static int length(LinearList *This);</span><br><span class="line">static void print(LinearList *This);</span><br><span class="line">static int indexElem(LinearList *This, ElemType* x);</span><br><span class="line">static int priorElem(LinearList *This, ElemType* cur_elem, ElemType* pre_elem);</span><br><span class="line">static int getElem(LinearList *This, int index, ElemType* e);</span><br><span class="line">static int modifyElem(LinearList *This, int index, ElemType* e);</span><br><span class="line">static int nextElem(LinearList *This, ElemType* cur_elem, ElemType* next_elem);</span><br><span class="line">static int insertElem(LinearList *This, int index, ElemType* e);</span><br><span class="line">static int deleteElem(LinearList *This, int index, ElemType* e);</span><br><span class="line">static int appendElem(LinearList *This,ElemType* e);</span><br><span class="line">static int popElem(LinearList *This, ElemType* e);</span><br><span class="line"></span><br><span class="line">LinearList *InitLinearList()&#123;</span><br><span class="line">    LinearList *L = (LinearList *)malloc(sizeof(LinearList));</span><br><span class="line">    LinearList_P *p = (LinearList_P *)malloc(sizeof(LinearList_P));</span><br><span class="line">    p-&gt;elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">    p-&gt;length = 0; //当前长度</span><br><span class="line">    p-&gt;size = LIST_INIT_SIZE; //当前分配量</span><br><span class="line">    L-&gt;This = p;</span><br><span class="line">    L-&gt;clear = clear;</span><br><span class="line">    L-&gt;isEmpty = isEmpty;</span><br><span class="line">    L-&gt;length = length;</span><br><span class="line">    L-&gt;print = print;</span><br><span class="line">    L-&gt;indexElem = indexElem;</span><br><span class="line">    L-&gt;priorElem = priorElem;</span><br><span class="line">    L-&gt;getElem = getElem;</span><br><span class="line">    L-&gt;modifyElem = modifyElem;</span><br><span class="line">    L-&gt;nextElem = nextElem;</span><br><span class="line">    L-&gt;insertElem = insertElem;</span><br><span class="line">    L-&gt;deleteElem = deleteElem;</span><br><span class="line">    L-&gt;appendElem = appendElem;</span><br><span class="line">    L-&gt;popElem = popElem;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyLinearList(LinearList *L)&#123;</span><br><span class="line">    free(L-&gt;This);</span><br><span class="line">    free(L);</span><br><span class="line">    L = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void clear(LinearList *This)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    p-&gt;length = 0; //当前长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int isEmpty(LinearList *This)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    return (p-&gt;length == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int length(LinearList *This)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    return p-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void print(LinearList *This)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i &lt; p-&gt;length; i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, p-&gt;elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexElem(LinearList *This, ElemType* x)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    for (int i = 0; i &lt; p-&gt;length; i++)&#123;</span><br><span class="line">        if (p-&gt;elem[i] == *x)&#123;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int priorElem(LinearList *This, ElemType* cur_elem, ElemType* pre_elem)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    pos = indexElem(This, cur_elem);</span><br><span class="line">    if(pos &lt;= 0) return -1;</span><br><span class="line">    *pre_elem = p-&gt;elem[pos-1];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int getElem(LinearList *This, int index, ElemType* e)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    if (index&lt;0 || index &gt;= p-&gt;length) return -1;</span><br><span class="line">    *e = p-&gt;elem[index];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int modifyElem(LinearList *This, int index, ElemType* e)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    if (index&lt;0 || index &gt;= p-&gt;length) return -1;</span><br><span class="line">    p-&gt;elem[index] = *e;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int nextElem(LinearList *This, ElemType* cur_elem, ElemType* next_elem)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    pos = indexElem(This, cur_elem);</span><br><span class="line">    if(pos == -1 || pos == (p-&gt;length - 1)) return -1;</span><br><span class="line">    *next_elem = p-&gt;elem[pos+1];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int insertElem(LinearList *This, int index, ElemType* e)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    if (index&lt;0 || index &gt;= p-&gt;length) return -1;</span><br><span class="line">    if (p-&gt;length &gt;= p-&gt;size)&#123; //判断存储空间是否够用</span><br><span class="line">        ElemType *newbase = (ElemType *)realloc(p-&gt;elem, (p-&gt;size + LISTINCREMENT)*sizeof(ElemType));</span><br><span class="line">        if (!newbase) return -1;//存储空间分配失败</span><br><span class="line">        p-&gt;elem = newbase;//新基址</span><br><span class="line">        p-&gt;size += LISTINCREMENT;//增加存储容量</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType *elem_q = NULL;, *elem_p = NULL;;</span><br><span class="line">    elem_q = &amp;(p-&gt;elem[index]); //q为插入位置</span><br><span class="line">    for (elem_p = &amp;(p-&gt;elem[p-&gt;length - 1]); elem_p &gt;= elem_q; --elem_p)&#123; //从ai到an-1依次后移，注意后移操作要从后往前进行</span><br><span class="line">        *(elem_p + 1) = *elem_p;</span><br><span class="line">    &#125;</span><br><span class="line">    *elem_q = *e;</span><br><span class="line">    ++p-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int deleteElem(LinearList *This, int index, ElemType* e)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    if (index&lt;1 || index &gt; p-&gt;length) return -1;</span><br><span class="line">    ElemType *elem_q = NULL;, *elem_p = NULL;;</span><br><span class="line">    elem_p = &amp;(p-&gt;elem[index]);//elem_p为被删除元素的位置</span><br><span class="line">    *e = *elem_p; //被删除的元素赋值给e</span><br><span class="line">    elem_q = p-&gt;elem + p-&gt;length - 1;//elem_q指向表尾最后一个元素</span><br><span class="line">    for (++elem_p; elem_p &lt;= elem_q; ++elem_p)&#123; //从elem_p的下一个元素开始依次前移</span><br><span class="line">        *(elem_p - 1) = *elem_p;</span><br><span class="line">    &#125;</span><br><span class="line">    --p-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int appendElem(LinearList *This,ElemType* e)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    if (p-&gt;length &gt;= p-&gt;size)&#123; //判断存储空间是否够用</span><br><span class="line">        ElemType *newbase = (ElemType *)realloc(p-&gt;elem, (p-&gt;size + LISTINCREMENT)*sizeof(ElemType));</span><br><span class="line">        if (!newbase) return -1;//存储空间分配失败</span><br><span class="line">        p-&gt;elem = newbase;//新基址</span><br><span class="line">        p-&gt;size += LISTINCREMENT;//增加存储容量</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;elem[p-&gt;length] = *e;</span><br><span class="line">    ++p-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int popElem(LinearList *This, ElemType* e)&#123;</span><br><span class="line">    LinearList_P *p = This-&gt;This;</span><br><span class="line">    if (isEmpty(This)) return -1;</span><br><span class="line">    *e = p-&gt;elem[p-&gt;length - 1];</span><br><span class="line">    --p-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinearList-h文件："><a href="#LinearList-h文件：" class="headerlink" title="LinearList.h文件："></a>LinearList.h文件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* Define to prevent recursive inclusion -------------------------------------*/</span><br><span class="line">#ifndef __LINEAR_LIST_H</span><br><span class="line">#define __LINEAR_LIST_H</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">/* Exported types ------------------------------------------------------------*/</span><br><span class="line">typedef int ElemType;      //数据元素的类型，假设是int型的</span><br><span class="line"></span><br><span class="line">typedef struct LinearList_P&#123;</span><br><span class="line">    ElemType *elem;  //存储空间的基地址</span><br><span class="line">    int length;      //当前线性表的长度</span><br><span class="line">    int size;    //当前分配的存储容量</span><br><span class="line">&#125;LinearList_P;</span><br><span class="line"></span><br><span class="line">typedef struct LinearList&#123;</span><br><span class="line">    LinearList_P *This;  </span><br><span class="line">    void (*clear)(struct LinearList *This);</span><br><span class="line">    int (*isEmpty)(struct LinearList *This);</span><br><span class="line">    int (*length)(struct LinearList *This);</span><br><span class="line">    void (*print)(struct LinearList *This);</span><br><span class="line">    int (*indexElem)(struct LinearList *This, ElemType* x);</span><br><span class="line">    int (*priorElem)(struct LinearList *This, ElemType* cur_elem, ElemType* pre_elem);</span><br><span class="line">    int (*getElem)(struct LinearList *This, int index, ElemType* e);</span><br><span class="line">    int (*modifyElem)(struct LinearList *This, int index, ElemType* e);</span><br><span class="line">    int (*nextElem)(struct LinearList *This, ElemType* cur_elem, ElemType* next_elem);</span><br><span class="line">    int (*insertElem)(struct LinearList *This, int index, ElemType* e);</span><br><span class="line">    int (*deleteElem)(struct LinearList *This, int index, ElemType* e);</span><br><span class="line">    int (*appendElem)(struct LinearList *This,ElemType* e);</span><br><span class="line">    int (*popElem)(struct LinearList *This, ElemType* e);</span><br><span class="line">&#125;LinearList;</span><br><span class="line"></span><br><span class="line">/* Exported define -----------------------------------------------------------*/</span><br><span class="line">#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量</span><br><span class="line">#define LISTINCREMENT 10   //线性表存储空间的分配增量(当存储空间不够时要用到)</span><br><span class="line">/* Exported macro ------------------------------------------------------------*/</span><br><span class="line">LinearList *InitLinearList();</span><br><span class="line">void DestroyLinearList(LinearList *L);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="测试文件-testLinearList-c"><a href="#测试文件-testLinearList-c" class="headerlink" title="测试文件 testLinearList.c"></a>测试文件 testLinearList.c</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &quot;LinearList.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType elem,elem1;</span><br><span class="line">    LinearList *list = InitLinearList();</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    for (i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    printf(&quot;list is empty:%d\n&quot;,list-&gt;isEmpty(list));</span><br><span class="line">    printf(&quot;list length:%d\n&quot;,list-&gt;length(list));</span><br><span class="line">    list-&gt;clear(list);</span><br><span class="line">    for (i = 10; i &lt; 20; i++)&#123;</span><br><span class="line">        list-&gt;appendElem(list,&amp;i);</span><br><span class="line">    &#125;   </span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 17;</span><br><span class="line">    printf(&quot;the index of 17 is %d\n&quot;,list-&gt;indexElem(list,&amp;elem));</span><br><span class="line">    list-&gt;priorElem(list,&amp;elem,&amp;elem1);</span><br><span class="line">    printf(&quot;the prior elem of 17 is %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;nextElem(list,&amp;elem,&amp;elem1);</span><br><span class="line">    printf(&quot;the next elem of 17 is %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;the elem of index 3 is %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;modifyElem(list,3,&amp;elem);</span><br><span class="line">    list-&gt;getElem(list,3,&amp;elem1);</span><br><span class="line">    printf(&quot;modify the elem of index 3 to %d\n&quot;,elem1);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    elem = 25;</span><br><span class="line">    list-&gt;insertElem(list,5,&amp;elem);</span><br><span class="line">    printf(&quot;insert elem %d to index 5\n&quot;,elem);</span><br><span class="line">    list-&gt;deleteElem(list,7,&amp;elem);</span><br><span class="line">    printf(&quot;delete elem %d of index 7\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    list-&gt;popElem(list,&amp;elem);</span><br><span class="line">    printf(&quot;pop elem %d\n&quot;,elem);</span><br><span class="line">    list-&gt;print(list);</span><br><span class="line">    DestroyLinearList(list);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc LinearList.c LinearList.h testLinearList.c -o testLinearList</span><br></pre></td></tr></table></figure><p>运行testLinearList<br>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list is empty:1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">list is empty:0</span><br><span class="line">list length:10</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">the index of 17 is 7</span><br><span class="line">the prior elem of 17 is 16</span><br><span class="line">the next elem of 17 is 18</span><br><span class="line">the elem of index 3 is 13</span><br><span class="line">modify the elem of index 3 to 17</span><br><span class="line">10 11 12 17 14 15 16 17 18 19</span><br><span class="line">insert elem 25 to index 5</span><br><span class="line">delete elem 16 of index 7</span><br><span class="line">10 11 12 17 14 25 15 17 18 19</span><br><span class="line">pop elem 19</span><br><span class="line">10 11 12 17 14 25 15 17 18</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解a.out</title>
      <link href="/2018/08/12/%E7%90%86%E8%A7%A3a-out/"/>
      <url>/2018/08/12/%E7%90%86%E8%A7%A3a-out/</url>
      
        <content type="html"><![CDATA[<p>你是否曾疑惑“a.out”这个名字是怎样确定的？把所有的输出文件都缺省的使用同一个名字a.out可能会带来不便，可能会忘了它来自哪一个源文件，对任何文件进行下一次编译时都有可能覆盖它。</p><span id="more"></span><p>a.out是“assembler output”（汇编程序输出）的缩写形式。这里有一个问题：它不是汇编程序输出，而是链接器输出。“汇编程序输出”这个名字的产生纯属历史原因。在早期的语言中并不存在链接器，程序是这样创建的：先把所有源文件连接在一起，然后进行汇编，汇编产生的汇编程序输出保存在a.out中。即使最后有了链接器之后，最后一个环节的输出文件依然沿用了这个命名习惯。</p><p>UNIX中的可执行文件是以一种特殊的方式加上标签，这样系统就能确认它们的特殊属性。为重要的数据定义标签，用独特的数字唯一的标识该数据是一种普遍采用的编程技巧。可执行文件用文件的第一个字节来标注，文件以十六进制数7F开头，紧跟在后面的第二至第四个字节为“ELF”（Executable and Linking Format）可执行文件和链接格式。</p><p>在UNIX中，段表示一个二进制文件相关的内容块，里面保存了和某种特定类型（如符号表条目）相关的所有信息。术语section也被广泛使用，section是ELF文件中的最小组织单位。一个段一般包含几个section。size命令+可执行文件可以告诉你这个文件中的三个段（文本段、数据段和bss段）的大小。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-c33741cae0ad76c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="size命令"><br>检查可执行文件内容的另一种方式是使用nm或dump工具。nm可以列出目标文件的符号清单。<br>编译下面的源文件，在结果的a.out文件上运行nm程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">char pear[40];</span><br><span class="line">static double peach;</span><br><span class="line">int mango = 13;</span><br><span class="line">static long melon = 2001;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">        int i = 3,j,*ip;</span><br><span class="line">        ip = malloc(sizeof(i));</span><br><span class="line">        pear[5]=i;</span><br><span class="line">        peach = 2.0 * mango;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行nm程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -Sln a.out</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/9169686-588430e6afd70293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行nm程序"><br>我们对上面显示的内容稍作整理：</p><table><thead><tr><th>值</th><th>大小</th><th>类型</th><th>名字</th></tr></thead><tbody><tr><td>000000000000064a</td><td>000000000000004a</td><td>T</td><td>main</td></tr><tr><td>0000000000201010</td><td>0000000000000004</td><td>D</td><td>mango</td></tr><tr><td>0000000000201018</td><td>0000000000000008</td><td>d</td><td>melon</td></tr><tr><td>0000000000201028</td><td>0000000000000008</td><td>b</td><td>peach</td></tr><tr><td>0000000000201040</td><td>0000000000000028</td><td>B</td><td>pear</td></tr></tbody></table><p>下面说明符号类型：<br><strong>对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的。</strong></p><table><thead><tr><th>符号类型</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</td></tr><tr><td>B</td><td>该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为B，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。</td></tr><tr><td>C</td><td>该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。</td></tr><tr><td>D</td><td>该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] &#x3D; {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。</td></tr><tr><td>G</td><td>该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。</td></tr><tr><td>I</td><td>该符号是对另一个符号的间接引用。</td></tr><tr><td>N</td><td>该符号是一个debugging符号。</td></tr><tr><td>R</td><td>该符号位于只读数据区。例如定义全局const int test[] &#x3D; {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test &#x3D; “abc”, const char test_int &#x3D; 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。</td></tr><tr><td>S</td><td>符号位于非初始化数据区，用于small object。</td></tr><tr><td>T</td><td>该符号位于代码区text section。</td></tr><tr><td>U</td><td>该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。</td></tr><tr><td>V</td><td>该符号是一个weak object。</td></tr><tr><td>W</td><td>The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</td></tr><tr><td>-</td><td>该符号是a.out格式文件中的stabs symbol。</td></tr><tr><td>?</td><td>该符号类型没有定义。</td></tr></tbody></table><p>根据上面的内容，我们可以判断出a.out文件里面的内容分布：</p><table><thead><tr><th>a.out段</th><th>内容</th></tr></thead><tbody><tr><td>a.out开头</td><td>0x7F + “ELF”</td></tr><tr><td>a.out其他内容</td><td>…</td></tr><tr><td>BSS段</td><td>(b)pear,(B)peach：未初始化的全局和静态变量</td></tr><tr><td>数据段</td><td>(d)mango,(D)melon：初始化后的全局和静态变量</td></tr><tr><td>文本段</td><td>可执行文件的指令</td></tr></tbody></table><p>1.局部变量并不进入a.out，它们在运行时创建。<br>2.BSS段这个名字是“Block Started by Symbol”（由符号开始的块）的缩写，它是旧式IBM04汇编程序的一个伪指令，UNIX借用了这个名字。有些人喜欢把它记作Better Save Space。由于BSS段只保存没有值的变量，所以事实上它并不需要保存这些变量的映像。BSS段不保存在目标文件中（除了记录BSS段在运行时所需要的大小）。<br>3.数据段保存在目标文件中。<br>4.文本段是最容易受优化措施影响的段。a.out文件的大小受调试状态下编译的影响，但段不受影响。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、假设空间与归纳偏好</title>
      <link href="/2018/08/11/%E4%BA%8C%E3%80%81%E5%81%87%E8%AE%BE%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%BD%92%E7%BA%B3%E5%81%8F%E5%A5%BD/"/>
      <url>/2018/08/11/%E4%BA%8C%E3%80%81%E5%81%87%E8%AE%BE%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%BD%92%E7%BA%B3%E5%81%8F%E5%A5%BD/</url>
      
        <content type="html"><![CDATA[<h5 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h5><p><strong>归纳（induction）</strong>与<strong>演绎（deduction）</strong>是科学推理的两大基本手段。前者是从特殊到一般的<strong>泛化（generalization）</strong>过程，即从具体的事实归结出一般性规律；后者则是从一般到特殊的<strong>特化（specialization）</strong>过程，即从基础原理推演出具体状况。</p><span id="more"></span><p>例如，在数学公理系统中，基于一组公理和推理规则推导出与之相洽的定理，这里演绎；而从样例中学习显然是一个归纳的过程，因此亦称<strong>归纳学习（inductive learning）</strong>。</p><p>归纳学习有狭义与广义之分，广义的归纳学习大体相当于从样例中学习，而狭义的归纳学习则要求从训练数据中学得<strong>概念（concept）</strong>，因此亦称为概念学习或概念形成。概念学习技术目前研究、应用都比较少，因为要学得泛化性能好且语义明确的概念实在太困难了，现实常用的技术大多是产生“黑箱”模型。然而，对概念学习有所了解，有助于理解机器学习的一些基础思想。</p><p>概念学习中最基本的是布尔概念学习，即对“是”、“不是”这样的可表示为0&#x2F;1布尔值的目标概念的学习。举一个简单的例子，假定我们获得了一个西瓜训练数据集：</p><table><thead><tr><th>编号</th><th>色泽</th><th>根蒂</th><th>敲声</th><th>好瓜</th></tr></thead><tbody><tr><td>1</td><td>青绿</td><td>蜷缩</td><td>浊响</td><td>是</td></tr><tr><td>2</td><td>乌黑</td><td>蜷缩</td><td>浊响</td><td>是</td></tr><tr><td>3</td><td>青绿</td><td>硬挺</td><td>清脆</td><td>否</td></tr><tr><td>4</td><td>乌黑</td><td>稍卷</td><td>沉闷</td><td>否</td></tr></tbody></table><p>这里要学习的目标是“好瓜”，暂且假设“好瓜”可由“色泽”“根蒂”“敲声”这三个因素完全确定，换言之，只要某个瓜的这三个属性取值明确了，我们就能判断出它是不是好瓜。</p><p>于是，我们学得的将是“好瓜是某种色泽、某种根蒂、某种敲声的瓜”这样的概念，用布尔表达式写出来则是“好瓜↔（色泽&#x3D;？）^（根蒂&#x3D;？）^（敲声&#x3D;？）”，这里”？“表示尚未确定的取值，而我们的任务就是通过对表的训练集进行学习，把”？“确定下来。</p><p>对于表中第一行，（色泽&#x3D;青绿）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;浊响）就是好瓜，但这是一个已见过的瓜，我们学习的目的是泛化，即通过对训练集中瓜的学习以获得对没见过的瓜进行判断的能力。如果仅仅把训练集中的瓜记住，今后再见到一模一样的瓜当然可以判断。”记住“训练样本，就是所谓的”机械学习“。</p><p>但是，对没见过的瓜，例如（色泽&#x3D;浅白）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;浊响）怎么办？我们可以把学习过程看作一个在所有<strong>假设（hypothesis）</strong>组成的空间中进行搜索的过程，搜索目标是找到与训练集<strong>”匹配“（fit）</strong>的假设，即能够将训练集中的瓜判断正确的假设。假设的表示一旦确定，假设空间及其规模大小就确定了。</p><p>这里我们的假设空间由形如”（色泽&#x3D;？）^（根蒂&#x3D;？）^（敲声&#x3D;？）“的可能取值所形成的假设组成。例如色泽有”青绿“”乌黑“”浅白“这三种可能取值；还需考虑到，也许”色泽“无论取什么值都适合，我们用通配符”*“来表示，例如“好瓜↔（色泽&#x3D;*）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;浊响）”。(此外，还需考虑极端情况：有可能”好瓜“这个概念根本就不成立，世界上没有”好瓜“这种东西，我们用Ø表示这个假设。)<strong>这里我们假定训练样本不含噪声，并且不考虑”非青绿“这样的操作。由于训练集包含正例，因此Ø假设自然不会出现。</strong></p><p>若”色泽“”根蒂”“敲声“分别有3、2、2种可能取值，则我们面临的假设空间规模大小为4<em>3</em>3+1 &#x3D; 37（含*）。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-32d0cdd732afbc55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西瓜问题的假设空间"><br>可以有许多策略对这个假设空间进行搜索，例如自顶向下、从一般到特殊，或是自底向上、从特殊到一般，搜索过程中可以不断删除与正例不一致的假设、和（或）与反例一致的假设。最终将会获得与训练集一致（即对所有训练样本能够进行正确判断）的假设，这就是我们学得的结果。</p><p>需注意的是，现实问题中我们常面临很大的假设空间，但学习过程是基于有限样本训练集进行的，因此，可能有多个假设与训练集一致，即存在着一个与训练集一致的假设集合，我们称之为<strong>版本空间（version space）</strong>。<img src="https://upload-images.jianshu.io/upload_images/9169686-2147357134175360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西瓜问题的版本空间"></p><h5 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h5><p>通过学习得到的模型对应了假设空间中的一个假设。于是上图的西瓜问题版本空间给我们带来一个麻烦：现在有三个与训练集一致的假设，但与它们对应的模型在面临新样本的时候，却会产生不同的输出。</p><p>若仅有上表中的训练样本，则无法断定上述三个假设中哪一个更好。然而，对于一个具体的学习算法而言，它必须要产生一个模型。这时，学习算法本身的“偏好”就会起到关键的作用。例如，若我们的算法喜欢“尽可能特殊”的模型，则它会选择“好瓜↔（色泽&#x3D;*）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;浊响）”；但若我们的算法喜欢“尽可能一般”的模型，并且由于某种原因它更“相信”根蒂，则它会选择“好瓜↔（色泽&#x3D;*）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;*）”。尽可能特殊即“使用情形尽可能少”；尽可能一般即“适用情形尽可能多”。机器学习算法在学习过程中对某种类型假设的偏好，称为<strong>“归纳偏好”（inductive bias）</strong>，或简称为“偏好”。</p><p>任何一个有效的机器学习算法必有其归纳偏好，否则它将被假设空间中看似在训练集上“等效”的假设所迷惑，而无法产生确定的学习结果。可以想象，如果没有偏好，我们的西瓜学习算法产生的模型每次在进行预测时随机抽选训练集上的等效假设，那么对这个新瓜“色泽&#x3D;青绿）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;沉闷）”，学得模型时而告诉我们它是好的、时而告诉我们它是不好的，这样的学习结果显然没有意义。</p><p>归纳偏好的作用在下图这个回归学习图示中可能更直观。这里的每个训练样本是图中的一个点（x，y），要学得一个与训练集一致的模型，相当于找到一条穿过所有训练样本点的曲线。显然，对有限个样本点组成的训练集，存在着很多条曲线与其一致。我们的学习算法必须有某种偏好，才能产出它认为“正确”的模型。例如，若认为相似的样本应有相似的输出（例如，在各种属性上都很相像的西瓜，成熟程度应该比较接近），则对应的学习算法可能偏好图中比较“平滑”的曲线A而不是比较“崎岖”的曲线B。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-14cd98c54858f958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="存在多条曲线与有限样本训练集一致"></p><p>归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或“价值观”。那么，有没有一般性的原则来引导算法确立“正确的”偏好呢？<strong>“奥卡姆剃刀（Occam’s razor）”</strong>是一种常用的、自然科学研究中最基本的原则，即<strong>“若有多个假设与观察一致，则选择最简单的那个”</strong>。如果采用这个原则，并且假设我们认为“更平滑”意味着“更简单”（例如曲线A更易于描述，其方程式是y&#x3D;-x^2+6x+1,而曲线B则要复杂的多），则在上图中我们会自然的偏好“平滑”的曲线A。</p><p>然而，奥卡姆剃刀并非唯一可行的原则。要注意到，奥卡姆剃刀本身存在不同的诠释，例如对西瓜问题来说，假设1：“好瓜↔（色泽&#x3D;*）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;浊响）”和假设2：“好瓜↔（色泽&#x3D;*）^（根蒂&#x3D;蜷缩）^（敲声&#x3D;*）”这两个假设，哪一个更“简单”呢？这个问题并不简单，需借助其他机制才能解决。</p><p>事实上，归纳偏好对应了学习算法本身所做出的关与“什么样的模型更好”的假设。在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能。</p><p>让我们再回头看看曲线图。假设学习算法fa基于某种归纳偏好产生了对应于曲线A的模型，学习算法fb基于另一种归纳偏好产生了对应于曲线B的模型。基于前面讨论的平滑曲线的某种“描述简单性”，我们满怀信心的期待算法fa比fb更好。确实，下图（a）显示出，与B相比，A与训练集外的样本更一致；换言之，A的泛化能力比B强。但是，若出现了图（b）的情况，B与训练集外的样本更一致。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-3d82353267d8dbd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="黑点：训练样本；白点：测试样本"></p><p>这种情况完全可能出现。换言之，对于一个学习算法fa，若它在某些问题上比学习算法fb好，则必然存在在另一些问题上，fb比fa好。这个结论对任何算法均成立。<strong>“没有免费的午餐”定理（No Free Lunch Theorem，简称NFL定理）</strong>证实，无论学习算法fa多聪明、学习算法fb多笨拙，它们的期望性能竟然相同（训练集外误差）。</p><p>但是，同时我们需注意到，NFL定理有一个重要前提：所有“问题”出现的机会相同、或所有问题同等重要。但实际情形并不是这样的。很多时候，我们只关注自己正在试图解决的问题（例如某个具体应用任务），希望为它找到一个解决方案，至于这个解决方案在别的问题、甚至在相似的问题上是否为好方案，我们并不关心。</p><p>NFL定理最重要的寓意，是让我们清楚的认识到，脱离具体问题，空泛的谈论“什么学习算法更好”毫无意义，因为若考虑所有潜在的问题，则所有学习算法都一样好。要谈论算法的相对优劣，必须要针对具体的学习问题；在某些问题上表现好的学习算法，在另一些问题上却可能不尽如人意，学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、机器学习基本术语</title>
      <link href="/2018/08/11/%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/"/>
      <url>/2018/08/11/%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h5 id="机器学习："><a href="#机器学习：" class="headerlink" title="机器学习："></a>机器学习：</h5><p>致力于研究如何通过计算手段，利用经验来改善系统自身的性能。在计算机系统中，“经验”通常以“数据”形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中产生<strong>“模型”(model)<strong>的算法，即</strong>“学习算法”（learning algorithm）</strong>。</p><span id="more"></span><p>有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型，在面对新的情况时，模型会给我们提供相应的判断。如果说计算机科学是研究关于算法的学问，那么类似的，可以说机器学习是研究关于学习算法的学问。</p><h5 id="数据集（data-set）"><a href="#数据集（data-set）" class="headerlink" title="数据集（data set）"></a>数据集（data set）</h5><p>一组记录的集合称为一个数据集，其中每条记录是关于一个事件或对象的描述，成为一个<strong>示例（instance）</strong>或<strong>样本（sample）</strong>。反映事件或对象在某方面的表现或性质的事项，成为<strong>属性（attribute）</strong>或<strong>特征（feature）</strong>；属性上的取值称为<strong>属性值（attribute value）</strong>。属性张成的空间称为<strong>属性空间（attribute space）</strong>、<strong>样本空间（sample space）</strong>或<strong>输入空间</strong>。例如一个对象有三个属性，将这三个属性作为三个坐标轴，则它们张成一个用于描述该对象的三维空间，每一个对象都可以在这个空间中找到自己的坐标位置。由于空间中的每个点对应一个坐标向量，因此我们也把一个示例称为一个<strong>特征向量（feature vector）</strong>。<br><strong>一般的，令D&#x3D;{x1, x2, …, xm}表示包含m个示例的数据集，每个示例由d个属性描述，则每个示例xi&#x3D;（xi1，xi2，…，xid）是d维样本空间X中的一个向量，xi∈X，其中xij是xi在第j个属性上的取值，d称为样本xi的维数（dimensionality）。</strong></p><h5 id="训练（training）"><a href="#训练（training）" class="headerlink" title="训练（training）"></a>训练（training）</h5><p>从数据中学得模型的过程称为<strong>学习（learning）</strong>或<strong>训练（training）</strong>，这个过程通过执行某个学习算法来完成。训练过程中使用的数据称为<strong>训练数据（training data）</strong>，其中每个样本称为一个<strong>训练样本（training sample）</strong>，训练样本组成的集合称为<strong>训练集（training set）</strong>。<br>学得模型对应了关于数据的某种潜在的规律，因此亦称<strong>假设（hypothesis）</strong>；这种潜在规律自身，则称为<strong>真相</strong>或<strong>真实（ground-truth）</strong>，学习过程就是为了找出或逼近真相。<br>如果希望学得一个能够帮助我们判断的模型，仅有前面的示例数据显然是不够的，要建立这样的关于<strong>预测（prediction）</strong>的模型，我们需获得训练样本的结果信息。示例结果的信息，称为<strong>标记（label）</strong>；拥有了标记信息的示例，则称为<strong>样例（example）</strong>。<br><strong>一般的，用（xi，yi）表示第i个样例，其中yi∈Y是示例xi的标记，Y是所有标记的集合，亦称标记空间（label space）或输出空间。</strong></p><h5 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h5><p>若我们预测的是离散值，此类学习任务称为<strong>分类（classification）</strong>；若欲预测的是连续值，此类学习任务称为<strong>回归（regression）</strong>。<br>对只涉及两个类别的<strong>二分类（binary classification）</strong>任务，通常称其中一个类为<strong>正类（positive class）</strong>，另一个类为<strong>反类（negative class）</strong>；涉及多个类别时，则称为<strong>多分类（multi-class classification）任务</strong>。<br><strong>一般的，预测任务是希望通过对训练集{（x1，y1），（x2，y2），…(xm，ym)}进行学习，建立一个从输入空间X到输出空间Y的映射f：X→Y。对二分类任务，通常令Y&#x3D;{-1,+1}或{0，1}；对多分类任务，|Y|&gt;2；对回归任务，Y&#x3D;R，R为实数集。</strong><br>学得模型后，使用其进行预测的过程称为<strong>测试（testing）</strong>，被预测的样本称为<strong>测试样本（testing sample）</strong>。例如在学得f后，对测试例x，可得到其预测标记y&#x3D;f(x)。<br>我们还可以对对象做<strong>聚类（clustering）</strong>，即将训练集中的对象分成若干组，每组称为一个<strong>簇（cluster）</strong>；这些自动形成的簇可能对应一些潜在的概念划分。这样的学习过程有助于我们了解数据内在的规律，能为更深入的分析数据建立基础。需说明的是，在聚类学习中，潜在的概念我们事先是不知道的，而且学习过程中使用的训练样本通常不拥有标记信息。<br>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类：<strong>监督学习（supervised learning）</strong>和<strong>无监督学习（unsupervised learning）</strong>，分类和回归是前者的代表，而聚类则是后者的代表。</p><h5 id="机器学习的目的"><a href="#机器学习的目的" class="headerlink" title="机器学习的目的"></a>机器学习的目的</h5><p>需注意的是，机器学习的目标是使学得的模型能很好的适用于新样本，而不仅仅在训练样本上工作的很好；即便对聚类这样的无监督学习任务，我们也希望学得的簇划分能适用于没在训练集中出现的样本。<br>学得模型适用于新样本的能力，称为<strong>泛化（generalization）</strong>能力。具有强泛化能力的模型能很好的适用于整个样本空间。于是，尽管训练集通常只是样本空间的一个很小的采样，我们仍希望它能很好的反映出样本空间的特性，否则假设样本空间中全体样本服从一个未知<strong>分布（distribution）D</strong>，我们获得的每个样本都是独立的从这个分布上采用获得的，即<strong>独立同分布（independent and identically distributed，简称i.i.d.）</strong>。一般而言，训练样本越多，我们得到的关于D的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码调用Zxing的二维码解码功能</title>
      <link href="/2018/08/05/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8Zxing%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%A7%A3%E7%A0%81%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/08/05/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8Zxing%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%A7%A3%E7%A0%81%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>在上一篇分析了google的Zxing条码扫描库的源码：<a href="https://www.jianshu.com/p/38610c6ef11b">分析google的Zxing条码扫描库源码</a><br>这里提一下如何简洁的使用Zxing的库。网上有很多基于Zxing的包含Android部分修改后的可用库，但是笔者始终觉得内容有些臃肿和使用不自由、灵活。</p><span id="more"></span><p>其实，我们只要使用Zxing的core里面的内容就够了，android部分的可以完全由自己设计。<br>最最直接的方法是拿core里面我们使用到的部分代码进行修改，精简后加到自己的工程里。但是这种还是有些麻烦，需要花费一点时间去细看源码。<br>其实，还有更快速使用的方法：使用core打包好的jar库。<br><a href="http://repo1.maven.org/maven2/com/google/zxing/core/">Zxing的Jar包下载地址</a><br>下载目前最新的版本：core-3.3.3.jar。<br>然后新建一个android工程，将core-3.3.3.jar文件放在libs文件夹下，右键jar包选择“Add As Library”。<br>Zxing便已导入android工程中。<br>二维码解码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qrCodeReader = new QRCodeReader();</span><br><span class="line">try &#123;</span><br><span class="line">    rawResult = qrCodeReader.decode(bitmap);</span><br><span class="line">&#125;catch (ReaderException re)&#123;</span><br><span class="line">    //Log.i(&quot;解码异常&quot;,re.toString());</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    qrCodeReader.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功解码得出的内容：<br>1.文本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rawresult.getText()</span><br></pre></td></tr></table></figure><p>2.位置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResultPoint[] points = rawresult.getResultPoints();</span><br><span class="line">ResultPoint bottomLeft = points[0];</span><br><span class="line">ResultPoint topLeft = points[1];</span><br><span class="line">ResultPoint topRight = points[2];</span><br></pre></td></tr></table></figure><p>一个调用手机摄像头，全屏识别二维码，并标记二维码位置的android demo:<br><a href="https://github.com/MrBluyee/QRCodeDemo">QRcodeDemo</a><br>这个demo简单的调用了zxing的core的jar的库，摄像头部分使用zxing安卓的camera源码并做了一点点的修改。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-eea743ad6f7d3a6e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="app结构.JPG"></p><p>效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-03b7f56d8dbfda75.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot_20180807-170506.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/9169686-d86906643b833e6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot_20180807-170555.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/9169686-8b31b7026470d692.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot_20180807-170607.jpg"></p><p>屏幕上用绿框标记了二维码三个定位点的位置，直接从rawresult中读出来的位置信息作者发现与屏幕上显示的实际的位置有偏差，而且状态看上去像是对原图1920*1080做了缩小处理。查看了core的detect源码，并未发现在哪一处做了明显的缩放处理，无奈在获取到rawresult数据后稍微处理了一下，这才与实际显示有相近的匹配。<br>在屏幕上显示的几行数据表示的意思：</p><ul><li>QRcode content：二维码的信息</li><li>QRcode pix_center x: 二维码中心位置的x的像素坐标（对应width）</li><li>QRcode pix_center y: 二维码中心位置的y的像素坐标（对应height）</li><li>QRcode percent_center x: 二维码中心位置的x的相对于屏幕的百分比坐标</li><li>QRcode percent_center y: 二维码中心位置的y的相对于屏幕的百分比坐标</li><li>QRcode rotate angle:二维码相对于摄像头旋转的角度。</li></ul><p>QRcode rotate angle计算过程：<br>1.以二维码左上角的定位点为坐标系原点，以右上角的定位点作为动点。<br>2.计算Δx &#x3D; topRight.x - topLeft.x, Δy &#x3D; topRight.y - topLeft.y<br>3.计算两点之间的距离：Δl &#x3D; sqrt(pow(Δx,2) + pow(Δy,2))<br>4.计算角度angle &#x3D; arcsin(Δy &#x2F; Δl )，要注意到这里的角度信息，包含了y的正负信息，但是x的正负未考虑进去，所得到的角度还要做进一步的区分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">伪代码：</span><br><span class="line">if (Δy &gt; 0)&#123;</span><br><span class="line">    if(Δx &lt; 0) angle = PI - angle;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if(Δx &lt; 0) angle = -PI - angle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析google的Zxing条码扫描库源码</title>
      <link href="/2018/08/02/%E5%88%86%E6%9E%90google%E7%9A%84Zxing%E6%9D%A1%E7%A0%81%E6%89%AB%E6%8F%8F%E5%BA%93%E6%BA%90%E7%A0%81/"/>
      <url>/2018/08/02/%E5%88%86%E6%9E%90google%E7%9A%84Zxing%E6%9D%A1%E7%A0%81%E6%89%AB%E6%8F%8F%E5%BA%93%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>ZXing是一个开放源码的，用Java实现的多种格式的条码扫描与生成库。<br>Zxing的GITHUB地址：<a href="https://github.com/zxing/zxing">Zxing</a></p><span id="more"></span><p>ZXing支持的格式：</p><table><thead><tr><th>1D product</th><th>1D industrial</th><th>2D</th></tr></thead><tbody><tr><td>UPC-A</td><td>Code 39</td><td>QR Code</td></tr><tr><td>UPC-E</td><td>Code 93</td><td>Data Matrix</td></tr><tr><td>EAN-8</td><td>Code 128</td><td>Aztec (beta)</td></tr><tr><td>EAN-13</td><td>Codabar</td><td>PDF 417 (beta)</td></tr><tr><td></td><td>ITF</td><td>MaxiCode</td></tr><tr><td></td><td>RSS-14</td><td></td></tr><tr><td></td><td>RSS-Expanded</td><td></td></tr></tbody></table><p>zxing代码库结构及其介绍如下：</p><table><thead><tr><th>Module</th><th>Description</th></tr></thead><tbody><tr><td>core</td><td>The core image decoding library, and test code</td></tr><tr><td>javase</td><td>JavaSE-specific client code</td></tr><tr><td>android</td><td>Android client Barcode Scanner</td></tr><tr><td>android-integration</td><td>Supports integration with Barcode Scanner via Intent</td></tr><tr><td>android-core</td><td>Android-related code shared among android, other Android apps</td></tr><tr><td>zxingorg</td><td>The source behind zxing.org</td></tr><tr><td>zxing.appspot.com</td><td>The source behind web-based barcode generator at zxing.appspot.com</td></tr></tbody></table><p>这篇文章主要分析android上是如何调用zxing去识别二维码的。<br>先在GITHUB上下载源码，目前最新的版本是3.3.3。解压并打开文件夹，我们主要看android、android-core和core这三个文件夹。</p><h3 id="android文件夹："><a href="#android文件夹：" class="headerlink" title="android文件夹："></a>android文件夹：</h3><p>在“zxing-zxing-3.3.3\android\src\com\google\zxing\client\android”下有android的src代码。</p><h4 id="CaptureActivity-java"><a href="#CaptureActivity-java" class="headerlink" title="CaptureActivity.java"></a>CaptureActivity.java</h4><p>主界面是CaptureActivity.java。在CaptureActivity.java中，cameraManager用于调用摄像头。<br>摄像头的初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void initCamera(SurfaceHolder surfaceHolder) &#123;</span><br><span class="line">  if (surfaceHolder == null) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;No SurfaceHolder provided&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (cameraManager.isOpen()) &#123;</span><br><span class="line">    Log.w(TAG, &quot;initCamera() while already open -- late SurfaceView callback?&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    cameraManager.openDriver(surfaceHolder);</span><br><span class="line">    // Creating the handler starts the preview, which can also throw a RuntimeException.</span><br><span class="line">    if (handler == null) &#123;</span><br><span class="line">      handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);</span><br><span class="line">    &#125;</span><br><span class="line">    decodeOrStoreSavedBitmap(null, null);</span><br><span class="line">  &#125; catch (IOException ioe) &#123;</span><br><span class="line">    Log.w(TAG, ioe);</span><br><span class="line">    displayFrameworkBugMessageAndExit();</span><br><span class="line">  &#125; catch (RuntimeException e) &#123;</span><br><span class="line">    // Barcode Scanner has seen crashes in the wild of this variety:</span><br><span class="line">    // java.?lang.?RuntimeException: Fail to connect to camera service</span><br><span class="line">    Log.w(TAG, &quot;Unexpected error initializing camera&quot;, e);</span><br><span class="line">    displayFrameworkBugMessageAndExit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在打开摄像头后，即调用CaptureActivityHandler进行识别操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cameraManager.openDriver(surfaceHolder);</span><br><span class="line">// Creating the handler starts the preview, which can also throw a RuntimeException.</span><br><span class="line">if (handler == null) &#123;</span><br><span class="line">  handler = new CaptureActivityHandler(this, decodeFormats, decodeHints, characterSet, cameraManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摄像头预览的内容是放在名为preview_view的SurfaceView容器里的。CaptureActivity extends Activity implements SurfaceHolder.Callback并重写了这三个Surface的Callback函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void surfaceCreated(SurfaceHolder holder) &#123;</span><br><span class="line">  if (holder == null) &#123;</span><br><span class="line">    Log.e(TAG, &quot;*** WARNING *** surfaceCreated() gave us a null surface!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!hasSurface) &#123;</span><br><span class="line">    hasSurface = true;</span><br><span class="line">    initCamera(holder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line">  hasSurface = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123;</span><br><span class="line">  // do nothing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用  public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor)来处理返回到这层的识别的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A valid barcode has been found, so give an indication of success and show the results.</span><br><span class="line"> *</span><br><span class="line"> * @param rawResult The contents of the barcode.</span><br><span class="line"> * @param scaleFactor amount by which thumbnail was scaled</span><br><span class="line"> * @param barcode   A greyscale bitmap of the camera data which was decoded.</span><br><span class="line"> */</span><br><span class="line">public void handleDecode(Result rawResult, Bitmap barcode, float scaleFactor) &#123;</span><br></pre></td></tr></table></figure><p>这其中，处理又有两种方式：内部方式和外部方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">switch (source) &#123;</span><br><span class="line">  case NATIVE_APP_INTENT:</span><br><span class="line">  case PRODUCT_SEARCH_LINK:</span><br><span class="line">    handleDecodeExternally(rawResult, resultHandler, barcode);</span><br><span class="line">    break;</span><br><span class="line">  case ZXING_LINK:</span><br><span class="line">    if (scanFromWebPageManager == null || !scanFromWebPageManager.isScanFromWebPage()) &#123;</span><br><span class="line">      handleDecodeInternally(rawResult, resultHandler, barcode);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      handleDecodeExternally(rawResult, resultHandler, barcode);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  case NONE:</span><br><span class="line">    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);</span><br><span class="line">    if (fromLiveScan &amp;&amp; prefs.getBoolean(PreferencesActivity.KEY_BULK_MODE, false)) &#123;</span><br><span class="line">      Toast.makeText(getApplicationContext(),</span><br><span class="line">                     getResources().getString(R.string.msg_bulk_mode_scanned) + &quot; (&quot; + rawResult.getText() + &#x27;)&#x27;,</span><br><span class="line">                     Toast.LENGTH_SHORT).show();</span><br><span class="line">      maybeSetClipboard(resultHandler);</span><br><span class="line">      // Wait a moment or else it will scan the same barcode continuously about 3 times</span><br><span class="line">      restartPreviewAfterDelay(BULK_MODE_SCAN_DELAY_MS);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      handleDecodeInternally(rawResult, resultHandler, barcode);</span><br><span class="line">    &#125;</span><br><span class="line">    break;+</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleDecodeInternally主要是在UI上做显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Put up our own UI for how to handle the decoded contents.</span><br><span class="line">private void handleDecodeInternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) &#123;</span><br></pre></td></tr></table></figure><p>而handleDecodeExternally则进一步往上一层传，如果外部有调用的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Briefly show the contents of the barcode, then handle the result outside Barcode Scanner.</span><br><span class="line">private void handleDecodeExternally(Result rawResult, ResultHandler resultHandler, Bitmap barcode) &#123;</span><br></pre></td></tr></table></figure><h4 id="CaptureActivityHandler-java"><a href="#CaptureActivityHandler-java" class="headerlink" title="CaptureActivityHandler.java"></a>CaptureActivityHandler.java</h4><p>在CaptureActivity调用了CaptureActivityHandler后，参数仅一步传递到DecodeThread:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CaptureActivityHandler(CaptureActivity activity,</span><br><span class="line">                       Collection&lt;BarcodeFormat&gt; decodeFormats,</span><br><span class="line">                       Map&lt;DecodeHintType,?&gt; baseHints,</span><br><span class="line">                       String characterSet,</span><br><span class="line">                       CameraManager cameraManager) &#123;</span><br><span class="line">  this.activity = activity;</span><br><span class="line">  decodeThread = new DecodeThread(activity, decodeFormats, baseHints, characterSet,</span><br><span class="line">      new ViewfinderResultPointCallback(activity.getViewfinderView()));</span><br><span class="line">  decodeThread.start();</span><br><span class="line">  state = State.SUCCESS;</span><br><span class="line"></span><br><span class="line">  // Start ourselves capturing previews and decoding.</span><br><span class="line">  this.cameraManager = cameraManager;</span><br><span class="line">  cameraManager.startPreview();</span><br><span class="line">  restartPreviewAndDecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，CaptureActivityHandler继承了handle，并重写了handleMessage方法，从而使用CaptureActivityHandler来为CaptureActivity处理底层的消息。调用过程：<br>在CaptureActivity的onActivityResult方法中获取返回的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onActivityResult(int requestCode, int resultCode, Intent intent) &#123;</span><br><span class="line">  if (resultCode == RESULT_OK &amp;&amp; requestCode == HISTORY_REQUEST_CODE &amp;&amp; historyManager != null) &#123;</span><br><span class="line">    int itemNumber = intent.getIntExtra(Intents.History.ITEM_NUMBER, -1);</span><br><span class="line">    if (itemNumber &gt;= 0) &#123;</span><br><span class="line">      HistoryItem historyItem = historyManager.buildHistoryItem(itemNumber);</span><br><span class="line">      decodeOrStoreSavedBitmap(null, historyItem.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中，返回的信息被保存至历史记录，并在decodeOrStoreSavedBitmap函数里将消息传递到CaptureActivityHandler的handleMessage：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void decodeOrStoreSavedBitmap(Bitmap bitmap, Result result) &#123;</span><br><span class="line">  // Bitmap isn&#x27;t used yet -- will be used soon</span><br><span class="line">  if (handler == null) &#123;</span><br><span class="line">    savedResultToShow = result;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">      savedResultToShow = result;</span><br><span class="line">    &#125;</span><br><span class="line">    if (savedResultToShow != null) &#123;</span><br><span class="line">      Message message = Message.obtain(handler, R.id.decode_succeeded, savedResultToShow);</span><br><span class="line">      handler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">    savedResultToShow = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handleMessage里调用了前面所说的CaptureActivity里的handleDecode的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case R.id.decode_succeeded:</span><br><span class="line">  state = State.SUCCESS;</span><br><span class="line">  Bundle bundle = message.getData();</span><br><span class="line">  Bitmap barcode = null;</span><br><span class="line">  float scaleFactor = 1.0f;</span><br><span class="line">  if (bundle != null) &#123;</span><br><span class="line">    byte[] compressedBitmap = bundle.getByteArray(DecodeThread.BARCODE_BITMAP);</span><br><span class="line">    if (compressedBitmap != null) &#123;</span><br><span class="line">      barcode = BitmapFactory.decodeByteArray(compressedBitmap, 0, compressedBitmap.length, null);</span><br><span class="line">      // Mutable copy:</span><br><span class="line">      barcode = barcode.copy(Bitmap.Config.ARGB_8888, true);</span><br><span class="line">    &#125;</span><br><span class="line">    scaleFactor = bundle.getFloat(DecodeThread.BARCODE_SCALED_FACTOR);          </span><br><span class="line">  &#125;</span><br><span class="line">  activity.handleDecode((Result) message.obj, barcode, scaleFactor);</span><br><span class="line">  break;</span><br></pre></td></tr></table></figure><h4 id="DecodeThread-java："><a href="#DecodeThread-java：" class="headerlink" title="DecodeThread.java："></a>DecodeThread.java：</h4><p>DecodeThread是一个线程，继承了Thread。<br>其初始化里添加了decodeFormats的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">DecodeThread(CaptureActivity activity,</span><br><span class="line">             Collection&lt;BarcodeFormat&gt; decodeFormats,</span><br><span class="line">             Map&lt;DecodeHintType,?&gt; baseHints,</span><br><span class="line">             String characterSet,</span><br><span class="line">             ResultPointCallback resultPointCallback) &#123;</span><br><span class="line"></span><br><span class="line">  this.activity = activity;</span><br><span class="line">  handlerInitLatch = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">  hints = new EnumMap&lt;&gt;(DecodeHintType.class);</span><br><span class="line">  if (baseHints != null) &#123;</span><br><span class="line">    hints.putAll(baseHints);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // The prefs can&#x27;t change while the thread is running, so pick them up once here.</span><br><span class="line">  if (decodeFormats == null || decodeFormats.isEmpty()) &#123;</span><br><span class="line">    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);</span><br><span class="line">    decodeFormats = EnumSet.noneOf(BarcodeFormat.class);</span><br><span class="line">    if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_PRODUCT, true)) &#123;</span><br><span class="line">      decodeFormats.addAll(DecodeFormatManager.PRODUCT_FORMATS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_1D_INDUSTRIAL, true)) &#123;</span><br><span class="line">      decodeFormats.addAll(DecodeFormatManager.INDUSTRIAL_FORMATS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_QR, true)) &#123;</span><br><span class="line">      decodeFormats.addAll(DecodeFormatManager.QR_CODE_FORMATS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_DATA_MATRIX, true)) &#123;</span><br><span class="line">      decodeFormats.addAll(DecodeFormatManager.DATA_MATRIX_FORMATS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_AZTEC, false)) &#123;</span><br><span class="line">      decodeFormats.addAll(DecodeFormatManager.AZTEC_FORMATS);</span><br><span class="line">    &#125;</span><br><span class="line">    if (prefs.getBoolean(PreferencesActivity.KEY_DECODE_PDF417, false)) &#123;</span><br><span class="line">      decodeFormats.addAll(DecodeFormatManager.PDF417_FORMATS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);</span><br><span class="line"></span><br><span class="line">  if (characterSet != null) &#123;</span><br><span class="line">    hints.put(DecodeHintType.CHARACTER_SET, characterSet);</span><br><span class="line">  &#125;</span><br><span class="line">  hints.put(DecodeHintType.NEED_RESULT_POINT_CALLBACK, resultPointCallback);</span><br><span class="line">  Log.i(&quot;DecodeThread&quot;, &quot;Hints: &quot; + hints);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其run方法里通向下一层调用的方法DecodeHandler：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">  Looper.prepare();</span><br><span class="line">  handler = new DecodeHandler(activity, hints);</span><br><span class="line">  handlerInitLatch.countDown();</span><br><span class="line">  Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DecodeHandler-java："><a href="#DecodeHandler-java：" class="headerlink" title="DecodeHandler.java："></a>DecodeHandler.java：</h4><p>DecodeHandler继承Handler，在handleMessage里调用该class里的decode函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handleMessage(Message message) &#123;</span><br><span class="line">  if (message == null || !running) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  switch (message.what) &#123;</span><br><span class="line">    case R.id.decode:</span><br><span class="line">      decode((byte[]) message.obj, message.arg1, message.arg2);</span><br><span class="line">      break;</span><br><span class="line">    case R.id.quit:</span><br><span class="line">      running = false;</span><br><span class="line">      Looper.myLooper().quit();</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decode函数完成了解码和解码结果的数据回传，android的调用core的解码的接口就在decode里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void decode(byte[] data, int width, int height) &#123;</span><br><span class="line">  long start = System.currentTimeMillis();</span><br><span class="line">  Result rawResult = null;</span><br><span class="line">  PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height);</span><br><span class="line">  if (source != null) &#123;</span><br><span class="line">    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));</span><br><span class="line">    try &#123;</span><br><span class="line">      rawResult = multiFormatReader.decodeWithState(bitmap);</span><br><span class="line">    &#125; catch (ReaderException re) &#123;</span><br><span class="line">      // continue</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      multiFormatReader.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Handler handler = activity.getHandler();</span><br><span class="line">  if (rawResult != null) &#123;</span><br><span class="line">    // Don&#x27;t log the barcode contents for security.</span><br><span class="line">    long end = System.currentTimeMillis();</span><br><span class="line">    Log.d(TAG, &quot;Found barcode in &quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line">    if (handler != null) &#123;</span><br><span class="line">      Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult);</span><br><span class="line">      Bundle bundle = new Bundle();</span><br><span class="line">      bundleThumbnail(source, bundle);        </span><br><span class="line">      message.setData(bundle);</span><br><span class="line">      message.sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (handler != null) &#123;</span><br><span class="line">      Message message = Message.obtain(handler, R.id.decode_failed);</span><br><span class="line">      message.sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decode调用的底层函数为：rawResult &#x3D; multiFormatReader.decodeWithState(bitmap);<br>安卓层扫码大致流程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-4c0cad7568704ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安卓层扫码大致流程"></p><h3 id="core文件夹："><a href="#core文件夹：" class="headerlink" title="core文件夹："></a>core文件夹：</h3><p>在“zxing-zxing-3.3.3\core\src\main\java\com\google\zxing”下有core的src代码。</p><h4 id="MultiFormatReader-java"><a href="#MultiFormatReader-java" class="headerlink" title="MultiFormatReader.java"></a>MultiFormatReader.java</h4><p>MultiFormatReader支持读取多种格式的码的内容，我们只看二维码部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (formats.contains(BarcodeFormat.QR_CODE)) &#123;</span><br><span class="line">  readers.add(new QRCodeReader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new一个QRCodeReader()实例，解码在decodeInternal里调用reader.decode(image, hints)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Result decodeInternal(BinaryBitmap image) throws NotFoundException &#123;</span><br><span class="line">  if (readers != null) &#123;</span><br><span class="line">    for (Reader reader : readers) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        return reader.decode(image, hints);</span><br><span class="line">      &#125; catch (ReaderException re) &#123;</span><br><span class="line">        // continue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  throw NotFoundException.getNotFoundInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="QRCodeReader-java"><a href="#QRCodeReader-java" class="headerlink" title="QRCodeReader.java"></a>QRCodeReader.java</h4><p>QRCodeReader.java在“zxing-zxing-3.3.3\core\src\main\java\com\google\zxing\qrcode”文件夹下：<br>实现解码的函数为  public final Result decode(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints)，在<br>  public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException中被调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final Result decode(BinaryBitmap image, Map&lt;DecodeHintType,?&gt; hints)</span><br><span class="line">    throws NotFoundException, ChecksumException, FormatException &#123;</span><br><span class="line">  DecoderResult decoderResult;</span><br><span class="line">  ResultPoint[] points;</span><br><span class="line">  if (hints != null &amp;&amp; hints.containsKey(DecodeHintType.PURE_BARCODE)) &#123;</span><br><span class="line">    BitMatrix bits = extractPureBits(image.getBlackMatrix());</span><br><span class="line">    decoderResult = decoder.decode(bits, hints);</span><br><span class="line">    points = NO_POINTS;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    DetectorResult detectorResult = new Detector(image.getBlackMatrix()).detect(hints);</span><br><span class="line">    decoderResult = decoder.decode(detectorResult.getBits(), hints);</span><br><span class="line">    points = detectorResult.getPoints();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If the code was mirrored: swap the bottom-left and the top-right points.</span><br><span class="line">  if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) &#123;</span><br><span class="line">    ((QRCodeDecoderMetaData) decoderResult.getOther()).applyMirroredCorrection(points);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Result result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), points, BarcodeFormat.QR_CODE);</span><br><span class="line">  List&lt;byte[]&gt; byteSegments = decoderResult.getByteSegments();</span><br><span class="line">  if (byteSegments != null) &#123;</span><br><span class="line">    result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);</span><br><span class="line">  &#125;</span><br><span class="line">  String ecLevel = decoderResult.getECLevel();</span><br><span class="line">  if (ecLevel != null) &#123;</span><br><span class="line">    result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);</span><br><span class="line">  &#125;</span><br><span class="line">  if (decoderResult.hasStructuredAppend()) &#123;</span><br><span class="line">    result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE,</span><br><span class="line">                       decoderResult.getStructuredAppendSequenceNumber());</span><br><span class="line">    result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY,</span><br><span class="line">                       decoderResult.getStructuredAppendParity());</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该函数先检测图片中的二维码，检测到之后再进行解码：<br>检测二维码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DetectorResult detectorResult = new Detector(image.getBlackMatrix()).detect(hints);</span><br></pre></td></tr></table></figure><p>解码二维码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decoderResult = decoder.decode(detectorResult.getBits(), hints);</span><br></pre></td></tr></table></figure><p>在这里我们可以看到上层得到的rawResult里包含的是什么内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), points, BarcodeFormat.QR_CODE);</span><br></pre></td></tr></table></figure><p>points为Detector检测到的二维码的位置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points = detectorResult.getPoints();</span><br></pre></td></tr></table></figure><p>在QRCodeReader.java里还有一个特别的函数，对一张干净的二维码图片进行快速解码，得到bits信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This method detects a code in a &quot;pure&quot; image -- that is, pure monochrome image</span><br><span class="line"> * which contains only an unrotated, unskewed, image of a code, with some white border</span><br><span class="line"> * around it. This is a specialized method that works exceptionally fast in this special</span><br><span class="line"> * case.</span><br><span class="line"> *</span><br><span class="line"> * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)</span><br><span class="line"> */</span><br><span class="line">private static BitMatrix extractPureBits(BitMatrix image) throws NotFoundException </span><br></pre></td></tr></table></figure><h4 id="Decoder-java"><a href="#Decoder-java" class="headerlink" title="Decoder.java:"></a>Decoder.java:</h4><p>Decoder.java在“zxing-zxing-3.3.3\core\src\main\java\com\google\zxing\qrcode\decoder”文件夹下：<br>主要的解码函数是private DecoderResult decode(BitMatrix bits, Map&lt;DecodeHintType,?&gt; hints)和<br>private DecoderResult decode(BitMatrixParser parser, Map&lt;DecodeHintType,?&gt; hints)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;p&gt;Decodes a QR Code represented as a &#123;@link BitMatrix&#125;. A 1 or &quot;true&quot; is taken to mean a black module.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param bits booleans representing white/black QR Code modules</span><br><span class="line"> * @param hints decoding hints that should be used to influence decoding</span><br><span class="line"> * @return text and bytes encoded within the QR Code</span><br><span class="line"> * @throws FormatException if the QR Code cannot be decoded</span><br><span class="line"> * @throws ChecksumException if error correction fails</span><br><span class="line"> */</span><br><span class="line">public DecoderResult decode(BitMatrix bits, Map&lt;DecodeHintType,?&gt; hints)</span><br><span class="line">    throws FormatException, ChecksumException &#123;</span><br><span class="line"></span><br><span class="line">  // Construct a parser and read version, error-correction level</span><br><span class="line">  BitMatrixParser parser = new BitMatrixParser(bits);</span><br><span class="line">  FormatException fe = null;</span><br><span class="line">  ChecksumException ce = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    return decode(parser, hints);</span><br><span class="line">  &#125; catch (FormatException e) &#123;</span><br><span class="line">    fe = e;</span><br><span class="line">  &#125; catch (ChecksumException e) &#123;</span><br><span class="line">    ce = e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">    // Revert the bit matrix</span><br><span class="line">    parser.remask();</span><br><span class="line"></span><br><span class="line">    // Will be attempting a mirrored reading of the version and format info.</span><br><span class="line">    parser.setMirror(true);</span><br><span class="line"></span><br><span class="line">    // Preemptively read the version.</span><br><span class="line">    parser.readVersion();</span><br><span class="line"></span><br><span class="line">    // Preemptively read the format information.</span><br><span class="line">    parser.readFormatInformation();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Since we&#x27;re here, this means we have successfully detected some kind</span><br><span class="line">     * of version and format information when mirrored. This is a good sign,</span><br><span class="line">     * that the QR code may be mirrored, and we should try once more with a</span><br><span class="line">     * mirrored content.</span><br><span class="line">     */</span><br><span class="line">    // Prepare for a mirrored reading.</span><br><span class="line">    parser.mirror();</span><br><span class="line"></span><br><span class="line">    DecoderResult result = decode(parser, hints);</span><br><span class="line"></span><br><span class="line">    // Success! Notify the caller that the code was mirrored.</span><br><span class="line">    result.setOther(new QRCodeDecoderMetaData(true));</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">  &#125; catch (FormatException | ChecksumException e) &#123;</span><br><span class="line">    // Throw the exception from the original reading</span><br><span class="line">    if (fe != null) &#123;</span><br><span class="line">      throw fe;</span><br><span class="line">    &#125;</span><br><span class="line">    throw ce; // If fe is null, this can&#x27;t be</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private DecoderResult decode(BitMatrixParser parser, Map&lt;DecodeHintType,?&gt; hints)</span><br><span class="line">    throws FormatException, ChecksumException &#123;</span><br><span class="line">  Version version = parser.readVersion();</span><br><span class="line">  ErrorCorrectionLevel ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();</span><br><span class="line"></span><br><span class="line">  // Read codewords</span><br><span class="line">  byte[] codewords = parser.readCodewords();</span><br><span class="line">  // Separate into data blocks</span><br><span class="line">  DataBlock[] dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);</span><br><span class="line"></span><br><span class="line">  // Count total number of data bytes</span><br><span class="line">  int totalBytes = 0;</span><br><span class="line">  for (DataBlock dataBlock : dataBlocks) &#123;</span><br><span class="line">    totalBytes += dataBlock.getNumDataCodewords();</span><br><span class="line">  &#125;</span><br><span class="line">  byte[] resultBytes = new byte[totalBytes];</span><br><span class="line">  int resultOffset = 0;</span><br><span class="line"></span><br><span class="line">  // Error-correct and copy data blocks together into a stream of bytes</span><br><span class="line">  for (DataBlock dataBlock : dataBlocks) &#123;</span><br><span class="line">    byte[] codewordBytes = dataBlock.getCodewords();</span><br><span class="line">    int numDataCodewords = dataBlock.getNumDataCodewords();</span><br><span class="line">    correctErrors(codewordBytes, numDataCodewords);</span><br><span class="line">    for (int i = 0; i &lt; numDataCodewords; i++) &#123;</span><br><span class="line">      resultBytes[resultOffset++] = codewordBytes[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Decode the contents of that stream of bytes</span><br><span class="line">  return DecodedBitStreamParser.decode(resultBytes, version, ecLevel, hints);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Detector-java"><a href="#Detector-java" class="headerlink" title="Detector.java:"></a>Detector.java:</h4><p>Detector.java在“zxing-zxing-3.3.3\core\src\main\java\com\google\zxing\qrcode\detector”文件夹下：<br>在这里可以看到points里面存放的位置信息的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (alignmentPattern == null) &#123;</span><br><span class="line">  points = new ResultPoint[]&#123;bottomLeft, topLeft, topRight&#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  points = new ResultPoint[]&#123;bottomLeft, topLeft, topRight, alignmentPattern&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bottomLeft, topLeft, topRight为二维码的三个定位点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FinderPattern topLeft = info.getTopLeft();</span><br><span class="line">FinderPattern topRight = info.getTopRight();</span><br><span class="line">FinderPattern bottomLeft = info.getBottomLeft();</span><br></pre></td></tr></table></figure><p>对FinderPattern的定义在FinderPattern.java里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FinderPattern(float posX, float posY, float estimatedModuleSize) &#123;</span><br><span class="line">  this(posX, posY, estimatedModuleSize, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private FinderPattern(float posX, float posY, float estimatedModuleSize, int count) &#123;</span><br><span class="line">  super(posX, posY);</span><br><span class="line">  this.estimatedModuleSize = estimatedModuleSize;</span><br><span class="line">  this.count = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，topLeft的x,y两个值为float类型的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的interpositioning</title>
      <link href="/2018/08/01/C%E8%AF%AD%E8%A8%80%E7%9A%84interpositioning/"/>
      <url>/2018/08/01/C%E8%AF%AD%E8%A8%80%E7%9A%84interpositioning/</url>
      
        <content type="html"><![CDATA[<p>interpositioning（有些人称它为“interposing”）就是通过编写与库函数同名的函数来取代该库函数的行为。它可以使库函数在特定的程序中被同名的用户函数所取代，通常是用于调试或为了提高效率。</p><span id="more"></span><p>使用interpositioning需要格外小心。很容易发生自己代码中某个符号的定义取代函数库中的相同符号的意外。不仅你自己所进行的所有对该库函数的调用将被自己版本的函数调用所取代，而且所有调用该函数库的系统调用也将用你的函数取而代之（在你的代码中的对该函数的系统调用部分）。一个例子：嵌入式开发中，printf重定向到串口：在自己的代码段使用interpositioning重写实现printf函数的底层fputc()函数。fputc()函数原本是将字符ch打印到文件指针stream所指向的文件流去的，重定向到串口不需要打印到文件流，而是打印到串口。使用interpositioning方法重写fputc()函数后，在自己的程序里调用printf()函数时，一样会使用自己版本的fputc()函数取代原来的fputc()函数。</p><p>当编译器注意到库函数被另外一个定义覆盖时，它通常不会给出错误信息。这也是遵循C语言的设计哲学，即程序员所做的都是对的。在这里，编译器也认为这是程序员的意图。interpositioning本身并不是BUG，它是编译器明确要求支持的。如果要避免interpositioning产生BUG，一个准则就是：不要让程序中的任何符号成为全局的，除非有意把它们作为程序的接口之一。</p><p>C语言所有的关键字都是保留的：</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>auto</td><td>extern</td><td>short</td><td>while</td><td>break</td></tr><tr><td>float</td><td>signed</td><td>_Alignas</td><td>case</td><td>for</td></tr><tr><td>sizeof</td><td>_Alignof</td><td>char</td><td>goto</td><td>static</td></tr><tr><td>_Atomic</td><td>const</td><td>if</td><td>struct</td><td>_Bool</td></tr><tr><td>continue</td><td>inline</td><td>switch</td><td>_Complex</td><td>default</td></tr><tr><td>int</td><td>typedef</td><td>_Generic</td><td>do</td><td>long</td></tr><tr><td>union</td><td>_Imaginary</td><td>double</td><td>register</td><td>unsigned</td></tr><tr><td>_Noreturn</td><td>else</td><td>restrict</td><td>void</td><td>_Static_assert</td></tr><tr><td>enum</td><td>return</td><td>volatile</td><td>_Thread_local</td><td>-</td></tr></tbody></table><p>下表所列出的标识符不应该出现在自己程序的声明中。它们中的有些是始终保留的，其他一些则只有在包含一个特定的头文件后才是保留的。它们中的有些只在全局范围内才是保留的，其他一些规则无论在全局范围还是在文件范围内都予以保留。避免麻烦最容易的方法就是认为这些标识符始终属于系统所有，不把它们用作自己的标识符。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的静态库和动态库</title>
      <link href="/2018/07/31/Linux%E4%B8%8B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2018/07/31/Linux%E4%B8%8B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h4 id="linux下的库："><a href="#linux下的库：" class="headerlink" title="linux下的库："></a>linux下的库：</h4><p>linux下的库有两种：静态库和共享库（动态库）。<br>二者的不同点在于代码被载入的时刻不同。<br>静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。<br>共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p><span id="more"></span><h4 id="库的产生："><a href="#库的产生：" class="headerlink" title="库的产生："></a>库的产生：</h4><p>静态库的后缀是.a，它的产生分两步:<br>1.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表。<br>2.ar命令将很多.o转换成.a，成为静态库。<br>动态库的后缀是.so，它由gcc加特定参数编译产生。<br>具体例程：<a href="https://www.jianshu.com/p/dbe848e4ad0d">gcc程序编译的静态链接和动态链接</a></p><h4 id="库的位置："><a href="#库的位置：" class="headerlink" title="库的位置："></a>库的位置：</h4><p>在linux下，库文件一般放在&#x2F;usr&#x2F;lib和&#x2F;lib下，<br>静态库的名字一般为libxxxx.a，其中xxxx是该lib的名称<br>动态库的名字一般为libxxxx.so.major.minor，xxxx是该lib的名称，major是主版本号， minor是副版本号。</p><h4 id="查看可执行程序依赖的库："><a href="#查看可执行程序依赖的库：" class="headerlink" title="查看可执行程序依赖的库："></a>查看可执行程序依赖的库：</h4><p>ldd命令可以查看一个可执行程序依赖的共享库，<br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ldd main</span><br><span class="line">    linux-vdso.so.1 (0x00007ffe5e7b9000)</span><br><span class="line">    libhelloworld.so =&gt; /home/mrbluyee/mypro/C/libhelloworld.so (0x00007fd38e2ac000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd38debb000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007fd38e6b0000)</span><br></pre></td></tr></table></figure><h4 id="静态库链接时搜索路径顺序："><a href="#静态库链接时搜索路径顺序：" class="headerlink" title="静态库链接时搜索路径顺序："></a>静态库链接时搜索路径顺序：</h4><p>a.ld会去找GCC命令中的参数-L<br>b.再找gcc的环境变量LIBRARY_PATH<br>(LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径)<br>c.再找内定目录 &#x2F;lib &#x2F;usr&#x2F;lib &#x2F;usr&#x2F;local&#x2F;lib</p><h4 id="动态链接时、执行时搜索路径顺序"><a href="#动态链接时、执行时搜索路径顺序" class="headerlink" title="动态链接时、执行时搜索路径顺序:"></a>动态链接时、执行时搜索路径顺序:</h4><p>a.编译目标代码时指定的动态库搜索路径；<br>b.环境变量LD_LIBRARY_PATH指定的动态库搜索路径；<br>(LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径)<br>c.配置文件&#x2F;etc&#x2F;ld.so.conf中指定的动态库搜索路径；<br>d.默认的动态库搜索路径&#x2F;lib；<br>e.默认的动态库搜索路径&#x2F;usr&#x2F;lib。</p><h4 id="可执行程序在执行的时候定位库文件："><a href="#可执行程序在执行的时候定位库文件：" class="headerlink" title="可执行程序在执行的时候定位库文件："></a>可执行程序在执行的时候定位库文件：</h4><p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。<br>此时就需要系统动态载入器(dynamic linker&#x2F;loader)。</p><p>对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索：<br>a.elf文件的 DT_RPATH段<br>b.环境变量LD_LIBRARY_PATH<br>c.&#x2F;etc&#x2F;ld.so.cache文件列表<br>d.&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录<br>找到库文件后将其载入内存。</p><p>当出现：error while loading shared libraries: libxxx.so: cannot open shared object file: No such file or directory 的错误时，对应的3种解决方案在这里有例程描述：<br><a href="https://www.jianshu.com/p/dbe848e4ad0d">gcc程序编译的静态链接和动态链接</a><br>同样，下面的方法是一样的：<br>想要系统能够找到新安装的库的方法：<br>a.如果安装在&#x2F;lib或者&#x2F;usr&#x2F;lib下，那么ld默认能够找到，无需其他操作。<br>b.如果安装在其他目录，需要将其添加到&#x2F;etc&#x2F;ld.so.cache文件中，步骤如下:<br>—1.编辑&#x2F;etc&#x2F;ld.so.conf文件，加入库文件所在目录的路径<br>—2.运行ldconfig 目录名字，该命令会重建&#x2F;etc&#x2F;ld.so.cache文件</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc程序编译的静态链接和动态链接</title>
      <link href="/2018/07/31/gcc%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2018/07/31/gcc%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>在链接阶段中，所有对应于源文件的.o文件、”-l”选项指定的库文件、无法识别的文件名（包括指定的.o目标文件和.a库文件）按命令行中的顺序传递给链接器。</p><span id="more"></span><p>下面看一下，链接的过程是怎样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gcc -v -o helloworld helloworld.o</span><br><span class="line"></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-6.3.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --with-gmp=/mingw --with-mpfr --with-mpc=/mingw --with-isl=/mingw --prefix=/mingw --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-pkgversion=&#x27;MinGW.org GCC-6.3.0-1&#x27; --enable-static --enable-shared --enable-threads --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --enable-libgomp --disable-libvtv --enable-nls</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 6.3.0 (MinGW.org GCC-6.3.0-1) </span><br><span class="line">COMPILER_PATH=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../libexec/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/</span><br><span class="line">LIBRARY_PATH=d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../lib/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br><span class="line"> d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/collect2.exe -plugin d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/liblto_plugin-0.dll -plugin-opt=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe -plugin-opt=-fresolution=C:\Users\MrBlu\AppData\Local\Temp\cceFgn0y.res -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -plugin-opt=-pass-through=-ladvapi32 -plugin-opt=-pass-through=-lshell32 -plugin-opt=-pass-through=-luser32 -plugin-opt=-pass-through=-lkernel32 -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -Bdynamic -o helloworld.exe d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../crt2.o d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/crtbegin.o -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0 -Ld:/software/mingw/bin/../lib/gcc -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../.. helloworld.o -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt -ladvapi32 -lshell32 -luser32 -lkernel32 -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/crtend.o</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br></pre></td></tr></table></figure><p>crt2.o 、crtbegin.o、crtend.o是gcc加入的系统标准启动文件，对于一般应用程序，这些启动是必须的。<br>-Ldir：在库文件的搜索路径列表中添加dir目录。<br>-lname：添加链接库文件。</p><h4 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h4><p>库有两种：静态库（.a、.lib）和动态库（.so、.dll）。<br>window上对应的是.lib、.dll。<br>linux上对应的是.a、.so</p><p>如果函数库的一份拷贝是可执行文件的物理组成部分，称之为静态链接。静态链接当链接程序时，需要使用的每个库函数的一份拷贝被加入到可执行文件中。静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大（即使是在静态链接中，整个库文件也并没有全部装入到可执行文件中，所装入的只是需要的函数）。</p><p>如果可执行文件只是包含了文件名，让载入器在运行时能够寻找程序所需要的函数库，称之为动态链接。动态链接允许系统提供一个庞大的函数库集合，可以提供许多有用的服务，程序在运行时寻找它们。动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。</p><p>收集模块准备执行的三个阶段的规范名称是链接-编辑（link-editing）、载入（loading）和运行时链接（runtime linking）。静态链接的模块被链接编辑时载入，以便运行。动态链接的模块被链接编辑后载入，并在运行时进行链接以便运行。</p><p>程序执行时，在main函数被调用之前，运行时载入器把共享的数据对象载入到进程的地址空间。外部函数被真正调用之前，运行时载入器并不解析它们。所以动态链接即使链接了函数库，如果没有实际调用，也不会带来额外开销。</p><p>gcc编译器默认使用动态链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o helloworld_shared helloworld.o</span><br></pre></td></tr></table></figure><p>gcc编译器使用静态链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -o helloworld_static helloworld.o</span><br></pre></td></tr></table></figure><p>在windows平台上使用mingw编译发现这两种方式生成的exe文件的大小都一样，为40kb，怀疑mingw的编译的库是静态库。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-d754fc6ed9f6553c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="捕获1.JPG"><br>下面看一下linux平台上使用gcc两种编译方式的文件大小区别：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-a8db81edf848c424.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot1png"><br>可以看到helloworld_shared的大小为8344，而helloworld_static的大小达到844792。</p><p>-nostartfiles：<br>不链接系统标准启动文件，而标准库文件仍然正常使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gcc -v -nostartfiles -o helloworld helloworld.o</span><br><span class="line"></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-6.3.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --with-gmp=/mingw --with-mpfr --with-mpc=/mingw --with-isl=/mingw --prefix=/mingw --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-pkgversion=&#x27;MinGW.org GCC-6.3.0-1&#x27; --enable-static --enable-shared --enable-threads --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --enable-libgomp --disable-libvtv --enable-nls</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 6.3.0 (MinGW.org GCC-6.3.0-1) </span><br><span class="line">COMPILER_PATH=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../libexec/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/</span><br><span class="line">LIBRARY_PATH=d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../lib/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-nostartfiles&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br><span class="line"> d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/collect2.exe -plugin d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/liblto_plugin-0.dll -plugin-opt=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe -plugin-opt=-fresolution=C:\Users\MrBlu\AppData\Local\Temp\ccZxAfxD.res -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -plugin-opt=-pass-through=-ladvapi32 -plugin-opt=-pass-through=-lshell32 -plugin-opt=-pass-through=-luser32 -plugin-opt=-pass-through=-lkernel32 -plugin-opt=-pass-through=-lmingw32 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lmoldname -plugin-opt=-pass-through=-lmingwex -plugin-opt=-pass-through=-lmsvcrt -Bdynamic -o helloworld.exe -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0 -Ld:/software/mingw/bin/../lib/gcc -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../.. helloworld.o -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt -ladvapi32 -lshell32 -luser32 -lkernel32 -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt</span><br><span class="line">ertr000001.o:(.rdata+0x0): undefined reference to `_pei386_runtime_relocator&#x27;</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>-nostdlib<br>不链接系统标准启动文件和标准库文件，会提示因为没有链接系统标准启动文件和标准库文件，而链接失败。<br>该选项常用于裸机&#x2F;bootloader、linux内核等程序，因为它们不需要启动文件、标准库文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gcc -v -nostdlib -o helloworld helloworld.o</span><br><span class="line"></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe</span><br><span class="line">Target: mingw32</span><br><span class="line">Configured with: ../src/gcc-6.3.0/configure --build=x86_64-pc-linux-gnu --host=mingw32 --target=mingw32 --with-gmp=/mingw --with-mpfr --with-mpc=/mingw --with-isl=/mingw --prefix=/mingw --disable-win32-registry --with-arch=i586 --with-tune=generic --enable-languages=c,c++,objc,obj-c++,fortran,ada --with-pkgversion=&#x27;MinGW.org GCC-6.3.0-1&#x27; --enable-static --enable-shared --enable-threads --with-dwarf2 --disable-sjlj-exceptions --enable-version-specific-runtime-libs --with-libiconv-prefix=/mingw --with-libintl-prefix=/mingw --enable-libstdcxx-debug --enable-libgomp --disable-libvtv --enable-nls</span><br><span class="line">Thread model: win32</span><br><span class="line">gcc version 6.3.0 (MinGW.org GCC-6.3.0-1) </span><br><span class="line">COMPILER_PATH=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../libexec/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/bin/</span><br><span class="line">LIBRARY_PATH=d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/;d:/software/mingw/bin/../lib/gcc/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib/;d:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../</span><br><span class="line">COLLECT_GCC_OPTIONS=&#x27;-v&#x27; &#x27;-nostdlib&#x27; &#x27;-o&#x27; &#x27;helloworld.exe&#x27; &#x27;-mtune=generic&#x27; &#x27;-march=i586&#x27;</span><br><span class="line"> d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/collect2.exe -plugin d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/liblto_plugin-0.dll -plugin-opt=d:/software/mingw/bin/../libexec/gcc/mingw32/6.3.0/lto-wrapper.exe -plugin-opt=-fresolution=C:\Users\MrBlu\AppData\Local\Temp\ccRAu2K4.res -Bdynamic -o helloworld.exe -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0 -Ld:/software/mingw/bin/../lib/gcc -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../../mingw32/lib -Ld:/software/mingw/bin/../lib/gcc/mingw32/6.3.0/../../.. helloworld.o</span><br><span class="line">helloworld.o:helloworld.c:(.text+0xa): undefined reference to `__main&#x27;</span><br><span class="line">helloworld.o:helloworld.c:(.text+0x25): undefined reference to `puts&#x27;</span><br><span class="line">helloworld.o:helloworld.c:(.text+0x3b): undefined reference to `printf&#x27;</span><br><span class="line">helloworld.o:helloworld.c:(.text+0x47): undefined reference to `puts&#x27;</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><h4 id="动态链接的优点"><a href="#动态链接的优点" class="headerlink" title="动态链接的优点"></a>动态链接的优点</h4><p>动态链接的优点是可执行文件的体积可以非常小。虽然运行速度稍慢一些，但动态链接能够更加有效的利用磁盘空间，而且链接-编辑阶段的时间也会缩短（因为链接器的有些工作被推迟到载入时）。</p><p>动态链接的主要目的是把程序与它们使用的特定的函数库版本中分离开来。取而代之的是，我们约定由系统向程序提供一个接口，该接口保持稳定，不随时间和操作系统的后续版本发生变化。</p><p>程序可以调用接口所承诺的服务，而不必担心这些功能是怎样提供的或者它们的底层实现是否改变。由于它是介于应用程序和函数库二进制可执行文件所提供的服务之间的接口，所以称它为应用程序二进制接口（Application Binary Interface，ABI）。</p><p>尽管单个可执行文件的启动速度稍受影响，但动态链接可以从两个方面提高性能：<br>1.动态链接可执行文件比功能相同的静态链接可执行文件的体积小。它能够节省磁盘空间和虚拟内存，因为函数库只有在需要时才被映射到进程中。<br>2.所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库的一个单独拷贝。操作系统内核保证映射到内存中的函数库可以被所有使用它们的进程共享。这就提供了更好的I&#x2F;O和交换空间利用率，节省了物理内存，从而提高了系统的整体性能。如果可执行文件是静态链接的，每个文件都将拥有一份函数库的拷贝，显然极为浪费。</p><p>动态链接使得函数库的版本升级更为容易。新的函数库可以随时发布，只要安装到系统中，旧的程序就能够自动获得新版本函数库的优点而无需重新链接。动态链接允许用户在运行时选择需要执行的函数库。这就使为了提高速度或提高内存使用效率或包含额外的调试信息而创建新版本的函数库是完全可能的，用户可以根据自己的喜好，在程序执行时用一个库文件取代另一个库文件。</p><p>动态链接是一种“just-in-time（JIT）”链接，这意味着程序在运行时必须能够找到它们所需要的函数库。链接器通过把库文件名或路径名植入可执行文件中来做到这一点。这意味着，函数库的路径不能随意移动。如果把程序链接到&#x2F;usr&#x2F;lib&#x2F;libthread.so库，那么就不能把该函数库移动到其他目录，除非在链接器中进行特别说明。否则，当程序调用该函数库的函数时，就会在运行时导致失败。当在一台机器上编译完程序后，把它拿到另一台不同的机器上运行时，也可能出现这种情况。执行程序的机器必须具有该程序需要链接的函数库，而且这些函数库必须位于在链接器中所说明的目录。对于标准系统函数库而言，这并不成问题。</p><p>任何人都可以创建静态或动态的函数库。只需简单的编译一些不包含main函数的代码，并把编译所生的.o用正确的工具进行处理。<br>使用<a href="https://www.jianshu.com/p/00ee0ec582a1">gcc程序编译的过程</a>中的示例代码在Ubuntu下使用gcc创建静态和动态库：</p><h4 id="首先将helloworld代码拆分开来："><a href="#首先将helloworld代码拆分开来：" class="headerlink" title="首先将helloworld代码拆分开来："></a>首先将helloworld代码拆分开来：</h4><p>分别为“helloworld.c”、“helloworld.h”、“main.c”,<br>helloworld.c内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0 </span><br><span class="line"></span><br><span class="line">#define DEBUG_ENABLE</span><br><span class="line"></span><br><span class="line">void helloworld(void)&#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        if(i == TRUE)&#123;</span><br><span class="line">                printf(&quot;hello\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">#ifdef DEBUG_ENABLE</span><br><span class="line">                printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">#endif</span><br><span class="line">                printf(&quot;hello world\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>helloworld.h内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HELLO_WORLD_H </span><br><span class="line">#define HELLO_WORLD_H </span><br><span class="line">    void helloworld(void);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>main.c内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include  &quot;helloworld.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"> &#123;</span><br><span class="line">     helloworld();</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="将helloworld-c生成动态链接库："><a href="#将helloworld-c生成动态链接库：" class="headerlink" title="将helloworld.c生成动态链接库："></a>将helloworld.c生成动态链接库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared helloworld.c -o libhelloworld.so</span><br></pre></td></tr></table></figure><p> -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。 与位置无关的代码表示用这种方法产生的代码保证对于任何全局数据的访问都是通过额外的间接方法完成的。这使它很容易对数据进行重新定位，只要简单的修改全局偏移量表的其中一个值就可以了。类似的，每个函数调用的产生就像是通过过程链接表的某个间接地址所产生的一样。这样，文本可以很容易的重新定位到任何地方，只要修改一下偏移量表就可以了。所以当代码在运行时被映射进来时，运行时链接器可以直接把它们放在任何空闲的地方，而代码本身并不需要修改。</p><p>在缺省情况下，编译器并不产生与位置无关的代码，因为额外的指针解除引用操作将使程序在运行时稍慢。然而，如果不使用与位置无关的代码，所产生的代码就会被对应到固定的地址，这对于可执行文件来说确实很好，但对于共享库，速度却要慢一点，因为现在每个全局引用就不得不在运行时通过修改页面安排到固定的位置，这使得页面无法共享。</p><p>运行时链接器总能够安排对页面的引用。但是，使用位置无关代码，任务被极大的简化了。当然需要权衡一下，位置无关代码与由运行时链接器安排代码相比，速度是快了还是慢了。根据经验，对于函数库应该始终使用与位置无关代码。对于共享库，与位置无关的代码显得格外有用，因为每个使用共享库的进程一般都会把它映射到不同的虚拟地址（尽管共享库同一份物理拷贝）。</p><p>一个相关的术语是“纯代码（pure code）”。纯可执行文件是只包含代码（无静态或初始化过的数据）的文件。它之所以称为“纯”是因为它不必进行修改就能被其他特定的进程执行。它从堆栈或者其他（非纯）段引用数据。纯代码可以被共享。如果生成与位置无关代码（意味着共享），你通常也希望它是纯代码。</p><h4 id="编译main时加入libhelloworld-so："><a href="#编译main时加入libhelloworld-so：" class="headerlink" title="编译main时加入libhelloworld.so："></a>编译main时加入libhelloworld.so：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.h main.c -L. -lhelloworld -o main</span><br></pre></td></tr></table></figure><p>-L. : 标记告诉gcc函数库可能位于当前目录。<br>-l ：后面加上动态链接库，动态链接库的名字前的lib不用加上去。传给C编译器的命令行参数里并没有提到函数库的完整路径名。它甚至没有提到在函数库目录中该文件的完整名字。实际上，编译器被告知根据选项-lname链接到相应的函数库，函数库的名字是libname.so——换句话说，“lib”部分和文件扩展名被省略掉了，但在前面加了一个“l”。</p><h4 id="运行main，出错："><a href="#运行main，出错：" class="headerlink" title="运行main，出错："></a>运行main，出错：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main: error while loading shared libraries: libhelloworld.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>程序在运行时，会查找需要的动态库文件，若找到，则载入动态库，否则将提示类似上述错误而终止程序运行。有多种方法可以解决：</p><p>a.将文件 libhelloworld.so复制到目录&#x2F;usr&#x2F;lib中，再执行则没有问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ sudo mv libhelloworld.so /usr/lib</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main</span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>b.既然连接器会搜寻LD_LIBRARY_PATH所指定的目录，那么我们可以将这个环境变量设置成当前目录： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ export LD_LIBRARY_PATH=$(pwd)</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main</span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>c.ldconfig命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ sudo ldconfig ~/mypro/C</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main</span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>当用户在某个目录下面创建或拷贝了一个动态链接库,若想使其被系统共享,可以执行一下”ldconfig 目录名”这个命令。此命令的功能在于让ldconfig将指定目录下的动态链接库被系统共享起来,意即:在缓存文件&#x2F;etc&#x2F;ld.so.cache中追加进指定目录下的共享库。上述指令让系统共享了~&#x2F;mypro&#x2F;C目录下的动态链接库。</p><p>可以查看程序执行时调用动态库的过程： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ldd main</span><br><span class="line">    linux-vdso.so.1 (0x00007ffd56fa4000)</span><br><span class="line">    libhelloworld.so =&gt; /home/mrbluyee/mypro/C/libhelloworld.so (0x00007fcec730f000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcec6f1e000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007fcec7713000)</span><br></pre></td></tr></table></figure><h4 id="将helloworld-c生成静态链接库："><a href="#将helloworld-c生成静态链接库：" class="headerlink" title="将helloworld.c生成静态链接库："></a>将helloworld.c生成静态链接库：</h4><p>a.先将helloworld.c编译生成.o文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o helloworld.o helloworld.c</span><br></pre></td></tr></table></figure><p>b.通过ar工具将目标文件打包成.a静态库文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rc libhelloworld.a helloworld.o</span><br></pre></td></tr></table></figure><p>注意：静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o&#x2F;.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。故ar工具里打包的一定是.o的文件，否则当运行连接了该静态库的可执行程序会报错。</p><h4 id="编译main时加入libhelloworld-a："><a href="#编译main时加入libhelloworld-a：" class="headerlink" title="编译main时加入libhelloworld.a："></a>编译main时加入libhelloworld.a：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.h main.c -static -L. -lhelloworld -o main_static </span><br></pre></td></tr></table></figure><p>可以看到，使用动态链接库生成的mian与静态链接库生成的main_static的大小区别：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-5700c0fbe7393588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot2.png"><br>动态链接库生成的mian大小为8288，而静态链接库生成的main_static的大小为844856。</p><h4 id="删除libhelloworld-a后运行main-static："><a href="#删除libhelloworld-a后运行main-static：" class="headerlink" title="删除libhelloworld.a后运行main_static："></a>删除libhelloworld.a后运行main_static：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrbluyee@mrbluyee:~/mypro/C$ rm libhelloworld.a</span><br><span class="line">mrbluyee@mrbluyee:~/mypro/C$ ./main_static </span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>程序照常运行，静态库中的helloworld函数已经链接到main_static文件中了。</p><h4 id="多个文件生成动态-静态库的用法："><a href="#多个文件生成动态-静态库的用法：" class="headerlink" title="多个文件生成动态&#x2F;静态库的用法："></a>多个文件生成动态&#x2F;静态库的用法：</h4><p>动态库:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.gcc -fPIC -shared xxx1.c xxx2.c xxx3.c -o libxxx.so </span><br><span class="line">2.gcc -fPIC -shared xxx1.o xxx2.o xxx3.o -o libxxx.so </span><br></pre></td></tr></table></figure><p>静态库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -rc libxxx.a xxx1.o xxx2.o xxx3.o</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc程序编译的过程</title>
      <link href="/2018/07/31/gcc%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/31/gcc%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理（preprocessing）、编译（compilation）、汇编（assembly）和链接（linking）等4步才能变成可执行文件，通常使用“编译”统称这4个步骤。</p><span id="more"></span><ul><li><p>预处理（preprocessing）<br>C&#x2F;C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令“#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。预处理就是将要包含（include）的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些代码输出到一个“.i”文件中等待进一步处理。</p></li><li><p>编译（compilation）<br>编译就是把C&#x2F;C++代码（比如上述的“.i”文件）翻译成汇编代码。</p></li><li><p>汇编（assembly）<br>汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在linux系统上一般表现为ELF目标文件（OBJ文件）。“反汇编”是指将机器代码转换为汇编代码。</p></li><li><p>链接（linking）<br>链接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件链接起来，最终生成可以在特定平台运行的可执行文件。</p></li></ul><p>编译器利用这4个步骤中的一个或多个来处理输入文件，源文件的后缀名表示源文件所用的语言，后缀名控制着编译器的默认动作。<br>文件后缀名对应表：</p><table><thead><tr><th>后缀名</th><th>类型</th></tr></thead><tbody><tr><td>.c</td><td>c源程序</td></tr><tr><td>.h</td><td>预处理器文件</td></tr><tr><td>.cpp</td><td>c++源程序</td></tr><tr><td>.i</td><td>预处理后的c文件</td></tr><tr><td>.ii</td><td>预处理后的c++文件</td></tr><tr><td>.s</td><td>汇编语言源程序</td></tr><tr><td>.o</td><td>目标文件（Object file）</td></tr><tr><td>.a</td><td>静态链接库文件（linux）</td></tr><tr><td>.so</td><td>动态链接库文件（linux）</td></tr><tr><td>.lib</td><td>静态链接库文件（windows）</td></tr><tr><td>.dll</td><td>动态链接库文件（windows）</td></tr></tbody></table><p>gcc的使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">gcc --help</span><br><span class="line"></span><br><span class="line">Usage: gcc [options] file...</span><br><span class="line">Options:</span><br><span class="line">  -pass-exit-codes         Exit with highest error code from a phase.</span><br><span class="line">  --help                   Display this information.</span><br><span class="line">  --target-help            Display target specific command line options.</span><br><span class="line">  --help=&#123;common|optimizers|params|target|warnings|[^]&#123;joined|separate|undocumented&#125;&#125;[,...].</span><br><span class="line">                           Display specific types of command line options.</span><br><span class="line">  (Use &#x27;-v --help&#x27; to display command line options of sub-processes).</span><br><span class="line">  --version                Display compiler version information.</span><br><span class="line">  -dumpspecs               Display all of the built in spec strings.</span><br><span class="line">  -dumpversion             Display the version of the compiler.</span><br><span class="line">  -dumpmachine             Display the compiler&#x27;s target processor.</span><br><span class="line">  -print-search-dirs       Display the directories in the compiler&#x27;s search path.</span><br><span class="line">  -print-libgcc-file-name  Display the name of the compiler&#x27;s companion library.</span><br><span class="line">  -print-file-name=&lt;lib&gt;   Display the full path to library &lt;lib&gt;.</span><br><span class="line">  -print-prog-name=&lt;prog&gt;  Display the full path to compiler component &lt;prog&gt;.</span><br><span class="line">  -print-multiarch         Display the target&#x27;s normalized GNU triplet, used as</span><br><span class="line">                           a component in the library path.</span><br><span class="line">  -print-multi-directory   Display the root directory for versions of libgcc.</span><br><span class="line">  -print-multi-lib         Display the mapping between command line options and</span><br><span class="line">                           multiple library search directories.</span><br><span class="line">  -print-multi-os-directory Display the relative path to OS libraries.</span><br><span class="line">  -print-sysroot           Display the target libraries directory.</span><br><span class="line">  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.</span><br><span class="line">  -Wa,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the assembler.</span><br><span class="line">  -Wp,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the preprocessor.</span><br><span class="line">  -Wl,&lt;options&gt;            Pass comma-separated &lt;options&gt; on to the linker.</span><br><span class="line">  -Xassembler &lt;arg&gt;        Pass &lt;arg&gt; on to the assembler.</span><br><span class="line">  -Xpreprocessor &lt;arg&gt;     Pass &lt;arg&gt; on to the preprocessor.</span><br><span class="line">  -Xlinker &lt;arg&gt;           Pass &lt;arg&gt; on to the linker.</span><br><span class="line">  -save-temps              Do not delete intermediate files.</span><br><span class="line">  -save-temps=&lt;arg&gt;        Do not delete intermediate files.</span><br><span class="line">  -no-canonical-prefixes   Do not canonicalize paths when building relative</span><br><span class="line">                           prefixes to other gcc components.</span><br><span class="line">  -pipe                    Use pipes rather than intermediate files.</span><br><span class="line">  -time                    Time the execution of each subprocess.</span><br><span class="line">  -specs=&lt;file&gt;            Override built-in specs with the contents of &lt;file&gt;.</span><br><span class="line">  -std=&lt;standard&gt;          Assume that the input sources are for &lt;standard&gt;.</span><br><span class="line">  --sysroot=&lt;directory&gt;    Use &lt;directory&gt; as the root directory for headers</span><br><span class="line">                           and libraries.</span><br><span class="line">  -B &lt;directory&gt;           Add &lt;directory&gt; to the compiler&#x27;s search paths.</span><br><span class="line">  -v                       Display the programs invoked by the compiler.</span><br><span class="line">  -###                     Like -v but options quoted and commands not executed.</span><br><span class="line">  -E                       Preprocess only; do not compile, assemble or link.</span><br><span class="line">  -S                       Compile only; do not assemble or link.</span><br><span class="line">  -c                       Compile and assemble, but do not link.</span><br><span class="line">  -o &lt;file&gt;                Place the output into &lt;file&gt;.</span><br><span class="line">  -pie                     Create a position independent executable.</span><br><span class="line">  -shared                  Create a shared library.</span><br><span class="line">  -x &lt;language&gt;            Specify the language of the following input files.</span><br><span class="line">                           Permissible languages include: c c++ assembler none</span><br><span class="line">                           &#x27;none&#x27; means revert to the default behavior of</span><br><span class="line">                           guessing the language based on the file&#x27;s extension.</span><br><span class="line"></span><br><span class="line">Options starting with -g, -f, -m, -O, -W, or --param are automatically</span><br><span class="line"> passed on to the various sub-processes invoked by gcc.  In order to pass</span><br><span class="line"> other options on to these processes the -W&lt;letter&gt; options must be used.</span><br><span class="line"></span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://gcc.gnu.org/bugs.html&gt;.</span><br></pre></td></tr></table></figure><p>常用选项：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-v</td><td>查看gcc编译器的版本，显示gcc执行时的详细过程</td></tr><tr><td>-E</td><td>只预处理，不编译、汇编、链接</td></tr><tr><td>-S</td><td>只编译，不汇编、链接</td></tr><tr><td>-c</td><td>编译和汇编，不链接</td></tr><tr><td>-o <file></td><td>指定输出文件名为file</td></tr><tr><td>-static</td><td>进行静态编译，即链接静态库，禁止使用动态库</td></tr><tr><td>-shared</td><td>1.可以生成动态库文件  2.进行动态编译，尽可能的链接动态库，只有没有动态库时才会链接同名的静态库（默认选项，可省略）</td></tr><tr><td>-Ldir</td><td>在库文件的搜索路径列表中添加dir目录</td></tr><tr><td>-lname</td><td>链接称为libname.a(静态库)或者libname.so(动态库)的库文件。若两个库都在，则根据编译方式（-static还是-shared）而进行链接。</td></tr><tr><td>-fPIC</td><td>生成使用相对地址的位置无关的目标代码（Position Independent Code）。</td></tr></tbody></table><p>以一个实例来分析gcc程序编译的过程（helloworld.c）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0 </span><br><span class="line"></span><br><span class="line">#define DEBUG_ENABLE</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    if(i == TRUE)&#123;</span><br><span class="line">        printf(&quot;hello\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">#ifdef DEBUG_ENABLE</span><br><span class="line">        printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">#endif</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -o helloworld.i helloworld.c</span><br></pre></td></tr></table></figure><p>打开helloworld.i文件(用sublime打开)，<br>可以看到include的文件已插入原文件中，宏定义展开、条件编译命令已选择好代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">434  __attribute__((__cdecl__)) __attribute__((__nothrow__)) int putw (int, FILE *);</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439 </span><br><span class="line">440 # 2 &quot;helloworld.c&quot; 2</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448 # 8 &quot;helloworld.c&quot;</span><br><span class="line">449 int main(void)&#123;</span><br><span class="line">450 int i = 0;</span><br><span class="line">451 if(i == 1)&#123;</span><br><span class="line">452  printf(&quot;hello\n&quot;);</span><br><span class="line">453 &#125;else&#123;</span><br><span class="line">454</span><br><span class="line">455  printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">456</span><br><span class="line">457  printf(&quot;hello world\n&quot;);</span><br><span class="line">458 &#125;</span><br><span class="line">459 return 0;</span><br><span class="line">460 &#125;</span><br><span class="line">461</span><br></pre></td></tr></table></figure><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S -o helloworld.s helloworld.i</span><br></pre></td></tr></table></figure><p>编译生成的汇编代码内容如下(用sublime打开)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    .file   &quot;helloworld.c&quot;</span><br><span class="line">    .def    ___main;    .scl    2;  .type   32; .endef</span><br><span class="line">    .section .rdata,&quot;dr&quot;</span><br><span class="line">LC0:</span><br><span class="line">    .ascii &quot;hello\0&quot;</span><br><span class="line">LC1:</span><br><span class="line">    .ascii &quot;i = %d\12\0&quot;</span><br><span class="line">LC2:</span><br><span class="line">    .ascii &quot;hello world\0&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl  _main</span><br><span class="line">    .def    _main;  .scl    2;  .type   32; .endef</span><br><span class="line">_main:</span><br><span class="line">LFB10:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushl   %ebp</span><br><span class="line">    .cfi_def_cfa_offset 8</span><br><span class="line">    .cfi_offset 5, -8</span><br><span class="line">    movl    %esp, %ebp</span><br><span class="line">    .cfi_def_cfa_register 5</span><br><span class="line">    andl    $-16, %esp</span><br><span class="line">    subl    $32, %esp</span><br><span class="line">    call    ___main</span><br><span class="line">    movl    $0, 28(%esp)</span><br><span class="line">    cmpl    $1, 28(%esp)</span><br><span class="line">    jne L2</span><br><span class="line">    movl    $LC0, (%esp)</span><br><span class="line">    call    _puts</span><br><span class="line">    jmp L3</span><br><span class="line">L2:</span><br><span class="line">    movl    28(%esp), %eax</span><br><span class="line">    movl    %eax, 4(%esp)</span><br><span class="line">    movl    $LC1, (%esp)</span><br><span class="line">    call    _printf</span><br><span class="line">    movl    $LC2, (%esp)</span><br><span class="line">    call    _puts</span><br><span class="line">L3:</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_restore 5</span><br><span class="line">    .cfi_def_cfa 4, 4</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">LFE10:</span><br><span class="line">    .ident  &quot;GCC: (MinGW.org GCC-6.3.0-1) 6.3.0&quot;</span><br><span class="line">    .def    _puts;  .scl    2;  .type   32; .endef</span><br><span class="line">    .def    _printf;    .scl    2;  .type   32; .endef</span><br></pre></td></tr></table></figure><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o helloworld.o helloworld.s</span><br></pre></td></tr></table></figure><p>.o文件打开内容如下（用winhex打开）：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-a67a388778be8c9a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="捕获.JPG"></p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o helloworld helloworld.o</span><br></pre></td></tr></table></figure><p>最终生成helloworld.exe文件，执行（使用的是Notepad++里的控制台）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">Process started (PID=15044) &gt;&gt;&gt;</span><br><span class="line">i = 0</span><br><span class="line">hello world</span><br><span class="line">&lt;&lt;&lt; Process finished (PID=15044). (Exit code 0)</span><br></pre></td></tr></table></figure><p>在编译过程中，除非使用了”-E”、”-S”、”-c”选项，或者编译器错误阻止了完整的过程，否则最后步骤总是链接。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc  helloworld.c</span><br><span class="line">gcc -o helloworld helloworld.c</span><br></pre></td></tr></table></figure><p>都是已经完成链接操作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数组与指针的不同之处</title>
      <link href="/2018/07/30/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84/"/>
      <url>/2018/07/30/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h4 id="数组并非指针"><a href="#数组并非指针" class="headerlink" title="数组并非指针"></a>数组并非指针</h4><p>C编程新手最常听到的说法之一就是“数组和指针是相同的”。不幸的是，这是一种非常危险的说法，并不完全正确。<br>ANSI C标准6.5.4.2节建议：</p><blockquote><p>注意以下声明的区别：<br>extern int *x;<br>extern int y[];<br>第一条语句声明x是个int型的指针；第二条语句声明y是个int型数组，长度尚未确定（不完整的类型），其存储在别处定义。</p></blockquote><p>标准并没有做更细的规定。许多C语言书籍对数组与指针何时相同、何时不同含糊其辞，对于这个应该重点阐述的话题只是一带而过。先看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件1：</span><br><span class="line">int mango[100];</span><br><span class="line"></span><br><span class="line">文件2：</span><br><span class="line">extern int *mango;</span><br></pre></td></tr></table></figure><p>这里，文件1定义了数组mango，但文件2声明它为指针。这有什么错误吗？无论如何，“每个人都知道”在C语言中，数组和指针非常相似。问题在于“每个人”这种说法是错误的！这相当于把整数和浮点数混为一谈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件1：</span><br><span class="line">int guava;</span><br><span class="line"></span><br><span class="line">文件2：</span><br><span class="line">extern float guava;</span><br></pre></td></tr></table></figure><p>上面这个int和float的例子非常明显，类型不匹配，没人会指望这样的代码能够运行。但是为什么人们会认为指针和数组始终应该是可以互换的呢？</p><p>答案是对数组的引用总是可以写成对指针的引用，而且确实存在一种指针和数组的定义完全相同的上下文环境。</p><p>不幸的是，这只是数组的一种极为普通的用法，并非所有情况下都是如此。但是，人们却自然而然的归纳并假定在所有的情况下数组和指针都是等同的，包括上面完全错误的“数组定义等同于指针的外部声明”这种情况。</p><h4 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h4><p>在搞清这个问题之前，需要在头脑里重新整理一些基本的C语言术语。记住，C语言中的对象必须有且只有一个定义，但它可以有多个extern声明。这里所说的对象跟C++中的对象并无关系，这里的对象只是跟链接器有关的东西，比如函数和变量。</p><p>定义是一种特殊的声明，它创建了一个对象；声明简单的说明了在其他地方创建的对象的名字，它允许你使用这个名字。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>定义</td><td>只能出现在一个地方</td><td>确定对象的类型并分配内存，用于创建新的对象。例如：int my_array[100];</td></tr><tr><td>声明</td><td>可以多次出现</td><td>描述对象的类型，用于指代其他地方定义的对象（例如在其他文件里）例：extern int my_array[];</td></tr></tbody></table><p>区分定义和声明：<br>1.声明相当于普通的声明：它所说明的并非自身，而是描述其他地方的创建的对象。<br>2.定义相当于特殊的声明：它为对象分配内存。</p><p><strong>extern</strong> 对象声明告诉编译器对象的类型和名字，对象的内存分配则在别处进行。由于并未在声明中为数组分配内存，所以并不需要提供关于数组长度的信息。对于多维数组，需要提供除最左边一维之外其他维的长度——这就给编译器足够的信息产生相应的代码。</p><h4 id="对数组和对指针的引用的不同之处"><a href="#对数组和对指针的引用的不同之处" class="headerlink" title="对数组和对指针的引用的不同之处"></a>对数组和对指针的引用的不同之处</h4><p>首先需要注意的是“地址y”和“地址y的内容”之间的区别。这是一个相当微妙之处，因为在大多数编程语言中我们用同一个符号来表示这两样东西，由编译器根据上下文环境判断它的具体含义。</p><p>以一个简单的赋值为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br></pre></td></tr></table></figure><table><thead><tr><th>x</th><th>&#x3D;</th><th>y</th></tr></thead><tbody><tr><td>在这个上下文环境里，符号x的含义是x所代表的地址。</td><td></td><td>在这个上下文里，符号y的含义是y所代表的地址的内容。</td></tr><tr><td>这被称为左值</td><td></td><td>这被称为右值</td></tr><tr><td>左值在编译时可知，左值表示存储结果的地方。</td><td></td><td>右值直到运行时才知。如无特别说明，右值表示“y的内容”。</td></tr></tbody></table><p><strong>c语言引入“可修改的左值”这个术语。<br>它表示左值允许出现在赋值语句的左边，这个奇怪的术语是为了与数组名区分。<br>数组名也用于确定对象在内存中的位置，也是左值，但它不能作为赋值的对象。因此，数组名是个左值但不是可修改的左值。<br>标准规定赋值符必须用可修改的左值作为它左边一侧的操作数。<br>用通俗的话说，只能给可以修改的东西赋值。</strong></p><p>编译器为每个变量分配一个地址（左值），这个地址在编译时可知，而且该变量在运行时一直保存于这个地址。存储于变量中的值（右值）只有在运行时才可知。如果需要用到变量中存储的值，编译器就发出指令从指定地址读入变量值并将它存于寄存器中。</p><p>这里的关键之处在于每个符号的地址在编译时可知。所以，如果编译器需要一个地址（可能还需要加上偏移量）来执行某种操作，它就可以直接进行操作，并不需要增加指令首先取得具体的地址。相反，对于指针，必须首先在运行时取得它的当前值，然后才能对它进行解除引用操作（作为以后进行查找的步骤之一。）</p><p>1.对数组进行下标引用的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a[9] = &quot;abcdefgh&quot;;</span><br><span class="line">...</span><br><span class="line">c = a[i];</span><br></pre></td></tr></table></figure><p>首先，编译器符号表有数组a的地址，假设为9980；<br>运行时步骤1：取i的值，将它与9980相加（获得a[i]对应的偏移地址）<br>运行时步骤2：取地址（9980+i）的内容。</p><p>这就是为什么extern char a[]与extern char a[100]等价的原因。这两个声明都提示a是一个数组，也就是一个内存地址，数组内的字符可以从这个地址找到。编译器并不需要知道数组总共有多长，因为数组长度只用于表示偏离起始地址的最大偏移量。从数组提取一个字符，只要简单的用符号表里a的地址加上下标的偏移量，所需要的字符就位于这个地址中。</p><p>如果声明extern char *p，它将告诉编译器p是一个指针，它指向的对象是一个字符。为了取得这个字符，必须得到地址p的内容，把内容再作为字符的地址，并从这个地址中取得这个字符。指针的访问要灵活的多，但需要增加一次额外的提取。</p><p>2.对指针的引用的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p;</span><br><span class="line">...</span><br><span class="line">c = *p;</span><br></pre></td></tr></table></figure><p>首先，编译器有符号p的地址，假设为4624；<br>运行时步骤1：取地址4624的内容，为5081；<br>运行时步骤2：取地址5081的内容。</p><p>3.对指针进行下标引用的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p = &quot;abcdefgh&quot;;</span><br><span class="line">...</span><br><span class="line">c = p[i];</span><br></pre></td></tr></table></figure><p>首先，编译器符号表有一个p，假设地址为4624；<br>运行时步骤1：取地址4624的内容，为5081；<br>运行时步骤2：取得i的值，并将它与5081相加；<br>运行时步骤3：取地址（5081+i）的内容。</p><p>对照1、3的访问方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[] = &quot;abcdefgh&quot;; ... a[3];</span><br><span class="line">char *p = &quot;abcdefgh&quot;; ... p[3];</span><br></pre></td></tr></table></figure><p>在这两种情况下，都可以取得字符‘d’，但两者的途径非常不一样。</p><p>定义为指针，但以数组方式引用，编译器将会：<br>a.取得符号表中p的地址，提取存储于此处的指针。<br>b.把下标所表示的偏移量与指针的值相加，产生一个地址。<br>c.访问上面这个地址，取得字符。</p><blockquote><p>编译器已被告知p是一个指向字符的指针。p[i]表示”从p所指的地址开始，前进i步，每步都是一个字符（即每个元素的长度为一个字节）。“如果是其他类型的指针（如int或double），其步长（每步的字节数）也各不相同。</p></blockquote><p><strong>既然把p声明成指针，那么不管p原先定义为指针还是数组，都会按照上面所示的三个步骤进行操作，但是只有当p原来定义为指针时这个方法才是正确的。</strong></p><h4 id="定义为数组，但被声明为指针的问题"><a href="#定义为数组，但被声明为指针的问题" class="headerlink" title="定义为数组，但被声明为指针的问题"></a>定义为数组，但被声明为指针的问题</h4><p>假设p原先的定义是char p[10]，p在外部文件被声明为extern char *p。<br>当用p[i]这种形式提取这个声明的指针p的内容时，实际上得到的是一个字符。但按照上面的方法，编译器却把取到的字符当成是一个地址，把ACSII字符解释为地址显然是牛头不对马嘴，它很可能会污染程序地址空间的内容，并出现莫名其妙的错误。</p><p>指针的外部声明与数组定义不匹配的问题很容易修正，只要修改声明，使之与定义相匹配即可，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件1：</span><br><span class="line">int mango[100];</span><br><span class="line"></span><br><span class="line">文件2：</span><br><span class="line">extern int mango[];</span><br></pre></td></tr></table></figure><p>mango数组的定义分配了100个int的空间。<br>而指针定义 int *raisin；则申请一个地址容纳该指针。<br>指针的名字是raisin，它可以指向任何一个int变量（或int数组）。<br>指针变量raisin本身始终位于同一个地址，但它的内容在任何时候都可以不同，指向不同地址的int变量。这些不同的int变量可以有不同的值。<br>mango数组的地址并不能改变，在不同的时候它的内容可以不同，但它总是表示100个连续的内存空间。</p><h4 id="数组和指针的其他区别"><a href="#数组和指针的其他区别" class="headerlink" title="数组和指针的其他区别"></a>数组和指针的其他区别</h4><p>比较数组和指针的另外一个方法就是比对两者的特点。</p><table><thead><tr><th>指针</th><th>数组</th></tr></thead><tbody><tr><td>保存数据地址</td><td>保存数据</td></tr><tr><td>间接访问数据，首先取得指针的内容，把它作为地址，然后从这个地址提取数据。如果指针有一个下标[i]，就把指针的内容加上i作为地址，从中提取数据</td><td>直接访问数据，a[i]只是简单的以a+i为地址取得数据。</td></tr><tr><td>通常用于动态数据结构</td><td>通常用于存储固定数目且数据类型相同的元素</td></tr><tr><td>相关的函数为malloc()、free()</td><td>隐式分配和删除</td></tr><tr><td>通常指向匿名数据</td><td>自身即为数据名</td></tr></tbody></table><p>数组和指针都可以在它们的定义中用字符串常量进行初始化。尽管看上去一样，底层的机制却不相同。<br>定义指针时，编译器并不为指针所指向的对象分配空间，它只分配指针本身的空间，除非在定义时同时赋给指针一个字符串常量进行初始化。例如，下面的定义创建了一个字符串常量（为其分配了内存）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *p = &quot;breadfruit&quot;;</span><br></pre></td></tr></table></figure><p>注意只有对字符串常量才是如此。不能指望为浮点数之类的常量分配空间，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float *pip = 3.141；//错误！无法通过编译。</span><br></pre></td></tr></table></figure><p>在ANSI C中，初始化指针时所创建的字符串常量被定义为只读。如果试图通过指针修改这个字符串的值，程序就会出现未定义的行为。在有些编译器中，字符串常量被存放在只允许读取的文本段中，以防止它被修改。</p><p>数组也可以用字符串常量进行初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char a[] = &quot;gooseberry&quot;;</span><br></pre></td></tr></table></figure><p>与指针不同，由字符串常量初始化的数组是可以修改的。其中的单个字符在以后可以改变，比如下面的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strncpy(a, &quot;black&quot;, 5);</span><br></pre></td></tr></table></figure><p>就将数组的值修改为”blackberry”。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的typedef</title>
      <link href="/2018/07/29/C%E8%AF%AD%E8%A8%80%E7%9A%84typedef/"/>
      <url>/2018/07/29/C%E8%AF%AD%E8%A8%80%E7%9A%84typedef/</url>
      
        <content type="html"><![CDATA[<p>typedef是一种有趣的声明形式：它为一种类型引入新的名字，而不是为变量分配空间。在某些方面，typedef类似于宏文本替换——它并没有引入新的类型，而是为现有类型取个新名字，但它们之间存在一个关键性的区别。</p><span id="more"></span><p>typedef关键字可以是一个常规声明的一部分，可以出现在靠近声明开始部分的任何地方。事实上，typedef 的格式与变量声明完全一样，只是多了这个关键字，向你提醒它的实质。由于typedef看上去跟变量声明完全一样，它们读起来也是一样的。普通的声明表示“这个名字是一个指定类型的变量”，而typedef关键字并不是创建一个变量，而是宣称“这个名字是指定类型的同义词”。</p><p>一般情况下，typedef用于简洁的表示指向其他东西的指针。典型的例子是signal()原型的声明。signal()是一种系统调用，用于通知运行时系统：当某种特定的“软件中断”发生时调用特定的程序。调用signal()并通过传参告诉它中断的类型以及用于处理中断的程序。在ANSI C标准中，signal()的声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*signal(int sig,void(*func)(int)))(int);</span><br></pre></td></tr></table></figure><p>用<a href="https://www.jianshu.com/p/474f4da7aeef">分析C语言的声明（2）</a>介绍的方法分析这个声明：<br>首先：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*signal( ))(int);</span><br></pre></td></tr></table></figure><p>signal是一个函数，它返回一个函数指针，后者所指向的函数接受一个int参数并返回void。<br>其中提取出来的通用的部分是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*func)(int);</span><br></pre></td></tr></table></figure><p>这个表示一个函数指针，所指向的函数接受一个int参数，返回值是void。下面用typedef来“代表”通用部分，从而进行简化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*ptr_to_func) (int);</span><br><span class="line">/* 它表示ptr_to_func是一个函数指针，该函数接受一个int参数，返回值为void。*/</span><br><span class="line"></span><br><span class="line">ptr_to_func signal(int, ptr_to_func);</span><br><span class="line">/* 它表示signal是一个函数，它接受两个参数，</span><br><span class="line">    其中一个是int，另一个是ptr_to_func，返回值是ptr_to_func。*/</span><br></pre></td></tr></table></figure><p>然而，说到typedef就不能不说一下它的缺点。它同样具有其他声明一样的混乱语法，同样可以把几个声明器塞到一个声明中去。对于结构体，除了可以在书写时省掉struct关键字之外，typedef并不能提供显著的好处，而少些一个struct其实并没有多大帮助。在任何typedef声明中，甚至不必把typedef放在声明的开始位置。</p><h4 id="typedef和-define的区别"><a href="#typedef和-define的区别" class="headerlink" title="typedef和#define的区别"></a>typedef和#define的区别</h4><p>typedef和define之间有一个关键性的区别。正确思考这个问题的方法就是把typedef看成是一种彻底的“封装”类型——在声明它之后不能再往里面增加别的东西。它和define的区别体现在两个方面：<br>1.可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define peach int </span><br><span class="line"></span><br><span class="line">unsigned peach i ; //没有问题</span><br><span class="line"></span><br><span class="line">typedef int banana；</span><br><span class="line"></span><br><span class="line">unsigned banana i；//错误，非法</span><br></pre></td></tr></table></figure><p>2.在连续几个变量的声明中，用typedef定义的类型能够保证声明中所有的变量均为同一种类型，而用#define定义的类型则无法保证。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define  int_ptr int * </span><br><span class="line"></span><br><span class="line">int_ptr chalk, cheese;</span><br></pre></td></tr></table></figure><p>经过宏扩展，第二行变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int * chalk, cheese;</span><br></pre></td></tr></table></figure><p>这使得chalk和cheese成为不同的类型：chalk是一个指向int的指针，而cheese则是一个int。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef char * char_ptr;</span><br><span class="line"></span><br><span class="line">char_ptr Bentley, Rolls_Royce;</span><br></pre></td></tr></table></figure><p>使用typedef定义的类型能够保证它们的类型相同，都是指向char的指针。</p><h4 id="typedef-struct-foo-…-foo-的含义"><a href="#typedef-struct-foo-…-foo-的含义" class="headerlink" title="typedef struct foo{ … foo;}的含义"></a>typedef struct foo{ … foo;}的含义</h4><p>C语言存在多种名字空间：</p><ul><li>标签名（label name）。</li><li>标签（tag）：这个名字空间用于所有的结构体、枚举和联合。</li><li>成员名：每个结构体或联合都有自身的名字空间。</li><li>其他。</li></ul><p>在同一个名字空间里，任何名字必须具有唯一性，但在不同的名字空间里可以存在相同的名字。由于每个结构体或联合具有自己的名字空间，所以同一个名字可以出现在许多不同的结构内。有时可以看到这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct foo &#123; int foo;&#125; foo;</span><br></pre></td></tr></table></figure><p>这显然会让将来维护这段代码的程序员感到困惑和沮丧，你说sizeof(foo)到底是表示哪个foo呢？<br>有些东西更加稀罕，像下面这样的声明竟然也是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct baz &#123; int baz; &#125; baz;</span><br><span class="line">struct baz variable_1;</span><br><span class="line">baz variable_2;</span><br></pre></td></tr></table></figure><p>太多的“baz”了！让我们换一些清楚的名字，整理一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef struct my_tag &#123; int i; &#125; my_type;</span><br><span class="line">struct my_tag variable_1;</span><br><span class="line">my_type variable_2;</span><br></pre></td></tr></table></figure><p>这个typedef声明引入了my_type这个名字作为”struct my_tag { int i; }”的简写形式。如果你用typedef声明一个标识符表示struct 结构类型，那么以后使用这个标识符时前面就不必加上关键字struct 了。但这个typedef声明同时也引入了结构标签my_tag，在它面前加个关键字struct可以表示同样的意思。</p><p>下面两个声明具有相似的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef struct fruit &#123; int weight , price_per_lb; &#125; fruit; // 语句1</span><br><span class="line">struct veg &#123; int weight , price_per_lb; &#125; veg; //语句2</span><br></pre></td></tr></table></figure><p>但它们代表的意思却完全不一样，语句1声明了结构体标签”fruit“和由typedef声明的结构体类型”fruit“，其实际效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct fruit mandarin; //使用结构体标签”fruit“</span><br><span class="line">fruit mandarin; //使用结构体类型”fruit“</span><br></pre></td></tr></table></figure><p>语句2声明了结构体标签”veg“和变量veg。只有结构体标签能够在以后的声明中使用，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct veg potato;</span><br></pre></td></tr></table></figure><p>如果试图使用veg cabbage这样的声明，将是一个错误。</p><h4 id="使用typedef的一些提示："><a href="#使用typedef的一些提示：" class="headerlink" title="使用typedef的一些提示："></a>使用typedef的一些提示：</h4><p>1.不要在一个typedef中放入几个声明器，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int *ptr, (fun()), arr[5];</span><br><span class="line">/* ptr是“指向int的指针”类型，</span><br><span class="line"> * fun是“指向返回值为int函数的指针”类型</span><br><span class="line"> * arr是“长度为5的int型数组”类型</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>2.千万不要把typedef嵌到声明的中间部分，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned const long typedef int volatile *kumquat;</span><br></pre></td></tr></table></figure><p>3.typedef为数据类型创建别名，而不是创建新的数据类型，可以对任何类型进行typedef声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*array_ptr)[100];</span><br></pre></td></tr></table></figure><p>4.应该只对所希望的变量类型进行typedef声明，为变量类型取一个喜欢的别名。关键字typedef应该如前所述出现声明的开始位置。在同一个代码块中，typedef引入的名字不能与其他标识符同名。</p><p>5.不要为了方便起见对结构体使用typedef。这样做唯一的好处是能使你不必书写”struct“关键字，但这个关键字可以向你提示一些信息，你不应该把它省掉。应该始终在结构体的定义中使用结构标签，即使它并非必须。这种做法可以使代码更为清晰。</p><p>6.typedef应该用在：</p><ul><li>数组、结构体、指针以及函数的组合类型。</li><li>可移植类型。比如当你需要一种至少20bit的类型时，可以对它进行typedef操作。这样，当把代码移植到不同的平台时，要选择正确的类型如short，int，long时，只要在typedef中进行修改就可以了，无需对每一个声明都加以修改。</li><li>typedef也可以为后面的强制类型转换提供一个简单的名字，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*ptr_to_int_fun)(void);</span><br><span class="line"></span><br><span class="line">char * p;</span><br><span class="line">...;</span><br><span class="line">...  = (ptr_to_int_fun) p;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的联合（union）与枚举（enum）</title>
      <link href="/2018/07/29/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%81%94%E5%90%88%EF%BC%88union%EF%BC%89%E4%B8%8E%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89/"/>
      <url>/2018/07/29/C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%81%94%E5%90%88%EF%BC%88union%EF%BC%89%E4%B8%8E%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="联合（union）"><a href="#联合（union）" class="headerlink" title="联合（union）"></a>联合（union）</h4><p>联合（union）在许多其他语言中被称为变体记录（variant record）。它的外表与结构体相似，但在内存布局上存在关键性的区别。在结构体中，每个成员依次存储，而在联合中，所有的成员都从偏移地址零开始存储。这样，每个成员的位置都重叠在一起；在某一时刻，只有一个成员真正存储于该地址。</p><span id="more"></span><p>联合既有一些优点，也有一些缺点。它的缺点就是那些所谓的优点其实并不怎么出色。联合的优点是它的外观同结构体一样，只是用关键字union取代了关键字struct。所以，如果你对结构体的一切都已了如指掌，基本上也就掌握了联合。联合的一般形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union 联合标签（可选）&#123;</span><br><span class="line">  类型1 标识符1；</span><br><span class="line">  类型2 标识符2；</span><br><span class="line">  ...</span><br><span class="line">  类型N 标识符N;</span><br><span class="line">&#125;变量定义（可选）;</span><br></pre></td></tr></table></figure><p>联合一般是作为大型结构的一部分存在的。在有些大型结构中，存在一些与实际表示的数据类型有关的隐式或显式的信息。如果存储数据时是一种类型，但在提取该数据时却成了另外一种类型，这显然存在着明显的类型不安全性。在Ada语言中，所有不同类型的字段都显式的存储于记录中，这就避免了这个问题。C语言则含糊的多，让程序员自己去回忆放在那儿的究竟是什么东西。</p><p>联合一般用来节省空间，因为有些数据项是不可能同时出现的，如果同时存储它们，显然颇为浪费。例如，如果我们要存储一些关于动物种类的信息，首先想到的方法可能是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct creature&#123;</span><br><span class="line">  char has_backbone;</span><br><span class="line">  char has_fur;</span><br><span class="line">  short num_of_legs_in_excess_of_4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，我们知道，所有的动物要么是脊椎动物，要么是无脊椎动物。进而，我们还知道只有脊椎动物才可能有毛皮，只有无脊椎动物才可能有多于4条的腿。没有一种动物既有毛皮又有超过4条的腿。这样，可以通过把两个互相排斥的字段存储于一个联合中来节省空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union secondary_characteristics&#123;</span><br><span class="line">  char has_fur;</span><br><span class="line">  short num_of_legs_in_excess_of_4;</span><br><span class="line">&#125;;</span><br><span class="line">struct creature&#123;</span><br><span class="line">  char has_backbone;</span><br><span class="line">  union secondary_characteristics form;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们通常采取这种方式来节省备用的存储空间。如果我们有一个数据文件，里面存储了20000000个动物，使用这种方法，可以节省大约20MB的磁盘空间。</p><p>然而，联合还有其他用途，联合也可以把同一个数据解释成两种不同的东西，而不是把两个不同的数据解释为一个东西。该用法例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union bits32_tag&#123;</span><br><span class="line">  int whole; //一个32位的值</span><br><span class="line">  struct &#123; char c0, c1, c2, c3;&#125; bytes; //4个8位的字节</span><br><span class="line">&#125; value；</span><br></pre></td></tr></table></figure><p>这个联合允许程序员提取整个32位值（作为 int）,也可以提取单独的字节字段如value.bytes.c0等。采用其他的方法也能达到这个目的，但联合不需要额外的赋值或强制类型转换。</p><p>在实际工作中，结构体的使用比联合多得多。</p><h4 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h4><p>枚举（enum）通过一种简单的途径，把一串名字与一串整型值联系在一起。对于像C这样的弱类型语言而言，很少有什么事只能靠枚举而不能用#define来解决的。枚举的一般形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum 可选标签 &#123;内容...&#125; 可选变量定义；</span><br></pre></td></tr></table></figure><p>其中的“内容…”是把一些标识符的列表，可能有一些整型值赋给它们。下面是一个枚举实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum sizes &#123; small = 7, medium, large = 10, humungous &#125;;</span><br></pre></td></tr></table></figure><p>缺省情况下，整型值从0开始。如果对列表中的某个标识符进行了赋值，那么紧接其后的那个标识符的值就比所赋的值大1，然后类推。枚举具有一个优点：#define 定义的名字一般在编译时被丢弃，而枚举名字则通常一直在调试器中可见，可以在调试代码时使用它们。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言的结构体(struct)</title>
      <link href="/2018/07/29/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-struct/"/>
      <url>/2018/07/29/C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-struct/</url>
      
        <content type="html"><![CDATA[<p>结构体就是一种把一些数据组合在一起的数据结构。在C语言中，进行组合的通常方法是把需要组合的东西放在花括号里面：{内容…}。关键字struct放在左花括号前面，以便编译器能够从程序块中认出它：struct {内容…}</p><span id="more"></span><p>结构体的内容可以是任何其他数据声明：单个数据项、数组、其他结构、指针等。我们可以在结构体的定义后面跟一些变量名，表示这些变量的类型是这个结构。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;内容...&#125; plum, pomegranate, pear;</span><br></pre></td></tr></table></figure><p>另外还需要注意的一点是，可以在struct关键字后面加一个可选的”结构标签“：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct fruit_tag &#123;内容...&#125; plum, pomegranate, pear;</span><br></pre></td></tr></table></figure><p>这样，我们就可以在将来的声明中用struct fruit_tag作为struct {内容…} 的简写形式了。<br>因此，结构体的通常形式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct 结构标签（可选）&#123;</span><br><span class="line">  类型1 标识符1；</span><br><span class="line">  类型2 标识符2；</span><br><span class="line">  ...</span><br><span class="line">  类型N 标识符N;</span><br><span class="line">&#125;变量定义（可选）;</span><br></pre></td></tr></table></figure><p>结构体中也允许存在位段、无名字段以及字对齐所需的填充字段。这些都是通过在字段的声明后面加一个冒号以及一个表示字段位长的整数来实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 处理ID信息 */</span><br><span class="line">struct pid_tag &#123;</span><br><span class="line">  unsigned int inactive : 1;</span><br><span class="line">  unsigned int              : 1;  //1个位的填充</span><br><span class="line">  unsigned int recount : 6;</span><br><span class="line">  unsigned int              : 0; //填充到下一个字边界</span><br><span class="line">  short pid_id;</span><br><span class="line">  struct pid_tag *link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法通常被称作”深入逻辑元件的编程“，你可以在系统编程中看到它们。它也能用于把一个布尔标志以位而不是字符来表示。位段的类型必须是int, unsigned int 或 signed int (或加上限定符)。至于int位段的值可不可以取负值则取决于编译器。</p><p>我不喜欢把结构体的声明和变量的定义混合在一起，更喜欢采用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct veg &#123;int weight ,price_per_lb&#125;;</span><br><span class="line">struct  veg onion,radish,turnip;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct veg &#123;int weight ,price_per_lb&#125;onion,radish,turnip;</span><br></pre></td></tr></table></figure><p>确实，后面一种方法可以少打了几个字，但我们应该更关心代码是否容易阅读，而不是是否容易书写。我们只编写一次代码，但在以后的程序维护过程中将多次阅读这些代码。如果一行代码只做一件事，看上去会简单些。基于这个理由，变量的声明应该与类型的声明分开。</p><p>两个跟结构体有关的参数传递问题：<br>1.有些C语言书籍声称”在调用函数时，参数按照从右到左的次序压倒堆栈里。“这种说法过于简单了。参数在传递时首先尽可能的存放到寄存器中（追求速度）。注意，int型变量i跟只包含一个int型成员的结构体变量s在参数传递时的方式可能完全不同。一个int型参数一般会被传递到寄存器中，而结构体参数则很可能被传递到堆栈中。</p><p>2.在结构体中放置数组，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct s_tag &#123; int a[100]; &#125;;</span><br></pre></td></tr></table></figure><p>现在，你可以把数组当作第一等级的类型，用赋值语句拷贝整个数组，以传值调用的方式把它传递到函数，或者把它作为函数的返回类型。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">struct s_tag &#123;int a[10];&#125;;</span><br><span class="line">struct s_tag orange,lime,lemon;</span><br><span class="line">struct s_tag twofold(struct s_tag s)&#123;</span><br><span class="line">    int j;</span><br><span class="line">    for(j=0;j&lt;10;j++)&#123;</span><br><span class="line">        s.a[j] *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        lime.a[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    lemon = twofold(lime);</span><br><span class="line">    orange = lemon;</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,lime.a[i]);</span><br><span class="line">    &#125;   </span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,lemon.a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,orange.a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 1 1 1 1 1 1 1 </span><br><span class="line">2 2 2 2 2 2 2 2 2 2 </span><br><span class="line">2 2 2 2 2 2 2 2 2 2</span><br></pre></td></tr></table></figure><p>在典型情况下，并不会频繁地对整个数组进行赋值操作。但是如果需要这样做，可以通过把它放入到结构体中来实现。</p><p>在结构体中包含指向结构本身的指针：<br>在结构体中包含一个指向结构本身的指针，这种方法常用于列表（list）、树（tree）以及许多其他动态数据结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*结构体中有一个指向结构本身的指针*/</span><br><span class="line">struct node_tag &#123;</span><br><span class="line">  int datum;</span><br><span class="line">  struct node_tag *next;</span><br><span class="line">&#125;;</span><br><span class="line">struct node_tag a, b;</span><br><span class="line">a.next = &amp;b; /* a, b链接在一起 */</span><br><span class="line">a.next-&gt;next = NULL;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析C语言的声明（1）</title>
      <link href="/2018/07/28/%E5%88%86%E6%9E%90C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%881%EF%BC%89/"/>
      <url>/2018/07/28/%E5%88%86%E6%9E%90C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>C语言声明的语法有时会带来严重的问题。C语言声明的语法对于编译器的处理来说并不是什么大不了的事，但是对于一般的程序员，它却会成为障碍。C语言声明的语法渗透于整个语言使用的方方面面，毫不夸张的说，正是由于在组合类型方面的笨拙行为，C语言被显著且毫无必要的复杂化了。</p><span id="more"></span><p>C语言的声明模型之所以如此晦涩，原因之一是早期在设计C语言时，出现的一种C语言设计哲学，要求对象的声明形式与它的使用形式尽可能相似。一个int类型的指针数组被声明为 int *p[3];并以*p[i]这样的表达式引用或使用指针所指向的int数据，所以它的声明形式和使用形式非常相似。</p><p>这种做法的好处是各种不同操作符的优先级在“声明“和”使用“时是一样的。它的缺点在于操作符的优先级过于复杂，程序员需要记住特殊的规则才能推断出int *p[3]到底是一个int型的指针数组，还是一个指向int数组的指针。</p><h4 id="数组指针与指针数组："><a href="#数组指针与指针数组：" class="headerlink" title="数组指针与指针数组："></a>数组指针与指针数组：</h4><p>数组指针（也称行指针）<br>定义 int (*p)[n];<br>()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。<br>如要将二维数组赋给一指针，应这样赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4];</span><br><span class="line">int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。</span><br><span class="line"> p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span><br><span class="line"> p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span><br></pre></td></tr></table></figure><p>所以数组指针也称指向一维数组的指针，亦称行指针。</p><p>指针数组<br>定义 int *p[n];<br>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p&#x3D;a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p&#x3D;a; 这里*p表示指针数组第一个元素的值，a的首地址的值。<br>如要将二维数组赋给一指针数组:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *p[3];//这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]</span><br><span class="line">int a[3][4];</span><br><span class="line">p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针,所以要分别赋值。</span><br><span class="line">for(i=0;i&lt;3;i++)&#123;</span><br><span class="line">  p[i]=a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组指针和指针数组在指向二维数组时，其引用是一样的，比如要表示数组中i行j列一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(p[i]+j)</span><br><span class="line">*(*(p+i)+j)</span><br><span class="line">(*(p+i))[j]</span><br><span class="line">p[i][j]</span><br></pre></td></tr></table></figure><p>C语言的声明所存在的最大的问题是你无法以一种人们所习惯的自然方式从左向右阅读——一个声明，在ANSI C引入volatile和const关键字后，情况就更糟糕了。由于这些关键字只能出现在声明中（而不是使用中），这就使得现如今声明形式和使用形式能完全对的上号的例子越来越少了。</p><p>如果想要把什么东西的类型强制转换为指向数组的指针，就不得不使用下面的语句来表示这个强制类型转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char (*j)[20];  /*j是一个指向数组的指针，组内右20个char元素。*/</span><br><span class="line">j = (char (*)[20])malloc(20);</span><br></pre></td></tr></table></figure><p>如果把星号两边看上去多余的括号拿掉，代码会变成非法的。<br>涉及指针和const的声明可能会出现几种不同的顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int * grape;</span><br><span class="line">int const * grape;</span><br><span class="line">int * const grape;</span><br></pre></td></tr></table></figure><p>最后一种情况指针是只读的，在前两种情况下，指针所指向的对象是只读的。当然，如果要对象和指针都只读，如下面两种声明所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * const grape;</span><br><span class="line">int const * const grape;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析C语言的声明（2）</title>
      <link href="/2018/07/28/%E5%88%86%E6%9E%90C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%882%EF%BC%89/"/>
      <url>/2018/07/28/%E5%88%86%E6%9E%90C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="声明器（declarator）"><a href="#声明器（declarator）" class="headerlink" title="声明器（declarator）"></a>声明器（declarator）</h4><p>声明器是所有声明的核心，简单的说，声明器就是标识符以及与它组合在一起的任何指针、函数括号、数组下标等。<br><strong>表： C语言中的声明器（declarator）</strong></p><table><thead><tr><th>数量</th><th>C语言中的名字</th><th>C语言中出现的形式</th></tr></thead><tbody><tr><td>零个或多个</td><td>指针</td><td>下列形式之一：</td></tr><tr><td></td><td></td><td>*const volatile</td></tr><tr><td></td><td></td><td>*volatile</td></tr><tr><td></td><td></td><td>*</td></tr><tr><td></td><td></td><td>*const</td></tr><tr><td></td><td></td><td>*volatile const</td></tr><tr><td>有且只有一个</td><td>直接声明器</td><td>下列形式之一：</td></tr><tr><td></td><td></td><td>标识符</td></tr><tr><td></td><td></td><td>标识符[下标]</td></tr><tr><td></td><td></td><td>标识符(参数)</td></tr><tr><td></td><td></td><td>(声明器)</td></tr><tr><td>零个或一个</td><td>初始化内容</td><td>&#x3D; 初始值</td></tr></tbody></table><p>一个声明由下表所示的各个部分组成（并非所有的组合形式都是合法的，但这个表描述了我们进一步讨论所用到的词汇）。声明确定了变量的基本类型以及初始值（如果有的话）。<br><strong>表： C语言中的声明</strong></p><table><thead><tr><th>数量</th><th>C语言中的名字</th><th>C语言中出现的形式</th></tr></thead><tbody><tr><td>至少一个类型说明符</td><td>类型说明符(type-specifier)</td><td>void char short int long signed unsigned float double</td></tr><tr><td></td><td></td><td>结构说明符（struct-specifier）</td></tr><tr><td></td><td></td><td>枚举说明符（enum-specifier）</td></tr><tr><td></td><td></td><td>联合说明符（union-specifier）</td></tr><tr><td></td><td>存储类型（storage-class）</td><td>extern static register</td></tr><tr><td></td><td></td><td>auto typedef</td></tr><tr><td></td><td>类型限定符（type-qualifier）</td><td>const volatile</td></tr><tr><td>有且只有一个</td><td>声明器（declarator）</td><td>参见上表定义</td></tr><tr><td>零个或多个</td><td>更多的声明器</td><td>, 声明器</td></tr><tr><td>一个</td><td>分号</td><td>；</td></tr></tbody></table><p>让我们看一下如果你使用这些部件来构造一个声明，情况能够复杂到什么程度。同时要记住，在合法的声明中存在限制条件。你不可以像下面那样做：</p><ul><li>函数的返回值不能是一个函数，所以像foo()()这样是非法的。</li><li>函数的返回值不能是一个数组，所以像foo()[]这样是非法的。</li><li>数组里不能有函数，所以像foo<a href=""></a>这样是非法的。<br>但像下面这样则是合法的：</li><li>函数的返回值允许是一个函数指针，如： int (*foo())()</li><li>函数的返回值允许是一个指向数组的指针，如：int (*foo())[]</li><li>数组里面允许有函数指针，如 int (* foo[])()</li><li>数组里面允许有其他数组，所以你经常能看到int foo[][]</li></ul><h4 id="优先级规则"><a href="#优先级规则" class="headerlink" title="优先级规则"></a>优先级规则</h4><p>要理解一个声明，必须要懂得其中的优先级规则。</p><ul><li>A  声明从它的名字开始读取，然后按照优先级顺序依次读取。</li><li>B  优先级从高到低依次是：<br>——-B. 1  声明中被括号括起来的那部分<br>——-B. 2  后缀操作符：<br>————–括号()表示这是一个函数，而<br>————–方括号[]表示这是一个数组。<br>——-B. 3  前缀操作符：星号*表示“指向…的指针”</li><li>C  如果const和（或）volatile关键字的后面紧跟类型说明符（如int，long等），那么它作用于类型说明符。在其他情况下，onst和（或）volatile关键字作用于它左边紧邻的指针星号。</li></ul><p>用优先级规则分析C语言的一例声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * const *(*next)();</span><br></pre></td></tr></table></figure><ul><li>A  首先，看变量名“next”，并注意到它直接被括号括住。</li><li>B. 1  所以先把括号里面的东西作为一个整体，得出“next是一个指向…的指针”。</li><li>B  然后考虑括号外面的东西，在星号前缀和括号后缀之间作出选择。</li><li>B. 2  B. 2规则告诉我们优先级较高的是右边的函数括号，所以得出“next是一个函数指针，指向一个返回…的函数”。</li><li>B. 3  然后，处理前缀“*”，得出指针所指的内容。</li><li>C  最后，把“char * const”解释为指向字符的常量指针。</li></ul><p>把上述分析结果加以概括，这个声明表示“next是一个指针，它指向一个函数，该函数返回另一个指针，该指针指向一个类型为char的常量指针”。</p><p>一个更复杂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *(* c[10]) (int **p);</span><br></pre></td></tr></table></figure><p>1.<strong>c</strong><br>变量名是c<br>2.<strong>c[10]</strong><br>c是一个有10个元素的数组。<br>3.<strong>(* c[10])</strong><br>c是一个有10个元素的数组，数组的元素类型是指针，即c是指针数组。<br>4.<strong>(* c[10]) (int **p)</strong>;<br>数组的元素指针指向函数，故指针的类型是函数指针。指向的函数接收的形参p为int型的指针的指针类型（二级指针）。<br>5.<strong>*(* c[10]) (int **p)</strong>;<br>函数的返回值为一个指针。<br>6.<strong>char *(* c[10]) (int **p)</strong>;<br>函数的返回值为一个指向char的指针。</p><p>概括的说便是：<br>c是一个数组[0…9]，它的元素类型是函数指针，其所指向的函数的形参p是int型的指针的指针类型，函数的返回值是一个指向char的指针。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lint静态代码分析</title>
      <link href="/2018/07/28/Lint%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/07/28/Lint%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>lint是最著名的C语言工具之一，是由贝尔实验室SteveJohnson于1979在PCC(PortableC Compiler)基础上开发的静态代码分析。</p><span id="more"></span><h4 id="静态程序分析"><a href="#静态程序分析" class="headerlink" title="静态程序分析:"></a>静态程序分析:</h4><p>“静态程序分析(Static program analysis)”是指使用自动化工具软件对程序源代码进行检查，以分析程序行为的技术，应用于程序的正确性检查、安全缺陷检测、程序优化等。它的特点就是不执行程序，相反，通过在真实或模拟环境中执行程序进行分析的方法称为“动态程序分析(Dynamic program analysis)”。</p><p>静态程序分析往往作为一个多人参与的项目中代码审查过程的一个阶段，因编写完一部分代码之后就可以进行静态分析，分析过程不需要执行整个程序，这有助于在项目早期发现以下问题：变量声明了但未使用、变量类型不匹配、变量在使用前未定义、不可达代码、死循环、数组越界、内存泄漏等。下图说明了静态程序分析在进行项目编码过程中所处的位置：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-219a657115b0bf26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 静态程序分析在项目过程中所处的位置"></p><p>静态分析工具相比编译器，对代码进行了更加严格的检查，像数组越界访问、内存泄漏、使用不当的类型转换等问题，都可以通过静态分析工具检查出来，我们甚至可以在分析工具的分析标准里定义代码的编写规范，在检测到不符合编写规范的代码时抛出告警，这些功能都是编译器没有的。</p><blockquote><p>以上内容摘自<a href="https://blog.csdn.net/u014775175/article/details/66050875">代码静态分析工具——splint的学习与使用</a></p></blockquote><p>LINT工具是一种软件质量保证工具，许多国外的大型专业软件公司，如微软公司，都 把它作为程序检查工具，在程序合入正试版本或交付测试之前一定要保证通过了LINT检查 ，他们要求软件工程师在使用LINT时要打开所有的编译开关，如果一定要关闭某些开关， 那么要给出关闭这些开关的正当理由。 可想而知，如果从我们编码后第一次编译程序时就使用LINT来检查程序，并且保证消 除所有的LINT告警，我们就不会遇到象今天这么多的告警信息。</p><p>即使在今天，我们如果能 抽出一定的精力来消除程序中的LINT告警，以后再维持这种无告警状态就是很容易的了。 我们程序质量的提高也是不言而喻的。 PC-LINT是GIMPEL SOFTWARE公司的产品，其中的内容是非常广泛的，光是选项就有30 0多个，涉及到程序编译及语法使用中的方方面面。</p><p>如果要给LINT工具下一个形象点的定义，那就是：一种更加严格的编译器。它不仅可 以象普通编译器那样检查出一般的语法错误，还可以检查出那些虽然完全合乎语法要求， 但很可能是潜在的、不易发现的错误。</p><h4 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a>基本功能：</h4><ul><li>可能的空指针</li><li>在释放内存后使用了指向该内存的指针</li><li>赋值次序问题</li><li>拼写错误</li><li>被0除</li><li>失败的case语句(遗漏了break语句)</li><li>不可移植的代码(依赖了特定的机器实现)</li><li>宏参数没有使用圆括号</li><li>符号的丢失</li><li>异常的表达式</li><li>变量没有初始化</li><li>可疑的判断语句(例如,if(x&#x3D;0))</li><li>printf&#x2F;scanf的格式检查</li></ul><h4 id="系统版本："><a href="#系统版本：" class="headerlink" title="系统版本："></a>系统版本：</h4><ul><li><p><strong>UNIX系统</strong> 在UNIX系统中，可自动获得lint，它是一个标准的UNIX工具。</p></li><li><p><strong>Linux系统</strong> 在Linux各种发行版中,使用lint的版本是GNU下的Splint(前身是LClint)</p></li><li><p><strong>Windows</strong> 在Windows系统中，从第三方获得的lint工具的名称是PC lint以及Splint</p></li></ul><blockquote><p>以上内容摘自百度百科  <a href="https://baike.baidu.com/item/lint/2836851">lint</a></p></blockquote><p><a href="https://blog.csdn.net/u014775175/article/details/66050875">Splint使用教程1</a><br><a href="https://blog.csdn.net/xylt1/article/details/77895841">Splint使用教程2</a></p><p><a href="https://blog.csdn.net/scucj/article/details/4409735">PC-Lint使用教程</a></p><p><a href="https://blog.csdn.net/a910626/article/details/51737392">在android studio中使用lint</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C函数的返回值</title>
      <link href="/2018/07/28/C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2018/07/28/C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>首先看一段有问题的代码：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">char * string_copy(char * source_str)&#123;</span><br><span class="line">    char buffer[120];</span><br><span class="line">    strncpy(buffer, source_str, 119);</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    char *destination_str;</span><br><span class="line">    char source_str[] = &quot;hello world&quot;;</span><br><span class="line">    destination_str = string_copy(source_str);</span><br><span class="line">    printf(&quot;%s\n&quot;,destination_str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时就给出了警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In function &#x27;string_copy&#x27;:</span><br><span class="line"> warning: function returns address of local variable [-Wreturn-local-addr]</span><br><span class="line">return buffer;</span><br></pre></td></tr></table></figure><p>buffer是一个自动分配内存的数组，是该函数的局部变量。当控制流离开声明局部变量的范围时，自动变量便自动失效。这就意味着即使返回一个指向局部变量的指针，当函数结束时，由于该变量已被销毁，谁也不知道这个指针所指向的地址的内容是什么。</p><p>在C语言中，自动变量在堆栈中分配内存。当包含自动变量的函数或代码块退出时，它们所占用的内存便被回收，它们的内容肯定会被下一个所调用的函数覆盖。这一切取决于堆栈中先前的自动变量位于何处，活动函数声明了什么变量，写入了什么内容等。原先自动变量地址的内容可能被立即覆盖，也可能稍后才被覆盖，这就是问题难以被发现的原因。</p><p>然而，无论是编译器还是lint程序都无法检测到局部数组返回的所有情况（它有可能通过某一层间接形式存在躲过检查）。</p><p>解决这个问题有几种方案：</p><p>1.函数可以返回一个常量，或指向常量的指针。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func()&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这是最简单的解决方案，但是如果是其他需要返回变化的内容时，这就无能为力了。</p><p>2.使用全局声明的变量。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char my_global_array[120];</span><br><span class="line">char *fun()&#123;</span><br><span class="line">  ...</span><br><span class="line">  my_global_array[i] = ...;</span><br><span class="line">  ...</span><br><span class="line">  return my_global_array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这适用于自己创建字符串的情况，也很简单易用。它的缺点在于任何人都有可能在任何时候修改这个全局数组，而且该函数的下一次调用也会覆盖该数组的内容。</p><p>3.使用静态数组。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char * func()&#123;</span><br><span class="line">  static char buffer[120];</span><br><span class="line">  ...</span><br><span class="line">  return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就可以防止任何人修改这个数组。只有拥有指向该数组的指针函数（通过参数传递给它）才能修改这个静态数组。但是，该函数的下一次调用将覆盖这个数组的内容，所以调用者必须在此之前使用或备份数组的内容。和全局数组一样，大型缓冲区如果闲置不用是非常浪费内存空间的。</p><p>4.显式分配一些内存，保存返回值。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char * func()&#123;</span><br><span class="line">  char *s = (char *)malloc(120 * sizeof(char));</span><br><span class="line">  ...</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法具有静态数组的优点，而且在每次调用时都创建一个新的缓冲区，所以该函数以后的调用不会覆盖以前的返回值。它适用于多线程的代码（在某一时刻具有超过一个的活动线程的程序）。它的缺点在于程序员必须承担内存管理的责任。根据程序的复杂程度，这项任务可能很容易，也可能很复杂.如果内存仍在使用就释放或者出现“内存泄漏”（不再使用的内存未回收），就会产生bug。人们非常容易忘记释放已分配的内存。</p><p>5.最好的解决方案就是要求调用者分配内存来保存函数的返回值。为了提高安全性，调用者应该同时指定缓冲区的大小。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">void string_copy(char * destination_str,char * source_str,int size)&#123;</span><br><span class="line">    strncpy(destination_str, source_str, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    char source_str[] = &quot;hello world&quot;;</span><br><span class="line">    int str_size = 120;</span><br><span class="line">    char *destination_str = (char *)malloc(str_size * sizeof(char));</span><br><span class="line">    string_copy(destination_str,source_str,str_size);</span><br><span class="line">    printf(&quot;%s\n&quot;,destination_str);</span><br><span class="line">    free(destination_str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以在同一代码块中同时进行”malloc”和”free”操作，内存管理是最为轻松的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C运算符的优先级与结合性</title>
      <link href="/2018/07/27/C%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7/"/>
      <url>/2018/07/27/C%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>C语言运算符优先级与结合性:<br>同一优先级的运算符，运算次序由结合方向所决定。</p><span id="more"></span><table><thead><tr><th>优先级</th><th>运算符</th><th>名称或含义</th><th>使用形式</th><th>结合方向</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><strong>[]</strong></td><td>数组下标</td><td>数组名[常量表达式]</td><td>左到右</td><td>–</td></tr><tr><td></td><td><strong>()</strong></td><td>圆括号</td><td>(表达式）&#x2F;函数名(形参表)</td><td>左到右</td><td>–</td></tr><tr><td></td><td><strong>.</strong></td><td>成员选择（对象）</td><td>对象.成员名</td><td>左到右</td><td>–</td></tr><tr><td></td><td><strong>-&gt;</strong></td><td>成员选择（指针）</td><td>对象指针-&gt;成员名</td><td>左到右</td><td>–</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td><strong>-</strong></td><td>负号运算符</td><td>-表达式</td><td><strong>右到左</strong></td><td>单目运算符</td></tr><tr><td></td><td><strong>~</strong></td><td>按位取反运算符</td><td>~表达式</td><td><strong>右到左</strong></td><td>单目运算符</td></tr><tr><td></td><td><strong>++</strong></td><td>自增运算符</td><td>++变量名&#x2F;变量名++</td><td><strong>右到左</strong></td><td>单目运算符</td></tr><tr><td></td><td><strong>–</strong></td><td>自减运算符</td><td>–变量名&#x2F;变量名–</td><td><strong>右到左</strong></td><td>单目运算符</td></tr><tr><td></td><td><strong>*</strong></td><td>取值运算符</td><td>*指针变量</td><td><strong>右到左</strong></td><td>单目运算符</td></tr><tr><td></td><td><strong>&amp;</strong></td><td>取地址运算符</td><td>&amp;变量名</td><td><strong>右到左</strong></td><td>单目运算符</td></tr><tr><td></td><td><strong>!</strong></td><td>逻辑非运算符</td><td>!表达式</td><td><strong>右到左</strong></td><td>单目运算符</td></tr><tr><td></td><td><strong>(类型)</strong></td><td>强制类型转换</td><td>(数据类型)表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>sizeof</strong></td><td>长度运算符</td><td>sizeof(表达式)</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td><strong>&#x2F;</strong></td><td>除</td><td>表达式&#x2F;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>*</strong></td><td>乘</td><td>表达式*表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>%</strong></td><td>余数（取模）</td><td>整型表达式%整型表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>4</td><td><strong>+</strong></td><td>加</td><td>表达式+表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>-</strong></td><td>减</td><td>表达式-表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>5</td><td><strong>&lt;&lt;</strong></td><td>左移</td><td>变量&lt;&lt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>&gt;&gt;</strong></td><td>右移</td><td>变量&gt;&gt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td><strong>&gt;</strong></td><td>大于</td><td>表达式&gt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>&gt;&#x3D;</strong></td><td>大于等于</td><td>表达式&gt;&#x3D;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>&lt;</strong></td><td>小于</td><td>表达式&lt;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>&lt;&#x3D;</strong></td><td>小于等于</td><td>表达式&lt;&#x3D;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>7</td><td><strong>&#x3D;&#x3D;</strong></td><td>等于</td><td>表达式&#x3D;&#x3D;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td><strong>!&#x3D;</strong></td><td>不等于</td><td>表达式!&#x3D; 表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td><strong>&amp;</strong></td><td>按位与</td><td>表达式&amp;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>9</td><td><strong>^</strong></td><td>按位异或</td><td>表达式^表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>10</td><td><strong>｜</strong></td><td>按位或</td><td>表达式｜表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>11</td><td><strong>&amp;&amp;</strong></td><td>逻辑与</td><td>表达式&amp;&amp;表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>12</td><td><strong>｜｜</strong></td><td>逻辑或</td><td>表达式｜｜表达式</td><td>左到右</td><td>双目运算符</td></tr><tr><td>13</td><td><strong>?:</strong></td><td>条件运算符</td><td>表达式1?表达式2: 表达式3</td><td><strong>右到左</strong></td><td><strong>三目运算符</strong></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>14</td><td><strong>&#x3D;</strong></td><td>赋值运算符</td><td>变量&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>&#x2F;&#x3D;</strong></td><td>除后赋值</td><td>变量&#x2F;&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>*&#x3D;</strong></td><td>乘后赋值</td><td>变量*&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>%&#x3D;</strong></td><td>取模后赋值</td><td>变量%&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>+&#x3D;</strong></td><td>加后赋值</td><td>变量+&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>-&#x3D;</strong></td><td>减后赋值</td><td>变量-&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>&lt;&lt;&#x3D;</strong></td><td>左移后赋值</td><td>变量&lt;&lt;&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>&gt;&gt;&#x3D;</strong></td><td>右移后赋值</td><td>变量&gt;&gt;&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>&amp;&#x3D;</strong></td><td>按位与后赋值</td><td>变量&amp;&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>^&#x3D;</strong></td><td>按位异或后赋值</td><td>变量^&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td><strong>｜&#x3D;</strong></td><td>按位或后赋值</td><td>变量｜&#x3D;表达式</td><td><strong>右到左</strong></td><td>–</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>15</td><td><strong>,</strong></td><td>逗号运算符</td><td>表达式,表达式,…</td><td>左到右</td><td>–</td></tr></tbody></table><p>c语言运算符优先级存在的问题(按照常规方式使用时，可能引起误会的运算符)：</p><table><thead><tr><th>优先级问题</th><th>表达式</th><th>可能误以为的结果</th><th>实际结果</th></tr></thead><tbody><tr><td>.的优先级高于*。-&gt;操作符用于消除这个问题</td><td>*p.f</td><td>p所指向的字段。 (*p).f</td><td>对p取f偏移，作为指针，然后进行引用。 *(p.f)</td></tr><tr><td>[]高于*</td><td>int *ap[]</td><td>ap是一个指向int数组的指针。 int (*ap)[]</td><td>ap是个元素为int指针的数组。 int *(ap[])</td></tr><tr><td>函数()高于*</td><td>int *fp()</td><td>fp是个函数指针，所指函数返回int。int(*fp)()</td><td>fp是个函数，返回int*。int *(fp())</td></tr><tr><td>&#x3D;&#x3D;和!&#x3D;高于位操作符</td><td>(val &amp; mask !&#x3D; 0)</td><td>(val &amp; mask) !&#x3D; 0</td><td>val &amp; (mask !&#x3D;0)</td></tr><tr><td>&#x3D;&#x3D;和!&#x3D;高于赋值符</td><td>c &#x3D; getchar() !&#x3D; EOF</td><td>(c &#x3D; getchar()) !&#x3D; EOF</td><td>c&#x3D;(getchar() !&#x3D; EOF)</td></tr><tr><td>算术运算高于移位运算</td><td>msb &lt;&lt; 4 + lsb</td><td>(msb &lt;&lt; 4) + lsb</td><td>msb &lt;&lt; (4 + lsb)</td></tr><tr><td>逗号运算符在所有运算符中优先级最低</td><td>i &#x3D; 1,2</td><td>i &#x3D; (1,2)</td><td>(i &#x3D; 1),2</td></tr></tbody></table><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = 1,2</span><br></pre></td></tr></table></figure><p>i的最终结果是什么？我们知道逗号运算符的值就是最右边操作数的值，但在这里，赋值符的优先级更高，所以实际情况应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i = 1),2</span><br></pre></td></tr></table></figure><p>i赋值为1，接着执行常量2的运算，计算结果丢弃。最终，i的结果是1而不是2。</p><p>综上，在写代码时，表达式中如果有布尔操作、算术运算、位操作等混合运算，始终应在适当的地方加上括号，使之清楚明了。</p><p>在优先级和结合性规则告诉你哪些符号组成一个意群的同时，这些意群内部如何进行计算的次序始终是未定义的。在下面的表达式里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = f() + g() * h();</span><br></pre></td></tr></table></figure><p>g()和h()的返回值先组成一个意群，执行乘法运算，但g()和h()的调用可能以任何顺序出现，g()的调用不一定早于h()。类似，f()可能在乘法之前也可能在乘法之后调用，也可能在g()和h()之间调用。唯一可以确定的就是乘法会在加法之前执行(因为乘法的结果是加法运算的操作数之一)。如果编写程序时要依赖这些意群计算的先后顺序，那就是不好的编程风格。大部分编程语言并未明确规定操作数计算的顺序。之所以未作定义，是想让编译器充分利用自身架构的特点，或者充分利用存储于寄存器中的值。</p><blockquote><p>结合性是什么?它是仲裁者，在几个操作符具有相同的优先级时决定先执行哪一个。</p></blockquote><p>每一个操作符拥有某一级别的优先级，同时也拥有左结合性或者右结合性。优先级决定一个不含括号的表达式中操作数之间的“紧密程度”。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a * b + c </span><br></pre></td></tr></table></figure><p>因为乘法运算符的优先级高于加法运算符的优先级，所以先执行乘法a * b，而不是加法b + c。<br>但是，许多操作符的优先级是相同的，这时，操作符的结合性就开始发挥作用了。在表达式中如果有几个优先级相同的操作符，结合性就起仲裁作用，由它决定哪个操作符先执行。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a,b =1 ,c =2;</span><br><span class="line">a = b = c;</span><br></pre></td></tr></table></figure><p><strong>所有的赋值符（包括复合赋值符）都具有右结合性。</strong><br>就是说，表达式中最右边的操作最先执行，然后从右到左依次执行。这样，c先赋值给b，然后b再赋值给a，最终a的值就是2。类似的，具有左结合性的操作符（如位操作符 &amp; 和 | ）则是从左至右依次执行。</p><p>结合性只用于表达式中出现两个以上相同优先级的操作符的情况，用于消除歧义。事实上，你会注意到所有优先级相同的操作符，它们的结合性也相同。这是必须如此的，否则结合性依然无法消除歧义。如果在计算表达式的值需要考虑结合性，那么最好把这个表达式一分为二或者使用括号。</p><p>在C语言中，跟顺序有关的问题，有些定义的很好，如优先级和结合性，有些则定义的很含糊，如大部分表达式里各个操作数计算的顺序就是不确定的，它的目的是为了让编译器设计者选区最合适的方法来产生最快的代码。之所以说“大部分”，是因为某些操作符如&amp;&amp;和||等，其操作数的计算是规定顺序的。这两个操作符严格按照从左到右的顺序依次计算两个操作数，当结果提前得知时便忽略剩余的计算。但是，在函数调用中，各个参数的计算顺序是不确定的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言main函数的参数</title>
      <link href="/2018/07/27/C%E8%AF%AD%E8%A8%80main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2018/07/27/C%E8%AF%AD%E8%A8%80main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="main的参数"><a href="#main的参数" class="headerlink" title="main的参数"></a>main的参数</h4><p>Ｃ语言规定main函数的参数只能有两个，习惯上这两个参数写为argc和argv，argc(第一个形参)必须是整型变量,argv( 第二个形参)必须是指向字符串的指针数组。格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char *argv[]) </span><br></pre></td></tr></table></figure><p>由于main函数不能被其它函数调用， 因此不可能在程序内部取得实际值。那么，在何处把实参值赋予main函数的形参呢? </p><p>实际上,main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。在DOS下一条完整的运行命令包含2部分：命令与相应的参数。格式为： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 参数1 参数2 ... </span><br></pre></td></tr></table></figure><p>这种格式也叫命令行，命令行中的命令就是可执行文件的文件名，它后面的参数要用空格分隔，是对命令的进一步补充，即是传递给main()函数的参数。</p><p>其中整型argc表示命令行中字符串的个数，argc的值是在输入命令行时由系统按实际参数的个数自动赋予的。指针数组argv[]指向命令行中的各个字符串。这两个参数可以用任何合法的标识符命名，但是习惯采用argc和argv。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    printf(&quot;argc = %d\n&quot;,argc);</span><br><span class="line">    for(i = 0;i&lt;argc;i++)&#123;</span><br><span class="line">        printf(&quot;argv[%d] = %s\n&quot;,i,argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后在命令行中执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template_arg.exe -a -b -c -d hello.txt</span><br></pre></td></tr></table></figure><p>程序运行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">argc = 6</span><br><span class="line">argv[0] = template_arg.exe</span><br><span class="line">argv[1] = -a</span><br><span class="line">argv[2] = -b</span><br><span class="line">argv[3] = -c</span><br><span class="line">argv[4] = -d</span><br><span class="line">argv[5] = hello.txt</span><br></pre></td></tr></table></figure><p>可见，argc为6，argv[0]为自身运行目录路径和程序名。<br>从argv[1]开始指向命令行中我们添加的参数。<br>这种形式带来的问题就是选项开关和其他参数（如文件名）之间分类不清（都是字符串），实现命令行参数位置的灵活和不出错，意味着在代码中解析命令行参数时要充分考虑可能出现的情况。</p><p>有些C程序员采用了一种约定，带’–’的参数，表示从这个参数开始，后面的参数都不是选项开关，即便它是以连字符开头。一种更好的解决办法是把包袱扔给系统而不是用户，使用参数处理器把参数分成选项开关和非选项开关两种，目前这种简单的argv机制由于使用的太广，因而不可能对它做任何修改。</p><h4 id="main的返回值"><a href="#main的返回值" class="headerlink" title="main的返回值"></a>main的返回值</h4><p>在 C99 标准中，main函数只有以下两种定义方式是正确的： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int main( void ) </span><br><span class="line">int main( int argc, char *argv[]) </span><br></pre></td></tr></table></figure><p>void main()的用法是错误的。<br>main 函数的返回值类型必须是 int，返回值用于说明程序的退出状态。<br>如果返回0，则代表程序正常退出；返回其它数字的含义则由系统决定。<br>通常，返回非零代表程序异常退出。<br>如果 main 函数的最后没有写 return 语句的话，C99 规定编译器要自动在生成的目标文件中（如 exe 文件）加入return 0。<br> 在 C89 中，main( ) 是可以接受的，也就是说 main()等同于int main()，不明确标明返回值的，默认返回值为int。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minGW的gdb调试</title>
      <link href="/2018/07/24/minGW%E7%9A%84gdb%E8%B0%83%E8%AF%95/"/>
      <url>/2018/07/24/minGW%E7%9A%84gdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>MinGW（Minimalist GNU for Windows）提供了一套简单方便的Windows下的基于GCC程序开发环境。MinGW收集了一系列免费的Windows是用的头文件和库文件；同时整合了GNU的工具集，特别是GNU程序开发工具，如经典的gcc，g++，make等。MinGW是完全免费的自由软件，它在Windows平台下模拟了Linux下GCC的开发环境，为C++的跨平台开发提供了良好的基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。</p><span id="more"></span><p>简单的说，它是个精简的C&#x2F;C++编译器，它实际上是将经典的开源C语言&#x2F;C++编译器GCC&#x2F;G++移植到了Windows下，并且包含了Win32API，因此可以将源代码编译生成Windows下的可执行程序。虽然VC6等编译器，只要点击鼠标就可以完成编译，但它会自动生成一大堆工程文件，让初学者摸不着头脑，而MinGW则只会生成一个可执行文件。</p><p>gdb调试测试代码(test.c)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(int *a,int *b)&#123;</span><br><span class="line">    int temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=1,b=2;</span><br><span class="line">    swap(&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;a = %d ,b = %d\n&quot;,a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要支持调试，在编译时要加入-g选项，编译命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g test.c -o test.exe</span><br></pre></td></tr></table></figure><p>gdb调试加载文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb test.exe</span><br></pre></td></tr></table></figure><p>出现gdb命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GNU gdb (GDB) 7.6.1</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;mingw32&quot;.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from D:\mypro\C\test.exe...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>gdb调试命令表：</p><table><thead><tr><th>命令</th><th>解释</th><th>简写</th></tr></thead><tbody><tr><td>file</td><td>加载一个可执行文件，也可以在运行gdb的时候加载，两种方法都不会运行程序</td><td>无</td></tr><tr><td>list</td><td>列出可执行源码的一部分，通常在程序开始运行前执行，用来设置断点</td><td>l</td></tr><tr><td>next</td><td>单步调试，不进入函数</td><td>n</td></tr><tr><td>step</td><td>单步调试，进入函数</td><td>s</td></tr><tr><td>run</td><td>运行加载了的程序</td><td>r</td></tr><tr><td>continue</td><td>继续执行程序</td><td>c</td></tr><tr><td>quit</td><td>退出调试</td><td>q</td></tr><tr><td>print</td><td>输出制定的变量的值，变量要在程序运行处可见</td><td>p</td></tr><tr><td>break</td><td>设置断点</td><td>b</td></tr><tr><td>info break</td><td>查看断点的信息</td><td>i b</td></tr><tr><td>delete</td><td>删除断点</td><td>d</td></tr><tr><td>watch</td><td>监视一个变量的值，一旦值发生变化，程序将会被暂停执行</td><td>wa</td></tr><tr><td>help</td><td>查看gdb的帮助信息</td><td>h</td></tr></tbody></table><h4 id="l命令，列出部分代码："><a href="#l命令，列出部分代码：" class="headerlink" title="l命令，列出部分代码："></a>l命令，列出部分代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">2   </span><br><span class="line">3   void swap(int *a,int *b)&#123;</span><br><span class="line">4       int temp = *a;</span><br><span class="line">5       *a = *b;</span><br><span class="line">6       *b = temp;</span><br><span class="line">7   &#125;</span><br><span class="line">8   </span><br><span class="line">9   int main(void)</span><br><span class="line">10  &#123;</span><br><span class="line">11      int a=1,b=2;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>继续输入l命令可以继续列出后面的代码，直到文件里代码列完</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">12      swap(&amp;a,&amp;b);</span><br><span class="line">13      printf(&quot;a = %d ,b = %d\n&quot;,a,b);</span><br><span class="line">14      return 0;</span><br><span class="line">15  &#125;(gdb) l</span><br><span class="line">(gdb) Line number 16 out of range; test.c has 15 lines.</span><br></pre></td></tr></table></figure><h4 id="start命令，开始运行，会停到main入口处："><a href="#start命令，开始运行，会停到main入口处：" class="headerlink" title="start命令，开始运行，会停到main入口处："></a>start命令，开始运行，会停到main入口处：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x401491: file test.c, line 11.</span><br><span class="line">Starting program: D:\mypro\C/test.exe </span><br><span class="line">[New Thread 8000.0x18c4]</span><br><span class="line">[New Thread 8000.0x2418]</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, main () at test.c:11</span><br><span class="line">11      int a=1,b=2;</span><br></pre></td></tr></table></figure><h4 id="n命令：单步调试，不进入函数，跳到第12行"><a href="#n命令：单步调试，不进入函数，跳到第12行" class="headerlink" title="n命令：单步调试，不进入函数，跳到第12行"></a>n命令：单步调试，不进入函数，跳到第12行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">12      swap(&amp;a,&amp;b);</span><br></pre></td></tr></table></figure><h4 id="s命令：单步调试，进入函数，跳到第4行"><a href="#s命令：单步调试，进入函数，跳到第4行" class="headerlink" title="s命令：单步调试，进入函数，跳到第4行"></a>s命令：单步调试，进入函数，跳到第4行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">swap (a=0x61ff2c, b=0x61ff28) at test.c:4</span><br><span class="line">4       int temp = *a;</span><br></pre></td></tr></table></figure><h4 id="b命令设置断点（b-第n行代码的行数）："><a href="#b命令设置断点（b-第n行代码的行数）：" class="headerlink" title="b命令设置断点（b + 第n行代码的行数）："></a>b命令设置断点（b + 第n行代码的行数）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 2 at 0x401478: file test.c, line 6.</span><br></pre></td></tr></table></figure><h4 id="r命令-运行程序，直到下一个断点就停："><a href="#r命令-运行程序，直到下一个断点就停：" class="headerlink" title="r命令,运行程序，直到下一个断点就停："></a>r命令,运行程序，直到下一个断点就停：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n)</span><br><span class="line">...</span><br><span class="line">Breakpoint 2, swap (a=0x61ff2c, b=0x61ff28) at test.c:6</span><br><span class="line">6       *b = temp;</span><br></pre></td></tr></table></figure><h4 id="p命令-输出制定的变量的值，变量要在程序运行处可见"><a href="#p命令-输出制定的变量的值，变量要在程序运行处可见" class="headerlink" title="p命令,输出制定的变量的值，变量要在程序运行处可见:"></a>p命令,输出制定的变量的值，变量要在程序运行处可见:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *a</span><br><span class="line">$1 = 2</span><br><span class="line">(gdb) p *b</span><br><span class="line">$2 = 2</span><br><span class="line">(gdb) p a</span><br><span class="line">$3 = (int *) 0x61ff2c</span><br><span class="line">(gdb) p b</span><br><span class="line">$4 = (int *) 0x61ff28</span><br></pre></td></tr></table></figure><p>next一下，再看b的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">7   &#125;</span><br><span class="line">(gdb) p *b</span><br><span class="line">$5 = 1</span><br></pre></td></tr></table></figure><h4 id="i-b命令-查看断点信息"><a href="#i-b命令-查看断点信息" class="headerlink" title="i b命令,查看断点信息:"></a>i b命令,查看断点信息:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       breakpoint     keep y   0x00401478 in swap at test.c:6</span><br><span class="line">    breakpoint already hit 1 time</span><br></pre></td></tr></table></figure><h4 id="d命令-删除断点，不加断点位置即删除所有断点"><a href="#d命令-删除断点，不加断点位置即删除所有断点" class="headerlink" title="d命令,删除断点，不加断点位置即删除所有断点:"></a>d命令,删除断点，不加断点位置即删除所有断点:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) d </span><br><span class="line">Delete all breakpoints? (y or n) [answered Y; input not from terminal]</span><br><span class="line">(gdb) i b</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure><h4 id="没有断点后，再试一下r命令，可以看到，执行完了程序："><a href="#没有断点后，再试一下r命令，可以看到，执行完了程序：" class="headerlink" title="没有断点后，再试一下r命令，可以看到，执行完了程序："></a>没有断点后，再试一下r命令，可以看到，执行完了程序：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) [answered Y; input not from terminal]</span><br><span class="line">error return ../../gdb-7.6.1/gdb/windows-nat.c:1275 was 5</span><br><span class="line">Starting program: D:\mypro\C/test.exe </span><br><span class="line">[New Thread 1976.0x1460]</span><br><span class="line">[New Thread 1976.0x5e0]</span><br><span class="line">a = 2 ,b = 1</span><br><span class="line">[Inferior 1 (process 1976) exited normally]</span><br></pre></td></tr></table></figure><h4 id="q命令，退出gdb："><a href="#q命令，退出gdb：" class="headerlink" title="q命令，退出gdb："></a>q命令，退出gdb：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C符号的重载</title>
      <link href="/2018/07/23/C%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2018/07/23/C%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>C语言中有误导性质或是不适当的特性与C语言的简洁有关（部分与符号的过度复用有关），有些则与操作符的优先级有关。</p><span id="more"></span><p>C语言里，许多符号是被“重载”的——在不同的上下文环境里有不同的意义。甚至有些关键字也被重载而具有好几种意义，这也是C语言的范围规则对程序员不那么清晰的主要原因。<br>表展示C语言中类似的符号是如何具有多种不同意义的。</p><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>static</td><td>1.在函数内部，表示该变量的值在各个调用间一直保持延续性。</td></tr><tr><td></td><td>2.在函数这一级，表示该函数只对本文件可见</td></tr><tr><td>extern</td><td>1.用于函数定义，表示全局可见（属于冗余的）</td></tr><tr><td></td><td>2.用于变量，表示它在其他地方定义</td></tr><tr><td>void</td><td>1.作为函数的返回类型，表示不返回任何值</td></tr><tr><td></td><td>2.在指针声明中，表示通用指针的类型</td></tr><tr><td></td><td>3.位于参数列表中，表示没有参数</td></tr><tr><td>*</td><td>1.乘法运算符</td></tr><tr><td></td><td>2.用于指针，间接引用</td></tr><tr><td></td><td>3.在声明中，表示指针</td></tr><tr><td>&amp;</td><td>1.位的AND操作符</td></tr><tr><td></td><td>2.取地址操作符</td></tr><tr><td>&#x3D;</td><td>1.赋值符</td></tr><tr><td>&#x3D;&#x3D;</td><td>1.比较运算符</td></tr><tr><td>&lt;&#x3D;</td><td>1.小于等于运算符</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>1.左移复合赋值运算符</td></tr><tr><td>&lt;</td><td>1.小于运算符</td></tr><tr><td></td><td>2.#include指令的左定界符</td></tr><tr><td>()</td><td>1.在函数中，包围形式参数表</td></tr><tr><td></td><td>2.调用一个函数</td></tr><tr><td></td><td>3.改变表达式的运算次序</td></tr><tr><td></td><td>4.强制类型转换</td></tr><tr><td></td><td>5.定义带参数的宏</td></tr><tr><td></td><td>6.包围sizeof操作符的操作数（如果它是类型名）</td></tr></tbody></table><p>除此之外，还有一些符号具有多个容易混淆的意思。重载存在的问题之处如下面语句所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = N * sizeof * q;</span><br></pre></td></tr></table></figure><p>这里是一个乘号还是两个乘号？<br>答案是这里只有一个乘号，因为sizeof操作符把指针q指向的东西（*q）作为操作数，它返回q所指向对象的类型的字节数，便于malloc函数分配内存。当sizeof的操作数是个类型名时，两边必须加上括号（这常常使人误以为它是个函数），但操作数如果是个变量则不必加括号。<br>一个更复杂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = sizeof(int) * p;</span><br></pre></td></tr></table></figure><p>是int的长度乘以p？或者是把未知类型的指针p强制转换为int，然后进行sizeof操作？<br>实际检验一下：</p><p>代码段1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int *q;</span><br><span class="line">    int p;</span><br><span class="line">    p = sizeof(int) * q;</span><br><span class="line">    printf(&quot;%d\n&quot;,p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = sizeof(int) * q;</span><br><span class="line">error: invalid operands to binary * (have &#x27;unsigned int&#x27; and &#x27;int *&#x27;)</span><br></pre></td></tr></table></figure><p>明显这样并不是把未知类型的指针p强制转换为int，然后进行sizeof操作，而是编译器把星号(*)当作乘号来处理了，但由于左右操作数类型不匹配而报错。</p><p>代码段2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int *q;</span><br><span class="line">    int p = (int) * q;</span><br><span class="line">    p = sizeof p;</span><br><span class="line">    printf(&quot;%d\n&quot;,p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写便为把未知类型的指针p强制转换为int，然后进行sizeof操作。<br>运行输出：<br>4</p><p>代码段3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int *q;</span><br><span class="line">    int p;</span><br><span class="line">    p = sizeof(int) * (int)q;</span><br><span class="line">    printf(&quot;%d\n&quot;,p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对指针p的地址进行强制转换，指针p强制转换为int，然后乘上sizeof(int)。</p><p>代码段4：<br>另外一种对该句代码的合理解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int q = 2;</span><br><span class="line">    int p;</span><br><span class="line">    p = sizeof(int) * q;</span><br><span class="line">    printf(&quot;%d\n&quot;,p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>q为int型变量，p &#x3D; int的长度乘以q,结果输出：<br>8</p><p>让一个符号所表达的意思越多，编译器就越难检测到这个符号在你的使用中所存在的异常情况。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现排列组合</title>
      <link href="/2018/07/23/C%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>/2018/07/23/C%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h4 id="排列的定义："><a href="#排列的定义：" class="headerlink" title="排列的定义："></a>排列的定义：</h4><p>从n个不同元素中，任取m(m≤n,m与n均为自然数,下同）个元素按照一定的顺序排成一列，叫做从n个不同元素中取出m个元素的一个排列；从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，用符号 A(n,m)表示。</p><span id="more"></span><p>C实现全排列代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//全排列</span><br><span class="line">void permutation(int *array,int start,int end)&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int i=0;</span><br><span class="line">    if(start&gt;end)</span><br><span class="line">        return;</span><br><span class="line">    if(start&lt;end)&#123;</span><br><span class="line">        permutation(array, start+1, end);</span><br><span class="line">        for(i=start+1;i&lt;=end;i++)&#123;</span><br><span class="line">            temp=array[start];</span><br><span class="line">            array[start]=array[i];</span><br><span class="line">            array[i]=temp;</span><br><span class="line">            permutation(array, start+1, end);</span><br><span class="line">            temp=array[start];</span><br><span class="line">            array[start]=array[i];</span><br><span class="line">            array[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(i=0;i&lt;=end;i++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;,array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int i[5]=&#123;1,3,4,2,5&#125;;</span><br><span class="line">    permutation(i,0,4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">1 3 4 2 5 </span><br><span class="line">1 3 4 5 2 </span><br><span class="line">1 3 2 4 5 </span><br><span class="line">1 3 2 5 4 </span><br><span class="line">1 3 5 2 4 </span><br><span class="line">1 3 5 4 2 </span><br><span class="line">1 4 3 2 5 </span><br><span class="line">1 4 3 5 2 </span><br><span class="line">1 4 2 3 5 </span><br><span class="line">1 4 2 5 3 </span><br><span class="line">1 4 5 2 3 </span><br><span class="line">1 4 5 3 2 </span><br><span class="line">1 2 4 3 5 </span><br><span class="line">1 2 4 5 3 </span><br><span class="line">1 2 3 4 5 </span><br><span class="line">1 2 3 5 4 </span><br><span class="line">1 2 5 3 4 </span><br><span class="line">1 2 5 4 3 </span><br><span class="line">1 5 4 2 3 </span><br><span class="line">1 5 4 3 2 </span><br><span class="line">1 5 2 4 3 </span><br><span class="line">1 5 2 3 4 </span><br><span class="line">1 5 3 2 4 </span><br><span class="line">1 5 3 4 2 </span><br><span class="line">3 1 4 2 5 </span><br><span class="line">3 1 4 5 2 </span><br><span class="line">3 1 2 4 5 </span><br><span class="line">3 1 2 5 4 </span><br><span class="line">3 1 5 2 4 </span><br><span class="line">3 1 5 4 2 </span><br><span class="line">3 4 1 2 5 </span><br><span class="line">3 4 1 5 2 </span><br><span class="line">3 4 2 1 5 </span><br><span class="line">3 4 2 5 1 </span><br><span class="line">3 4 5 2 1 </span><br><span class="line">3 4 5 1 2 </span><br><span class="line">3 2 4 1 5 </span><br><span class="line">3 2 4 5 1 </span><br><span class="line">3 2 1 4 5 </span><br><span class="line">3 2 1 5 4 </span><br><span class="line">3 2 5 1 4 </span><br><span class="line">3 2 5 4 1 </span><br><span class="line">3 5 4 2 1 </span><br><span class="line">3 5 4 1 2 </span><br><span class="line">3 5 2 4 1 </span><br><span class="line">3 5 2 1 4 </span><br><span class="line">3 5 1 2 4 </span><br><span class="line">3 5 1 4 2 </span><br><span class="line">4 3 1 2 5 </span><br><span class="line">4 3 1 5 2 </span><br><span class="line">4 3 2 1 5 </span><br><span class="line">4 3 2 5 1 </span><br><span class="line">4 3 5 2 1 </span><br><span class="line">4 3 5 1 2 </span><br><span class="line">4 1 3 2 5 </span><br><span class="line">4 1 3 5 2 </span><br><span class="line">4 1 2 3 5 </span><br><span class="line">4 1 2 5 3 </span><br><span class="line">4 1 5 2 3 </span><br><span class="line">4 1 5 3 2 </span><br><span class="line">4 2 1 3 5 </span><br><span class="line">4 2 1 5 3 </span><br><span class="line">4 2 3 1 5 </span><br><span class="line">4 2 3 5 1 </span><br><span class="line">4 2 5 3 1 </span><br><span class="line">4 2 5 1 3 </span><br><span class="line">4 5 1 2 3 </span><br><span class="line">4 5 1 3 2 </span><br><span class="line">4 5 2 1 3 </span><br><span class="line">4 5 2 3 1 </span><br><span class="line">4 5 3 2 1 </span><br><span class="line">4 5 3 1 2 </span><br><span class="line">2 3 4 1 5 </span><br><span class="line">2 3 4 5 1 </span><br><span class="line">2 3 1 4 5 </span><br><span class="line">2 3 1 5 4 </span><br><span class="line">2 3 5 1 4 </span><br><span class="line">2 3 5 4 1 </span><br><span class="line">2 4 3 1 5 </span><br><span class="line">2 4 3 5 1 </span><br><span class="line">2 4 1 3 5 </span><br><span class="line">2 4 1 5 3 </span><br><span class="line">2 4 5 1 3 </span><br><span class="line">2 4 5 3 1 </span><br><span class="line">2 1 4 3 5 </span><br><span class="line">2 1 4 5 3 </span><br><span class="line">2 1 3 4 5 </span><br><span class="line">2 1 3 5 4 </span><br><span class="line">2 1 5 3 4 </span><br><span class="line">2 1 5 4 3 </span><br><span class="line">2 5 4 1 3 </span><br><span class="line">2 5 4 3 1 </span><br><span class="line">2 5 1 4 3 </span><br><span class="line">2 5 1 3 4 </span><br><span class="line">2 5 3 1 4 </span><br><span class="line">2 5 3 4 1 </span><br><span class="line">5 3 4 2 1 </span><br><span class="line">5 3 4 1 2 </span><br><span class="line">5 3 2 4 1 </span><br><span class="line">5 3 2 1 4 </span><br><span class="line">5 3 1 2 4 </span><br><span class="line">5 3 1 4 2 </span><br><span class="line">5 4 3 2 1 </span><br><span class="line">5 4 3 1 2 </span><br><span class="line">5 4 2 3 1 </span><br><span class="line">5 4 2 1 3 </span><br><span class="line">5 4 1 2 3 </span><br><span class="line">5 4 1 3 2 </span><br><span class="line">5 2 4 3 1 </span><br><span class="line">5 2 4 1 3 </span><br><span class="line">5 2 3 4 1 </span><br><span class="line">5 2 3 1 4 </span><br><span class="line">5 2 1 3 4 </span><br><span class="line">5 2 1 4 3 </span><br><span class="line">5 1 4 2 3 </span><br><span class="line">5 1 4 3 2 </span><br><span class="line">5 1 2 4 3 </span><br><span class="line">5 1 2 3 4 </span><br><span class="line">5 1 3 2 4 </span><br><span class="line">5 1 3 4 2</span><br></pre></td></tr></table></figure><h4 id="组合的定义："><a href="#组合的定义：" class="headerlink" title="组合的定义："></a>组合的定义：</h4><p>从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号 C(n,m) 表示。</p><p>C实现组合代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define N 5</span><br><span class="line">//组合,C(num,m)</span><br><span class="line">void combination(int *array,int start,int num,int m)&#123;</span><br><span class="line">    static int queue[N];</span><br><span class="line">    static int top;</span><br><span class="line">    int i;</span><br><span class="line">    if(start&gt;num)</span><br><span class="line">        return;</span><br><span class="line">    if(top==m)&#123;</span><br><span class="line">        for(i=0;i&lt;m;i++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;,queue[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[top++] = array[start];</span><br><span class="line">    combination(array,start+1,num,m);</span><br><span class="line">    top--;</span><br><span class="line">    combination(array,start+1,num,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int i[N]=&#123;1,3,4,2,5&#125;;</span><br><span class="line">    combination(i,0,5,2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 3 </span><br><span class="line">1 4 </span><br><span class="line">1 2 </span><br><span class="line">1 5 </span><br><span class="line">3 4 </span><br><span class="line">3 2 </span><br><span class="line">3 5 </span><br><span class="line">4 2 </span><br><span class="line">4 5 </span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu搭建nfc测试环境（libnfc+mfoc）</title>
      <link href="/2018/07/23/ubuntu%E6%90%AD%E5%BB%BAnfc%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88libnfc-mfoc%EF%BC%89/"/>
      <url>/2018/07/23/ubuntu%E6%90%AD%E5%BB%BAnfc%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%EF%BC%88libnfc-mfoc%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>系统：ubuntu18.04<br>libnfc官网：<a href="http://nfc-tools.org/index.php/Libnfc">libnfc</a><br>libnfc github: <a href="https://github.com/nfc-tools/libnfc">libnfc github</a><br>硬件：pn532、ch341usb转串口模块</p><span id="more"></span><h4 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h4 id="2-安装依赖库"><a href="#2-安装依赖库" class="headerlink" title="2.安装依赖库"></a>2.安装依赖库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libusb-dev libpcsclite-dev libusb-0.1-4 libpcsclite1 libccid pcscd</span><br></pre></td></tr></table></figure><h4 id="3-插上usb转串口模块，检查驱动有没有安装过，终端运行："><a href="#3-插上usb转串口模块，检查驱动有没有安装过，终端运行：" class="headerlink" title="3.插上usb转串口模块，检查驱动有没有安装过，终端运行："></a>3.插上usb转串口模块，检查驱动有没有安装过，终端运行：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep usbserial  </span><br></pre></td></tr></table></figure><p>若有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbserial              45056  1 ch341</span><br></pre></td></tr></table></figure><p>这样的，说明系统支持usb转串口。终端运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep ttyUSB0</span><br></pre></td></tr></table></figure><p>如果出现以下连接成功的信息，则说明系统已识别该设备了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb 3-4.3: ch341-uart converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>驱动已安装好。如果没有，需安装usb转串口驱动。终端运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install minicom</span><br></pre></td></tr></table></figure><p>安装好后，终端运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo minicom -s</span><br></pre></td></tr></table></figure><p>这时会弹出配置界面，使用方向键选择 Serial port setup ，按Enter键，进入设置环境。<br>输入a或者A，选择串口设备，在这里我使用的是USB转串口,将&#x2F;dev&#x2F;tty8修改为&#x2F;dev&#x2F;ttyUSB0。<br>配置完串口设备后，按Enter键。输入E可以配置波特率，pn532按默认配置即可，不用改波特率  115200 8N1 （波特率：115200，数据位：8，奇偶校验位：N 无，停止位：1）。<br>输入F，配置硬件流控，选择NO，再继续配置软件流控，也选择NO。都配置完后，按下Enter键返回上一界面，选择save setup as dfl（即将其保存位默认配置），再选择Exit，关闭minicom。<br>再次输入命令  sudo minicom，使刚才的配置生效，可以看到串口输出信息，串口配置完成。</p><h4 id="4-在etc下新建nfc文件夹，放配置文件（这一步解决后面会遇到的执行nfc-list时出现No-NFC-device-found的问题）"><a href="#4-在etc下新建nfc文件夹，放配置文件（这一步解决后面会遇到的执行nfc-list时出现No-NFC-device-found的问题）" class="headerlink" title="4.在etc下新建nfc文件夹，放配置文件（这一步解决后面会遇到的执行nfc-list时出现No NFC device found的问题）"></a>4.在etc下新建nfc文件夹，放配置文件（这一步解决后面会遇到的执行nfc-list时出现No NFC device found的问题）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/nfc &amp;&amp; sudo mkdir /etc/nfc/devices.d/</span><br><span class="line">sudo vim /etc/nfc/devices.d/pn532_via_uart2usb.conf</span><br></pre></td></tr></table></figure><p>pn532_via_uart2usb.conf文件里添加以下配置语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Typical configuration file for PN532 board (ie. microbuilder.eu / Adafruit) device </span><br><span class="line">name = &quot;Adafruit PN532 board via UART&quot; </span><br><span class="line">connstring = pn532_uart:/dev/ttyUSB0 </span><br><span class="line">allow_intrusive_scan = true </span><br><span class="line">log_level = 3</span><br></pre></td></tr></table></figure><h4 id="5-选择一个libnfc要安装的目录，在该目录下终端运行："><a href="#5-选择一个libnfc要安装的目录，在该目录下终端运行：" class="headerlink" title="5.选择一个libnfc要安装的目录，在该目录下终端运行："></a>5.选择一个libnfc要安装的目录，在该目录下终端运行：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nfc-tools/libnfc.git</span><br></pre></td></tr></table></figure><p>然后libnfc会下载到该目录的libnfc文件夹下。</p><h4 id="6-终端运行："><a href="#6-终端运行：" class="headerlink" title="6.终端运行："></a>6.终端运行：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd libnfc</span><br><span class="line">sudo autoreconf -vis</span><br><span class="line"> ./configure --prefix=/usr --with-drivers=pn532_uart --sysconfdir=/etc</span><br></pre></td></tr></table></figure><p>可能会遇到的错误：<br>1.’doxygen is mandatory.’<br>安装doxygen：<br>选择一个doxygen要安装的目录，在该目录下终端运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/doxygen/doxygen.git</span><br><span class="line">cd doxygen</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>没有cmke的再安装一下cmake：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure><p>make完后，终端运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>以安装doxygen。<br>2.’PKG_CHECK_MODULES ERROR’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure: line 14085: syntax error near unexpected token `libusb,&#x27;</span><br><span class="line">./configure: line 14085: &#x27;PKG_CHECK_MODULES(libusb,libusb,HAVE_LIBUSB=1,HAVE_LIBUSB=0)&#x27; </span><br></pre></td></tr></table></figure><p>论坛上说安装pkg-config,安装了后可以解决。实测安装了后这个问题还在，由于支持的库已经确认安装好了，我的做法是直接vim打开configure文件，找到对应行的位置，注释掉。一共有3处PKG_CHECK_MODULES。（vim 冒号加行数+回车即跳转到该行，加#号注释）。注释完后configure可以执行完毕。最后可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Selected drivers:</span><br><span class="line">acr122_pcsc...... no</span><br><span class="line">acr122_usb....... no</span><br><span class="line">acr122s.......... no</span><br><span class="line">arygon........... no</span><br><span class="line">pn53x_usb........ no</span><br><span class="line">pn532_uart....... yes</span><br><span class="line">pn532_spi....... no</span><br><span class="line">pn532_i2c........ no</span><br></pre></td></tr></table></figure><h4 id="7-在libnfc文件夹下终端运行："><a href="#7-在libnfc文件夹下终端运行：" class="headerlink" title="7.在libnfc文件夹下终端运行："></a>7.在libnfc文件夹下终端运行：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h4 id="8-安装libnfc："><a href="#8-安装libnfc：" class="headerlink" title="8.安装libnfc："></a>8.安装libnfc：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="9-验证安装是否成功："><a href="#9-验证安装是否成功：" class="headerlink" title="9.验证安装是否成功："></a>9.验证安装是否成功：</h4><p>将PN532接上usb转串口模块，usb转串口模块插入PC USB接口，然后进入如下目录：<br>libnfc&#x2F;utils，运行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./nfc-list</span><br></pre></td></tr></table></figure><p>出现以下信息表示安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NFC device: Adafruit PN532 board via UART opened</span><br></pre></td></tr></table></figure><p>下面就可以把卡放在PN532上去使用libnfc了。<br>libnfc常用指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nfc-list：</span><br><span class="line">Lists the first target present of each founded device</span><br><span class="line"></span><br><span class="line">nfc-mfclassic：</span><br><span class="line">Usage: nfc-mfclassic r|w a|b &lt;dump.mfd&gt; [&lt;keys.mfd&gt;]</span><br><span class="line">  r|w           - Perform read from (r) or write to (w) card</span><br><span class="line">  a|b           - Use A or B keys for action</span><br><span class="line">  &lt;dump.mfd&gt;    - MiFare Dump (MFD) used to write (card to MFD) or (MFD to card)</span><br><span class="line">  &lt;keys.mfd&gt;    - MiFare Dump (MFD) that contain the keys (optional)</span><br><span class="line">Or: nfc-mfclassic x &lt;dump.mfd&gt; &lt;payload.bin&gt;</span><br><span class="line">  x             - Extract payload (data blocks) from MFD</span><br><span class="line">  &lt;dump.mfd&gt;    - MiFare Dump (MFD) that contains wanted payload</span><br><span class="line">  &lt;payload.bin&gt; - Binary file where payload will be extracted</span><br></pre></td></tr></table></figure><h4 id="10-安装mfoc"><a href="#10-安装mfoc" class="headerlink" title="10.安装mfoc"></a>10.安装mfoc</h4><p>选择一个mfoc要安装的目录，在该目录下终端运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nfc-tools/mfoc</span><br></pre></td></tr></table></figure><p>克隆好后，打开文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd mfoc/</span><br><span class="line">autoreconf -vis</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>即可安装完成，测试是否安装好：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src/</span><br><span class="line">mfoc -h</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Usage: mfoc [-h] [-k key] [-f file] ... [-P probnum] [-T tolerance] [-O output]</span><br><span class="line"></span><br><span class="line">  h     print this help and exit</span><br><span class="line">  k     try the specified key in addition to the default keys</span><br><span class="line">  f     parses a file of keys to add in addition to the default keys </span><br><span class="line">  P     number of probes per sector, instead of default of 20</span><br><span class="line">  T     nonce tolerance half-range, instead of default of 20</span><br><span class="line">        (i.e., 40 for the total range, in both directions)</span><br><span class="line">  O     file in which the card contents will be written (REQUIRED)</span><br><span class="line">  D     file in which partial card info will be written in case PRNG is not vulnerable</span><br><span class="line"></span><br><span class="line">Example: mfoc -O mycard.mfd</span><br><span class="line">Example: mfoc -k ffffeeeedddd -O mycard.mfd</span><br><span class="line">Example: mfoc -f keys.txt -O mycard.mfd</span><br><span class="line">Example: mfoc -P 50 -T 30 -O mycard.mfd</span><br><span class="line"></span><br><span class="line">This is mfoc version 0.10.7.</span><br><span class="line">For more information, run: &#x27;man mfoc&#x27;.</span><br></pre></td></tr></table></figure><p>安装完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C太多的缺省可见性</title>
      <link href="/2018/07/23/C%E5%A4%AA%E5%A4%9A%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/2018/07/23/C%E5%A4%AA%E5%A4%9A%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>定义C函数时，在缺省情况下函数的名字是全局可见的。可以在函数的名字前加个冗余的extern关键字，也可以不加，效果是一样的。</p><span id="more"></span><p>这个函数对于链接到它所在的目标文件的任何东西都是可见的，如果想限制对这个函数的访问，就必须加个static关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return_type fun() &#123; /*在任何地方均可见*/ &#125;  </span><br><span class="line">extern return_type fun() &#123; /*在任何地方均可见*/ &#125;  </span><br><span class="line">static return_type fun() &#123; /*在这个文件之外不可见*/ &#125;  </span><br></pre></td></tr></table></figure><p>在C中，事实上，很多人都没有在函数名前添加存储类型说明符的习惯，所以大多数函数都是全局可见的。<br>这种太大范围的全局可见性会与C语言的另一个特性互相影响，那就是interposition。interposition就是用户编写和库函数同名的函数并取而代之的行为。许多C程序员完全没有注意过这个特性。<br>范围过宽的问题常见于库中：一个库需要让一个对象在另一个库中可见，唯一的方法是让它变得全局可见。但这样一来，它对于链接到该库的所有对象都是可见的了。这就是”all-or-nothing”——一个符号要么全局可见，要么对其他文件都不可见。在C语言中，对信息可见性的选择就是这么有限。<br>一个大型函数内部的一群调用的内部函数，如果外文件调用不到这些内部函数，在这些函数声明时最好加上static限定符，否则缺省情况下这些内部函数是全局可见的。<br>软件对象在大多数情况下应该缺省的采用有限可见性，当程序员需要让它全局可见时，应该采用显示的手段。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C自动合并相邻字符串常量</title>
      <link href="/2018/07/22/C%E8%87%AA%E5%8A%A8%E5%90%88%E5%B9%B6%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F/"/>
      <url>/2018/07/22/C%E8%87%AA%E5%8A%A8%E5%90%88%E5%B9%B6%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>ANSI C的一个特性是相邻的字符串常量被自动合并成一个字符串，这就省掉了书写多行信息时必须在行末尾加’\‘的做法，后续的字符串可以出现在每行的开头。</p><span id="more"></span><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;hello \</span><br><span class="line">    world \</span><br><span class="line">    \n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;hello &quot;</span><br><span class="line">    &quot;world&quot;</span><br><span class="line">    &quot; \n&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello   world   </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>可见行末加’&#39;的做法，把下一行的缩进也包含到字符串里了，要实现一样的效果，得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;hello \</span><br><span class="line">world \</span><br><span class="line">\n&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;hello &quot;</span><br><span class="line">    &quot;world&quot;</span><br><span class="line">    &quot; \n&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>自动合并是在编译时自动合并，除了最后一个字符串外，其余每个字符串末尾的’\0’字符会被自动删除。<br>然而，这种自动合并在字符串数组初始化时要特别注意。字符串数组在初始化时，如果不小心漏掉了一个逗号，编译器将不会发出错误信息，而是悄无声息的把两个字符串合并在一起。代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    char *word[] = &#123;</span><br><span class="line">        &quot;pen&quot;,</span><br><span class="line">        &quot;class&quot;,</span><br><span class="line">        &quot;note&quot; //这里漏掉逗号</span><br><span class="line">        &quot;book&quot;,</span><br><span class="line">    &#125;;      </span><br><span class="line">    printf(&quot;%s&quot;,word[2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notebook</span><br></pre></td></tr></table></figure><p>这样，word[2]由原来的”note”变为”notebook”。而更可怕的错误是，字符串数组的长度比预期的少了一个，如果在程序中访问或修改word[3]，就是数组越界，访问或修改了其他的内容。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    char *word[] = &#123;</span><br><span class="line">        &quot;pen&quot;,</span><br><span class="line">        &quot;class&quot;,</span><br><span class="line">        &quot;note&quot; //这里漏掉逗号</span><br><span class="line">        &quot;book&quot;,</span><br><span class="line">    &#125;;      </span><br><span class="line">    printf(&quot;%s&quot;,word[3]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?@</span><br></pre></td></tr></table></figure><p>关于数组、枚举、结构体等变量声明时最后一个逗号的问题：<br>在上述代码中，”book”后面有一个逗号。这个逗号不是打字错误，而且最早的C语法中继承下来的东西，是计算机发展早期非常古老的一种写法，这么写的目的是让以后的程序维护人员少输入一个逗号，现代的C语言中一般已经不这么用了。<br>当然，现在加不加效果都一样，都无所谓的，对代码本身来说没有什么意义。</p><blockquote><p>These extra commas are permitted but are not required.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C存在fall through的switch语句</title>
      <link href="/2018/07/22/C%E5%AD%98%E5%9C%A8fall-through%E7%9A%84switch%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/07/22/C%E5%AD%98%E5%9C%A8fall-through%E7%9A%84switch%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>switch语句的一般形式如下：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">    case 常量表达式：零条或多条语句</span><br><span class="line">    case 常量表达式：零条或多条语句</span><br><span class="line">    default: 零条或多条语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个遵循标准的C编译器至少允许一条switch语句中有257个case标签（ANSI C标准），这是为了允许switch满足一个8bit字符的所有情况（256个可能的值加上EOF）。<br>每个case结构由3部分组成：关键字case；紧随其后的常量值或常量表达式；再紧接一个冒号。看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    const int a = 2;</span><br><span class="line">    switch(i)&#123;</span><br><span class="line">        case 1: j=1;</span><br><span class="line">        case a: j=2;</span><br><span class="line">        case 3: j=3;</span><br><span class="line">        default: j=4;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译出错：<br> case a: j&#x3D;2;<br> error: case label does not reduce to an integer constant<br>从这里不仅可以看出const修饰的变量并不代表就是常量，而且case后面必须为常量值或常量表达式。<br>a.当表达式的值与case中的常量匹配时，该case后面的语句就会执行。<br>b.default（如果有的话）可以出现在case列表的任意位置，但习惯上总是把default放在最后，它在其他的case均无法匹配时被选中执行。<br>c.如果没有default，而且所有的case均不匹配，那整条switch语句便什么都不做。</p><blockquote><p>许多人可能觉得如果所有的case均不匹配，应该给出一个运行时错误信息，提示无匹配。在C语言中，几乎从来不进行运行时错误检查，运行时检查与C语言的设计理念相违背。按照C语言的理念，程序员应该知道自己正在干什么，而且保证自己的所作所为是正确的。</p></blockquote><h3 id="switch存在的问题："><a href="#switch存在的问题：" class="headerlink" title="switch存在的问题："></a>switch存在的问题：</h3><h4 id="其一：可以在switch的左花括号之后声明一些变量，但变量不会被初始化。"><a href="#其一：可以在switch的左花括号之后声明一些变量，但变量不会被初始化。" class="headerlink" title="其一：可以在switch的左花括号之后声明一些变量，但变量不会被初始化。"></a>其一：可以在switch的左花括号之后声明一些变量，但变量不会被初始化。</h4><p>例如，可以在switch的左花括号之后声明一些变量，从而进行一些局部存储的分配。在最初的编译器里，这是一个技巧——绝大多数用于处理任何复合语句的代码都可以被复用，可以用于处理switch语句中由花括号包住的那部分代码。所以在这个位置上声明一些变量会被编译器很自然的接受，尽管在switch语句中为这些变量加上初始值是没有什么用处的，因为它绝不会被执行——语句从匹配表达式的case开始执行。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    switch(i)&#123;</span><br><span class="line">        int a = 2;</span><br><span class="line">        case 1: j=1;</span><br><span class="line">        case 2: j=2;</span><br><span class="line">        case 3: j=3;</span><br><span class="line">        default: j=4;</span><br><span class="line">        printf(&quot;%d\n&quot;,a);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,j);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时警告：<br>printf(“%d\n”,a);<br>warning: ‘a’ is used uninitialized in this function [-Wuninitialized]<br>运行结果显示：<br>0<br>4</p><p>在C语言中，当建立一个块时，一般总是这样开始的：<br>{<br>语句<br>}<br>你总是可以在两者之间增加一些声明，如：<br>{<br>声明<br>语句<br>}<br>当分配动态内存代价较高时，你可能会采用这种局部存储的方法，但有可能的话要尽量避免，编译器可以自由的忽略它，它可以通过函数调用来分配所有局部块需要的内存空间。<br>另一种用法是声明一些完全局部于当前块的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int a = 2,b = 1;</span><br><span class="line">    if(a &gt; b)&#123;</span><br><span class="line">        int temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;,a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：<br>a &#x3D; 1, b &#x3D; 2<br>若增加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int a = 2,b = 1;</span><br><span class="line">    if(a &gt; b)&#123;</span><br><span class="line">        int temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;temp = %d\n&quot;,temp);</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;,a,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译出错：<br>printf(“temp &#x3D; %d\n”,temp);<br>error: ‘temp’ undeclared (first use in this function)<br>可见，变量temp完全局部于if语句的代码块。<br>C++在这方面又进了一步，允许语句和声明以任意的顺序出现，甚至允许变量的声明出现在for表达式的内部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i&lt;100; i++)&#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="其二：switch内部任何语句都可以加上标签。"><a href="#其二：switch内部任何语句都可以加上标签。" class="headerlink" title="其二：switch内部任何语句都可以加上标签。"></a>其二：switch内部任何语句都可以加上标签。</h4><p>switch内部任何语句都可以加上标签，并在执行时跳转到那里，这就有可能破坏程序流的结构化。示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int i = 2;</span><br><span class="line">    switch(i)&#123;</span><br><span class="line">        case 5+3: do_again:</span><br><span class="line">        case 2: printf(&quot;loop\n&quot;);goto do_again;</span><br><span class="line">        default: i++;</span><br><span class="line">        case 3: ;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行时，程序循环输出“loop”。<br>同时，平时在其他地方，为了避免破坏程序流的结构化，应当尽量不要使用goto语句。</p><h4 id="其三：对case可能出现的值太过于放纵了。"><a href="#其三：对case可能出现的值太过于放纵了。" class="headerlink" title="其三：对case可能出现的值太过于放纵了。"></a>其三：对case可能出现的值太过于放纵了。</h4><p>所有的case都是可选的，任何形式的语句——包括带标签的语句都是允许的。这就意味着有些错误很难检测出来。代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int i = 2;</span><br><span class="line">    switch(i)&#123;</span><br><span class="line">        case 5+3: ;</span><br><span class="line">        case 2: printf(&quot;loop\n&quot;);</span><br><span class="line">        defau1t: i++;</span><br><span class="line">        case 3: ;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码将default的字母l变为数字1，编译警告：<br>defau1t: i++;<br>warning: label ‘defau1t’ defined but not used [-Wunused-label]<br>此时default由语句变为一个标签，程序仍然能够执行，执行输出结果：<br>loop<br>3</p><h4 id="其四：最大的缺点——fall-through"><a href="#其四：最大的缺点——fall-through" class="headerlink" title="其四：最大的缺点——fall through"></a>其四：最大的缺点——fall through</h4><p>switch不会在每个case标签后面的语句执行完毕后自动终止。一旦执行某个case语句，程序将会依次执行后面所有的case，除非遇到break语句。代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    switch(2)&#123;</span><br><span class="line">        case 1: printf(&quot;case 1\n&quot;);</span><br><span class="line">        case 2: printf(&quot;case 2\n&quot;);</span><br><span class="line">        case 3: printf(&quot;case 3\n&quot;);</span><br><span class="line">        case 4: printf(&quot;case 4\n&quot;);</span><br><span class="line">        default: printf(&quot;default\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case 2</span><br><span class="line">case 3</span><br><span class="line">case 4</span><br><span class="line">default</span><br></pre></td></tr></table></figure><p>这称之为“fall through”，意思是：如果case语句后面不加break，就依次执行下去，以满足某些特殊情况的要求。但实际上，这是一个非常不好的特性，因为几乎所有的case都需要以break结尾。在大多数情况下，你不希望因这个缺省的行为而不得不加上一条额外的break语句来改变它。</p><h4 id="其五：break到底中断了什么。"><a href="#其五：break到底中断了什么。" class="headerlink" title="其五：break到底中断了什么。"></a>其五：break到底中断了什么。</h4><p>先看一段有bug的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int i = 2,a = 0,b = 1;</span><br><span class="line">    switch(i)&#123;</span><br><span class="line">        case 1: </span><br><span class="line">            printf(&quot;case 1\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case 2: </span><br><span class="line">            if(a == 0)&#123;</span><br><span class="line">                printf(&quot;step 1\n&quot;);</span><br><span class="line">                if(b ==1)</span><br><span class="line">                    break;</span><br><span class="line">                printf(&quot;step 2\n&quot;);</span><br><span class="line">            &#125;//代码意图是跳到这里</span><br><span class="line">            printf(&quot;step 3\n&quot;);</span><br><span class="line">            b++;</span><br><span class="line">            break;</span><br><span class="line">        default: printf(&quot;default\n&quot;);</span><br><span class="line">    &#125;//事实是跳到这里</span><br><span class="line">    printf(&quot;b = %d\n&quot;,b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：<br>step 1<br>b &#x3D; 1<br>所以，从上面可以体会到，break语句跳出的是最近的那层循环语句或switch语句。if中的break语句使得代码直接跳出switch语句。在C语言中，不要低估”break“语句对控制结构的影响，慎重使用。<br>故综上，switch语句的一般形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">    case 常量表达式：</span><br><span class="line">             零条或多条语句；</span><br><span class="line">              break；</span><br><span class="line">    case 常量表达式：</span><br><span class="line">              零条或多条语句；</span><br><span class="line">              break；</span><br><span class="line">    default: </span><br><span class="line">              零条或多条语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C的特性</title>
      <link href="/2018/07/20/C%E7%9A%84%E7%89%B9%E6%80%A7/"/>
      <url>/2018/07/20/C%E7%9A%84%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>1.C语言采用编译模式而不是解释模式，引入类型系统，每个变量在使用前必须先声明。</p><span id="more"></span><p>2.C语言排斥强类型，它允许程序员需要时可以在不同类型的对象间赋值。</p><p>3.C语言的基本数据类型直接与底层硬件对应。</p><p>4.表达式中的数组名可以看作是指针，但是数组和指针不是在任何情况下都是等效的。</p><p>5.register关键字：这个关键字能给编译器提供线索，就是程序中的哪些变量属于热门（经常被使用），这样就可以把它们存放到寄存器中。使用register关键字简化了编译器，却把包袱丢给了程序员。让编译器在使用各个变量时自动处理寄存器的分配工作显然比一经声明就把这类变量在生命期内始终保留在寄存器里要好。</p><p>6.C预处理所实现的功能：<br>  字符串替换：（宏定义的常量）<br>  头文件包含<br>  通用代码模板的扩展：（宏定义的语句）</p><p>7.宏最好只用于命名常量，并为一些适当的结构提供简洁的记法。宏名应该大写，这样很容易与函数调用区分开来。</p><p>8.参数与原型不匹配：<br>编译如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(const char **p) &#123; &#125;</span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">    foo(argv);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现：<br>warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]<br>note: expected ‘const char **‘ but argument is of type ‘char **‘<br>因为const char **与char **并不相容，在ANSI C标准第6.3.2.2节中讲述约束条件的小节中有这么一句话：</p><blockquote><p>每个实参都应该具有自己的类型，这样它的值就可以赋值给与它所对应的形参类型的对象（该对象的类型不能含有限定符）</p></blockquote><p>这就是说参数传递过程类似于赋值。要使上述的赋值形式合法，必须满足下列条件之一：<br>a.两个操作数都是指向有限定符或无限定符的相容类型的指针。<br>b.左边指针所指向的类型必须具有右边指针所指向类型的全部限定符。<br>正是因为条件b,使得下面的代码是合法的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *cp;</span><br><span class="line">const char *ccp;</span><br><span class="line">ccp = cp;</span><br></pre></td></tr></table></figure><p>分析：<br>a.左操作数是一个指向有const限定符的char指针。<br>b.右操作数是一个指向没有限定符的char指针。<br>c.char类型与char类型是相容的，左操作数所指向的类型具有右操作数所指向类型的限定符（无），再加上自身的限定符（const）。<br>d.反过来赋值，编译器会警告：<br>warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]</p><p>8.const float *类型并不是一个有限定符的类型——它的类型是“指向一个具有const限定符的float类型的指针”，也就是说const限定符是修饰指针所指向的类型，而不是指针本身。</p><p>9.关键字const并不能把变量变成常量。在一个符号前加上const限定符只是表示这个符号不能被赋值。也就是说它的值对于这个符号来说是只读的（但它并不能防止通过程序的内部或者外部的方法来修改这个值）。const最有用之处就是用它来限定函数的形参，这样该函数将不会修改实参指针所指向的数据，但其他的函数却可能会修改它。<br>const可以用在数据上，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int limit = 10;</span><br><span class="line">const int * limitp = &amp;limit ;</span><br><span class="line">int i = 27;</span><br><span class="line">limitp = &amp;i;</span><br></pre></td></tr></table></figure><p>这段代码表示limitp是一个指向常量整型的指针。这个指针不能用于修改这个整型数，但是在任何时候，这个指针本身的值却可改变。这样，它就指向了不同的地址。const和*的组合通常只用于在数组形式的参数中模拟传值调用。它声称“我给你一个指向它的指针，但你不能修改它。”<br>这个约定类似于void *的用法，尽管在理论上void *可以用于任何情形，但通常被限制于把指针从一种类型转换为另一种类型。<br>改变const变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int limit = 10;</span><br><span class="line">int *limitp = &amp;limit ;</span><br><span class="line">*limitp = 20;</span><br><span class="line">printf(&quot;%d&quot;,limit);</span><br></pre></td></tr></table></figure><p>编译时警告：<br>int *limitp &#x3D; &amp;limit ;<br>warning: initialization discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]<br>输出结果为：<br>20<br>而这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int limit = 10;</span><br><span class="line">const int *limitp = &amp;limit ;</span><br><span class="line">*limitp = 20;</span><br><span class="line">printf(&quot;%d&quot;,limit);</span><br></pre></td></tr></table></figure><p>编译出错：<br>*limitp &#x3D; 20;<br>error: assignment of read-only location ‘*limitp’</p><p>10.算术转换：</p><h4 id="整型升级："><a href="#整型升级：" class="headerlink" title="整型升级："></a>整型升级：</h4><p>char，short int或者int型位段，包括它们的有符号或无符号类型，以及枚举类型，可以使用在需要int或unsigned int的表达式中。如果int可以完整表示源类型的所有值，那么该源类型的值就转换为int，否则转换为unsigned int。</p><h4 id="寻常算术转换："><a href="#寻常算术转换：" class="headerlink" title="寻常算术转换："></a>寻常算术转换：</h4><p>许多操作数类型为算术类型的双目运算符会引发转换，并以类似的方式产生结果类型。它的目的是产生一个普通类型，同时也是运算符结果的类型。<br>首先，如果其中一个操作数的类型是long double，那么另一个操作数也被转换为long double。<br>其次，如果其中一个操作数的类型是double，那么另一个操作数也被转换为double。<br>再次，其中一个操作数的类型是float，那么另一个操作数也被转换为float。<br>否则，两个操作数进行整型升级，执行下面的规则：<br>如果其中一个操作数的类型是unsigned long int，那么另一个操作数也被转换为unsigned long int。<br>其次，如果其中一个操作数的类型是long int，而另一个操作数的类型是unsigned int，如果long int能够完整表示unsigned int的值，那么unsigned int类型操作数被转换为long int，如果long int不能完整表示unsigned int的值，那么两个操作数都被转换为unsigned long int。<br>再次，如果其中一个操作数的类型是long int，那么另一个操作数也被转换为long int。<br>再再次，如果其中一个操作数的类型是unsigned int，那么另一个操作数也被转换为unsigned int。<br>如果以上情况都不属于，那么两个操作数都为int。<br>浮点操作数和浮点表达式的值可以用比类型本身所要求的更大的精度和更广的范围来表示，而它的类型并不因此改变。</p><h4 id="大致意思是："><a href="#大致意思是：" class="headerlink" title="大致意思是："></a>大致意思是：</h4><blockquote><p>当执行算术运算时，操作数的类型如果不同，就会发生转换。数据类型一般朝着浮点精度更高，长度更长的方向转换，整型数如果转换为signed不会丢失信息，就转换为signed，否则转换为unsigned。</p></blockquote><h4 id="一个微妙的bug："><a href="#一个微妙的bug：" class="headerlink" title="一个微妙的bug："></a>一个微妙的bug：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int array[] = &#123;23,34,12,17,204,99,16&#125;;</span><br><span class="line">#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int d=-1,x=0;</span><br><span class="line">    if(d &lt;= TOTAL_ELEMENTS -2)</span><br><span class="line">        x = array[d+1];</span><br><span class="line">    printf(&quot;%d&quot;,x);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译输出警告：<br>if(d &lt;&#x3D; TOTAL_ELEMENTS -2)<br>warning: comparison between signed and unsigned integer expressions [-Wsign-compare]<br>执行结果输出：<br>0<br>原因：<br>TOTAL_ELEMENTS所定义的值是unsigned int类型（因为sizeof()的返回类型是无符号数）。<br>if语句在signed int和unsigned int之间测试相等性，所以d被升级为unsigned int类型，-1转换成unsigned int的结果是一个非常大的正整数，导致表达式的值为假。<br>要修正这个问题，只要对TOTAL_ELEMENTS进行强制类型转换即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(d &lt;= (int)TOTAL_ELEMENTS -2)</span><br></pre></td></tr></table></figure><p>此外，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TOTAL_ELEMENTS (sizeof(array)/sizeof(array[0]))</span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TOTAL_ELEMENTS (sizeof(array)/sizeof(int))</span><br></pre></td></tr></table></figure><p>的好处在于前者可以在不修改#define语句的情况下改变数组的基本类型（比如，把int变成char）。</p><p>11.对无符号类型的建议：<br>a.尽量不要在代码中使用无符号类型，以免增加不必要的复杂性。尤其是，不要仅仅因为无符号数不存在负值而用它来表示数量。<br>b.尽量使用像int那样的有符号类型，这样在涉及升级混合类型的复杂细节时，不必担心边界情况（如-1被升级为非常大的正数）。<br>c.只有在使用位段和二进制掩码时，才可以用无符号数。应该在表达式中使用强制类型转换，使操作数均为有符号数或者无符号数，这样就不必由编译器来选择结果的类型。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——expert c programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现冒泡排序</title>
      <link href="/2018/07/20/C%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/20/C%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序：每次都是比较相邻的两个数，如果后面的数比前面的数大，则交换这两个数的位置。一直比较下去直到最后两个数比较完毕后，最小的数就在最后一个了。就如同是一个气泡，一步一步往后“翻滚”，直到最后一位。</p><span id="more"></span><p>例如将12 35 99 18 76  这5个数进行从大到小的排序，（每将一个数归位我们将其称为一趟）<br>第一趟：35 99 18 76 12<br>第二趟：99 35 76 18 12<br>第三趟：99 76 35 18 12<br>第四趟：99 76 35 18 12</p><p>“冒泡排序”的原理是：每一趟只能确定将一个数归位。即第一趟只能确定将末位上的数（即第5位）归位，第二趟只能将倒数第2位上的数（即第4位）归位，第三趟只能将倒数第3位上的数（即第3位）归位，而现在前面还有两个位置上的数没有归位，因此我们仍然需要进行第4趟。</p><p>第4趟只需要比较第1位和第2位的大小。因为后面三个位置上的数归位了，现在第1位是99，第2位是76，无需交换。这5个数的顺序不变仍然是99 76 35 18 12。到此排序结束。</p><p>最后总结一下：如果有n个数进行排序，只需将n-1个数归位，也就是说要进行n-<br>1趟操作。而每一趟都需要从第1位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一个尚未归位的数，已经归位的数则无需再进行比较。<br>C实现的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来,复杂度O(N^2)</span><br><span class="line">void bubble_sort(int *array,int start,int end)&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    for(i=start;i&lt;=end-1;i++)&#123;</span><br><span class="line">        for(j=start;j&lt;=end-i;j++)&#123;</span><br><span class="line">            if(array[j]&lt;array[j+1])&#123;</span><br><span class="line">                temp=array[j];</span><br><span class="line">                array[j]=array[j+1];</span><br><span class="line">                array[j+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int j=0;</span><br><span class="line">    int i[5]=&#123;1,3,4,2,5&#125;;</span><br><span class="line">    bubble_sort(i,0,4);</span><br><span class="line">    for(j=0;j&lt;5;j++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,i[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现快速排序</title>
      <link href="/2018/07/20/C%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/20/C%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。<br>当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。</p><span id="more"></span><p>假设我们对6 1 2 7 9 3 4 5 10 8 这10个数进行排序。首先在这个序列中随便找一个数作为基准数。为了方便，就让第一个数6作为基准数。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边。</p><p>方法是：分别从初始序列6 1 2 7 9 3 4 5 10 8两端开始检测。<strong>先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换它们</strong>（必须先从右边开始找）。<br>初始序列：         6 1 2 7 9 3 4 5 10 8<br>第一次交换后的序列：6 1 2 5 9 3 4 7 10 8<br>第二次交换后的序列：6 1 2 5 4 3 9 7 10 8<br>将3与基准数6交换:  3 1 2 5 4 6 9 7 10 8(第一趟)<br>现在基准数6已经归位，此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是3 1 2 5 4，右边的序列是9 7 10 8。接下来按刚才的步骤分别处理这两个序列，依此递归。</p><p>C实现的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//快速排序基于二分思想,平均时间复杂度O(NlogN)</span><br><span class="line"></span><br><span class="line">//数值排序</span><br><span class="line">void quick_sort_int(int *array,int start,int end)&#123;</span><br><span class="line">    int i,j,t,temp;</span><br><span class="line">    if(start&gt;end)</span><br><span class="line">        return;</span><br><span class="line">    temp=array[start];</span><br><span class="line">    i=start;</span><br><span class="line">    j=end;</span><br><span class="line">    while(i!=j)&#123;</span><br><span class="line">        while(array[j]&gt;=temp &amp;&amp; i&lt;j)&#123;//先从右往左找</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(array[i]&lt;=temp &amp;&amp; i&lt;j)&#123;//再从左往右找</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)&#123;</span><br><span class="line">            t=array[i];</span><br><span class="line">            array[i]=array[j];</span><br><span class="line">            array[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[start]=array[i];</span><br><span class="line">    array[i]=temp;</span><br><span class="line">    quick_sort_int(array,start,i-1);//继续处理左边的</span><br><span class="line">    quick_sort_int(array,i+1,end);//继续处理右边的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//字符串内排序</span><br><span class="line">void quick_sort_char(char *array,int start,int end)&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    char t,temp;</span><br><span class="line">    if(start&gt;end)</span><br><span class="line">        return;</span><br><span class="line">    temp=array[start];</span><br><span class="line">    i=start;</span><br><span class="line">    j=end;</span><br><span class="line">    while(i!=j)&#123;</span><br><span class="line">        while(array[j]&gt;=temp &amp;&amp; i&lt;j)&#123;//先从右往左找</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(array[i]&lt;=temp &amp;&amp; i&lt;j)&#123;//再从左往右找</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)&#123;</span><br><span class="line">            t=array[i];</span><br><span class="line">            array[i]=array[j];</span><br><span class="line">            array[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[start]=array[i];</span><br><span class="line">    array[i]=temp;</span><br><span class="line">    quick_sort_char(array,start,i-1);//继续处理左边的</span><br><span class="line">    quick_sort_char(array,i+1,end);//继续处理右边的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//字符串间排序,首字母,默认长度为10</span><br><span class="line">#define STRING_LEN 10</span><br><span class="line">void quick_sort_string(char (*array)[STRING_LEN],int start,int end)&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    char t[STRING_LEN],temp[STRING_LEN];</span><br><span class="line">    if(start&gt;end)</span><br><span class="line">        return;</span><br><span class="line">    strncpy(temp,array[start],STRING_LEN);</span><br><span class="line">    i=start;</span><br><span class="line">    j=end;</span><br><span class="line">    while(i!=j)&#123;</span><br><span class="line">        while(array[j][0]&gt;=temp[0] &amp;&amp; i&lt;j)&#123;//先从右往左找</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        while(array[i][0]&lt;=temp[0] &amp;&amp; i&lt;j)&#123;//再从左往右找</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;j)&#123;</span><br><span class="line">            strncpy(t,array[i],STRING_LEN);</span><br><span class="line">            strncpy(array[i],array[j],STRING_LEN);</span><br><span class="line">            strncpy(array[j],t,STRING_LEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    strncpy(array[start],array[i],STRING_LEN);</span><br><span class="line">    strncpy(array[i],temp,STRING_LEN);</span><br><span class="line">    quick_sort_string(array,start,i-1);//继续处理左边的</span><br><span class="line">    quick_sort_string(array,i+1,end);//继续处理右边的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">    int j=0;</span><br><span class="line">    int i[5]=&#123;1,3,4,2,5&#125;;</span><br><span class="line">    char array1[20] = &quot;mrbluyee&quot;;</span><br><span class="line">    char array2[20][STRING_LEN] = &#123;&quot;7&quot;,&quot;13&quot;,&quot;4&quot;,&quot;246&quot;,&quot;35&quot;&#125;;</span><br><span class="line">    </span><br><span class="line">    quick_sort_int(i,0,4);</span><br><span class="line">    for(j=0;j&lt;5;j++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,i[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    quick_sort_char(array1,0,strlen(array1)-1);</span><br><span class="line">    printf(&quot;%s&quot;,array1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    quick_sort_string(array2,0,4);</span><br><span class="line">    for(j=0;j&lt;5;j++)&#123;</span><br><span class="line">        printf(&quot;%s&quot;,array2[j]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line">beelmruy</span><br><span class="line">13</span><br><span class="line">246</span><br><span class="line">35</span><br><span class="line">4</span><br><span class="line">7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C实现线性表</title>
      <link href="/2018/07/20/C%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2018/07/20/C%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>线性表（Linear List）是最常用且最简单的一种数据结构。<br><a href="https://github.com/MrBluyee/DataStructure_C">github源码</a><br>抽象数据类型的定义如下：</p><span id="more"></span><p>ADT List {<br>数据对象：D＝{ | ∈ ElemSet, i&#x3D;1,2,…,n, n≥0 }<br>数据关系：R1＝{ &lt;ai-1 ,ai &gt;| ,∈D, i&#x3D;2,…,n }<br>基本操作：<br>InitList( &amp;L )<br>操作结果：构造一个空的线性表 L 。<br>DestroyList( &amp;L )<br>初始条件：线性表 L 已存在。<br>操作结果：销毁线性表 L 。<br>ListEmpty( L )<br>初始条件：线性表L已存在。<br>操作结果：若 L 为空表，则返回 TRUE，否则返回 FALSE。<br>ListLength( L )<br>初始条件：线性表 L 已存在。<br>操作结果：返回 L 中元素个数。<br>PriorElem( L, cur_e, &amp;pre_e )<br>初始条件：线性表 L 已存在。<br>操作结果：若 cur_e 是 L 中的数据元素，则用 pre_e 返回它的前驱，<br>　　　　　否则操作失败，pre_e 无定义。<br>NextElem( L, cur_e, &amp;next_e )<br>初始条件：线性表 L 已存在。<br>操作结果：若 cur_e 是 L 中的数据元素，则用 next_e 返回它的后继，<br>　　　　　否则操作失败，next_e 无定义。<br>GetElem( L, i, &amp;e )<br>初始条件：线性表 L 已存在，1≤i≤LengthList(L)。<br>操作结果：用 e 返回 L 中第 i 个元素的值。<br>LocateElem( L, e, compare( ) )<br>初始条件：线性表 L 已存在，compare( ) 是元素判定函数。<br>操作结果：返回 L 中第1个与 e 满足关系 compare( ) 的元素的位序。<br>　　　　　　　　若这样的元素不存在，则返回值为0。<br>ListTraverse(L, visit( ))<br>初始条件：线性表 L 已存在，visit( ) 为元素的访问函数。<br>操作结果：依次对 L 的每个元素调用函数 visit( )。<br>　　　　　　　一旦 visit( ) 失败，则操作失败。<br>ClearList( &amp;L )<br>初始条件：线性表 L 已存在。<br>操作结果：将 L 重置为空表。<br>PutElem( &amp;L, i, &amp;e )<br>初始条件：线性表L已存在，1≤i≤LengthList(L)。<br>操作结果：L 中第 i 个元素赋值同 e 的值。<br>ListInsert( &amp;L, i, e )<br>初始条件：线性表 L 已存在，1≤i≤LengthList(L)+1。<br>操作结果：在 L 的第 i 个元素之前插入新的元素 e，L 的长度增1。<br>ListDelete( &amp;L, i, &amp;e )<br>初始条件：线性表 L 已存在且非空，1≤i≤LengthList(L)。<br>操作结果：删除 L 的第 i 个元素，并用 e 返回其值，L 的长度减1。<br>} ADT List<br>对上述定义的抽象数据类型线性表，还可以进行一些更复杂的操作，例如取两个线性表的并集、交集和差集。<br>C实现的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">//线性表</span><br><span class="line"></span><br><span class="line">#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量</span><br><span class="line">#define LISTINCREMENT 10   //线性表存储空间的分配增量(当存储空间不够时要用到)</span><br><span class="line"></span><br><span class="line">typedef int ElemType;      //数据元素的类型，假设是int型的</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *elem;  //存储空间的基地址</span><br><span class="line">    int length;      //当前线性表的长度</span><br><span class="line">    int listsize;    //当前分配的存储容量</span><br><span class="line">&#125;LinearList;</span><br><span class="line"></span><br><span class="line">int init_list(LinearList* list)&#123;</span><br><span class="line">    list-&gt;elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">    if (!list-&gt;elem)&#123;</span><br><span class="line">        return -1; //空间分配失败</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;length = 0; //当前长度</span><br><span class="line">    list-&gt;listsize = LIST_INIT_SIZE; //当前分配量</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_list(LinearList* list)&#123;</span><br><span class="line">    list-&gt;length = 0; //当前长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void destroy_list(LinearList* list)&#123;</span><br><span class="line">    free(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int list_empty(LinearList* list)&#123;</span><br><span class="line">    return (list-&gt;length == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int list_length(LinearList* list)&#123;</span><br><span class="line">    return list-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_list(LinearList* list)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i &lt; list-&gt;length; i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, list-&gt;elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int locate_elem(LinearList* list, ElemType* x)&#123;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    for (int i = 0; i &lt; list-&gt;length; i++)&#123;</span><br><span class="line">        if (list-&gt;elem[i] == *x)&#123;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int prior_elem(LinearList* list, ElemType* cur_elem, ElemType* pre_elem)&#123;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    pos = locate_elem(list, cur_elem);</span><br><span class="line">    if(pos &lt;= 0) return -1;</span><br><span class="line">    *pre_elem = list-&gt;elem[pos-1];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_elem(LinearList* list, int index, ElemType* e)&#123;</span><br><span class="line">    if (index&lt;0 || index &gt;= list-&gt;length) return -1;</span><br><span class="line">    *e = list-&gt;elem[index];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int next_elem(LinearList* list, ElemType* cur_elem, ElemType* next_elem)&#123;</span><br><span class="line">    int pos = -1;</span><br><span class="line">    pos = locate_elem(list, cur_elem);</span><br><span class="line">    if(pos == -1 || pos == (list-&gt;length - 1)) return -1;</span><br><span class="line">    *next_elem = list-&gt;elem[pos+1];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int insert_elem(LinearList* list, int index, ElemType* e)&#123;</span><br><span class="line">    if (index&lt;0 || index &gt;= list-&gt;length) return -1;</span><br><span class="line">    if (list-&gt;length &gt;= list-&gt;listsize)&#123; //判断存储空间是否够用</span><br><span class="line">        ElemType *newbase = (ElemType *)realloc(list-&gt;elem, (list-&gt;listsize + LISTINCREMENT)*sizeof(ElemType));</span><br><span class="line">        if (!newbase) return -1;//存储空间分配失败</span><br><span class="line">        list-&gt;elem = newbase;//新基址</span><br><span class="line">        list-&gt;listsize += LISTINCREMENT;//增加存储容量</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType *q, *p;</span><br><span class="line">    q = &amp;(list-&gt;elem[index]); //q为插入位置</span><br><span class="line">    for (p = &amp;(list-&gt;elem[list-&gt;length - 1]); p &gt;= q; --p)&#123; //从ai到an-1依次后移，注意后移操作要从后往前进行</span><br><span class="line">        *(p + 1) = *p;</span><br><span class="line">    &#125;</span><br><span class="line">    *q = *e;</span><br><span class="line">    ++list-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete_elem(LinearList* list, int index, ElemType* e)</span><br><span class="line">&#123;</span><br><span class="line">    if (index&lt;1 || index &gt; list-&gt;length) return -1;</span><br><span class="line">    ElemType *q, *p;</span><br><span class="line">    p = &amp;(list-&gt;elem[index]);//p为被删除元素的位置</span><br><span class="line">    *e = *p; //被删除的元素赋值给e</span><br><span class="line">    q = list-&gt;elem + list-&gt;length - 1;//q指向表尾最后一个元素</span><br><span class="line">    for (++p; p &lt;= q; ++p)&#123; //从p的下一个元素开始依次前移</span><br><span class="line">        *(p - 1) = *p;</span><br><span class="line">    &#125;</span><br><span class="line">    --list-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int append_elem(LinearList* list,ElemType* e)&#123;</span><br><span class="line">    if (list-&gt;length &gt;= list-&gt;listsize)&#123; //判断存储空间是否够用</span><br><span class="line">        ElemType *newbase = (ElemType *)realloc(list-&gt;elem, (list-&gt;listsize + LISTINCREMENT)*sizeof(ElemType));</span><br><span class="line">        if (!newbase) return -1;//存储空间分配失败</span><br><span class="line">        list-&gt;elem = newbase;//新基址</span><br><span class="line">        list-&gt;listsize += LISTINCREMENT;//增加存储容量</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;elem[list-&gt;length] = *e;</span><br><span class="line">    ++list-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int pop_elem(LinearList* list, ElemType* e)&#123;</span><br><span class="line">    if (list_empty(list)) return -1;</span><br><span class="line">    *e = list-&gt;elem[list-&gt;length - 1];</span><br><span class="line">    --list-&gt;length;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void union_list(LinearList* list_a, LinearList* list_b, LinearList* list_c)&#123; //并集,C=A∪B</span><br><span class="line">    int i,a_length,b_length;</span><br><span class="line">    ElemType elem;</span><br><span class="line">    a_length = list_length(list_a);</span><br><span class="line">    b_length = list_length(list_b);</span><br><span class="line">    for(i=0;i&lt;a_length;i++)&#123;</span><br><span class="line">        get_elem(list_a, i, &amp;elem);</span><br><span class="line">        append_elem(list_c,&amp;elem);</span><br><span class="line">    &#125;   </span><br><span class="line">    for(i=0;i&lt;b_length;i++)&#123;</span><br><span class="line">        get_elem(list_b, i, &amp;elem);</span><br><span class="line">        if(locate_elem(list_a, &amp;elem) == -1)&#123;</span><br><span class="line">            append_elem(list_c,&amp;elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void intersect_list(LinearList* list_a, LinearList* list_b, LinearList* list_c)&#123; //交集,C=A∩B</span><br><span class="line">    int i,a_length;</span><br><span class="line">    ElemType elem;</span><br><span class="line">    a_length = list_length(list_a);</span><br><span class="line">    for(i=0;i&lt;a_length;i++)&#123;</span><br><span class="line">        get_elem(list_a, i, &amp;elem);</span><br><span class="line">        if(locate_elem(list_b, &amp;elem) != -1)&#123;</span><br><span class="line">            append_elem(list_c,&amp;elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void except_list(LinearList* list_a,LinearList* list_b, LinearList* list_c)&#123; //差集,C=A-B(属于A而不属于B)</span><br><span class="line">    int i,a_length;</span><br><span class="line">    ElemType elem;</span><br><span class="line">    a_length = list_length(list_a);</span><br><span class="line">    for(i=0;i&lt;a_length;i++)&#123;</span><br><span class="line">        get_elem(list_a, i, &amp;elem);</span><br><span class="line">        if(locate_elem(list_b, &amp;elem) == -1)&#123;</span><br><span class="line">            append_elem(list_c,&amp;elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType elem;</span><br><span class="line">    LinearList *list_a = (LinearList *)malloc(sizeof(LinearList));</span><br><span class="line">    LinearList *list_b = (LinearList *)malloc(sizeof(LinearList));</span><br><span class="line">    LinearList *list_c = (LinearList *)malloc(sizeof(LinearList));</span><br><span class="line">    init_list(list_a);</span><br><span class="line">    init_list(list_b);</span><br><span class="line">    init_list(list_c);</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        append_elem(list_a,&amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 20; i+=2)&#123;</span><br><span class="line">        append_elem(list_b,&amp;i);</span><br><span class="line">    &#125;   </span><br><span class="line">    print_list(list_a);</span><br><span class="line">    print_list(list_b);</span><br><span class="line">    </span><br><span class="line">    pop_elem(list_a, &amp;elem);</span><br><span class="line">    print_list(list_a);</span><br><span class="line">    printf(&quot;pop: %d \n&quot;,elem);</span><br><span class="line">    </span><br><span class="line">    delete_elem(list_a, 2, &amp;elem);</span><br><span class="line">    print_list(list_a);</span><br><span class="line">    printf(&quot;delete: %d \n&quot;,elem);</span><br><span class="line">    </span><br><span class="line">    insert_elem(list_a, 2, &amp;elem);</span><br><span class="line">    printf(&quot;insert: %d \n&quot;,elem);</span><br><span class="line">    print_list(list_a);</span><br><span class="line">    </span><br><span class="line">    get_elem(list_a, 5, &amp;elem);</span><br><span class="line">    printf(&quot;get elem at 5: %d \n&quot;,elem);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;locate : elem %d at %d \n&quot;,elem,locate_elem(list_a,&amp;elem));</span><br><span class="line">    </span><br><span class="line">    printf(&quot;list_a length : %d \n&quot;,list_length(list_a));</span><br><span class="line">    </span><br><span class="line">    print_list(list_a);</span><br><span class="line">    print_list(list_b);</span><br><span class="line">    </span><br><span class="line">    union_list(list_a,list_b,list_c);</span><br><span class="line">    print_list(list_c);</span><br><span class="line">    clear_list(list_c);</span><br><span class="line">    </span><br><span class="line">    intersect_list(list_a,list_b,list_c);</span><br><span class="line">    print_list(list_c);</span><br><span class="line">    clear_list(list_c);</span><br><span class="line">    </span><br><span class="line">    except_list(list_a,list_b,list_c);</span><br><span class="line">    print_list(list_c);</span><br><span class="line">    </span><br><span class="line">    destroy_list(list_a);</span><br><span class="line">    destroy_list(list_b);</span><br><span class="line">    destroy_list(list_c);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 2 4 6 8 10 12 14 16 18 </span><br><span class="line">0 1 2 3 4 5 6 7 8 </span><br><span class="line">pop: 9 </span><br><span class="line">0 1 3 4 5 6 7 8 </span><br><span class="line">delete: 2 </span><br><span class="line">insert: 2 </span><br><span class="line">0 1 2 3 4 5 6 7 8 </span><br><span class="line">get elem at 5: 5 </span><br><span class="line">locate : elem 5 at 5 </span><br><span class="line">list_a length : 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 </span><br><span class="line">0 2 4 6 8 10 12 14 16 18 </span><br><span class="line">0 1 2 3 4 5 6 7 8 10 12 14 16 18 </span><br><span class="line">0 2 4 6 8 </span><br><span class="line">1 3 5 7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——C数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python requests实现有道在线翻译请求</title>
      <link href="/2018/07/19/%E4%BD%BF%E7%94%A8Python-requests%E5%AE%9E%E7%8E%B0%E6%9C%89%E9%81%93%E5%9C%A8%E7%BA%BF%E7%BF%BB%E8%AF%91%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/07/19/%E4%BD%BF%E7%94%A8Python-requests%E5%AE%9E%E7%8E%B0%E6%9C%89%E9%81%93%E5%9C%A8%E7%BA%BF%E7%BF%BB%E8%AF%91%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>使用Python requests 请求有道翻译api：实现了函数传参传入要翻译的内容后，命令行打印出翻译后的内容。<br>库依赖：requests、json、io、sys、re、hashlib、time、platform</p><span id="more"></span><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import io</span><br><span class="line">import sys</span><br><span class="line">import re</span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import platform</span><br><span class="line"></span><br><span class="line">os_info = platform.platform()</span><br><span class="line"></span><br><span class="line">if os_info[0] == &#x27;W&#x27;:</span><br><span class="line">    sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&#x27;gb18030&#x27;)</span><br><span class="line">    #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">def translate(content):</span><br><span class="line">    url = &#x27;http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule&#x27;</span><br><span class="line">    headers = &#123;</span><br><span class="line">    &#x27;Cookie&#x27;:&#x27;OUTFOX_SEARCH_USER_ID=1799185238@10.169.0.83;&#x27;,</span><br><span class="line">    &#x27;Origin&#x27;: &#x27;http://fanyi.youdao.com&#x27;,</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&#x27;,</span><br><span class="line">    &#x27;Referer&#x27;: &#x27;http://fanyi.youdao.com/&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    d = content</span><br><span class="line">    u = &#x27;fanyideskweb&#x27;</span><br><span class="line">    f = str(int(time.time()*1000))</span><br><span class="line">    c = &quot;ebSeFb%=XZ%T[KZ)c(sy!&quot;</span><br><span class="line">    m.update((u + d + f + c).encode(&#x27;utf-8&#x27;))</span><br><span class="line">    payload = &#123;</span><br><span class="line">    &#x27;i&#x27;:d,</span><br><span class="line">    &#x27;from&#x27;:&#x27;AUTO&#x27;,</span><br><span class="line">    &#x27;to&#x27;:&#x27;AUTO&#x27;,</span><br><span class="line">    &#x27;smartresult&#x27;:&#x27;dict&#x27;,</span><br><span class="line">    &#x27;client&#x27;:u,</span><br><span class="line">    &#x27;salt&#x27;:f,</span><br><span class="line">    &#x27;sign&#x27;:m.hexdigest(),</span><br><span class="line">    &#x27;doctype&#x27;:&#x27;json&#x27;,</span><br><span class="line">    &#x27;version&#x27;:&#x27;2.1&#x27;,</span><br><span class="line">    &#x27;keyfrom&#x27;:&#x27;fanyi.web&#x27;,</span><br><span class="line">    &#x27;action&#x27;:&#x27;FY_BY_ENTER&#x27;,</span><br><span class="line">    &#x27;typoResult&#x27;:&#x27;false&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.post(url,headers = headers ,data = payload).json()</span><br><span class="line">    if r[&#x27;errorCode&#x27;] == 0:</span><br><span class="line">        #print(r[&#x27;translateResult&#x27;][0][0][&#x27;tgt&#x27;])</span><br><span class="line">        return r[&#x27;translateResult&#x27;][0][0][&#x27;tgt&#x27;]</span><br><span class="line">    else:</span><br><span class="line">        #print(r)</span><br><span class="line">        return &#x27;翻译错误&#x27;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">def main():</span><br><span class="line">    print(translate(&#x27;有道翻译api接口&#x27;))</span><br><span class="line">    </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>上面代码在命令行打印的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Youdao translation API interface</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python requests</title>
      <link href="/2018/07/19/Python-requests/"/>
      <url>/2018/07/19/Python-requests/</url>
      
        <content type="html"><![CDATA[<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><h4 id="导入-Requests-模块"><a href="#导入-Requests-模块" class="headerlink" title="导入 Requests 模块"></a>导入 Requests 模块</h4><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import requests</span><br></pre></td></tr></table></figure><h4 id="HTTP-请求类型"><a href="#HTTP-请求类型" class="headerlink" title="HTTP 请求类型"></a>HTTP 请求类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;)</span><br><span class="line">&gt;&gt;&gt; r = requests.post(&#x27;http://httpbin.org/post&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; r = requests.put(&#x27;http://httpbin.org/put&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; r = requests.delete(&#x27;http://httpbin.org/delete&#x27;)</span><br><span class="line">&gt;&gt;&gt; r = requests.head(&#x27;http://httpbin.org/get&#x27;)</span><br><span class="line">&gt;&gt;&gt; r = requests.options(&#x27;http://httpbin.org/get&#x27;)</span><br></pre></td></tr></table></figure><p>r为 Response 对象。我们可以从这个对象中获取所有我们想要的信息。</p><h3 id="传递-URL-参数"><a href="#传递-URL-参数" class="headerlink" title="传递 URL 参数"></a>传递 URL 参数</h3><p>Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; payload = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)</span><br></pre></td></tr></table></figure><p>通过打印输出该 URL，你能看到 URL 已被正确编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(r.url)</span><br><span class="line">http://httpbin.org/get?key2=value2&amp;key1=value1</span><br></pre></td></tr></table></figure><p>注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。<br>你还可以将一个列表作为值传入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; payload = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: [&#x27;value2&#x27;, &#x27;value3&#x27;]&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;http://httpbin.org/get&#x27;, params=payload)</span><br><span class="line">&gt;&gt;&gt; print(r.url)</span><br><span class="line">http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</span><br></pre></td></tr></table></figure><h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><h4 id="文本响应内容-r-text"><a href="#文本响应内容-r-text" class="headerlink" title="文本响应内容 r.text"></a>文本响应内容 r.text</h4><p>我们能读取服务器响应的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import requests</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;)</span><br><span class="line">&gt;&gt;&gt; r.text</span><br><span class="line">u&#x27;[&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...</span><br></pre></td></tr></table></figure><p>Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。</p><p>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。<br>当你访问 r.text 之时，Requests 会使用其推测的文本编码。<br>你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.encoding</span><br><span class="line">&#x27;utf-8&#x27;</span><br><span class="line">&gt;&gt;&gt; r.encoding = &#x27;ISO-8859-1&#x27;</span><br></pre></td></tr></table></figure><p>如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。<br>你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。</p><h4 id="二进制响应内容-r-content"><a href="#二进制响应内容-r-content" class="headerlink" title="二进制响应内容 r.content"></a>二进制响应内容 r.content</h4><p>你也能以字节的方式访问请求响应体，对于非文本请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.content</span><br><span class="line">b&#x27;[&#123;&quot;repository&quot;:&#123;&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...</span><br></pre></td></tr></table></figure><p>Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。<br>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; i = Image.open(BytesIO(r.content))</span><br></pre></td></tr></table></figure><h4 id="JSON-响应内容-r-json"><a href="#JSON-响应内容-r-json" class="headerlink" title="JSON 响应内容 r.json()"></a>JSON 响应内容 r.json()</h4><p>Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import requests</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;)</span><br><span class="line">&gt;&gt;&gt; r.json()</span><br><span class="line">[&#123;u&#x27;repository&#x27;: &#123;u&#x27;open_issues&#x27;: 0, u&#x27;url&#x27;: &#x27;https://github.com/...</span><br></pre></td></tr></table></figure><p>如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常。</p><p>需要注意的是，成功调用 r.json() 并不意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。</p><h4 id="原始响应内容-r-raw"><a href="#原始响应内容-r-raw" class="headerlink" title="原始响应内容 r.raw"></a>原始响应内容 r.raw</h4><p>在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 stream&#x3D;True。具体你可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;https://api.github.com/events&#x27;, stream=True)</span><br><span class="line">&gt;&gt;&gt; r.raw</span><br><span class="line">&lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt;</span><br><span class="line">&gt;&gt;&gt; r.raw.read(10)</span><br><span class="line">&#x27;\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03&#x27;</span><br></pre></td></tr></table></figure><p>但一般情况下，你应该以下面的模式将文本流保存到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(filename, &#x27;wb&#x27;) as fd:</span><br><span class="line">    for chunk in r.iter_content(chunk_size):</span><br><span class="line">        fd.write(chunk)</span><br></pre></td></tr></table></figure><p>使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。 Note that chunk_size can be freely adjusted to a number that may better fit your use cases.</p><h3 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h3><p>如果你想为请求添加 HTTP 头部，只要简单地传递一个 dict 给 headers 参数就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; url = &#x27;https://api.github.com/some/endpoint&#x27;</span><br><span class="line">&gt;&gt;&gt; headers = &#123;&#x27;user-agent&#x27;: &#x27;my-app/0.0.1&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure><p>注意: 定制 header 的优先级低于某些特定的信息源，例如：</p><ul><li>如果在 .netrc 中设置了用户认证信息，使用 headers&#x3D; 设置的授权就不会生效。而如果设置了 auth&#x3D; 参数，.netrc 的设置就无效了。</li><li>如果被重定向到别的主机，授权 header 就会被删除。</li><li>代理授权 header 会被 URL 中提供的代理身份覆盖掉。</li><li>在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。</li><li>更进一步讲，Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的 header 信息都会被传递进去。</li></ul><p>注意: 所有的 header 值必须是 string、bytestring 或者 unicode。尽管传递 unicode header 也是允许的，但不建议这样做。</p><h3 id="更加复杂的-POST-请求"><a href="#更加复杂的-POST-请求" class="headerlink" title="更加复杂的 POST 请求"></a>更加复杂的 POST 请求</h3><p>通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; payload = &#123;&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)</span><br><span class="line">&gt;&gt;&gt; print(r.text)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;key2&quot;: &quot;value2&quot;,</span><br><span class="line">    &quot;key1&quot;: &quot;value1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以为 data 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; payload = ((&#x27;key1&#x27;, &#x27;value1&#x27;), (&#x27;key1&#x27;, &#x27;value2&#x27;))</span><br><span class="line">&gt;&gt;&gt; r = requests.post(&#x27;http://httpbin.org/post&#x27;, data=payload)</span><br><span class="line">&gt;&gt;&gt; print(r.text)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;key1&quot;: [</span><br><span class="line">      &quot;value1&quot;,</span><br><span class="line">      &quot;value2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict，那么数据会被直接发布出去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; url = &#x27;https://api.github.com/some/endpoint&#x27;</span><br><span class="line">&gt;&gt;&gt; payload = &#123;&#x27;some&#x27;: &#x27;data&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload))</span><br></pre></td></tr></table></figure><h3 id="POST一个多部分编码-Multipart-Encoded-的文件"><a href="#POST一个多部分编码-Multipart-Encoded-的文件" class="headerlink" title="POST一个多部分编码(Multipart-Encoded)的文件"></a>POST一个多部分编码(Multipart-Encoded)的文件</h3><p>Requests 使得上传多部分编码文件变得很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; url = &#x27;http://httpbin.org/post&#x27;</span><br><span class="line">&gt;&gt;&gt; files = &#123;&#x27;file&#x27;: open(&#x27;report.xls&#x27;, &#x27;rb&#x27;)&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.post(url, files=files)</span><br><span class="line">&gt;&gt;&gt; r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;files&quot;: &#123;</span><br><span class="line">    &quot;file&quot;: &quot;&lt;censored...binary...data&gt;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以显式地设置文件名，文件类型和请求头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files = &#123;&#x27;file&#x27;: (&#x27;report.xls&#x27;, open(&#x27;report.xls&#x27;, &#x27;rb&#x27;), &#x27;application/vnd.ms-excel&#x27;, &#123;&#x27;Expires&#x27;: &#x27;0&#x27;&#125;)&#125;</span><br></pre></td></tr></table></figure><p>也可以发送作为文件来接收的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; files = &#123;&#x27;file&#x27;: (&#x27;report.csv&#x27;, &#x27;some,data,to,send\nanother,row,to,send\n&#x27;)&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.post(url, files=files)</span><br><span class="line">&gt;&gt;&gt; r.text</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;files&quot;: &#123;</span><br><span class="line">    &quot;file&quot;: &quot;some,data,to,send\\nanother,row,to,send\\n&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你发送一个非常大的文件作为 multipart&#x2F;form-data 请求，你可能希望将请求做成数据流。默认下 requests 不支持, 但有个第三方包 requests-toolbelt 是支持的。</p><p>强烈建议你用二进制模式(binary mode)打开文件。这是因为 Requests 可能会试图为你提供 Content-Length header，在它这样做的时候，这个值会被设为文件的字节数（bytes）。如果用文本模式(text mode)打开文件，就可能会发生错误。</p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>我们可以检测响应状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;http://httpbin.org/get&#x27;)</span><br><span class="line">&gt;&gt;&gt; r.status_code</span><br><span class="line">200</span><br></pre></td></tr></table></figure><p>为方便引用，Requests还附带了一个内置的状态码查询对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.status_code == requests.codes.ok</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 Response.raise_for_status() 来抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bad_r = requests.get(&#x27;http://httpbin.org/status/404&#x27;)</span><br><span class="line">&gt;&gt;&gt; bad_r.status_code</span><br><span class="line">404</span><br><span class="line">&gt;&gt;&gt; bad_r.raise_for_status()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;requests/models.py&quot;, line 832, in raise_for_status</span><br><span class="line">    raise http_error</span><br><span class="line">requests.exceptions.HTTPError: 404 Client Error</span><br></pre></td></tr></table></figure><p>若 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.raise_for_status()</span><br><span class="line">None</span><br></pre></td></tr></table></figure><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>我们可以查看以一个 Python 字典形式展示的服务器响应头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.headers</span><br><span class="line">&#123;</span><br><span class="line">    &#x27;content-encoding&#x27;: &#x27;gzip&#x27;,</span><br><span class="line">    &#x27;transfer-encoding&#x27;: &#x27;chunked&#x27;,</span><br><span class="line">    &#x27;connection&#x27;: &#x27;close&#x27;,</span><br><span class="line">    &#x27;server&#x27;: &#x27;nginx/1.0.4&#x27;,</span><br><span class="line">    &#x27;x-runtime&#x27;: &#x27;148ms&#x27;,</span><br><span class="line">    &#x27;etag&#x27;: &#x27;&quot;e1ca502697e5c9317743dc078f67693f&quot;&#x27;,</span><br><span class="line">    &#x27;content-type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据 RFC 2616， HTTP 头部是大小写不敏感的。</p><p>因此，我们可以使用任意大写形式来访问这些响应头字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.headers[&#x27;Content-Type&#x27;]</span><br><span class="line">&#x27;application/json&#x27;</span><br><span class="line">&gt;&gt;&gt; r.headers.get(&#x27;content-type&#x27;)</span><br><span class="line">&#x27;application/json&#x27;</span><br></pre></td></tr></table></figure><p>它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests 会将它们合并，这样它们就可以用一个映射来表示出来</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>如果某个响应中包含一些 cookie，你可以快速访问它们</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; url = &#x27;http://example.com/some/cookie/setting/url&#x27;</span><br><span class="line">&gt;&gt;&gt; r = requests.get(url)</span><br><span class="line">&gt;&gt;&gt; r.cookies[&#x27;example_cookie_name&#x27;]</span><br><span class="line">&#x27;example_cookie_value&#x27;</span><br></pre></td></tr></table></figure><p>要想发送你的cookies到服务器，可以使用 cookies 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; url = &#x27;http://httpbin.org/cookies&#x27;</span><br><span class="line">&gt;&gt;&gt; cookies = dict(cookies_are=&#x27;working&#x27;)</span><br><span class="line">&gt;&gt;&gt; r = requests.get(url, cookies=cookies)</span><br><span class="line">&gt;&gt;&gt; r.text</span><br><span class="line">&#x27;&#123;&quot;cookies&quot;: &#123;&quot;cookies_are&quot;: &quot;working&quot;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>Cookie 的返回对象为 RequestsCookieJar，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用。<br>你还可以把 Cookie Jar 传到 Requests 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">&gt;&gt;&gt; jar.set(&#x27;tasty_cookie&#x27;, &#x27;yum&#x27;, domain=&#x27;httpbin.org&#x27;, path=&#x27;/cookies&#x27;)</span><br><span class="line">&gt;&gt;&gt; jar.set(&#x27;gross_cookie&#x27;, &#x27;blech&#x27;, domain=&#x27;httpbin.org&#x27;, path=&#x27;/elsewhere&#x27;)</span><br><span class="line">&gt;&gt;&gt; url = &#x27;http://httpbin.org/cookies&#x27;</span><br><span class="line">&gt;&gt;&gt; r = requests.get(url, cookies=jar)</span><br><span class="line">&gt;&gt;&gt; r.text</span><br><span class="line">&#x27;&#123;&quot;cookies&quot;: &#123;&quot;tasty_cookie&quot;: &quot;yum&quot;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h3><p>默认情况下，除了 HEAD, Requests 会自动处理所有重定向。</p><p>可以使用响应对象的 history 方法来追踪重定向。</p><p>Response.history 是一个 Response 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p><p>例如，Github 将所有的 HTTP 请求重定向到 HTTPS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;http://github.com&#x27;)</span><br><span class="line">&gt;&gt;&gt; r.url</span><br><span class="line">&#x27;https://github.com/&#x27;</span><br><span class="line">&gt;&gt;&gt; r.status_code</span><br><span class="line">200</span><br><span class="line">&gt;&gt;&gt; r.history</span><br><span class="line">[&lt;Response [301]&gt;]</span><br></pre></td></tr></table></figure><p>如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&#x27;http://github.com&#x27;, allow_redirects=False)</span><br><span class="line">&gt;&gt;&gt; r.status_code</span><br><span class="line">301</span><br><span class="line">&gt;&gt;&gt; r.history</span><br><span class="line">[] </span><br></pre></td></tr></table></figure><p>如果你使用了 HEAD，你也可以启用重定向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.head(&#x27;http://github.com&#x27;, allow_redirects=True)</span><br><span class="line">&gt;&gt;&gt; r.url</span><br><span class="line">&#x27;https://github.com/&#x27;</span><br><span class="line">&gt;&gt;&gt; r.history</span><br><span class="line">[&lt;Response [301]&gt;]</span><br></pre></td></tr></table></figure><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; requests.get(&#x27;http://github.com&#x27;, timeout=0.001)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">requests.exceptions.Timeout: HTTPConnectionPool(host=&#x27;github.com&#x27;, port=80): Request timed out. (timeout=0.001)</span><br></pre></td></tr></table></figure><p>timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out.</p><h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><ul><li>遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 ConnectionError 异常。</li><li>如果 HTTP 请求返回了不成功的状态码， Response.raise_for_status() 会抛出一个 HTTPError 异常。</li><li>若请求超时，则抛出一个 Timeout 异常。</li><li>若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。</li><li>所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python re 提取百度百科</title>
      <link href="/2018/07/18/%E4%BD%BF%E7%94%A8Python-re-%E6%8F%90%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91/"/>
      <url>/2018/07/18/%E4%BD%BF%E7%94%A8Python-re-%E6%8F%90%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>使用Python re 提取百度百科的内容：实现了在命令行输入要查询的百科内容的词语后，命令行里打印出查到的内容的功能。内容由正则表达式提取出百度百科的网页内容。<br>库依赖：urllib3、json、certifi、io、sys、re、platform</p><span id="more"></span><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr.Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import urllib3</span><br><span class="line">import json</span><br><span class="line">import certifi</span><br><span class="line">import io</span><br><span class="line">import sys</span><br><span class="line">import re</span><br><span class="line">import platform</span><br><span class="line"></span><br><span class="line">os_info = platform.platform()</span><br><span class="line"></span><br><span class="line">if os_info[0] == &#x27;W&#x27;:</span><br><span class="line">    sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=&#x27;gb18030&#x27;)</span><br><span class="line">    #改变标准输出的默认编码</span><br><span class="line">    </span><br><span class="line">class BaiduPedia(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.html_data = &#x27;&#x27;</span><br><span class="line">        self.title = &#x27;&#x27;</span><br><span class="line">        self.other_pedias_list = []</span><br><span class="line"></span><br><span class="line">    def make_https_request(self,url,func,field = &#123;&#125;):</span><br><span class="line">        https = urllib3.PoolManager(cert_reqs=&#x27;CERT_REQUIRED&#x27;, ca_certs=certifi.where())</span><br><span class="line">        request_head = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&#x27;&#125;</span><br><span class="line">        r = https.request(func, url,fields = field,headers = request_head)</span><br><span class="line">        if r.status == 200:</span><br><span class="line">            self.html_data = r.data.decode(&#x27;utf-8&#x27;)</span><br><span class="line">        </span><br><span class="line">    def baidu_pedia_request(self,word):</span><br><span class="line">        url = &#x27;https://baike.baidu.com/search/word&#x27;</span><br><span class="line">        func = &#x27;GET&#x27;</span><br><span class="line">        field = &#123;&#x27;word&#x27;:word&#125;</span><br><span class="line">        self.make_https_request(url,func,field)</span><br><span class="line"></span><br><span class="line">    def save_file(self,web_data,filename):</span><br><span class="line">        with open(filename,&#x27;w&#x27;) as f:</span><br><span class="line">            f.write(web_data)</span><br><span class="line">        </span><br><span class="line">    def baidupedia_get_title(self,s):</span><br><span class="line">        pattern = re.compile(r&#x27;&lt;title&gt;.*?&lt;/title&gt;&#x27;, re.S)</span><br><span class="line">        self.title = pattern.search(s).group()[7:-13]</span><br><span class="line">    </span><br><span class="line">    def baidupedia_get_other_pedias_dict(self,s):</span><br><span class="line">        pattern = re.compile(r&#x27;&lt;li class=&quot;item&quot;&gt;▪&lt;a title=.*?&lt;/a&gt;&lt;/li&gt;&#x27;, re.S)</span><br><span class="line">        other_pedias = pattern.findall(s)</span><br><span class="line">        if len(other_pedias) &gt; 0:</span><br><span class="line">            print(&#x27;&#x27;)</span><br><span class="line">            print(&#x27;该词是一个多义词，请在下列义项上选择浏览:&#x27;)</span><br><span class="line">            print(&#x27;1&#x27; + self.title)</span><br><span class="line">            num_index = 2</span><br><span class="line">            for item in other_pedias:</span><br><span class="line">                index1 = item.find(&#x27;href&#x27;)</span><br><span class="line">                index2 = item.find(&#x27;&gt;&#x27;,index1)</span><br><span class="line">                other_pedias_href = &#x27;https://baike.baidu.com&#x27; + item[index1 + 6:index2 - 1]</span><br><span class="line">                other_pedias_title = item[index2 + 1:-9]</span><br><span class="line">                print(str(num_index) + other_pedias_title)</span><br><span class="line">                num_index += 1</span><br><span class="line">                self.other_pedias_list.append(other_pedias_href)</span><br><span class="line">            print(&#x27;&#x27;)</span><br><span class="line">    </span><br><span class="line">    def baidupedia_get_summary(self,s):</span><br><span class="line">        print(self.title)</span><br><span class="line">        print(&#x27;&#x27;)</span><br><span class="line">        pattern = re.compile(r&#x27;&lt;div class=&quot;promotion-declaration&quot;&gt;.*?&lt;/dl&gt;&lt;/div&gt;&#x27;, re.S)</span><br><span class="line">        head_content = pattern.search(s).group()</span><br><span class="line">        head_content = re.sub(r&#x27;&lt;[\u0008-\u007F]*?&gt;&#x27;,&#x27;&#x27;,head_content)</span><br><span class="line">        head_content = re.sub(r&#x27;\n\n*&#x27;,&#x27;\n&#x27;,head_content)</span><br><span class="line">        head_content = re.sub(r&#x27;&amp;nbsp;&#x27;,&#x27;&#x27;,head_content)</span><br><span class="line">        print(head_content)</span><br><span class="line">        </span><br><span class="line">    def baidupedia_get_content(self,s):</span><br><span class="line">        pattern = re.compile(r&#x27;&lt;a name=&quot;\d.*?&quot; class=&quot;lemma-anchor para-title&quot;.*?&lt;div class=&quot;anchor-list&quot;&gt;&#x27;, re.S)</span><br><span class="line">        content = pattern.findall(s)</span><br><span class="line">        for item in content:</span><br><span class="line">            item_pattern1 = re.compile(r&#x27;&lt;span class=&quot;title-prefix&quot;&gt;.*?&lt;/h.*?\d&#x27;, re.S)</span><br><span class="line">            item_content1 = item_pattern1.search(item).group()</span><br><span class="line">            item_catalogue =  re.sub(r&#x27;&lt;.*?n&gt;&#x27;,&#x27;&#x27;,item_content1)</span><br><span class="line">            if item_catalogue[-1] == &#x27;2&#x27;:</span><br><span class="line">                print(&#x27;---&#x27; + item_catalogue[:-4])</span><br><span class="line">            elif item_catalogue[-1] == &#x27;3&#x27;:</span><br><span class="line">                print(&#x27;------&#x27; + item_catalogue[:-4])</span><br><span class="line">            item_pattern2 = re.compile(r&#x27;&lt;div class=&quot;para&quot; label-module=&quot;para&quot;&gt;.*?&lt;/div&gt;&#x27;, re.S)</span><br><span class="line">            item_content2 = item_pattern2.findall(item)</span><br><span class="line">            for item_child in item_content2:</span><br><span class="line">                item_child_content1 = re.sub(r&#x27;&lt;[\u0008-\u007F\u4e00-\u9fa5]*?&gt;\r*\n*&#x27;, &#x27;&#x27;, item_child)</span><br><span class="line">                item_child_content1 = re.sub(r&#x27;&amp;.*?;&#x27;,&#x27;&#x27;,item_child_content1)</span><br><span class="line">                if item_catalogue[-1] == &#x27;2&#x27;:</span><br><span class="line">                    print(&#x27;   &#x27; + item_child_content1)</span><br><span class="line">                elif item_catalogue[-1] == &#x27;3&#x27;:</span><br><span class="line">                    print(&#x27;      &#x27; + item_child_content1)</span><br><span class="line">            print(&#x27;&#x27;)</span><br><span class="line">        </span><br><span class="line">    def baidupedia_match(self,s):</span><br><span class="line">        self.baidupedia_get_summary(s)</span><br><span class="line">        self.baidupedia_get_content(s)</span><br><span class="line">        </span><br><span class="line">    def baidupedia(self,word):</span><br><span class="line">        self.baidu_pedia_request(word)</span><br><span class="line">        self.baidupedia_get_title(self.html_data)</span><br><span class="line">        self.baidupedia_get_other_pedias_dict(self.html_data)</span><br><span class="line">        list_len = len(self.other_pedias_list)</span><br><span class="line">        if list_len &gt; 0:</span><br><span class="line">            num = int(input(&#x27;请输入你要查的意思：&#x27;))</span><br><span class="line">            print(&#x27;&#x27;)</span><br><span class="line">            if num == 1:</span><br><span class="line">                self.baidupedia_match(self.html_data)</span><br><span class="line">            else:</span><br><span class="line">                self.make_https_request(self.other_pedias_list[num - 2],&#x27;GET&#x27;)</span><br><span class="line">                self.baidupedia_get_title(self.html_data)</span><br><span class="line">                self.baidupedia_match(self.html_data)</span><br><span class="line">        else:</span><br><span class="line">            self.baidupedia_match(self.html_data)</span><br><span class="line">        </span><br><span class="line">def main():</span><br><span class="line">    word = input(&#x27;请输入你要查的词语：&#x27;)</span><br><span class="line">    baidu_pedia = BaiduPedia()</span><br><span class="line">    baidu_pedia.baidupedia(word)</span><br><span class="line">    </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>运行后出现提示，输入支持中英文词。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请输入你要查的词语：</span><br></pre></td></tr></table></figure><p>我们输入DNS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请输入你要查的词语：DNS</span><br><span class="line"></span><br><span class="line">该词是一个多义词，请在下列义项上选择浏览:</span><br><span class="line">1dns（域名系统）</span><br><span class="line">2体育术语</span><br><span class="line">3二硝基水杨酸</span><br><span class="line">4直接数值模拟</span><br><span class="line">5魔方比赛用语</span><br><span class="line">6生物化学实验</span><br><span class="line"></span><br><span class="line">请输入你要查的意思：</span><br></pre></td></tr></table></figure><p>由于DNS是个多义词，给出了一个选项，输入想要查的词的号，比如我们输入1后回车，表示想要查询域名系统的百科释义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br></pre></td><td class="code"><pre><span class="line">请输入你要查的意思：1</span><br><span class="line"></span><br><span class="line">dns（域名系统）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。</span><br><span class="line">中文名</span><br><span class="line">域名系统</span><br><span class="line">外文名</span><br><span class="line">Domain Name System</span><br><span class="line">使用协议</span><br><span class="line">UDP,TCP（当请求大于512字节时）</span><br><span class="line">使用端口</span><br><span class="line">53</span><br><span class="line"></span><br><span class="line">---DNS功能</span><br><span class="line">   每个IP地址都可以有一个主机名，主机名由一个或多个字符串组成，字符串之间用小数点隔开。有了主机名，就不要死记硬背每台IP设备的IP地址，只要记住相对直观有意义的主机名就行了。这就是DNS协议的功能。</span><br><span class="line">   主机名到IP地址的映射有两种方式：</span><br><span class="line">   1）静态映射，每台设备上都配置主机到IP地址的映射，各设备独立维护自己的映射表，而且只供本设备使用；</span><br><span class="line">   2）动态映射，建立一套域名解析系统（DNS），只在专门的DNS服务器上配置主机到IP地址的映射，网络上需要使用主机名通信的设备，首先需要到DNS服务器查询主机所对应的IP地址。[1]</span><br><span class="line">   通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。在解析域名时，可以首先采用静态域名解析的方法，如果静态域名解析不成功，再采用动态域名解析的方法。可以将一些常用的域名放入静态域名解析表中，这样可以大大提高域名解析效率。</span><br><span class="line"></span><br><span class="line">---DNS重要性</span><br><span class="line">   1、技术角度看</span><br><span class="line">   DNS解析是互联网绝大多数应用的实际寻址方式； 域名技术的再发展、以及基于域名技术的多种应用，丰富了互联网应用和协议。</span><br><span class="line">   2、资源角度看</span><br><span class="line">   域名是互联网上的身份标识，是不可重复的唯一标识资源； 互联网的全球化使得域名成为标识一国主权的国家战略资源。</span><br><span class="line"></span><br><span class="line">---DNS冗余</span><br><span class="line">   为保证服务的高可用性，DNS要求使dns</span><br><span class="line"></span><br><span class="line">   某个区域的资源记录通过手动或自动方式更新到单个主名称服务器（称为主 DNS服务器）上，主 DNS 服务器可以是一个或几个区域的权威名称服务器。</span><br><span class="line">   其它冗余名称服务器（称为辅 DNS 服务器）用作同一区域中主服务器的备份服务器，以防主服务器无法访问或宕机。辅 DNS服务器定期与主 DNS 服务器通讯，确保它的区域信息保持最新。如果不是最新信息，辅 DNS服务器就会从主服务器获取最新区域数据文件的副本。这种将区域文件复制到多台名称服务器的过程称为区域复制。</span><br><span class="line"></span><br><span class="line">---域名结构</span><br><span class="line">   通常 Internet 主机域名的一般结构为：主机名.三级域名.二级域名.顶级域名。 Internet 的顶级域名由 Internet网络协会域名注册查询负责网络地址分配的委员会进行登记和管理，它还为 Internet的每一台主机分配唯一的 IP 地址。全世界现有三个大的网络信息中心： 位于美国的 Inter-NIC，负责美国及其他地区； 位于荷兰的RIPE-NIC，负责欧洲地区；位于日本的APNIC ，负责亚太地区[1]。</span><br><span class="line"></span><br><span class="line">---解析器</span><br><span class="line">   解析器，或另一台DNS服务器递归代表的情况下，域名解析器，协商使用递归服务，使用查询头位。</span><br><span class="line">   解析通常需要遍历多个名称服务器，找到所需要的信息。然而，一些解析器的功能更简单地只用一个名称服务器进行通信。这些简单的解析器依赖于一个递归名称服务器（称为“存根解析器”），为他们寻找信息的执行工作。</span><br><span class="line"></span><br><span class="line">---DNS服务器</span><br><span class="line">   提供DNS服务的是安装了DNS服务器端软件的计算机。服务器端软件既可以是基于类linux操作系统，也可以是基于Windows操作系统的。装好DNS服务器软件后，您就可以在您指定的位置创建区域文件了，所谓区域文件就是包含了此域中名字到IP地址解析记录的一个文件，如文件的内容可能是这样的：primary name server = dns2（主服务器的主机名是 ）</span><br><span class="line">   serial = 2913 （序列号=2913、这个序列号的作用是当辅域名服务器来复制这个文件的时候，如果号码增加了就复制）</span><br><span class="line">   refresh = 10800 (3 hours) （刷新=10800秒、辅域名服务器每隔3小时查询一个主服务器）</span><br><span class="line">   retry = 3600 (1 hour) （重试=3600秒、当辅域名服务试图在主服务器上查询更新时，而连接失败了，辅域名服务器每隔1小时访问主域名服务器）</span><br><span class="line">   expire = 604800 (7 days) （到期=604800秒、辅域名服务器在向主服务更新失败后，7天后删除中的记录。）</span><br><span class="line">   default TTL = 3600 (1 hour) （默认生存时间=3600秒、缓存服务器保存记录的时间是1小时。也就是告诉缓存服务器保存域的解析记录为1小时）</span><br><span class="line"></span><br><span class="line">---SDNS</span><br><span class="line">   中国互联网络信息中心(CNNIC)研发出我国首个面向下一代互联网的域名服务平台——SDNS。</span><br><span class="line"></span><br><span class="line">---DNS查询方法</span><br><span class="line"></span><br><span class="line">------查询DNS服务器上的资源记录</span><br><span class="line">      在Windows平台下，使用命令行工具，输入nslookup，返回的结果包括域名对应的IP地址（A记录）、别名（CNAME记录）等。除了以上方法外，还可以通过一些DNS查询站点dns</span><br><span class="line"></span><br><span class="line">      常用的资源记录类型</span><br><span class="line">      A 地址 此记录列出特定主机名的 IP 地址。这是名称解析的重要记录。</span><br><span class="line">      CNAME 标准名称 此记录指定标准主机名的别名。</span><br><span class="line">      MX邮件交换器此记录列出了负责接收发到域中的电子邮件的主机。</span><br><span class="line">      NS名称服务器此记录指定负责给定区域的名称服务器。</span><br><span class="line"></span><br><span class="line">------FQDN名的解析过程查询</span><br><span class="line">      若想跟踪一个FQDN名的解析过程，在LinuxShell下输入dig www +trace，返回的结果包括从根域开始的递归或迭代过程，一直到权威域名服务器。</span><br><span class="line">      GeniePro DNS 应对DNS劫持和DNS缓存中毒攻击的关键性机制：一致性检查</span><br><span class="line">      每个Geniepro节点将自身的DNS记录发送给工作组内其他节点请求一致性检查；</span><br><span class="line">      每个Geniepro节点将自身的记录与收到的记录进行比较；</span><br><span class="line">      每个Geniepro工作组的通信协调节点将获得的DNS记录更新发送给其他组的通信协调节点请求一致性检查；</span><br><span class="line">      每个Genipro工作组的通信协调节点向上一级DNS服务器请求更新记录并与收到的其他通信协调节点的记录进行比较。</span><br><span class="line"></span><br><span class="line">------一致性仲裁</span><br><span class="line">      如果一致性检查发现记录不一致情况，则根据策略（少数服从多数、一票否决等）决定是否接受记录的变化 根据结果，各Geniepro节点将自身记录进行统一 通信协调节点选举 选举出的通信协调节点在任期内具有更新组内节点的权限 选举过程满足不可预测性和不可重复性DNS资源记录　如前所述，每个 DNS 数据库都由资源记录构成。一般来说，资源记录包含与特定主机有关的信息，如 IP 地址、主机的所有者或者提供服务的类型。</span><br><span class="line"></span><br><span class="line">---故障解决</span><br><span class="line">   当DNS解析出现错误，例如把一个域名解析成一个错误的IP地址，或者根本不知道某个域名对应的IP地址是什么时，就无法通过域名访问相应的站点了，这就是DNS解析故障。出现DNS解析故障最大的症状就是访问站点对应的IP地址没有问题，然而访问他的域名就会出现错误。</span><br><span class="line">   （1）用nslookup(网路查询)来判断是否真的是DNS解析故障：</span><br><span class="line">   要想百分之百判断是否为DNS解析故障就需要通过系统自带的NSLOOKUP来解决了。</span><br><span class="line">   第一步：确认自己的系统是windows 2000和windows xp以上操作系统，然后通过“开始-运行-输入CMD”后回车进入命令行模式。</span><br><span class="line">   第二步：输入nslookup命令后回车，将进入DNS解析查询界面。</span><br><span class="line">   第三步：命令行窗口中会显示出当前系统所使用的DNS服务器地址，例如笔者的DNS服务器IP为202.106.0.20。</span><br><span class="line">   第四步：接下来输入无法访问的站点对应的域名。假如不能访问的话，那么DNS解析应该是不能够正常进行的，会收到DNS request timed out，timeout was 2 seconds的提示信息。这说明本地计算机确实出现了DNS解析故障。</span><br><span class="line">   小提示：如果DNS解析正常的话，会反馈回正确的IP地址。</span><br><span class="line">   （2）查询DNS服务器工作是否正常：</span><br><span class="line">   这时候要看本地计算机使用的DNS地址是多少了，并且查询他的运行情况。</span><br><span class="line">   第一步：通过“开始-运行-输入CMD”后回车进入命令行模式。</span><br><span class="line">   第二步：输入ipconfig/all命令来查询网络参数。</span><br><span class="line">   第三步：在ipconfig /all显示信息中能够看到一个地方写着DNS SERVERS，这个就是本地的DNS服务器地址。例如笔者的是202.106.0.20和202.106.46.151。从这个地址可以看出是个外网地址，如果使用外网DNS出现解析错误时，可以更换一个其他的DNS服务器地址即可解决问题。</span><br><span class="line">   第四步：如果在DNS服务器处显示的是个人公司的内部网络地址，那么说明该公司的DNS解析工作是交给公司内部的DNS服务器来完成的，这时需要检查这个DNS服务器，在DNS服务器上进行nslookup操作看是否可以正常解析。解决DNS服务器上的DNS服务故障，一般来说问题也能够解决。</span><br><span class="line">   （3）清除DNS缓存信息法：</span><br><span class="line">   第一步：通过“开始-运行-输入CMD”进入命令行模式。</span><br><span class="line">   第二步：在命令行模式中我们可以看到在ipconfig /?中有一个名为/flushdns的参数，这个就是清除DNS缓存信息的命令。</span><br><span class="line">   第三步：执行ipconfig /flushdns命令，当出现“successfully flushed the dns resolver cache”的提示时就说明当前计算机的缓存信息已经被成功清除。</span><br><span class="line">   第四步：接下来我们再访问域名时，就会到DNS服务器上获取最新解析地址，再也不会出现因为以前的缓存造成解析错误故障了。</span><br><span class="line">   （4）修改HOSTS（主机）文件法：</span><br><span class="line">   第一步：通过“开始-搜索”，然后查找名叫hosts的文件。</span><br><span class="line">   第二步：当然对于已经知道他的路径的读者可以直接进入c:\windows\system32\drivers\etc目录中找到HOSTS文件。如果你的系统是windows 2000，那么应该到c:\winnt\system32\drivers\etc目录中寻找。</span><br><span class="line">   第三步：双击HOSTS文件，然后选择用“记事本”程序将其打开。</span><br><span class="line">   第四步：之后我们就会看到HOSTS文件的所有内容了，默认情况下只有一行内容“127.0.0.1 localhost”。（其他前面带有#的行都不是真正的内容，只是帮助信息而已）</span><br><span class="line">   第五步：将你希望进行DNS解析的条目添加到HOSTS文件中。具体格式是先写该域名对应的IP地址，然后空格接域名信息。</span><br><span class="line">   第六步：设置完毕后我们访问网址时就会自动根据是在内网还是外网来解析了。[2]</span><br><span class="line"></span><br><span class="line">---DNS安全问题</span><br><span class="line">   1.针对域名系统的恶意攻击：DDOS攻击造成域名解析瘫痪。</span><br><span class="line">   2.域名劫持：修改注册信息、劫持解析结果。</span><br><span class="line">   3.国家性质的域名系统安全事件：“.ly”域名瘫痪、“.af”域名的域名管理权变更。</span><br><span class="line">   4.系统上运行的DNS服务存在漏洞，导致被黑客获取权限，从而篡改DNS信息。</span><br><span class="line">   5.DNS设置不当，导致泄漏一些敏感信息。提供给黑客进一步攻击提供有力信息。</span><br><span class="line"></span><br><span class="line">---配置DNS</span><br><span class="line">   不同的网络设备配置的语法不一样，这里提供的配置方法是以锐捷网络设备为例的，一般也适用思科设备。</span><br><span class="line"></span><br><span class="line">---DNS解析</span><br><span class="line">   本节描述如何打开DNS域名解析功能开关。</span><br><span class="line">   R(config)#ip domain-lookup 打开DNS域名解析功能开关</span><br><span class="line">   　　配置DNS Server使用no ip domain-lookup命令关闭DNS域名解析的功能：R(config)#no ip domain-lookup</span><br><span class="line">   本节描述如何配置DNS服务器。只有配置了DNS服务器，才能进行动态域名解析。</span><br><span class="line">   如果要删除DNS服务器，可以使用no ip name-server [ip-address | ipv6-address] 命令。其中参数ip-address和ipv6-address表示删除指定的域名服务器，否则删除所有的域名服务器。</span><br><span class="line">   命令</span><br><span class="line">   作用</span><br><span class="line">   R(config)# ip name-server &#123;ip-address | ipv6-address&#125;</span><br><span class="line">   添加DNS Server的IP/IPV6地址。每次执行这条命令，设备都会添加一个DNS Server。当无法从第一个Server获取到域名时，设备会尝试向后续几个Server发送DNS请求，直到正确收到回应为止。系统最多支持6个域名服务器。</span><br><span class="line">   　　</span><br><span class="line"></span><br><span class="line">------静态配置主机名和IP/IPV6地址的映射</span><br><span class="line">      如何配置主机名和IP/IPV6地址的映射。本地维护了一张主机名和IP/IPV6地址的对应表，也叫主机名到IP/IPv6地址的映射表。主机名到IP/IPV6地址的映射表内容有两个来源：手工配置和动态学习。在不能动态学习的情况下，手工配置就有必要了。</span><br><span class="line">      命令</span><br><span class="line">      作用</span><br><span class="line">      R(config)# ip host host-name ip-address</span><br><span class="line">      手工配置主机名和IP地址映射</span><br><span class="line">      R(config)# ipv6 host host-name ipv6-address</span><br><span class="line">      手工配置主机名和IPV6地址映射</span><br><span class="line">      使用该命令的no形式就可以删除主机名和IP/IPV6地址的映射。</span><br><span class="line">      　　</span><br><span class="line"></span><br><span class="line">------清除动态主机名缓存表</span><br><span class="line">      本节描述如何清除动态主机名缓存表。如果输入clear host或clear host * 命令将清除动态缓存表。否则只删除指定域名的表项。</span><br><span class="line">      命令</span><br><span class="line">      作用</span><br><span class="line">      R#clear host [host-name]</span><br><span class="line">      清除动态主机名缓存表。</span><br><span class="line">      该命令不能删除静态配置的主机名。</span><br><span class="line"></span><br><span class="line">------域名解析信息显示</span><br><span class="line">      本节描述如何显示DNS的相关配置信息：</span><br><span class="line">      命令</span><br><span class="line">      作用</span><br><span class="line">      R# show hosts [host-name]</span><br><span class="line">      查看DNS的相关参数</span><br><span class="line">      R# show hosts</span><br><span class="line">      Name servers are:</span><br><span class="line">      192.168.5.134 static</span><br><span class="line">      Host type Address TTL(sec)</span><br><span class="line">      www.163.com static 192.168.5.243 ---</span><br><span class="line"></span><br><span class="line">---DNS配置举例</span><br><span class="line"></span><br><span class="line">------静态域名解析配置举例</span><br><span class="line">      拓扑图</span><br><span class="line">      如右图静态域名解析配置组网图所示：</span><br><span class="line">      静态域名解析配置组网图</span><br><span class="line"></span><br><span class="line">      应用需求</span><br><span class="line">      由于网络设备R-A经常访问域名为destination.com的主机，可利用静态域名解析功能，实现通过destination.com主机名访问IP地址为1.1.1.20的主机，提高域名解析的效率。</span><br><span class="line">      配置要点</span><br><span class="line">      1. 确保设备和主机间路由可达</span><br><span class="line">      2. 主机名和IP地址间的映射正确</span><br><span class="line">      配置步骤</span><br><span class="line">      手工配置主机名和IP地址间的映射；本例中，配置主机名为destination.com其对应IP地址为1.1.1.20</span><br><span class="line">      R-A(config)#ip host destination.com 1.1.1.20</span><br><span class="line">      配置验证</span><br><span class="line">      第一步，查看域名解析信息；关注点主机、IP地址间的映射关系是否正确。</span><br><span class="line">      R-A# show host</span><br><span class="line">      Name servers are:</span><br><span class="line">      Host type Address TTL(sec)</span><br><span class="line">      destination.com static 1.1.1.20 ---</span><br><span class="line">      第二步，使用ping destination.com命令，查看执行结果。</span><br><span class="line">      R-A# ping destination.com</span><br><span class="line">      Translating destination.com...[OK]</span><br><span class="line">      Sending 5, 100-byte ICMP Echoes to 1.1.1.20, timeout is 2 seconds:</span><br><span class="line">       press Ctrl+C to break </span><br><span class="line">      !!!!!</span><br><span class="line">      Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br><span class="line">      从以上显示信息可以看出，R-A通过静态域名解析，成功实现通过destination.com主机名访问IP地址为1.1.1.20的主机。</span><br><span class="line"></span><br><span class="line">------动态域名解析配置举例</span><br><span class="line">      拓扑图</span><br><span class="line">      动态域名解析配置组网图</span><br><span class="line"></span><br><span class="line">      应用需求</span><br><span class="line">      1. DNS域名服务器的IP地址为192.168.31.206/24。</span><br><span class="line">      2. 网络设备为DNS客户端，通过动态域名解析功能，实现通过host.com主机名访问IP地址为10.1.1.2的主机。</span><br><span class="line">      配置要点</span><br><span class="line">      1. DNS客户端和DNS服务器端、访问主机间的路由要可达</span><br><span class="line">      2. DNS域名解析开关打开。域名解析功能开关默认开启。</span><br><span class="line">      3. 正确配置DNS域名服务器的IP地址</span><br><span class="line">      配置步骤</span><br><span class="line">      第一步，配置DNS域名服务器</span><br><span class="line">      不同域名服务器的配置方法不同，请根据实际情况搭建DNS服务器。具体方法在此不做具体说明。</span><br><span class="line">      在DNS服务器上添加主机和IP地址的映射。本例中，设置主机名：host.com；IP地址为10.1.1.2/24</span><br><span class="line">      第二步，配置DNS客户端</span><br><span class="line">      DNS客户端和DNS服务器端、访问主机间的路由要可达。接口IP配置如拓扑图所示。具体配置过程此处省略。</span><br><span class="line">      ！打开DNS域名解析功能开关；该功能默认开启</span><br><span class="line">      R(config)#ip domain-lookup</span><br><span class="line">      ！配置域名服务器的IP地址为192.168.31.206</span><br><span class="line">      R(config)#ip name-server 192.168.31.206</span><br><span class="line">      配置验证</span><br><span class="line">      第一步，使用ping host.com命令，查看执行结果。</span><br><span class="line">      R# ping host.com</span><br><span class="line">      Translating  host.com ...[OK]</span><br><span class="line">      Sending 5, 100-byte ICMP Echoes to 10.1.1.2, timeout is 2 seconds:</span><br><span class="line">       press Ctrl+C to break </span><br><span class="line">      !!!!!</span><br><span class="line">      Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br><span class="line">      从以上显示信息可以看出，客户端设备能ping通主机，且对应的目的IP地址为10.1.1.2。设备通过动态域名解析，成功实现通过host.com主机名访问IP地址为10.1.1.2的主机。</span><br><span class="line">      第二步，查看域名解析信息；关注点主机名、主机IP地址。</span><br><span class="line">      R# show host</span><br><span class="line">      Name servers are:</span><br><span class="line">      192.168.31.206 static</span><br><span class="line">      Host type Address TTL(sec)</span><br><span class="line">      host.com dynamic 10.1.1.2 3503 </span><br><span class="line">      从以上显示信息可以看出，主机名同主机IP地址的映射表项正确。</span><br><span class="line"></span><br><span class="line">---全国DNS信息</span><br><span class="line">   电信域名系统列表　　（按拼音排序， 共32条）</span><br><span class="line">   电信</span><br><span class="line">   A安徽</span><br><span class="line">   202.102.192.68</span><br><span class="line">   202.102.199.68</span><br><span class="line">   61.132.163.68</span><br><span class="line">   202.102.213.68</span><br><span class="line">   电信</span><br><span class="line">   A澳门</span><br><span class="line">   202.175.3.8</span><br><span class="line">   202.175.3.3</span><br><span class="line">   电信</span><br><span class="line">   B北京</span><br><span class="line">   202.96.199.133</span><br><span class="line">   202.96.0.133</span><br><span class="line">   电信</span><br><span class="line">   C重庆</span><br><span class="line">   61.128.128.68</span><br><span class="line">   61.128.192.68</span><br><span class="line">   电信</span><br><span class="line">   F福建</span><br><span class="line">   218.85.157.99</span><br><span class="line">   电信</span><br><span class="line">   G甘肃</span><br><span class="line">   202.100.64.68</span><br><span class="line">   61.178.0.93</span><br><span class="line">   电信</span><br><span class="line">   G广东</span><br><span class="line">   202.96.128.86</span><br><span class="line">   202.96.128.166</span><br><span class="line">   202.96.134.133</span><br><span class="line">   202.96.128.68</span><br><span class="line">   电信</span><br><span class="line">   G广西</span><br><span class="line">   202.103.224.68</span><br><span class="line">   202.103.225.68</span><br><span class="line">   电信</span><br><span class="line">   G贵州</span><br><span class="line">   202.98.192.67</span><br><span class="line">   202.98.198.167</span><br><span class="line">   电信</span><br><span class="line">   H海南</span><br><span class="line">   202.100.192.68</span><br><span class="line">   202.100.199.8</span><br><span class="line">   电信</span><br><span class="line">   H河北</span><br><span class="line">   222.222.222.222</span><br><span class="line">   电信</span><br><span class="line">   H黑龙江</span><br><span class="line">   219.147.198.230</span><br><span class="line">   219.146.0.130</span><br><span class="line">   电信</span><br><span class="line">   H河南</span><br><span class="line">   219.150.150.150</span><br><span class="line">   222.88.88.88</span><br><span class="line">   222.85.85.85</span><br><span class="line">   电信</span><br><span class="line">   H湖北</span><br><span class="line">   202.103.0.68</span><br><span class="line">   202.103.24.68</span><br><span class="line">   202.103.0.117</span><br><span class="line">   202.103.44.150</span><br><span class="line">   电信</span><br><span class="line">   H湖南</span><br><span class="line">   222.246.129.80</span><br><span class="line">   59.51.78.211</span><br><span class="line">   电信</span><br><span class="line">   J江苏</span><br><span class="line">   61.177.7.1</span><br><span class="line">   61.147.37.1</span><br><span class="line">   218.2.135.1</span><br><span class="line">   221.228.255.1</span><br><span class="line">   电信</span><br><span class="line">   J江西</span><br><span class="line">   202.101.224.68</span><br><span class="line">   202.101.226.69</span><br><span class="line">   电信</span><br><span class="line">   J吉林</span><br><span class="line">   219.149.194.55</span><br><span class="line">   电信</span><br><span class="line">   N宁夏</span><br><span class="line">   202.100.96.68</span><br><span class="line">   222.75.152.129</span><br><span class="line">   电信</span><br><span class="line">   Q青海</span><br><span class="line">   202.100.128.68</span><br><span class="line">   电信</span><br><span class="line">   S山东</span><br><span class="line">   219.146.0.130</span><br><span class="line">   电信</span><br><span class="line">   S上海</span><br><span class="line">   202.96.209.5</span><br><span class="line">   202.96.209.133</span><br><span class="line">   电信</span><br><span class="line">   S陕西</span><br><span class="line">   218.30.19.40</span><br><span class="line">   61.134.1.4</span><br><span class="line">   电信</span><br><span class="line">   S四川</span><br><span class="line">   61.139.2.69</span><br><span class="line">   202.98.96.68</span><br><span class="line">   218.6.200.139</span><br><span class="line">   61.139.54.66</span><br><span class="line">   电信</span><br><span class="line">   T天津</span><br><span class="line">   219.150.32.132</span><br><span class="line">   电信</span><br><span class="line">   X香港</span><br><span class="line">   205.252.144.126</span><br><span class="line">   218.102.62.71</span><br><span class="line">   电信</span><br><span class="line">   X新疆</span><br><span class="line">   61.128.114.166</span><br><span class="line">   61.128.114.133</span><br><span class="line">   电信</span><br><span class="line">   Y云南</span><br><span class="line">   222.172.200.68</span><br><span class="line">   61.166.150.123</span><br><span class="line">   电信</span><br><span class="line">   Z浙江</span><br><span class="line">   60.191.244.5</span><br><span class="line">   202.96.113.34</span><br><span class="line">   联通 DNS 列表 （按拼音排序， 共23条）</span><br><span class="line">   联通</span><br><span class="line">   A安徽</span><br><span class="line">   218.104.78.2</span><br><span class="line">   联通</span><br><span class="line">   B北京</span><br><span class="line">   202.106.0.20</span><br><span class="line">   202.106.196.115</span><br><span class="line">   联通</span><br><span class="line">   G甘肃</span><br><span class="line">   221.7.34.10</span><br><span class="line">   联通</span><br><span class="line">   G广东</span><br><span class="line">   221.4.66.66</span><br><span class="line">   210.21.4.130</span><br><span class="line">   221.4.8.1</span><br><span class="line">   联通</span><br><span class="line">   G广西</span><br><span class="line">   211.97.64.129</span><br><span class="line">   221.7.128.68</span><br><span class="line">   221.7.136.68</span><br><span class="line">   联通</span><br><span class="line">   H海南</span><br><span class="line">   221.11.132.2</span><br><span class="line">   联通</span><br><span class="line">   H河北</span><br><span class="line">   202.99.160.68</span><br><span class="line">   202.99.166.4</span><br><span class="line">   联通</span><br><span class="line">   H黑龙江</span><br><span class="line">   202.97.224.68</span><br><span class="line">   202.97.224.69</span><br><span class="line">   联通</span><br><span class="line">   H河南</span><br><span class="line">   202.102.224.68</span><br><span class="line">   202.102.227.68</span><br><span class="line">   联通</span><br><span class="line">   H湖北</span><br><span class="line">   218.104.111.122</span><br><span class="line">   218.104.111.114</span><br><span class="line">   联通</span><br><span class="line">   H湖南</span><br><span class="line">   58.20.127.170</span><br><span class="line">   58.20.57.4</span><br><span class="line">   联通</span><br><span class="line">   J江苏</span><br><span class="line">   221.6.4.66</span><br><span class="line">   221.6.96.177</span><br><span class="line">   218.104.32.106</span><br><span class="line">   联通</span><br><span class="line">   J江西</span><br><span class="line">   220.248.192.12</span><br><span class="line">   220.248.192.13</span><br><span class="line">   联通</span><br><span class="line">   J吉林</span><br><span class="line">   202.98.0.68</span><br><span class="line">   202.98.5.68</span><br><span class="line">   联通</span><br><span class="line">   L辽宁</span><br><span class="line">   202.96.69.38</span><br><span class="line">   202.96.64.68</span><br><span class="line">   联通</span><br><span class="line">   N内蒙古</span><br><span class="line">   202.99.224.8</span><br><span class="line">   202.99.224.67</span><br><span class="line">   202.99.224.68</span><br><span class="line">   联通</span><br><span class="line">   S山东</span><br><span class="line">   202.102.152.3</span><br><span class="line">   202.102.134.68</span><br><span class="line">   联通</span><br><span class="line">   S上海</span><br><span class="line">   210.22.70.3</span><br><span class="line">   210.22.84.3</span><br><span class="line">   210.52.207.2</span><br><span class="line">   联通</span><br><span class="line">   S山西</span><br><span class="line">   202.99.192.66</span><br><span class="line">   202.99.192.68</span><br><span class="line">   联通</span><br><span class="line">   S四川</span><br><span class="line">   221.10.251.196</span><br><span class="line">   联通</span><br><span class="line">   T天津</span><br><span class="line">   202.99.96.68</span><br><span class="line">   202.99.104.68</span><br><span class="line">   联通</span><br><span class="line">   Y云南</span><br><span class="line">   221.3.131.9</span><br><span class="line">   221.3.131.10</span><br><span class="line">   联通</span><br><span class="line">   Z浙江</span><br><span class="line">   西宁</span><br><span class="line">   221.12.1.228</span><br><span class="line">   221.207.58.58</span><br><span class="line">   221.12.33.228</span><br><span class="line">   221.207.58.68</span><br><span class="line">   221.12.65.228</span><br><span class="line">   218.108.248.200</span><br><span class="line">   211.138.30.66</span><br><span class="line"></span><br><span class="line">---港澳台dns地址</span><br><span class="line">   208.151.69.65</span><br><span class="line">   202.181.202.140</span><br><span class="line">   附送大型企业的几个DNS服务器地址</span><br><span class="line">   114DNS</span><br><span class="line">   在国内使用很差，上网会不稳定</span><br><span class="line"></span><br><span class="line">---IPv6公共DNS信息</span><br><span class="line"></span><br><span class="line">---热门事件</span><br><span class="line">   北京时间2014年1月21日，下午15时20分左右，全国大范围出现DNS故障，中国顶级域名根服务器出现故障，大部分网站受影响，此次故障未对国家顶级域名.CN造成影响，所有运行服务正常。[4]</span><br></pre></td></tr></table></figure><p>词条的分级内容由不同长度的短横线表示。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 正则表达式</title>
      <link href="/2018/07/17/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/07/17/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个模式(规则)的文本。</p><span id="more"></span><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><ul><li><p>在正则表达式中，如果直接给出字符，就是精确匹配。</p></li><li><p>用\d可以匹配一个数字，\w可以匹配一个字母或数字<br>‘00\d’可以匹配’007’，但无法匹配’00A’；<br>‘\d\d\d’可以匹配’010’；<br>‘\w\w\d’可以匹配’py3’；</p></li><li><p>.可以匹配任意字符<br>‘py.’可以匹配’pyc’、’pyo’、’py!’等等</p></li><li><p>要匹配变长的字符，在正则表达式中，<br>用*表示任意个字符（包括0个）<br>用+表示至少一个字符<br>用?表示0个或1个字符<br>用{n}表示n个字符<br>用{n,m}表示n-m个字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">来看一个复杂的例子：\d&#123;3&#125;\s+\d&#123;3,8&#125;</span><br><span class="line">\d&#123;3&#125;表示匹配3个数字，例如&#x27;010&#x27;；</span><br><span class="line">\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&#x27; &#x27;，&#x27; &#x27;等；</span><br><span class="line">\d&#123;3,8&#125;表示3-8个数字，例如&#x27;1234567&#x27;。</span><br><span class="line">综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</span><br><span class="line">如果要匹配&#x27;010-12345&#x27;这样的号码呢？由于&#x27;-&#x27;是特殊字符，在正则表达式中，要用&#x27;\&#x27;转义，所以，上面的正则是\d&#123;3&#125;\-\d&#123;3,8&#125;。</span><br><span class="line">但是，仍然无法匹配&#x27;010 - 12345&#x27;，因为带有空格。所以我们需要更复杂的匹配方式。</span><br></pre></td></tr></table></figure></li><li><p>要做更精确地匹配，可以用[]表示范围<br>[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线<br>[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等。<br>[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量。<br>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p></li><li><p>A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。</p></li><li><p>^表示行的开头，^\d表示必须以数字开头。</p></li><li><p>$表示行的结束，\d$表示必须以数字结束。</p></li><li><p>由于Python的字符串本身也用\转义，所以要特别注意：<br>s &#x3D; ‘ABC\\-001’   # Python的字符串<br>对应的正则表达式字符串变成：<br>‘ABC\-001’</p></li><li><p>建议使用Python的r前缀，就不用考虑转义的问题<br>s &#x3D; r’ABC-001’    # Python的字符串<br>对应的正则表达式字符串不变：<br>‘ABC-001’</p></li></ul><p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</p><ul><li>给定的字符串是否符合正则表达式的过滤逻辑（“匹配”）；</li><li>通过正则表达式，从文本字符串中获取我们想要的特定部分（“过滤”）。</li></ul><h3 id="Python-的-re-模块"><a href="#Python-的-re-模块" class="headerlink" title="Python 的 re 模块"></a>Python 的 re 模块</h3><p>正则表达式使用 对特殊字符进行转义，所以如果我们要使用原始字符串，只需加一个 r 前缀。</p><p>re 模块的一般使用步骤如下：</p><ul><li>使用 compile() 函数将正则表达式的字符串形式编译为一个 Pattern 对象</li><li>通过 Pattern 对象提供的一系列方法对文本进行匹配查找，获得匹配结果，一个 Match 对象。</li><li>最后使用 Match 对象提供的属性和方法获得信息，根据需要进行其他的操作</li></ul><h4 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile 函数"></a>compile 函数</h4><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤。</p><p>compile 函数用于编译正则表达式，生成一个 Pattern 对象，它的一般使用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"># 将正则表达式编译成 Pattern 对象</span><br><span class="line">pattern = re.compile(r&#x27;\d+&#x27;)</span><br></pre></td></tr></table></figure><p>在上面，我们已将一个正则表达式编译成 Pattern 对象，接下来，我们就可以利用 pattern 的一系列方法对文本进行匹配查找了。</p><p>Pattern 对象的一些常用方法主要有：</p><h5 id="match-方法"><a href="#match-方法" class="headerlink" title="match 方法"></a>match 方法</h5><p>match 方法：从起始位置开始查找，一次匹配。</p><p>match 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。它的一般使用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。因此，当你不指定 pos 和 endpos 时，match 方法默认匹配字符串的头部。</p><p>当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。<br>当匹配成功时返回一个 Match 对象，其中：</p><p>group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；</p><p>start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</p><p>end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</p><p>span([group]) 方法返回 (start(group), end(group))。</p><h5 id="search-方法"><a href="#search-方法" class="headerlink" title="search 方法"></a>search 方法</h5><p>search 方法：从任何位置开始查找，一次匹配。</p><p>search 方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果，它的一般使用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。</p><p>当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。</p><h5 id="findall-方法"><a href="#findall-方法" class="headerlink" title="findall 方法"></a>findall 方法</h5><p>findall 方法：全部匹配，返回列表</p><p>上面的 match 和 search 方法都是一次匹配，只要找到了一个匹配的结果就返回。然而，在大多数时候，我们需要搜索整个字符串，获得所有匹配的结果。</p><p>findall 方法的使用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。</p><p>findall 以列表形式返回全部能匹配的子串，如果没有匹配，则返回一个空列表。</p><h5 id="finditer-方法"><a href="#finditer-方法" class="headerlink" title="finditer 方法"></a>finditer 方法</h5><p>finditer 方法：全部匹配，返回迭代器</p><p>finditer 方法的行为跟 findall 的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果（Match 对象）的迭代器。</p><h5 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h5><p>split 方法：分割字符串，返回列表<br>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split(string[, maxsplit])</span><br></pre></td></tr></table></figure><p>其中，maxsplit 用于指定最大分割次数，不指定将全部分割。</p><h5 id="sub-方法"><a href="#sub-方法" class="headerlink" title="sub 方法"></a>sub 方法</h5><p>sub 方法：替换</p><p>sub 方法用于替换。它的使用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub(repl, string[, count])</span><br></pre></td></tr></table></figure><p>其中，repl 可以是字符串也可以是一个函数：</p><ul><li>如果 repl 是字符串，则会使用 repl 去替换字符串每一个匹配的子串，并返回替换后的字符串，另外，repl 还可以使用 id 的形式来引用分组，但不能使用编号 0；</li><li>如果 repl 是函数，这个方法应当只接受一个参数（Match 对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。</li></ul><p>count 用于指定最多替换次数，不指定时全部替换。</p><h4 id="匹配中文"><a href="#匹配中文" class="headerlink" title="匹配中文"></a>匹配中文</h4><p>在某些情况下，我们想匹配文本中的汉字，有一点需要注意的是，中文的 unicode 编码范围 主要在 [u4e00-u9fa5]，这里说主要是因为这个范围并不完整，比如没有包括全角（中文）标点，不过，在大部分情况下，应该是够用的。</p><p>假设现在想把字符串 title &#x3D; u’你好，hello，世界’ 中的中文提取出来，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">title = u&#x27;你好，hello，世界&#x27;</span><br><span class="line">pattern = re.compile(ur&#x27;[\u4e00-\u9fa5]+&#x27;)</span><br><span class="line">result = pattern.findall(title)</span><br><span class="line">print result</span><br></pre></td></tr></table></figure><p>注意到，我们在正则表达式前面加上了两个前缀 ur，其中 r 表示使用原始字符串，u 表示是 unicode 字符串。<br>执行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[u&#x27;\u4f60\u597d&#x27;, u&#x27;\u4e16\u754c&#x27;]</span><br></pre></td></tr></table></figure><h4 id="贪婪模式与非贪婪-模式"><a href="#贪婪模式与非贪婪-模式" class="headerlink" title="贪婪模式与非贪婪*模式"></a>贪婪模式与非贪婪*模式</h4><ul><li>贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配 ( * )；</li><li>非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配 ( ? )；</li></ul><p>Python里数量词默认是贪婪的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python urllib3构造OneNET HTTP SDK</title>
      <link href="/2018/07/16/%E4%BD%BF%E7%94%A8Python-urllib3%E6%9E%84%E9%80%A0OneNET-HTTP-SDK/"/>
      <url>/2018/07/16/%E4%BD%BF%E7%94%A8Python-urllib3%E6%9E%84%E9%80%A0OneNET-HTTP-SDK/</url>
      
        <content type="html"><![CDATA[<p>Python based SDK of OneNET HTTP protocol device<br>环境：Python 3.6<br>库依赖：urllib3 、 urllib 、os 、json<br>说明：onenet_http_api模块使用非常简单，使用该模块，用户不需要将精力放在网络通信接口上，而可以更多的去关注数据内容。<br><a href="https://github.com/MrBluyee/OneNET_Python_SDK">github源码</a></p><span id="more"></span><h3 id="开始使用："><a href="#开始使用：" class="headerlink" title="开始使用："></a>开始使用：</h3><p>import 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> onenet_http_api</span><br></pre></td></tr></table></figure><p>然后创建一个OneNetHTTPHandle实例。该实例处理与OneNet以HTTP协议通信的所有内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = onenet_http_api.OneNetHTTPHandle()</span><br></pre></td></tr></table></figure><h2 id="API介绍："><a href="#API介绍：" class="headerlink" title="API介绍："></a>API介绍：</h2><h3 id="设备："><a href="#设备：" class="headerlink" title="设备："></a>设备：</h3><h4 id="1-注册设备："><a href="#1-注册设备：" class="headerlink" title="1.注册设备："></a>1.注册设备：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_device(master_key,register_code,new_device_authinfo,new_device_name)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key: 为产品的APIKEY<br><br>register_code: 正式环境注册码<br><br>new_device_authinfo: 新建HTTP设备的设备唯一编号<br><br>new_device_name: 新建HTTP设备的设备名<br><br>返回：<br><br>若成功，则返回一个包含device_id和key的dict<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>master_key = <span class="string">&#x27;6K9Nxxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register_code = <span class="string">&#x27;1Wxxxxxxxxxxxx3&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_device_authinfo = <span class="string">&#x27;201805141201&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_device_name = <span class="string">&#x27;device1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.register_device(master_key,register_code,new_device_authinfo,new_device_name)</span><br><span class="line">&#123;<span class="string">&#x27;device_id&#x27;</span>: <span class="string">&#x27;31036923&#x27;</span>, <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;VfmTxxxxxxxxxxxxxxx&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取指定设备的信息"><a href="#2-获取指定设备的信息" class="headerlink" title="2.获取指定设备的信息"></a>2.获取指定设备的信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_device_info(key,device_id)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>返回：<br><br>若成功，则返回一个包含设备信息的dict<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_device_info(key,device_id)</span><br><span class="line">&#123;<span class="string">&#x27;private&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;protocol&#x27;</span>: <span class="string">&#x27;HTTP&#x27;</span>, <span class="string">&#x27;create_time&#x27;</span>: <span class="string">&#x27;2018-05-14 12:02:40&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;keys&#x27;</span>: [&#123;<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;auto generated device key&#x27;</span>, <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;VfmTxxxxxxxxxxxxxxxx=&#x27;</span>&#125;],</span><br><span class="line"> <span class="string">&#x27;online&#x27;</span>: <span class="literal">False</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;31xxxx&#x27;</span>, <span class="string">&#x27;auth_info&#x27;</span>: <span class="string">&#x27;201805141201&#x27;</span>, <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;device1&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-获取所有设备的信息："><a href="#3-获取所有设备的信息：" class="headerlink" title="3.获取所有设备的信息："></a>3.获取所有设备的信息：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_all_devices_info(master_key)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>返回：<br><br>若成功，则返回一个包含所有设备信息的dict<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_all_devices_info(master_key)</span><br></pre></td></tr></table></figure><h4 id="4-修改设备信息："><a href="#4-修改设备信息：" class="headerlink" title="4.修改设备信息："></a>4.修改设备信息：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modify_device_profile(key,device_id,**profile)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>可选参数：<br><br>“title”: “mydevice”, &#x2F;&#x2F;设备名（可选，最长16个字符）<br><br>“desc”: “some description”, &#x2F;&#x2F;设备描述（可选，最长16个字符）<br><br>“tags”: [“china”,”mobile”] , &#x2F;&#x2F;设备标签（可选）<br><br>“protocol”:”HTTP “, &#x2F;&#x2F;选择一种接入协议（可选）<br><br>“location”: {“lon”:106, “lat”: 29, “ele”: 370},&#x2F;&#x2F;设备位置{“经度”, “纬度”, “高度”}（可选）<br><br>“private”: true| false, &#x2F;&#x2F;设备私密性（可选）<br><br>“auth_info”:”201503041a5829151”, &#x2F;&#x2F;HTTP设备：”设备唯一编号”（可选）<br><br>“other”: {“version”: “1.0.0”, “manufacturer”: “china mobile”} &#x2F;&#x2F;其他信息（可选）<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>profile = &#123;</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;mydevice&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;desc&#x27;</span>: <span class="string">&#x27;some description&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;china&#x27;</span>,<span class="string">&#x27;mobile&#x27;</span>],</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;auth_info&#x27;</span>: <span class="string">&#x27;201805141226&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.modify_device_profile(key,device_id,**profile)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.modify_device_profile(key,device_id,title = <span class="string">&#x27;device1&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="5-删除设备："><a href="#5-删除设备：" class="headerlink" title="5.删除设备："></a>5.删除设备：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete_device(key,device_id)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br></p><p>说明：删除设备会删除该设备下所有数据流和数据点。<br><br>删除设备动作是异步的，系统会在后续逐步删除该设备下的数据流和数据点。<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.delete_device(key,device_id)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="数据流："><a href="#数据流：" class="headerlink" title="数据流："></a>数据流：</h3><h4 id="1-创建数据流："><a href="#1-创建数据流：" class="headerlink" title="1.创建数据流："></a>1.创建数据流：</h4><p>（建议在网页上通过设置数据流模板代替）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_device_datastream(key,device_id,stream_id,**profile)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>stream_id：数据流名称<br><br>可选参数：<br><br>“tags”:[“Tag1”,”Tag2”], &#x2F;&#x2F;数据流标签（可选，可以为一个或多个）<br><br>“unit”:”celsius”, &#x2F;&#x2F;单位（可选）<br><br>“unit_symbol”:”C” &#x2F;&#x2F;单位符号（可选）<br><br>返回：<br><br>若成功，则返回包含ds_uuid的dict<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stream_id = <span class="string">&#x27;datastream&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.create_device_datastream(key,device_id,stream_id)</span><br><span class="line">&#123;<span class="string">&#x27;ds_uuid&#x27;</span>: <span class="string">&#x27;8a9497b0-8863-58a6-8277-xxxxxxxxxxxxxxxxxx&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改数据流参数："><a href="#2-修改数据流参数：" class="headerlink" title="2.修改数据流参数："></a>2.修改数据流参数：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modify_device_datastream_profile(key,device_id,stream_id,**profile)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>stream_id：数据流名称<br><br>可选参数：<br><br>“tags”:[“Tag1”,”Tag2”], &#x2F;&#x2F;数据流标签（可选，可以为一个或多个）<br><br>“unit”:”celsius”, &#x2F;&#x2F;单位（可选）<br><br>“unit_symbol”:”C” &#x2F;&#x2F;单位符号（可选）<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>modify_profile = &#123;</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;Tag1&#x27;</span>,<span class="string">&#x27;Tag2&#x27;</span>],</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;unit&#x27;</span>: <span class="string">&#x27;celsius&#x27;</span>,</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;unit_symbol&#x27;</span>: <span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.modify_device_datastream_profile(key,device_id,stream_id,**modify_profile)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-获取数据流："><a href="#3-获取数据流：" class="headerlink" title="3.获取数据流："></a>3.获取数据流：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_device_datastream(key,device_id,stream_id)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>stream_id：数据流名称<br><br>返回：<br><br>若成功，则返回包含数据流信息的dict<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_device_datastream(key,device_id,stream_id)</span><br><span class="line">[&#123;<span class="string">&#x27;unit&#x27;</span>: <span class="string">&#x27;celsius&#x27;</span>, <span class="string">&#x27;create_time&#x27;</span>: <span class="string">&#x27;2018-05-14 12:35:12&#x27;</span>, <span class="string">&#x27;unit_symbol&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;datastream&#x27;</span>, <span class="string">&#x27;uuid&#x27;</span>: <span class="string">&#x27;8a9497b0-8863-58a6-8277-xxxxxxx&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>: [<span class="string">&#x27;Tag1&#x27;</span>, <span class="string">&#x27;Tag2&#x27;</span>]&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-删除数据流："><a href="#4-删除数据流：" class="headerlink" title="4.删除数据流："></a>4.删除数据流：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete_device_datastream(key,device_id,stream_id)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>stream_id：数据流名称<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.delete_device_datastream(key,device_id,stream_id)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="数据点："><a href="#数据点：" class="headerlink" title="数据点："></a>数据点：</h3><h4 id="1-新增数据点："><a href="#1-新增数据点：" class="headerlink" title="1.新增数据点："></a>1.新增数据点：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_datapoints(key,device_id,datapoints)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>datapoints：数据点<br><br>datapoints格式为：<br><br>datapoints &#x3D; {stream_id:data}<br><br>可选参数：<br><br>local_timestamp：本地时间戳<br><br>格式必须为”YYYY-MM-DDThh:mm:ss”的形式<br><br>(例如：2018-05-14T13:21:12）<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datapoints = &#123;</span><br><span class="line"><span class="meta">... </span>stream_id:<span class="number">10</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.post_datapoints(key,device_id,datapoints)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datapoints = &#123;</span><br><span class="line"><span class="meta">... </span>stream_id:<span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.post_datapoints(key,device_id,datapoints)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datapoints = &#123;</span><br><span class="line"><span class="meta">... </span>stream_id:<span class="number">20</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.post_datapoints(key,device_id,datapoints,local_timestamp = <span class="string">&#x27;2018-05-14T13:21:12&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-获取数据点："><a href="#2-获取数据点：" class="headerlink" title="2.获取数据点："></a>2.获取数据点：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_datapoints(key,device_id,**args)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>可选参数：<br><br>datastream_id&#x3D;a,b,c &#x2F;&#x2F;查询的数据流，多个数据流之间用逗号分隔（可选）<br><br>start&#x3D;2015-01-10T08:00:35 &#x2F;&#x2F;提取数据点的开始时间（可选）<br><br>end&#x3D;2015-01-10T08:00:35 &#x2F;&#x2F;提取数据点的结束时间（可选）<br><br>duration&#x3D;3600 &#x2F;&#x2F;查询时间区间（可选，单位为秒）<br><br>（start+duration：按时间顺序返回从start开始一段时间内的数据点）<br><br>（end+duration：按时间倒序返回从end回溯一段时间内的数据点）<br><br>limit&#x3D;100 &#x2F;&#x2F;限定本次请求最多返回的数据点数，0&lt;n&lt;&#x3D;6000（可选，默认1440）<br><br>cursor&#x3D; &#x2F;&#x2F;指定本次请求继续从cursor位置开始提取数据（可选）<br><br>sort&#x3D;DESC | ASC &#x2F;&#x2F;值为DESC|ASC时间排序方式，DESC:倒序，ASC升序，<br><br>（带任何参数或仅携带limit参数-默认降序，其他情况-默认升序）<br><br>返回：<br><br>若成功，则返回选择获取的数据点<br><br>若失败，则返回错误信息<br><br>说明：<br><br>1.若不携带任何可选参数，返回本设备所存在的所有数据流中的最新数据。<br><br>2.若不携带数据流id参数，携带limit参数时，会返回该设备每个数据流最多limit条数据。<br><br>其他情况limit参数用于限制返回数据点总数。<br><br>3.若要查看某一条数据流数据，需在可选参数中携带参数datastream_id。<br><br>4.要查看某一条数据流在某个时间范围内的数据，可以在增加start和end参数。<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_datapoints(key,device_id)</span><br><span class="line">&#123;<span class="string">&#x27;count&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;datastreams&#x27;</span>: [&#123;<span class="string">&#x27;datapoints&#x27;</span>: [&#123;<span class="string">&#x27;at&#x27;</span>: <span class="string">&#x27;2018-05-14 13:21:12.000&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="number">20</span>&#125;], <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;datastream&#x27;</span>&#125;]&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_datapoints(key,device_id,datastream_id = stream_id)</span><br><span class="line">&#123;<span class="string">&#x27;count&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;datastreams&#x27;</span>: [&#123;<span class="string">&#x27;datapoints&#x27;</span>: [&#123;<span class="string">&#x27;at&#x27;</span>: <span class="string">&#x27;2018-05-14 13:26:12.878&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>&#125;], <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;datastream&#x27;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制数据流："><a href="#二进制数据流：" class="headerlink" title="二进制数据流："></a>二进制数据流：</h3><h4 id="1-新增二进制数据流："><a href="#1-新增二进制数据流：" class="headerlink" title="1.新增二进制数据流："></a>1.新增二进制数据流：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_bindata(key,device_id,stream_id,bindata)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>stream_id：数据流名称<br><br>bindata: 要上传的普通二进制数据<br><br>返回：<br><br>若成功，则返回二进制数据索引号<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bindata = <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.post_bindata(key,device_id,stream_id,bindata)</span><br><span class="line">&#123;<span class="string">&#x27;index&#x27;</span>: <span class="string">&#x27;31037105_xxxxxxxxxxx0_datastream&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取二进制数据流："><a href="#2-获取二进制数据流：" class="headerlink" title="2.获取二进制数据流："></a>2.获取二进制数据流：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_bindata(key,data_index)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>data_index：二进制数据索引号<br><br>返回：<br><br>若成功，则返回二进制数据<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_bindata(key,data_index)</span><br><span class="line"><span class="string">b&#x27;hello world!&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-新增文件："><a href="#3-新增文件：" class="headerlink" title="3.新增文件："></a>3.新增文件：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_file(key,device_id,stream_id,file_path)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>device_id： device_id<br><br>stream_id：数据流名称<br><br>file_path: 要上传的文件路径（包含文件名）<br><br>文件、图像等（最大限制为800k）<br><br>返回：<br><br>若成功，则返回文件索引号<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_path = <span class="string">&#x27;1.jpeg&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.post_file(key,device_id,stream_id,file_path)</span><br><span class="line">&#123;<span class="string">&#x27;index&#x27;</span>: <span class="string">&#x27;31037105_1xxxxxxxxxx_datastream&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="4-获取文件："><a href="#4-获取文件：" class="headerlink" title="4.获取文件："></a>4.获取文件：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_file(key,file_index)</span><br></pre></td></tr></table></figure><p>参数：<br><br>key：为masterkey 或者 设备apikey<br><br>file_index：文件索引号<br><br>可选参数：<br><br>file_path： 保存的文件路径（不含文件名）<br><br>否则保存在当前程序运行目录<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_file(key,file_index)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>（文件已保存在当前程序运行目录）<br></p><h3 id="触发器："><a href="#触发器：" class="headerlink" title="触发器："></a>触发器：</h3><p>触发器的含义是：当指定范围内的数据点满足触发条件的要求时，会向url参数指定的地址发送post请求。</p><h4 id="1-创建触发器："><a href="#1-创建触发器：" class="headerlink" title="1.创建触发器："></a>1.创建触发器：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_trigger(master_key,url,trigger_type,trigger_threshold,**args)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>url:例：”<a href="http://xx.bb.com/">http://xx.bb.com</a>“<br><br>trigger_type：&gt; | &gt;&#x3D; | &lt; | &lt;&#x3D; | &#x3D;&#x3D; | inout | in | out | change | frozen | live<br><br>trigger_threshold：阙值。<br><br>说明：<br></p><ol><li>type为&gt;|&gt;&#x3D;|&lt;|&lt;&#x3D;|&#x3D;&#x3D;时，threshold必须为数值。<br></li><li>type为inout时，threshold设置为{“lolmt”:40, “uplmt”:52}， 表示数据流的值首次进入或离开闭区间[40,52]时触发；<br></li><li>type为change时，threshold 参数不用传递；当上传的值有改变时触发告警。<br></li><li>type为frozen时，threshold 为数值，指定多少秒内未上报数据触发告警，同时被监控对象进入frozen状态。<br></li><li>type为live时，threshold为数值（必选大于0），指定当前上报数据点时间距离上次上报数据点时间间隔超过多少秒触发告警，一般与frozen配合使用。<br><br>可选参数：<br><br>“title”:”wen du jian kong”, &#x2F;&#x2F;设备名（可选）<br><br>“ds_id”:”gps”, &#x2F;&#x2F;数据流名称（id）（可选）<br><br>“dev_id”:”1027”, &#x2F;&#x2F;设备ID（可选）<br><br>“ds_uuids”:&#x2F;&#x2F;数据流uuid（可选）<br><br>说明：<br><br>触发器有三种工作触发模式<br><br>1)在请求参数中单独指定了ds_id，不包括其他参数，那么当前项目下所有设备的数据流中数据流名称符合ds_id的数据都会进入触发判断逻辑；<br><br>2)在请求参数中单独指定了ds_uuids数组，那么只有这些指定的数据流会进入触发判断逻辑；<br><br>3)在请求参数中指定了ds_id和dev_ids，那么只有这些指定的设备的数据流会进入触发判断逻辑。<br><br>返回：<br><br>若成功，则返回触发器ID<br><br>若失败，则返回错误信息<br><br>例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.create_trigger(master_key,url,<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">10</span>,ds_id = stream_id)</span><br><span class="line">&#123;<span class="string">&#x27;trigger_id&#x27;</span>: <span class="number">112410</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.create_trigger(master_key,url,<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">10</span>,ds_id = stream_id,dev_id = device_id)</span><br><span class="line">&#123;<span class="string">&#x27;trigger_id&#x27;</span>: <span class="number">112411</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-修改触发器参数："><a href="#2-修改触发器参数：" class="headerlink" title="2.修改触发器参数："></a>2.修改触发器参数：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modify_trigger(master_key,trigger_id,**args)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>trigger_id：触发器ID<br><br>可选参数：<br><br>“title”:”wen du jian kong”, &#x2F;&#x2F;设备名（可选）<br><br>“ds_id”:”gps”, &#x2F;&#x2F;数据流名称（id）（可选）<br><br>“dev_id”:”1027”, &#x2F;&#x2F;设备ID（可选）<br><br>“ds_uuids”: &#x2F;&#x2F;数据流uuid（可选）<br><br>“url”:”&#x2F;&#x2F;xx.bb.com”,<br><br>“type”:”&gt; | &gt;&#x3D; | &lt; | &lt;&#x3D; | &#x3D;&#x3D; | inout | in | out | change | frozen | live”,<br><br>“threshold”:100 <br><br>说明：<br><br>1.可选参数ds_id、dev_id、ds_uuids至少要传入一个。<br><br>2.要修改type或者threshold时，必须同时传入这两个参数才能够生效。<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.modify_trigger(master_key,trigger_id,ds_id = stream_id,<span class="built_in">type</span> = <span class="string">&#x27;&gt;=&#x27;</span>,threshold = <span class="number">100</span>)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-获取指定触发器信息："><a href="#3-获取指定触发器信息：" class="headerlink" title="3.获取指定触发器信息："></a>3.获取指定触发器信息：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_trigger_info(master_key,trigger_id)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>trigger_id：触发器ID<br><br>返回：<br><br>若成功，则返回触发器信息<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_trigger_info(master_key,trigger_id)</span><br><span class="line">&#123;<span class="string">&#x27;create_time&#x27;</span>: <span class="string">&#x27;2018-05-14 14:07:26&#x27;</span>, <span class="string">&#x27;target_type&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;threshold&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">112411</span>, <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;&gt;=&#x27;</span>, <span class="string">&#x27;ds_id&#x27;</span>: <span class="string">&#x27;datastream&#x27;</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;http://www.mrbluyee.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="4-获取所有触发器信息："><a href="#4-获取所有触发器信息：" class="headerlink" title="4.获取所有触发器信息："></a>4.获取所有触发器信息：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_all_triggers_info(master_key)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>返回：<br><br>若成功，则返回所有触发器信息<br><br>若失败，则返回错误信息<br><br>例：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.get_all_triggers_info(master_key)</span><br></pre></td></tr></table></figure><h4 id="5-删除触发器："><a href="#5-删除触发器：" class="headerlink" title="5.删除触发器："></a>5.删除触发器：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete_trigger(master_key,trigger_id)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>trigger_id：触发器ID<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.delete_trigger(master_key,trigger_id)</span><br><span class="line"><span class="string">&#x27;succ&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="APIKEY"><a href="#APIKEY" class="headerlink" title="APIKEY:"></a>APIKEY:</h3><h4 id="1-创建APIKey："><a href="#1-创建APIKey：" class="headerlink" title="1.创建APIKey："></a>1.创建APIKey：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_apikey(master_key,key_title,resources,access_methods)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>key_title： key的名称<br><br>resources：被授权的资源<br><br>参数格式：<br><br>resources &#x3D; ({“dev_id”: device_id1},{“dev_id”: device_id2})<br><br>access_methods：被授权的命令<br><br>参数格式：<br><br>access_methods &#x3D;（’get’,’put’)<br><br>说明：授权命令是可选的，另外被授权的命令也可以是get、put、post的一个或几个，如只授权get和put命令：”access_methods”: [“get”,”put”]<br><br>返回：<br><br>若成功，则返回key_string<br><br>若失败，则返回错误信息<br></p><h4 id="2-修改APIKey："><a href="#2-修改APIKey：" class="headerlink" title="2.修改APIKey："></a>2.修改APIKey：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modify_apikey(master_key,key_string,**args)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>key_string： key_string<br><br>可选参数：<br><br>title： key的名称<br><br>resources：被授权的资源<br><br>access_methods：被授权的命令<br><br>说明：<br><br>1.对于master key不允许更新操作，masterkey默认具有最大权限，可以访问该用户名下所有设备、所有数据，可以进行POST、GET、PUT、DELETE操作。<br><br>如果更新master key系统会返回失败。<br><br>2..API key更新是覆盖操作，会将原来存在的授权资源和授权命令覆盖，不会保留原来的授权资源和授权命令。<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br></p><h4 id="3-获取APIKey信息："><a href="#3-获取APIKey信息：" class="headerlink" title="3.获取APIKey信息："></a>3.获取APIKey信息：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_apikey_info(master_key,**args)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>可选参数：<br><br>key &#x3D; key_string&#x2F;&#x2F;可选，只查看该key相关信息<br><br>page &#x3D; 1 &#x2F;&#x2F;指定页码, 可选<br><br>per_page &#x3D; 10 &#x2F;&#x2F;指定每页输出个数,可选,默认10，最多100<br><br>device_id &#x3D; xxbbcc&#x2F;&#x2F;可选,只查看与该设备相关的非master-key<br><br>返回：<br><br>若成功，则返回APIKey信息<br><br>若失败，则返回错误信息<br></p><h4 id="4-删除APIKey："><a href="#4-删除APIKey：" class="headerlink" title="4.删除APIKey："></a>4.删除APIKey：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete_apikey(master_key,key_string)</span><br></pre></td></tr></table></figure><p>参数：<br><br>master_key：masterkey<br><br>key_string： key_string<br><br>返回：<br><br>若成功，则返回’succ’<br><br>若失败，则返回错误信息<br></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python urllib3</title>
      <link href="/2018/07/14/Python-urllib3/"/>
      <url>/2018/07/14/Python-urllib3/</url>
      
        <content type="html"><![CDATA[<h3 id="First-things-first-import-the-urllib3-module"><a href="#First-things-first-import-the-urllib3-module" class="headerlink" title="First things first, import the urllib3 module"></a>First things first, import the urllib3 module</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib3</span><br></pre></td></tr></table></figure><h3 id="Making-requests"><a href="#Making-requests" class="headerlink" title="Making requests"></a>Making requests</h3><p>PoolManager instance：This object handles all of the details of connection pooling and thread safety。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http = urllib3.PoolManager()</span><br></pre></td></tr></table></figure><p>To make a request use request()：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = http.request(&#x27;GET&#x27;, &#x27;http://httpbin.org/robots.txt&#x27;)</span><br><span class="line">r.data</span><br></pre></td></tr></table></figure><p>request() returns a HTTPResponse object</p><p>You can use request() to make requests using any HTTP verb：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;POST&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/post&#x27;,</span><br><span class="line">...     fields=&#123;&#x27;hello&#x27;: &#x27;world&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>The Request data section covers sending other kinds of requests data, including JSON, files, and binary data.</p><h3 id="Response-content"><a href="#Response-content" class="headerlink" title="Response content"></a>Response content</h3><p>The HTTPResponse object provides status, data, and header attributes：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(&#x27;GET&#x27;, &#x27;http://httpbin.org/ip&#x27;)</span><br><span class="line">&gt;&gt;&gt; r.status</span><br><span class="line">200</span><br><span class="line">&gt;&gt;&gt; r.data</span><br><span class="line">b&#x27;&#123;\n  &quot;origin&quot;: &quot;104.232.115.37&quot;\n&#125;\n&#x27;</span><br><span class="line">&gt;&gt;&gt; r.headers</span><br><span class="line">HTTPHeaderDict(&#123;&#x27;Content-Length&#x27;: &#x27;33&#x27;, ...&#125;)</span><br></pre></td></tr></table></figure><h4 id="JSON-content"><a href="#JSON-content" class="headerlink" title="JSON content"></a>JSON content</h4><p>JSON content can be loaded by decoding and deserializing the data attribute of the request：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; r = http.request(&#x27;GET&#x27;, &#x27;http://httpbin.org/ip&#x27;)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))</span><br><span class="line">&#123;&#x27;origin&#x27;: &#x27;127.0.0.1&#x27;&#125;</span><br></pre></td></tr></table></figure><h4 id="Binary-content"><a href="#Binary-content" class="headerlink" title="Binary content"></a>Binary content</h4><p>The data attribute of the response is always set to a byte string representing the response content：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(&#x27;GET&#x27;, &#x27;http://httpbin.org/bytes/8&#x27;)</span><br><span class="line">&gt;&gt;&gt; r.data</span><br><span class="line">b&#x27;\xaa\xa5H?\x95\xe9\x9b\x11&#x27;</span><br></pre></td></tr></table></figure><p>Note: For larger responses, it’s sometimes better to stream the response.</p><h3 id="Request-data"><a href="#Request-data" class="headerlink" title="Request data"></a>Request data</h3><h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h4><p>You can specify headers as a dictionary in the headers argument in request()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/headers&#x27;,</span><br><span class="line">...     headers=&#123;</span><br><span class="line">...         &#x27;X-Something&#x27;: &#x27;value&#x27;</span><br><span class="line">...     &#125;)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))[&#x27;headers&#x27;]</span><br><span class="line">&#123;&#x27;X-Something&#x27;: &#x27;value&#x27;, ...&#125;</span><br></pre></td></tr></table></figure><h4 id="Query-parameters"><a href="#Query-parameters" class="headerlink" title="Query parameters"></a>Query parameters</h4><p>For GET, HEAD, and DELETE requests, you can simply pass the arguments as a dictionary in the fields argument to request()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/get&#x27;,</span><br><span class="line">...     fields=&#123;&#x27;arg&#x27;: &#x27;value&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))[&#x27;args&#x27;]</span><br><span class="line">&#123;&#x27;arg&#x27;: &#x27;value&#x27;&#125;</span><br></pre></td></tr></table></figure><p>For POST and PUT requests, you need to manually encode query parameters in the URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib.parse import urlencode</span><br><span class="line">&gt;&gt;&gt; encoded_args = urlencode(&#123;&#x27;arg&#x27;: &#x27;value&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; url = &#x27;http://httpbin.org/post?&#x27; + encoded_args</span><br><span class="line">&gt;&gt;&gt; r = http.request(&#x27;POST&#x27;, url)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))[&#x27;args&#x27;]</span><br><span class="line">&#123;&#x27;arg&#x27;: &#x27;value&#x27;&#125;</span><br></pre></td></tr></table></figure><h4 id="Form-data"><a href="#Form-data" class="headerlink" title="Form data"></a>Form data</h4><p>For PUT and POST requests, urllib3 will automatically form-encode the dictionary in the fields argument provided to request()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;POST&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/post&#x27;,</span><br><span class="line">...     fields=&#123;&#x27;field&#x27;: &#x27;value&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))[&#x27;form&#x27;]</span><br><span class="line">&#123;&#x27;field&#x27;: &#x27;value&#x27;&#125;</span><br></pre></td></tr></table></figure><p>multipart&#x2F;form-data请求:</p><ul><li>1、multipart&#x2F;form-data的基础方法是post，也就是说是由post方法来组合实现的</li><li>2、multipart&#x2F;form-data与post方法的不同之处：请求头，请求体。</li><li>3、multipart&#x2F;form-data的请求头必须包含一个特殊的头信息：Content-Type，且其值也必须规定为multipart&#x2F;form-data，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，不然接收方就无法正常解析和还原这个文件了。<br>具体的头信息如下：<br>Content-Type: multipart&#x2F;form-data; boundary&#x3D;${bound}<br>其中${bound} 是一个占位符，代表我们规定的分割符，可以自己任意规定，但为了避免和正常文本重复了，尽量要使用复杂一点的内容。</li><li>4、multipart&#x2F;form-data的请求体也是一个字符串，不过和post的请求体不同的是它的构造方式，post是简单的name&#x3D;value值连接，而multipart&#x2F;form-data则是添加了分隔符等内容的构造体。</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>You can sent JSON a request by specifying the encoded data as the body argument and setting the Content-Type header when calling request()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; data = &#123;&#x27;attribute&#x27;: &#x27;value&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; encoded_data = json.dumps(data).encode(&#x27;utf-8&#x27;)</span><br><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;POST&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/post&#x27;,</span><br><span class="line">...     body=encoded_data,</span><br><span class="line">...     headers=&#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))[&#x27;json&#x27;]</span><br><span class="line">&#123;&#x27;attribute&#x27;: &#x27;value&#x27;&#125;</span><br></pre></td></tr></table></figure><h4 id="Files-binary-data"><a href="#Files-binary-data" class="headerlink" title="Files &amp; binary data"></a>Files &amp; binary data</h4><p>For uploading files using multipart&#x2F;form-data encoding you can use the same approach as Form data and specify the file field as a tuple of (file_name, file_data)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&#x27;example.txt&#x27;) as fp:</span><br><span class="line">...     file_data = fp.read()</span><br><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;POST&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/post&#x27;,</span><br><span class="line">...     fields=&#123;</span><br><span class="line">...         &#x27;filefield&#x27;: (&#x27;example.txt&#x27;, file_data),</span><br><span class="line">...     &#125;)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))[&#x27;files&#x27;]</span><br><span class="line">&#123;&#x27;filefield&#x27;: &#x27;...&#x27;&#125;</span><br></pre></td></tr></table></figure><p>While specifying the filename is not strictly required, it’s recommended in order to match browser behavior. You can also pass a third item in the tuple to specify the file’s MIME type explicitly:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;POST&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/post&#x27;,</span><br><span class="line">...     fields=&#123;</span><br><span class="line">...         &#x27;filefield&#x27;: (&#x27;example.txt&#x27;, file_data, &#x27;text/plain&#x27;),</span><br><span class="line">...     &#125;)</span><br></pre></td></tr></table></figure><p>For sending raw binary data simply specify the body argument. It’s also recommended to set the Content-Type header</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&#x27;example.jpg&#x27;, &#x27;rb&#x27;) as fp:</span><br><span class="line">...     binary_data = fp.read()</span><br><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;POST&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/post&#x27;,</span><br><span class="line">...     body=binary_data,</span><br><span class="line">...     headers=&#123;&#x27;Content-Type&#x27;: &#x27;image/jpeg&#x27;&#125;)</span><br><span class="line">&gt;&gt;&gt; json.loads(r.data.decode(&#x27;utf-8&#x27;))[&#x27;data&#x27;]</span><br><span class="line">b&#x27;...&#x27;</span><br></pre></td></tr></table></figure><h3 id="Certificate-verification"><a href="#Certificate-verification" class="headerlink" title="Certificate verification"></a>Certificate verification</h3><p>SSL证书验证：<br>简单来说是验证两个问题：</p><ul><li>1、证书是否是信任的有效证书。所谓信任：浏览器内置了信任的根证书，就是看看web服务器的证书是不是这些信任根发的或者信任根的二级证书机构颁发的。所谓有效，就是看看web服务器证书是否在有效期，是否被吊销了。</li><li>2、对方是不是上述证书的合法持有者。简单来说证明对方是否持有证书的对应私钥。验证方法两种，一种是对方签个名，我用证书验证签名；另外一种是用证书做个信封，看对方是否能解开。</li></ul><p>It is highly recommended to always use SSL certificate verification. By default, urllib3 does not verify HTTPS requests.</p><p>In order to enable verification you will need a set of root certificates. The easiest and most reliable method is to use the certifi package which provides Mozilla’s root certificate bundle.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install certifi</span><br></pre></td></tr></table></figure><p>Once you have certificates, you can create a PoolManager that verifies certificates when making requests.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import certifi</span><br><span class="line">&gt;&gt;&gt; import urllib3</span><br><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(</span><br><span class="line">...     cert_reqs=&#x27;CERT_REQUIRED&#x27;,</span><br><span class="line">...     ca_certs=certifi.where())</span><br></pre></td></tr></table></figure><p>The PoolManager will automatically handle certificate verification and will raise SSLError if verification fails.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http.request(&#x27;GET&#x27;, &#x27;https://google.com&#x27;)</span><br><span class="line">(No exception)</span><br><span class="line">&gt;&gt;&gt; http.request(&#x27;GET&#x27;, &#x27;https://expired.badssl.com&#x27;)</span><br><span class="line">urllib3.exceptions.SSLError ...</span><br></pre></td></tr></table></figure><p>Note：<br>You can use OS-provided certificates if desired. Just specify the full path to the certificate bundle as the ca_certs argument instead of certifi.where(). For example, most Linux systems store the certificates at &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;ca-certificates.crt.</p><h3 id="Using-timeouts"><a href="#Using-timeouts" class="headerlink" title="Using timeouts"></a>Using timeouts</h3><p>Timeouts allow you to control how long requests are allowed to run before being aborted. In simple cases, you can specify a timeout as a float to request()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http.request(</span><br><span class="line">...     &#x27;GET&#x27;, &#x27;http://httpbin.org/delay/3&#x27;, timeout=4.0)</span><br><span class="line">&lt;urllib3.response.HTTPResponse&gt;</span><br><span class="line">&gt;&gt;&gt; http.request(</span><br><span class="line">...     &#x27;GET&#x27;, &#x27;http://httpbin.org/delay/3&#x27;, timeout=2.5)</span><br><span class="line">MaxRetryError caused by ReadTimeoutError</span><br></pre></td></tr></table></figure><p>For more granular control you can use a Timeout instance which lets you specify separate connect and read timeouts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/delay/3&#x27;,</span><br><span class="line">...     timeout=urllib3.Timeout(connect=1.0))</span><br><span class="line">&lt;urllib3.response.HTTPResponse&gt;</span><br><span class="line">&gt;&gt;&gt; http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/delay/3&#x27;,</span><br><span class="line">...     timeout=urllib3.Timeout(connect=1.0, read=2.0))</span><br><span class="line">MaxRetryError caused by ReadTimeoutError</span><br></pre></td></tr></table></figure><p>If you want all requests to be subject to the same timeout, you can specify the timeout at the PoolManager level.You still override this pool-level timeout by specifying timeout to request()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(timeout=3.0)</span><br><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(</span><br><span class="line">...     timeout=urllib3.Timeout(connect=1.0, read=2.0))</span><br></pre></td></tr></table></figure><h3 id="Retrying-requests"><a href="#Retrying-requests" class="headerlink" title="Retrying requests"></a>Retrying requests</h3><p>urllib3 can automatically retry idempotent requests. This same mechanism also handles redirects. You can control the retries using the retries parameter to request(). By default, urllib3 will retry requests 3 times and follow up to 3 redirects.</p><p>To change the number of retries just specify an integer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http.requests(&#x27;GET&#x27;, &#x27;http://httpbin.org/ip&#x27;, retries=10)</span><br></pre></td></tr></table></figure><p>To disable all retry and redirect logic specify retries&#x3D;False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http.request(</span><br><span class="line">...     &#x27;GET&#x27;, &#x27;http://nxdomain.example.com&#x27;, retries=False)</span><br><span class="line">NewConnectionError</span><br><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;, &#x27;http://httpbin.org/redirect/1&#x27;, retries=False)</span><br><span class="line">&gt;&gt;&gt; r.status</span><br><span class="line">302</span><br></pre></td></tr></table></figure><p>To disable redirects but keep the retrying logic, specify redirect&#x3D;False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;, &#x27;http://httpbin.org/redirect/1&#x27;, redirect=False)</span><br><span class="line">&gt;&gt;&gt; r.status</span><br><span class="line">302</span><br></pre></td></tr></table></figure><p>For more granular control you can use a Retry instance. This class allows you far greater control of how requests are retried.For example, to do a total of 3 retries, but limit to only 2 redirects</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/redirect/3&#x27;,</span><br><span class="line">...     retries=urllib3.Retry(3, redirect=2))</span><br><span class="line">MaxRetryError</span><br></pre></td></tr></table></figure><p>You can also disable exceptions for too many redirects and just return the 302 response</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/redirect/3&#x27;,</span><br><span class="line">...     retries=urllib3.Retry(</span><br><span class="line">...         redirect=2, raise_on_redirect=False))</span><br><span class="line">&gt;&gt;&gt; r.status</span><br><span class="line">302</span><br></pre></td></tr></table></figure><p>If you want all requests to be subject to the same retry policy, you can specify the retry at the PoolManager level.You still override this pool-level retry policy by specifying retries to request()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(retries=False)</span><br><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(</span><br><span class="line">...     retries=urllib3.Retry(5, redirect=2))</span><br></pre></td></tr></table></figure><h3 id="Errors-Exceptions"><a href="#Errors-Exceptions" class="headerlink" title="Errors &amp; Exceptions"></a>Errors &amp; Exceptions</h3><p>urllib3 wraps lower-level exceptions, for example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     http.request(&#x27;GET&#x27;, &#x27;nx.example.com&#x27;, retries=False)</span><br><span class="line">&gt;&gt;&gt; except urllib3.exceptions.NewConnectionError:</span><br><span class="line">...     print(&#x27;Connection failed.&#x27;)</span><br></pre></td></tr></table></figure><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>If you are using the standard library logging module urllib3 will emit several logs. In some cases this can be undesirable. You can use the standard logger interface to change the log level for urllib3’s logger</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; logging.getLogger(&quot;urllib3&quot;).setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure><h3 id="Customizing-pool-behavior"><a href="#Customizing-pool-behavior" class="headerlink" title="Customizing pool behavior"></a>Customizing pool behavior</h3><h4 id="PoolManager"><a href="#PoolManager" class="headerlink" title="PoolManager"></a>PoolManager</h4><p>The PoolManager class automatically handles creating ConnectionPool instances for each host as needed.</p><p>By default, it will keep a maximum of 10 ConnectionPool instances. </p><p>If you’re making requests to many different hosts it might improve performance to increase this number:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import urllib3</span><br><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(num_pools=50)</span><br></pre></td></tr></table></figure><p>However, keep in mind that this does increase memory and socket consumption.</p><h4 id="ConnectionPool"><a href="#ConnectionPool" class="headerlink" title="ConnectionPool"></a>ConnectionPool</h4><p>Similarly, the ConnectionPool class keeps a pool of individual HTTPConnection instances.</p><p>These connections are used during an individual request and returned to the pool when the request is complete.</p><p>By default only one connection will be saved for re-use. </p><p>If you are making many requests to the same host simultaneously it might improve performance to increase this number:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import urllib3</span><br><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(maxsize=10)</span><br><span class="line"># Alternatively</span><br><span class="line">&gt;&gt;&gt; http = urllib3.HTTPConnectionPool(&#x27;google.com&#x27;, maxsize=10)</span><br></pre></td></tr></table></figure><p>The behavior of the pooling for ConnectionPool is different from PoolManager. </p><p>By default, if a new request is made and there is no free connection in the pool then a new connection will be created. However, this connection will not be saved if more than maxsize connections exist. </p><p>This means that maxsize does not determine the maximum number of connections that can be open to a particular host, just the maximum number of connections to keep in the pool.</p><p>However, if you specify block&#x3D;True then there can be at most maxsize connections open to a particular host:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager(maxsize=10, block=True)</span><br><span class="line"># Alternatively</span><br><span class="line">&gt;&gt;&gt; http = urllib3.HTTPConnectionPool(&#x27;google.com&#x27;, maxsize=10, block=True)</span><br></pre></td></tr></table></figure><p>Any new requests will block until a connection is available from the pool. </p><p>This is a great way to prevent flooding a host with too many connections in multi-threaded applications.</p><h3 id="Streaming-and-IO"><a href="#Streaming-and-IO" class="headerlink" title="Streaming and IO"></a>Streaming and IO</h3><p>When dealing with large responses it’s often better to stream the response content</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import urllib3</span><br><span class="line">&gt;&gt;&gt; http = urllib3.PoolManager()</span><br><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/bytes/1024&#x27;,</span><br><span class="line">...     preload_content=False)</span><br><span class="line">&gt;&gt;&gt; for chunk in r.stream(32):</span><br><span class="line">...     print(chunk)</span><br><span class="line">b&#x27;...&#x27;</span><br><span class="line">b&#x27;...&#x27;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r.release_conn()</span><br></pre></td></tr></table></figure><p>Setting preload_content to False means that urllib3 will stream the response content. </p><p>stream() lets you iterate over chunks of the response content.</p><p>Note:<br>When using preload_content&#x3D;False, you should call release_conn() to release the http connection back to the connection pool so that it can be re-used.</p><p>However, you can also treat the HTTPResponse instance as a file-like object. This allows you to do buffering:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/bytes/1024&#x27;,</span><br><span class="line">...     preload_content=False)</span><br><span class="line">&gt;&gt;&gt; r.read(4)</span><br><span class="line">b&#x27;\x88\x1f\x8b\xe5&#x27;</span><br></pre></td></tr></table></figure><p>Calls to read() will block until more response data is available.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import io</span><br><span class="line">&gt;&gt;&gt; reader = io.BufferedReader(r, 8)</span><br><span class="line">&gt;&gt;&gt; reader.read(4)</span><br><span class="line">&gt;&gt;&gt; r.release_conn()</span><br></pre></td></tr></table></figure><p>You can use this file-like object to do things like decode the content using codecs.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import codecs</span><br><span class="line">&gt;&gt;&gt; reader = codecs.getreader(&#x27;utf-8&#x27;)</span><br><span class="line">&gt;&gt;&gt; r = http.request(</span><br><span class="line">...     &#x27;GET&#x27;,</span><br><span class="line">...     &#x27;http://httpbin.org/ip&#x27;,</span><br><span class="line">...     preload_content=False)</span><br><span class="line">&gt;&gt;&gt; json.load(reader(r))</span><br><span class="line">&#123;&#x27;origin&#x27;: &#x27;127.0.0.1&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; r.release_conn()</span><br></pre></td></tr></table></figure><h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><p>You can use ProxyManager to tunnel requests through an HTTP proxy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import urllib3</span><br><span class="line">&gt;&gt;&gt; proxy = urllib3.ProxyManager(&#x27;http://localhost:3128/&#x27;)</span><br><span class="line">&gt;&gt;&gt; proxy.request(&#x27;GET&#x27;, &#x27;http://google.com/&#x27;)</span><br></pre></td></tr></table></figure><p>The usage of ProxyManager is the same as PoolManager.</p><p>You can use SOCKSProxyManager to connect to SOCKS4 or SOCKS5 proxies. In order to use SOCKS proxies you will need to install PySocks or install urllib3 with the socks extra:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install urllib3[socks]</span><br></pre></td></tr></table></figure><p>Once PySocks is installed, you can use SOCKSProxyManager:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib3.contrib.socks import SOCKSProxyManager</span><br><span class="line">&gt;&gt;&gt; proxy = SOCKSProxyManager(&#x27;socks5://localhost:8889/&#x27;)</span><br><span class="line">&gt;&gt;&gt; proxy.request(&#x27;GET&#x27;, &#x27;http://google.com/&#x27;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫概述</title>
      <link href="/2018/07/07/Python%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/07/07/Python%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="爬虫概念"><a href="#爬虫概念" class="headerlink" title="爬虫概念"></a>爬虫概念</h4><p>抓取网页数据的程序</p><span id="more"></span><h4 id="网页三大特征"><a href="#网页三大特征" class="headerlink" title="网页三大特征"></a>网页三大特征</h4><ul><li>每个网页都有自己的URL（统一资源定位符）来进行定位</li><li>网页都是使用HTML（超文本标记语言）来描述页面信息。</li><li>网页都使用HTTP&#x2F;HTTPS(超文本传输协议)来传输HTML数据。</li></ul><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><ul><li>1.首先确定需要爬取的网页URL地址</li><li>2.通过HTTP&#x2F;HTTPS协议来获取对应的HTML页面</li><li>3.提取HTML页面里有用的数据<br>a.如果是需要的数据，就保存起来<br>b.如果是页面里的其他URL，就执行第二步</li></ul><h4 id="如何抓取HTML页面"><a href="#如何抓取HTML页面" class="headerlink" title="如何抓取HTML页面"></a>如何抓取HTML页面</h4><p>HTTP请求的处理，urllib、urllib2、requests</p><p>处理后的请求可以模拟浏览器发送请求，获取服务器响应的文件</p><h4 id="解析服务器的响应内容"><a href="#解析服务器的响应内容" class="headerlink" title="解析服务器的响应内容"></a>解析服务器的响应内容</h4><p>re、xpath、beautifulsoup4(BS4)、jsonpath、pyquery等</p><p>使用某种描述性语言来给我们需要提取的数据定义一个匹配规则，符合这个规则的数据就会被匹配。</p><h4 id="如何采集动态HTML、验证码的处理"><a href="#如何采集动态HTML、验证码的处理" class="headerlink" title="如何采集动态HTML、验证码的处理"></a>如何采集动态HTML、验证码的处理</h4><p>通用的动态页面采集：Selenuim+phantomJS(无界面)</p><h4 id="Scrapy框架"><a href="#Scrapy框架" class="headerlink" title="Scrapy框架"></a>Scrapy框架</h4><p>高定制性高性能（异步网络框架twisted）,数据下载速度快。<br>提供数据存储、数据下载、提取规则等组件。</p><h4 id="分布式策略"><a href="#分布式策略" class="headerlink" title="分布式策略"></a>分布式策略</h4><p>scrapy-redis，在Scrapy的基础上添加了一套以以redis数据库为核心的一套组件。<br>让Scrapy支持分布式的功能，主要在redis里做请求指纹去重、请求分配、数据临时存储。</p><h4 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h4><p>User Agent、IP代理、验证码、动态数据加载、加密数据</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python进程和线程</title>
      <link href="/2018/07/06/Python%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/07/06/Python%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>多任务：<br>简单地说，就是操作系统可以同时运行多个任务。</p><span id="more"></span><p>单核CPU执行多任务：<br>操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p><p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p><p>对于操作系统来说，一个任务就是一个进程（Process），有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p><p>前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p><p>有两种解决方案：</p><ul><li>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</li><li>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</li><li>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</li></ul><p>总结一下就是，多任务的实现有3种方式：</p><ul><li>多进程模式；</li><li>多线程模式；</li><li>多进程+多线程模式。</li></ul><p>同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。</p><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>Unix&#x2F;Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p><p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p><p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv cascade.xml在安卓APP中的使用</title>
      <link href="/2018/07/05/opencv-cascade-xml%E5%9C%A8%E5%AE%89%E5%8D%93APP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/05/opencv-cascade-xml%E5%9C%A8%E5%AE%89%E5%8D%93APP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/MrBluyee/DJAutocontrol">充电站项目mavic pro自动控制app源码</a><br>在上一篇文章中写了怎样训练出cascade.xml文件，这一篇讲解怎样在android app里使用级联分类器进行多目标检测。</p><span id="more"></span><p>首先要做的是在app中导入opencv4android的SDK。<a href="https://docs.opencv.org/2.4/doc/tutorials/introduction/android_binary_package/O4A_SDK.html">opencv4android SDK</a></p><p>配置环境：<a href="https://www.jianshu.com/p/6e16c0429044">OpenCV On Android环境配置指南</a></p><p>本项目采用动态链接库，免去安装额外的OpenCV Manager App。</p><p>图像处理与识别部分在src的application下的PictureHandle里。</p><p>使用步骤：</p><p>1.把cascade.xml文件放入res下的raw文件夹里。</p><p>2.在activity里加载opencv库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line"></span><br><span class="line">        super.onResume();</span><br><span class="line"></span><br><span class="line">        //load OpenCV engine and init OpenCV library</span><br><span class="line"></span><br><span class="line">        if(!OpenCVLoader.initDebug()) &#123;</span><br><span class="line"></span><br><span class="line">            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION, getApplicationContext(), mLoaderCallback);</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, &quot;Internal OpenCV library not found. Using Opencv Manager for initialization&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;else &#123;</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, &quot;OpenCV library found inside package. Using it!&quot;);</span><br><span class="line"></span><br><span class="line">            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.设置链接到opencv库的回调函数mLoaderCallback。在该回调函数里，我们加载cascade.xml文件，并对CascadeClassifier做初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onManagerConnected(int status) &#123;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case LoaderCallbackInterface.SUCCESS:</span><br><span class="line">            isInit = true;</span><br><span class="line">            try &#123;</span><br><span class="line">                // load cascade file from application resources</span><br><span class="line">                InputStream is = context.getResources().openRawResource(R.raw.cascade1);</span><br><span class="line">                File cascade1Dir = context.getDir(&quot;cascade1&quot;, Context.MODE_PRIVATE);</span><br><span class="line">                mCascade1File = new File(cascade1Dir, &quot;cascade1.xml&quot;);</span><br><span class="line">                FileOutputStream os = new FileOutputStream(mCascade1File);</span><br><span class="line"></span><br><span class="line">                byte[] buffer = new byte[4096];</span><br><span class="line">                int bytesRead;</span><br><span class="line">                while ((bytesRead = is.read(buffer)) != -1) &#123;</span><br><span class="line">                    os.write(buffer, 0, bytesRead);</span><br><span class="line">                &#125;</span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line"></span><br><span class="line">                // load cascade file from application resources</span><br><span class="line">                InputStream ise = context.getResources().openRawResource(R.raw.cascade2);</span><br><span class="line">                File cascade2Dir = context.getDir(&quot;cascade2&quot;, Context.MODE_PRIVATE);</span><br><span class="line">                mCascade2File = new File(cascade2Dir, &quot;cascade2.xml&quot;);</span><br><span class="line">                FileOutputStream ose = new FileOutputStream(mCascade2File);</span><br><span class="line"></span><br><span class="line">                while ((bytesRead = ise.read(buffer)) != -1) &#123;</span><br><span class="line">                    ose.write(buffer, 0, bytesRead);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ise.close();</span><br><span class="line">                ose.close();</span><br><span class="line"></span><br><span class="line">                mJavaDetector1 = new CascadeClassifier(mCascade1File.getAbsolutePath());</span><br><span class="line">                if (mJavaDetector1.empty()) &#123;</span><br><span class="line">                    Log.e(TAG, &quot;Failed to load cascade classifier&quot;);</span><br><span class="line">                    mJavaDetector1 = null;</span><br><span class="line">                &#125; else</span><br><span class="line">                    Log.i(TAG, &quot;Loaded cascade classifier from &quot; + mCascade1File.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">                mJavaDetector2 = new CascadeClassifier(mCascade2File.getAbsolutePath());</span><br><span class="line">                if (mJavaDetector2.empty()) &#123;</span><br><span class="line">                    Log.e(TAG, &quot;Failed to load cascade classifier&quot;);</span><br><span class="line">                    mJavaDetector2 = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Log.i(TAG, &quot;Loaded cascade classifier from &quot; + mCascade2File.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cascade1Dir.delete();</span><br><span class="line">                cascade2Dir.delete();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Log.e(TAG, &quot;Failed to load cascade. Exception thrown: &quot; + e);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            isInit = false;</span><br><span class="line">            super.onManagerConnected(status);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.新建的Picture_Detector1类。mavic pro的摄像头传回到app上的预览画面使用安卓texture，我们先从texture里取出一帧图片，保存到bitmap类的变量里。然后将bitmap转为opencv的mat类型数据，接着将图片转为灰度图像，传入detectMultiScale方法里检测目标。<br>下面是新建的Picture_Detector1类，开一个线程处理图像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Picture_Detector1 implements Runnable&#123;</span><br><span class="line">    private Bitmap bitmap;</span><br><span class="line">    private Handler UIHandler;</span><br><span class="line">    private Rect[] result;</span><br><span class="line"></span><br><span class="line">    public void begin() &#123;</span><br><span class="line">        new Thread(this).start();</span><br><span class="line">    &#125;</span><br><span class="line">    public Picture_Detector1(Bitmap bitmap,Handler UIHandler)&#123;</span><br><span class="line">        this.bitmap = bitmap;</span><br><span class="line">        this.UIHandler = UIHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Mat srcimg = new Mat();</span><br><span class="line">        Utils.bitmapToMat(bitmap, srcimg);</span><br><span class="line">        Imgproc.cvtColor(srcimg, srcimg,Imgproc.COLOR_RGBA2GRAY);</span><br><span class="line">        result = detector1(srcimg);</span><br><span class="line">        Message msg = new Message();</span><br><span class="line">        Bundle b = new Bundle();// 存放数据</span><br><span class="line">        b.putSerializable(&quot;picturedetector1&quot;, result);</span><br><span class="line">        msg.setData(b);</span><br><span class="line">        UIHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图像处理函数为 result &#x3D; detector1(srcimg);<br>函数代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Rect[] detector1(Mat srcimg) &#123;</span><br><span class="line">    if (mAbsoluteTargetSize == 0) &#123;</span><br><span class="line">        int height = srcimg.rows();</span><br><span class="line">        if (Math.round(height * mRelativeTargetSize) &gt; 0) &#123;</span><br><span class="line">            mAbsoluteTargetSize = Math.round(height * mRelativeTargetSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MatOfRect targets = new MatOfRect();</span><br><span class="line">    if (mDetectorType == JAVA_DETECTOR) &#123;</span><br><span class="line">        if (mJavaDetector1 != null)</span><br><span class="line">            mJavaDetector1.detectMultiScale(srcimg, targets, 1.1, 6, 2, // TODO: objdetect.CV_HAAR_SCALE_IMAGE</span><br><span class="line">                    new Size(mAbsoluteTargetSize, mAbsoluteTargetSize), new Size());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        Log.e(TAG, &quot;Detection method is not selected!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return targets.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CascadeClassifier为级联分类器检测类，使用Adaboost的方法，提取LBP\HOG\HAAR特征进行目标检测，加载traincascade进行训练的分类器。<br>detectMultiscale函数为多尺度多目标检测：<br>detectMultiScale能够实现多尺度检测，但多尺度检测是通过缩放图像来完成的。多尺度：通常搜索目标的模板尺寸大小是固定的，但是不同图片大小不同，所以目标对象的大小也是不定的，所以多尺度即不断缩放图片大小（缩放到与模板匹配），通过模板滑动窗函数搜索匹配；同一副图片可能在不同尺度下都得到匹配值，所以多尺度检测函数detectMultiscale是多尺度合并的结果。<br>多目标：通过检测符合模板匹配对象，可得到多个目标，均输出到objects向量里面。<br>detectMultiScale函数参数解释：<br>const Mat, —Mat类型的图像，待检测图片，一般为灰度图像加快检测速度。<br>Rect[],—检测得到的被检测物体的矩形框向量组；为输出量<br>doublescaleFactor, —图像缩放因子，必须大于1，表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%;一般设置为1.1 。<br>intminNeighbors,—构成检测目标的相邻矩形的最小个数(默认为3个)。如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。<br>如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，<br>这种设定值一般用在用户自定义对检测结果的组合程序上。<br>int flags, —要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING，如果设置为CV_HAAR_DO_CANNY_PRUNING，那么函数将会使用Canny边缘检测来排除边缘过多或过少的区域。<br>Size minObjectSize, —最小检测窗口大小<br>Size maxObjectSize)—最大检测窗口大小（默认是图像大小）<br>5.在activity里调用Picture_Detector:<br>新建myhandler，用于处理从线程中接收的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private Rect[] targets1Array = null;</span><br><span class="line"> private Rect[] targets2Array = null;</span><br><span class="line"> private MyHandler1 myHandler1;</span><br><span class="line"> private MyHandler2 myHandler2;</span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     setContentView(R.layout.activity_camera);</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     initUI();</span><br><span class="line">     myHandler1 = new MyHandler1();</span><br><span class="line">     myHandler2 = new MyHandler2();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class MyHandler1 extends Handler &#123;</span><br><span class="line">     public MyHandler1() &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public MyHandler1(Looper L) &#123;</span><br><span class="line">         super(L);</span><br><span class="line">     &#125;</span><br><span class="line">     // 子类必须重写此方法，接受数据</span><br><span class="line">     @Override</span><br><span class="line">     public void handleMessage(Message msg) &#123;</span><br><span class="line">         // TODO Auto-generated method stub</span><br><span class="line">         super.handleMessage(msg);</span><br><span class="line">         // 此处可以更新UI</span><br><span class="line">         Bundle b = msg.getData();</span><br><span class="line">         targets1Array = (Rect[]) b.getSerializable(&quot;picturedetector1&quot;);</span><br><span class="line">         if(targets1Array.length &gt; 0)&#123;</span><br><span class="line">             CameraActivity.this.runOnUiThread(new Runnable() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void run() &#123;</span><br><span class="line">                     mTrackingImage1.setX(targets1Array[0].x);</span><br><span class="line">                     mTrackingImage1.setY(targets1Array[0].y);</span><br><span class="line">                     mTrackingImage1.getLayoutParams().width = targets1Array[0].width;</span><br><span class="line">                     mTrackingImage1.getLayoutParams().height = targets1Array[0].height;</span><br><span class="line">                     mTrackingImage1.requestLayout();</span><br><span class="line">                     mTrackingImage1.setVisibility(View.VISIBLE);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">             CameraActivity.this.runOnUiThread(new Runnable() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void run() &#123;</span><br><span class="line">                     mTrackingImage1.setVisibility(View.INVISIBLE);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重写onSurfaceTextureUpdated回调函数，用于实时图像处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123;</span><br><span class="line">    super.onSurfaceTextureUpdated(surface);</span><br><span class="line">    Bitmap bitmap = mVideoSurface.getBitmap();</span><br><span class="line">    picturehandle.new Picture_Detector1(bitmap,myHandler1).begin();</span><br><span class="line">    picturehandle.new Picture_Detector2(bitmap,myHandler2).begin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv cascade级联分类器的训练</title>
      <link href="/2018/07/05/opencv-cascade%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84%E8%AE%AD%E7%BB%83/"/>
      <url>/2018/07/05/opencv-cascade%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记——opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PythonIO编程</title>
      <link href="/2018/07/05/PythonIO%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/07/05/PythonIO%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><span id="more"></span><p><img src="https://upload-images.jianshu.io/upload_images/9169686-fdb5a6e1e96d6b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件读写"></p><h3 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Python内置的os模块可以直接调用操作系统提供的接口函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.name # 操作系统类型</span><br><span class="line">&#x27;nt&#x27;</span><br></pre></td></tr></table></figure><p>如果是posix，说明系统是Linux、Unix或Mac OS X，如果是nt，就是Windows系统。<br>要获取详细的系统信息，可以调用uname()函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.uname()</span><br></pre></td></tr></table></figure><p>注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: module &#x27;os&#x27; has no attribute &#x27;uname&#x27;</span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ</span><br><span class="line">environ(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\ProgramData&#x27;, &#x27;ANDROID&#x27;: &#x27;C:\\Users\\MrBlu\\AppData\\Local\\Android\\Sdk\...</span><br></pre></td></tr></table></figure><p>要获取某个环境变量的值，可以调用os.environ.get(‘key’)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ.get(&#x27;PATH&#x27;)</span><br><span class="line">&#x27;C:\\Program Files\\Java\\jdk1.8.0_181\\bin;C:\\ProgramData\\Oracle\...</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&#x27;x&#x27;, &#x27;default&#x27;)</span><br><span class="line">&#x27;default&#x27;</span><br></pre></td></tr></table></figure><h4 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h4><h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&#x27;.&#x27;)</span><br><span class="line">&#x27;/Users/mrbluyee&#x27;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&#x27;/Users/mrbluyee&#x27;, &#x27;testdir&#x27;)</span><br><span class="line">&#x27;/Users/mrbluyee/testdir&#x27;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&#x27;/Users/mrbluyee/testdir&#x27;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&#x27;/Users/mrbluyee/testdir&#x27;)</span><br></pre></td></tr></table></figure><p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。在Linux&#x2F;Unix&#x2F;Mac下，os.path.join()返回这样的字符串：part-1&#x2F;part-2<br>而Windows下会返回这样的字符串：part-1\part-2</p><p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&#x27;/Users/mrbluyee/testdir/file.txt&#x27;)</span><br><span class="line">(&#x27;/Users/mrbluyee/testdir&#x27;, &#x27;file.txt&#x27;)</span><br></pre></td></tr></table></figure><p>os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.splitext(&#x27;/path/to/file.txt&#x27;)</span><br><span class="line">(&#x27;/path/to/file&#x27;, &#x27;.txt&#x27;)</span><br></pre></td></tr></table></figure><p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p><p>文件操作使用下面的函数。假定当前目录下有一个test.txt文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&#x27;test.py&#x27;)</span><br></pre></td></tr></table></figure><p>但是复制文件的函数居然在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。<br>幸运的是shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</p><p>最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&#x27;.&#x27;) if os.path.isdir(x)]</span><br><span class="line">[&#x27;.lein&#x27;, &#x27;.local&#x27;, &#x27;.m2&#x27;, &#x27;.npm&#x27;, &#x27;.ssh&#x27;, &#x27;.Trash&#x27;, &#x27;.vim&#x27;, &#x27;Applications&#x27;, &#x27;Desktop&#x27;, ...]</span><br></pre></td></tr></table></figure><p>要列出所有的.py文件，也只需一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&#x27;.&#x27;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#x27;.py&#x27;]</span><br><span class="line">[&#x27;apis.py&#x27;, &#x27;config.py&#x27;, &#x27;models.py&#x27;, &#x27;pymonitor.py&#x27;, &#x27;test_db.py&#x27;, &#x27;urls.py&#x27;, &#x27;wsgiapp.py&#x27;]</span><br></pre></td></tr></table></figure><h5 id="文件相关API"><a href="#文件相关API" class="headerlink" title="文件相关API"></a>文件相关API</h5><p>获取文件的大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsize = os.path.getsize(filePath)</span><br></pre></td></tr></table></figure><p>获取文件的访问时间:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = os.path.getatime(filePath)</span><br></pre></td></tr></table></figure><p>获取文件的创建时间:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = os.path.getctime(filePath)</span><br></pre></td></tr></table></figure><p>获取文件的修改时间:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = os.path.getmtime(filePath)</span><br></pre></td></tr></table></figure><p>判断文件是否存在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(test_file.txt)</span><br><span class="line">#True</span><br><span class="line">os.path.exists(no_exist_file.txt)</span><br><span class="line">#False</span><br></pre></td></tr></table></figure><p>判断文件夹是否存在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(test_dir)</span><br><span class="line">#True</span><br><span class="line">os.path.exists(no_exist_dir)</span><br><span class="line">#False</span><br></pre></td></tr></table></figure><p>可以看出用os.path.exists()方法，判断文件和文件夹是一样。</p><p>这种方法还是有个问题，假设你想检查文件“test_data”是否存在，但是当前路径下有个叫“test_data”的文件夹，这样就可能出现误判。为了避免这样的情况，可以这样:<br>只检查文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.isfile(&quot;test-data&quot;)</span><br></pre></td></tr></table></figure><p>判断是否为目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.isdir(Dir)</span><br></pre></td></tr></table></figure><p>通过这个方法，如果文件”test-data”不存在将返回False，反之返回True。</p><p>判断文件是否可做读写操作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">if os.access(&quot;/file/path/foo.txt&quot;, os.F_OK):</span><br><span class="line">    print &quot;Given file path is exist.&quot;</span><br><span class="line"></span><br><span class="line">if os.access(&quot;/file/path/foo.txt&quot;, os.R_OK):</span><br><span class="line">    print &quot;File is accessible to read&quot;</span><br><span class="line"></span><br><span class="line">if os.access(&quot;/file/path/foo.txt&quot;, os.W_OK):</span><br><span class="line">    print &quot;File is accessible to write&quot;</span><br><span class="line"></span><br><span class="line">if os.access(&quot;/file/path/foo.txt&quot;, os.X_OK):</span><br><span class="line">    print &quot;File is accessible to execute&quot;</span><br></pre></td></tr></table></figure><p>使用os.access()方法判断文件是否可进行读写操作。<br>os.access(path, mode)，path为文件路径，mode为操作模式，有这么几种:</p><ul><li>os.F_OK: 检查文件是否存在;</li><li>os.R_OK: 检查文件是否可读;</li><li>os.W_OK: 检查文件是否可以写入;</li><li>os.X_OK: 检查文件是否可以执行</li></ul><p>使用Try语句：<br>可以在程序中直接使用open()方法来检查文件是否存在和可读写。<br>open()：如果你open的文件不存在，程序会抛出错误，使用try语句来捕获这个错误。<br>程序无法访问文件，可能有很多原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f =open()</span><br><span class="line">    f.close()</span><br><span class="line">except FileNotFoundError:</span><br><span class="line">    print &quot;File is not found.&quot;</span><br><span class="line">except PersmissionError:</span><br><span class="line">    print &quot;You don&#x27;t have permission to access this file.&quot;</span><br></pre></td></tr></table></figure><ul><li>如果你open的文件不存在，将抛出一个FileNotFoundError的异常;</li><li>文件存在，但是没有权限访问，会抛出一个PersmissionError的异常。</li></ul><p>其实没有必要去这么细致的处理每个异常，上面的这两个异常都是IOError的子类。所以可以将程序简化一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f =open()</span><br><span class="line">    f.close()</span><br><span class="line">except IOError:</span><br><span class="line">    print &quot;File is not accessible.&quot;</span><br></pre></td></tr></table></figure><p>使用try语句进行判断，处理所有异常非常简单和优雅的。而且相比其他不需要引入其他外部模块。</p><h5 id="使用pathlib模块"><a href="#使用pathlib模块" class="headerlink" title="使用pathlib模块"></a>使用pathlib模块</h5><p>pathlib模块在Python3版本中是内建模块，但是在Python2中是需要单独安装三方模块。</p><p>使用pathlib需要先使用文件路径来创建path对象。此路径可以是文件名或目录路径。</p><p>检查路径是否存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = pathlib.Path(&quot;path/file&quot;)</span><br><span class="line">path.exist()</span><br></pre></td></tr></table></figure><p>检查路径是否是文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = pathlib.Path(&quot;path/file&quot;)</span><br><span class="line">path.is_file()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器</title>
      <link href="/2018/06/30/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2018/06/30/Python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>谈装饰器前，还要先要明白一件事，Python 中的函数和 Java、C++不太一样。</p><span id="more"></span><p>Python 中的函数可以像普通变量一样当做参数传递给另外一个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    print(&quot;foo&quot;)</span><br><span class="line">def bar(func):</span><br><span class="line">    func()</span><br><span class="line">bar(foo)</span><br></pre></td></tr></table></figure><p>装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数&#x2F;类对象。</p><p>它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。</p><p>有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>先来看一个简单例子，虽然实际代码可能比这复杂很多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br></pre></td></tr></table></figure><p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br><span class="line">    logging.info(&quot;foo is running&quot;)</span><br></pre></td></tr></table></figure><p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 logging 在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门处理日志 ，日志处理完之后再执行真正的业务代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line">    logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br><span class="line"></span><br><span class="line">use_logging(foo)</span><br></pre></td></tr></table></figure><p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 foo 函数，而是换成了 use_logging 函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p><h4 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line"></span><br><span class="line">    def wrapper():</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func()   # 把 foo 当做参数传递进来时，执行func()就相当于执行foo()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br><span class="line"></span><br><span class="line">foo = use_logging(foo)  # 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper</span><br><span class="line">foo()                    # 执行foo()就相当于执行 wrapper()</span><br></pre></td></tr></table></figure><p>use_logging 就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 foo 被 use_logging 装饰了一样，use_logging 返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="@ 语法糖"></a>@ 语法糖</h4><p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line"></span><br><span class="line">    def wrapper():</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@use_logging</span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;i am foo&quot;)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>如上所示，有了 @ ，我们就可以省去foo &#x3D; use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。</p><p>你们看到了没有，foo() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p><p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p><h4 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、**kwargs"></a>*args、**kwargs</h4><p>可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(name):</span><br><span class="line">    print(&quot;i am %s&quot; % name)</span><br></pre></td></tr></table></figure><p>我们可以在定义 wrapper 函数的时候指定参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def wrapper(name):</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func(name)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><p>这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def wrapper(*args):</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func(*args)</span><br><span class="line">return wrapper</span><br></pre></td></tr></table></figure><p>如此一来，甭管 foo 定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 foo 的业务逻辑了。这时还有读者会问，如果 foo 函数还定义了一些关键字参数呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(name, age=None, height=None):</span><br><span class="line">    print(&quot;I am %s, age %s, height %s&quot; % (name, age, height))</span><br></pre></td></tr></table></figure><p>这时，你就可以把 wrapper 函数指定关键字函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def wrapper(*args, **kwargs):</span><br><span class="line">        # args是一个数组，kwargs一个字典</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><h4 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h4><p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 foo 。</p><p>装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def use_logging(level):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            if level == &quot;warn&quot;:</span><br><span class="line">                logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">            elif level == &quot;info&quot;:</span><br><span class="line">                logging.info(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">            return func(*args)</span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@use_logging(level=&quot;warn&quot;)</span><br><span class="line">def foo(name=&#x27;foo&#x27;):</span><br><span class="line">    print(&quot;i am %s&quot; % name)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>上面的 use_logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我们使用@use_logging(level&#x3D;”warn”)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。<br>@use_logging(level&#x3D;”warn”)等价于@decorator</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。</p><p>使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print (&#x27;class decorator runing&#x27;)</span><br><span class="line">        self._func()</span><br><span class="line">        print (&#x27;class decorator ending&#x27;)</span><br><span class="line"></span><br><span class="line">@Foo</span><br><span class="line">def bar():</span><br><span class="line">    print (&#x27;bar&#x27;)</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><h4 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h4><p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 装饰器</span><br><span class="line">def logged(func):</span><br><span class="line">    def with_logging(*args, **kwargs):</span><br><span class="line">        print func.__name__      # 输出 &#x27;with_logging&#x27;</span><br><span class="line">        print func.__doc__       # 输出 None</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return with_logging</span><br><span class="line"></span><br><span class="line"># 函数</span><br><span class="line">@logged</span><br><span class="line">def f(x):</span><br><span class="line">   &quot;&quot;&quot;does some math&quot;&quot;&quot;</span><br><span class="line">   return x + x * x</span><br><span class="line"></span><br><span class="line">logged(f)</span><br></pre></td></tr></table></figure><p>不难发现，函数 f 被with_logging取代了，当然它的docstring，__name__就是变成了with_logging函数的信息了。</p><p>好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">def logged(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def with_logging(*args, **kwargs):</span><br><span class="line">        print func.__name__      # 输出 &#x27;f&#x27;</span><br><span class="line">        print func.__doc__       # 输出 &#x27;does some math&#x27;</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return with_logging</span><br><span class="line"></span><br><span class="line">@logged</span><br><span class="line">def f(x):</span><br><span class="line">   &quot;&quot;&quot;does some math&quot;&quot;&quot;</span><br><span class="line">   return x + x * x</span><br></pre></td></tr></table></figure><h4 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h4><p>一个函数还可以同时定义多个装饰器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@a</span><br><span class="line">@b</span><br><span class="line">@c</span><br><span class="line">def f ():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块</title>
      <link href="/2018/06/23/Python%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/06/23/Python%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h4 id="模块（Module）概述"><a href="#模块（Module）概述" class="headerlink" title="模块（Module）概述"></a>模块（Module）概述</h4><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p><span id="more"></span><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。例，一个abc.py的文件就是一个名字叫abc的模块。</p><p>使用模块最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p><p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。</p><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</li></ul><h4 id="包（Package）"><a href="#包（Package）" class="headerlink" title="包（Package）"></a>包（Package）</h4><p>如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。</p><p>假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-2134827ed3ddea9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mycompany目录"><br>现在，abc.py模块的名字就变成了mycompany.abc。<br>每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。</p><p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-2e9f24ab955d19ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多级层次的包结构"></p><p>文件www.py的模块名就是mycompany.web.www</p><h4 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h4><p>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</p><p><strong>结构</strong><br>我们以内建的sys模块为例，编写一个hello的模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&#x27; a test module &#x27;</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Mr Bluyee&#x27;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    if len(args)==1:</span><br><span class="line">        print(&#x27;Hello, world!&#x27;)</span><br><span class="line">    elif len(args)==2:</span><br><span class="line">        print(&#x27;Hello, %s!&#x27; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;Too many arguments!&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><ul><li>第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix&#x2F;Linux&#x2F;Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</li><li>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</li><li>第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名</li><li>使用sys模块的第一步，就是导入该模块  import sys<br>导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</li><li>sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。<br>例如：运行python3 hello.py获得的sys.argv就是[‘hello.py’]；<br>运行python3 hello.py Bluyee获得的sys.argv就是[‘hello.py’, ‘Bluyee’]。</li><li>最后，注意到这两行代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</li></ul><p><strong>作用域</strong><br>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。</p><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。</p><p>类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名。</p><p>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等。</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def _private_1(name):</span><br><span class="line">    return &#x27;Hello, %s&#x27; % name</span><br><span class="line"></span><br><span class="line">def _private_2(name):</span><br><span class="line">    return &#x27;Hi, %s&#x27; % name</span><br><span class="line"></span><br><span class="line">def greeting(name):</span><br><span class="line">    if len(name) &gt; 3:</span><br><span class="line">        return _private_1(name)</span><br><span class="line">    else:</span><br><span class="line">        return _private_2(name)</span><br></pre></td></tr></table></figure><p>我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p><h4 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h4><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。</p><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。</p><p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; &gt;&gt;&gt; sys.path</span><br></pre></td></tr></table></figure><p>如果我们要添加自己的搜索目录，有两种方法：</p><ul><li>一是直接修改sys.path，添加要搜索的目录:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#x27;/Users/yupro/python/my_py_scripts&#x27;)</span><br><span class="line"># 这种方法是在运行时修改，运行结束后失效。</span><br></pre></td></tr></table></figure></li><li>第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面向对象</title>
      <link href="/2018/06/20/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/06/20/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><span id="more"></span><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p><p>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。</p><p>数据封装、继承和多态是面向对象的三大特点。</p><h3 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h3><h4 id="类和实例-1"><a href="#类和实例-1" class="headerlink" title="类和实例"></a>类和实例</h4><p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p><p>以Student类为例，在Python中，定义类是通过class关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</p><p>定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student()</span><br><span class="line">&gt;&gt;&gt; bart</span><br><span class="line">&lt;__main__.Student object at 0x10a67a590&gt;</span><br><span class="line">&gt;&gt;&gt; Student</span><br><span class="line">&lt;class &#x27;__main__.Student&#x27;&gt;</span><br></pre></td></tr></table></figure><p>可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。</p><p>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.name = &#x27;Bart Simpson&#x27;</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&#x27;Bart Simpson&#x27;</span><br></pre></td></tr></table></figure><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>注意：特殊方法“__init__”前后分别有两个下划线！<br>注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。<br>有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&#x27;Bart Simpson&#x27;</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br></pre></td></tr></table></figure><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h4 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h4><p>面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_score(std):</span><br><span class="line">...     print(&#x27;%s: %s&#x27; % (std.name, std.score))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print_score(bart)</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure><p>但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&#x27;%s: %s&#x27; % (self.name, self.score))</span><br></pre></td></tr></table></figure><p>要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.print_score()</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure><p>这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p><p>封装的另一个好处是可以给Student类增加新的方法，比如get_grade：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.score &gt;= 90:</span><br><span class="line">            return &#x27;A&#x27;</span><br><span class="line">        elif self.score &gt;= 60:</span><br><span class="line">            return &#x27;B&#x27;</span><br><span class="line">        else:</span><br><span class="line">            return &#x27;C&#x27;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；</p><p>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；</p><p>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。</p><p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</p><h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p><p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; bart.score = 99</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">99</span><br></pre></td></tr></table></figure><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&#x27;%s: %s&#x27; % (self.__name, self.__score))</span><br></pre></td></tr></table></figure><p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__name&#x27;</span><br></pre></td></tr></table></figure><p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p><p>但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br></pre></td></tr></table></figure><p>如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        self.__score = score</span><br></pre></td></tr></table></figure><p>你也许会问，原先那种直接通过bart.score &#x3D; 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;bad score&#x27;)</span><br></pre></td></tr></table></figure><p>需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。<br>有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart._Student__name</span><br><span class="line">&#x27;Bart Simpson&#x27;</span><br></pre></td></tr></table></figure><p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。<br>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。<br>最后注意下面的这种错误写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.get_name()</span><br><span class="line">&#x27;Bart Simpson&#x27;</span><br><span class="line">&gt;&gt;&gt; bart.__name = &#x27;New Name&#x27; # 设置__name变量！</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">&#x27;New Name&#x27;</span><br></pre></td></tr></table></figure><p>表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name</span><br><span class="line">&#x27;Bart Simpson&#x27;</span><br></pre></td></tr></table></figure><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><h4 id="继承和多态-1"><a href="#继承和多态-1" class="headerlink" title="继承和多态"></a>继承和多态</h4><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;Animal is running...&#x27;)</span><br></pre></td></tr></table></figure><p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。</p><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure><p>当然，也可以对子类增加一些方法，比如Dog类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;Dog is running...&#x27;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&#x27;Eating meat...&#x27;)</span><br></pre></td></tr></table></figure><p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running…，符合逻辑的做法是分别显示Dog is running…和Cat is running…，因此，对Dog和Cat类改进如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;Dog is running...&#x27;)</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;Cat is running...&#x27;)</span><br><span class="line"></span><br><span class="line">再次运行，结果如下：</span><br><span class="line">Dog is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure><p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。</p><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = list() # a是list类型</span><br><span class="line">b = Animal() # b是Animal类型</span><br><span class="line">c = Dog() # c是Dog类型</span><br></pre></td></tr></table></figure><p>判断一个变量是否是某个类型可以用isinstance()判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(a, list)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Animal)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>看来a、b、c确实对应着list、Animal、Dog这3种类型。<br>但是等等，试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(c, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>看来c不仅仅是Dog，c还是Animal！<br>不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！</p><p>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = Animal()</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Dog)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>Dog可以看成Animal，但Animal不可以看成Dog。</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure><p>当我们传入Animal的实例时，run_twice()就打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Animal())</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure><p>当我们传入Dog的实例时，run_twice()就打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure><p>当我们传入Cat的实例时，run_twice()就打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Cat())</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;Tortoise is running slowly...&#x27;)</span><br></pre></td></tr></table></figure><p>当我们调用run_twice()时，传入Tortoise的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Tortoise())</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure><p>你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p><ul><li>对扩展开放：允许新增Animal子类；</li><li>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</li></ul><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-956faa4c5a18eefc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="继承树"></p><h4 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h4><p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#x27;Start...&#x27;)</span><br></pre></td></tr></table></figure><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p><p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p><h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><h4 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h4><p>首先，我们来判断对象类型，使用type()函数：<br>基本类型都可以用type()判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(&#x27;str&#x27;)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(None)</span><br><span class="line">&lt;type(None) &#x27;NoneType&#x27;&gt;</span><br></pre></td></tr></table></figure><p>如果一个变量指向函数或者类，也可以用type()判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(abs)</span><br><span class="line">&lt;class &#x27;builtin_function_or_method&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;__main__.Animal&#x27;&gt;</span><br></pre></td></tr></table></figure><p>但是type()函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)==type(456)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(123)==int</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&#x27;abc&#x27;)==type(&#x27;123&#x27;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&#x27;abc&#x27;)==str</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(&#x27;abc&#x27;)==type(123)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以使用types模块中定义的常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x)==types.LambdaType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h4 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h4><p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</p><p>如果继承关系是：object -&gt; Animal -&gt; Dog -&gt; Husky<br>那么，isinstance()就可以告诉我们，一个对象是否是某种类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 先创建3种类型的对象：</span><br><span class="line">&gt;&gt;&gt; a = Animal()</span><br><span class="line">&gt;&gt;&gt; d = Dog()</span><br><span class="line">&gt;&gt;&gt; h = Husky()</span><br><span class="line">判断：</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Husky)</span><br><span class="line">True</span><br><span class="line">再判断：</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型。换句话说，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p><p>能用type()判断的基本类型也可以用isinstance()判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(&#x27;a&#x27;, str)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b&#x27;a&#x27;, bytes)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</strong></p><h4 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h4><p>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&#x27;ABC&#x27;)</span><br><span class="line">[&#x27;__add__&#x27;, &#x27;__class__&#x27;,..., &#x27;__subclasshook__&#x27;, &#x27;capitalize&#x27;, &#x27;casefold&#x27;,..., &#x27;zfill&#x27;]</span><br></pre></td></tr></table></figure><p>类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; &#x27;ABC&#x27;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyDog(object):</span><br><span class="line">...     def __len__(self):</span><br><span class="line">...         return 100</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dog = MyDog()</span><br><span class="line">&gt;&gt;&gt; len(dog)</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>剩下的都是普通属性或方法，比如lower()返回小写的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;ABC&#x27;.lower()</span><br><span class="line">&#x27;abc&#x27;</span><br></pre></td></tr></table></figure><p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyObject(object):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.x = 9</span><br><span class="line">...     def power(self):</span><br><span class="line">...         return self.x * self.x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; obj = MyObject()</span><br><span class="line">紧接着，可以测试该对象的属性：</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &#x27;x&#x27;) # 有属性&#x27;x&#x27;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; obj.x</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &#x27;y&#x27;) # 有属性&#x27;y&#x27;吗？</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; setattr(obj, &#x27;y&#x27;, 19) # 设置一个属性&#x27;y&#x27;</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &#x27;y&#x27;) # 有属性&#x27;y&#x27;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &#x27;y&#x27;) # 获取属性&#x27;y&#x27;</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; obj.y # 获取属性&#x27;y&#x27;</span><br><span class="line">19</span><br></pre></td></tr></table></figure><p>如果试图获取不存在的属性，会抛出AttributeError的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &#x27;z&#x27;) # 获取属性&#x27;z&#x27;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#x27;MyObject&#x27; object has no attribute &#x27;z&#x27;</span><br></pre></td></tr></table></figure><p>可以传入一个default参数，如果属性不存在，就返回默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &#x27;z&#x27;, 404) # 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span><br><span class="line">404</span><br></pre></td></tr></table></figure><p>也可以获得对象的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(obj, &#x27;power&#x27;) # 有属性&#x27;power&#x27;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &#x27;power&#x27;) # 获取属性&#x27;power&#x27;</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn = getattr(obj, &#x27;power&#x27;) # 获取属性&#x27;power&#x27;并赋值到变量fn</span><br><span class="line">&gt;&gt;&gt; fn # fn指向obj.power</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的</span><br><span class="line">81</span><br></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = obj.x + obj.y</span><br></pre></td></tr></table></figure><p>就不要写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = getattr(obj, &#x27;x&#x27;) + getattr(obj, &#x27;y&#x27;)</span><br></pre></td></tr></table></figure><p>一个正确的用法的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def readImage(fp):</span><br><span class="line">    if hasattr(fp, &#x27;read&#x27;):</span><br><span class="line">        return readData(fp)</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure><p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。</p><p>请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。</p><h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。<br>给实例绑定属性的方法是通过实例变量，或者通过self变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">s = Student(&#x27;Bob&#x27;)</span><br><span class="line">s.score = 90</span><br></pre></td></tr></table></figure><p>但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name = &#x27;Student&#x27;</span><br></pre></td></tr></table></figure><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = &#x27;Student&#x27;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = &#x27;Michael&#x27; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h3 id="子类调用父类的方法"><a href="#子类调用父类的方法" class="headerlink" title="子类调用父类的方法"></a>子类调用父类的方法</h3><h4 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h4><p>子类覆盖父类初始化方法而出现的不确定问题。</p><p>python和其他面向对象语言类似，每个类可以拥有一个或者多个父类，它们从父类那里继承了属性和方法。如果一个方法在子类的实例中被调用，或者一个属性在子类的实例中被访问，但是该方法或属性在子类中并不存在，那么就会自动的去其父类中进行查找。</p><p>继承父类后，就能调用父类方法和访问父类属性，而要完成整个集成过程，子类是需要调用的构造函数的。</p><p>子类不显式调用父类的构造方法，而父类构造函数初始化了一些属性，就会出现问题。</p><p>如果子类和父类都有构造函数，子类其实是重写了父类的构造函数，如果不显式调用父类构造函数，父类的构造函数就不会被执行，导致子类实例访问父类初始化方法中初始的变量就会出现问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.namea=&quot;aaa&quot;</span><br><span class="line">    def funca(self):</span><br><span class="line">        print &quot;function a : %s&quot;%self.namea</span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.nameb=&quot;bbb&quot;</span><br><span class="line">    def funcb(self):</span><br><span class="line">        print &quot;function b :%s&quot;%self.nameb</span><br><span class="line">b=B()</span><br><span class="line">print b.nameb</span><br><span class="line">b.funcb()</span><br><span class="line">b.funca()</span><br><span class="line"></span><br><span class="line">代码如下:</span><br><span class="line">bbb</span><br><span class="line">function b : bbb</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:workbenchpythonMyPythonProjectteststudyoverwrite_method.py&quot;, line 19, in &lt;module&gt;</span><br><span class="line">    print b.funca()</span><br><span class="line">  File &quot;D:workbenchpythonMyPythonProjectteststudyoverwrite_method.py&quot;, line 6, in funca</span><br><span class="line">    print &quot;function a : %s&quot;%self.namea</span><br><span class="line">AttributeError: B instance has no attribute &#x27;namea&#x27;</span><br></pre></td></tr></table></figure><p>在子类中，构造函数被重写，但新的构造方法没有任何关于初始化父类的namea属性的代码，为了达到预期的效果，子类的构造方法必须调用其父类的构造方法来进行基本的初始化。有两种方法能达到这个目的：调用超类构造方法的未绑定版本，或者使用super函数。</p><h4 id="调用未绑定的超类构造方法"><a href="#调用未绑定的超类构造方法" class="headerlink" title="调用未绑定的超类构造方法"></a>调用未绑定的超类构造方法</h4><p>修改代码，多增一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.namea=&quot;aaa&quot;</span><br><span class="line">    def funca(self):</span><br><span class="line">        print &quot;function a : %s&quot;%self.namea</span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #这一行解决了问题</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        self.nameb=&quot;bbb&quot;</span><br><span class="line">    def funcb(self):</span><br><span class="line">        print &quot;function b : %s&quot;%self.nameb</span><br><span class="line">b=B()</span><br><span class="line">print b.nameb</span><br><span class="line">b.funcb()</span><br><span class="line">b.funca()</span><br></pre></td></tr></table></figure><p>这种方法叫做调用父类的未绑定的构造方法。在调用一个实例的方法时，该方法的self参数会被自动绑定到实例上（称为绑定方法）。但如果直接调用类的方法（比如A.__init），那么就没有实例会被绑定。这样就可以自由的提供需要的self参数，这种方法称为未绑定unbound方法。</p><p>通过将当前的实例作为self参数提供给未绑定方法，B类就能使用其父类构造方法的所有实现，从而namea变量被设置。</p><h4 id="使用super函数"><a href="#使用super函数" class="headerlink" title="使用super函数"></a>使用super函数</h4><p>修改代码，这次需要增加在原来代码上增加2行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#父类需要继承object对象</span><br><span class="line">class A(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.namea=&quot;aaa&quot;</span><br><span class="line">    def funca(self):</span><br><span class="line">        print &quot;function a : %s&quot;%self.namea</span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        #这一行解决问题</span><br><span class="line">        super(B,self).__init__()</span><br><span class="line">        self.nameb=&quot;bbb&quot;</span><br><span class="line">    def funcb(self):</span><br><span class="line">        print &quot;function b :%s&quot;%self.nameb</span><br><span class="line">b=B()</span><br><span class="line">print b.nameb</span><br><span class="line">b.funcb()</span><br><span class="line">b.funca()</span><br></pre></td></tr></table></figure><p>如上有注释的为新增的代码，其中第一句让类A继承自object类，这样才能使用super函数，因为这是python的“新式类”支持的特性。当前的类和对象可以作为super函数的参数使用，调用函数返回的对象的任何方法都是调用超类的方法，而不是当前类的方法。</p><p>super函数会返回一个super对象，这个对象负责进行方法解析，解析过程其会自动查找所有的父类以及父类的父类。</p><p>super函数比在超类中直接调用未绑定方法更直观，但是其最大的有点是如果子类继承了多个父类，它只需要使用一次super函数就可以。然而如果没有这个需求，直接使用A.<strong>init</strong>(self)更直观一些。</p><h3 id="强制子类重新实现父类方法"><a href="#强制子类重新实现父类方法" class="headerlink" title="强制子类重新实现父类方法"></a>强制子类重新实现父类方法</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>1.父类定义方法后,并没有具体实现。<br>这时候子类就必须自己实现一遍,但是按照继承的规则,子类可以不实现,可以调用父类的方。<br>这时问题就出现了,父类没有定义,子类没有定义,这个方法还被调用了,那调用就出了问题。<br>为了强制子类必须实现这种方法,防止后边出错。<br>但是由于python是解释运行,所以这个””强制”,必须在运行时才能发现。</li><li>2.不让子类调用父类的一些方法</li></ul><h4 id="NotImplementedError"><a href="#NotImplementedError" class="headerlink" title="NotImplementedError"></a>NotImplementedError</h4><p>raise NotImplementedError<br>字面看就能看出啥意思.在父类定义方法,要求子类必须自行实现时,可以在定义函数中这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class first:</span><br><span class="line">    def in_first(self):</span><br><span class="line">        raise NotImplementedError</span><br><span class="line"></span><br><span class="line">class second(first):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">instance_from_second = second()</span><br><span class="line">instance_from_second.in_first()# &lt;== NotImplementedError</span><br></pre></td></tr></table></figure><p>如果子类没有实现就会触发 NotImplementedError 的异常,这时就知道这个方法在子类中没有实现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python生成器与迭代器</title>
      <link href="/2018/06/19/Python%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2018/06/19/Python%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p><span id="more"></span><p>在Python中，迭代是通过for … in来完成的，而很多语言比如C语言，迭代list是通过下标完成的，比如Java代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i=0; i&lt;list.length; i++) &#123;</span><br><span class="line">    n = list[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p><p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">...     print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。<br>默认情况下，dict迭代的是key。<br>如果要迭代value，可以用for value in d.values()<br>如果要同时迭代key和value，可以用for k, v in d.items()</p><p>由于字符串也是可迭代对象，因此，也可以作用于for循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for ch in &#x27;ABC&#x27;:</span><br><span class="line">...     print(ch)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</p><p>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>如果要对list实现类似Java那样的下标循环怎么办？<br>Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, value in enumerate([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure><p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:</span><br><span class="line">...     print(x, y)</span><br><span class="line">...</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure><h3 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。<br>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(1, 11))</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...    L.append(x * x)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;]</span><br><span class="line">[&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;]</span><br></pre></td></tr></table></figure><p>三层和三层以上的循环就很少用到了。</p><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到</span><br><span class="line">&gt;&gt;&gt; [d for d in os.listdir(&#x27;.&#x27;)] # os.listdir可以列出文件和目录</span><br><span class="line">[&#x27;.emacs.d&#x27;, &#x27;.ssh&#x27;, &#x27;.Trash&#x27;, &#x27;Adlm&#x27;, &#x27;Applications&#x27;, &#x27;Desktop&#x27;, &#x27;Documents&#x27;, &#x27;Downloads&#x27;, &#x27;Library&#x27;, &#x27;Movies&#x27;, &#x27;Music&#x27;, &#x27;Pictures&#x27;, &#x27;Public&#x27;, &#x27;VirtualBox VMs&#x27;, &#x27;Workspace&#x27;, &#x27;XCode&#x27;]</span><br></pre></td></tr></table></figure><p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;x&#x27;: &#x27;A&#x27;, &#x27;y&#x27;: &#x27;B&#x27;, &#x27;z&#x27;: &#x27;C&#x27; &#125;</span><br><span class="line">&gt;&gt;&gt; for k, v in d.items():</span><br><span class="line">...     print(k, &#x27;=&#x27;, v)</span><br><span class="line">...</span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br></pre></td></tr></table></figure><p>因此，列表生成式也可以使用两个变量来生成list：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;x&#x27;: &#x27;A&#x27;, &#x27;y&#x27;: &#x27;B&#x27;, &#x27;z&#x27;: &#x27;C&#x27; &#125;</span><br><span class="line">&gt;&gt;&gt; [k + &#x27;=&#x27; + v for k, v in d.items()]</span><br><span class="line">[&#x27;y=B&#x27;, &#x27;x=A&#x27;, &#x27;z=C&#x27;]</span><br></pre></td></tr></table></figure><p>最后把一个list中所有的字符串变成小写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;IBM&#x27;, &#x27;Apple&#x27;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ibm&#x27;, &#x27;apple&#x27;]</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。<br>而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure><p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</p><p>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？<br>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><p>上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">...  </span><br></pre></td></tr></table></figure><p>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。</p><p>如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</p><p>在 Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁。</p><p>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：<br>1, 1, 2, 3, 5, 8, 13, 21, 34, …<br>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &#x27;done&#x27;</span><br></pre></td></tr></table></figure><p>上面的函数可以输出斐波那契数列的前N个数。</p><p>可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。<br>要把fib函数变成generator，只需要把print(b)改为yield b就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &#x27;done&#x27;</span><br></pre></td></tr></table></figure><p>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = fib(6)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;generator object fib at 0x104feaaa0&gt;</span><br></pre></td></tr></table></figure><p>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。<br>而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p><p>举个简单的例子，定义一个generator，依次返回数字1，3，5：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def odd():</span><br><span class="line">    print(&#x27;step 1&#x27;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&#x27;step 2&#x27;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&#x27;step 3&#x27;)</span><br><span class="line">    yield(5)</span><br></pre></td></tr></table></figure><p>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; o = odd()</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 3</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。</p><p>回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</p><p>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in fib(6):</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。</p><p>要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。</p><p>对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。</p><p>请注意区分普通函数和generator函数，普通函数调用直接返回结果,generator函数的“调用”实际返回一个generator对象。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>可以直接作用于for循环的数据类型有以下几种：</p><ul><li>一类是集合数据类型，如list、tuple、dict、set、str等；</li><li>一类是generator，包括生成器和带yield的generator function。</li></ul><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。<br>可以使用isinstance()判断一个对象是否是Iterable对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。<br>可以使用isinstance()判断一个对象是否是Iterator对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#x27;abc&#x27;, Iterator)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&#x27;abc&#x27;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>为什么list、dict、str等数据类型不是Iterator？</p><p>因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。</p><p>可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p><p><strong>凡是可作用于for循环的对象都是Iterable类型；</strong></p><p><strong>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</strong></p><p><strong>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</strong></p><p>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in [1, 2, 3, 4, 5]:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>实际上完全等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p><strong>迭代器对象</strong><br>迭代器就是用于迭代操作（for 循环）的对象，它像列表一样可以迭代获取其中的每一个元素，任何实现了 __next__ 方法的对象都可以称为迭代器。</p><p>它与列表的区别在于，构建迭代器的时候，不像列表把所有元素一次性加载到内存，而是以一种延迟计算（lazy evaluation）方式返回元素，这正是它的优点。比如列表含有中一千万个整数，需要占超过400M的内存，而迭代器只需要几十个字节的空间。因为它并没有把所有元素装载到内存中，而是等到调用 next 方法时候才返回该元素（call by need 的方式），本质上 for 循环就是不断地调用迭代器的next方法。</p><p>以斐波那契数列为例来实现一个迭代器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Fib:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.prev = 0</span><br><span class="line">        self.cur = 1</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.n &gt; 0:</span><br><span class="line">            value = self.cur</span><br><span class="line">            self.cur = self.cur + self.prev</span><br><span class="line">            self.prev = value</span><br><span class="line">            self.n -= 1</span><br><span class="line">            return value</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration()</span><br><span class="line"></span><br><span class="line">f = Fib(10)</span><br><span class="line">print([i for i in f])</span><br><span class="line">#[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure><h3 id="理解-Python-迭代对象、迭代器、生成器"><a href="#理解-Python-迭代对象、迭代器、生成器" class="headerlink" title="理解 Python 迭代对象、迭代器、生成器"></a>理解 Python 迭代对象、迭代器、生成器</h3><p><img src="https://upload-images.jianshu.io/upload_images/9169686-be325aa3b6fcae6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="理解 Python 迭代对象、迭代器、生成器"></p><h4 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h4><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用 in, not in关键字判断元素是否包含在容器中。</p><p>通常这类数据结构把所有的元素存储在内存中（也有一些特列并不是所有的元素都放在内存）。<br>在Python中，常见的容器对象有：</p><ul><li>list, deque, ….</li><li>set, frozensets, ….</li><li>dict, defaultdict, OrderedDict, Counter, ….</li><li>tuple, namedtuple, …</li><li>str</li></ul><p>容器比较容易理解，因为你就可以把它看作是一个盒子、一栋房子、一个柜子，里面可以塞任何东西。从技术角度来说，当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为是一个容器，比如 list，set，tuples都是容器对象</p><p>尽管绝大多数容器都提供了某种方式来获取其中的每一个元素，但这并不是容器本身提供的能力，而是可迭代对象赋予了容器这种能力，当然并不是所有的容器都是可迭代的,比如：Bloom filter</p><p>虽然Bloom filter可以用来检测某个元素是否包含在容器中，但是并不能从容器中获取其中的每一个值，因为Bloom filter压根就没把元素存储在容器中，而是通过一个散列函数映射成一个值保存在数组中。</p><h4 id="可迭代对象-iterable"><a href="#可迭代对象-iterable" class="headerlink" title="可迭代对象(iterable)"></a>可迭代对象(iterable)</h4><p>很多容器都是可迭代对象，此外还有更多的对象同样也是可迭代对象，比如处于打开状态的files，sockets等等。但凡是可以返回一个迭代器的对象都可称之为可迭代对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = iter(x)</span><br><span class="line">&gt;&gt;&gt; z = iter(x)</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(y)</span><br><span class="line">&lt;class &#x27;list_iterator&#x27;&gt;</span><br></pre></td></tr></table></figure><p>这里 x是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具体的数据类型，list是可迭代对象，dict是可迭代对象，set也是可迭代对象。</p><p> y和 z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。</p><p> 迭代器有一种具体的迭代器类型，比如 list_iterator， set_iterator。<br> 可迭代对象实现了 __iter__和 __next__方法,这两个方法对应内置函数 iter()和 next()。 __iter__方法返回可迭代对象本身，这使得他既是一个可迭代对象同时也是一个迭代器。<br> 当运行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [1, 2, 3]</span><br><span class="line">for elem in x:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>实际执行情况是：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-61265546dc5ff596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实际执行情况"></p><h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h4><p>它是一个带状态的对象，他能在你调用 next()方法的时候返回容器中的下一个值，任何实现了 __next__()方法的对象都是迭代器。<br>迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回。有很多关于迭代器的例子，比如 itertools函数返回的都是迭代器对象。<br>生成无限序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import count</span><br><span class="line">&gt;&gt;&gt; counter = count(start=13)</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>从一个有限序列中生成无限序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import cycle</span><br><span class="line">&gt;&gt;&gt; colors = cycle([&#x27;red&#x27;, &#x27;white&#x27;, &#x27;blue&#x27;])</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#x27;red&#x27;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#x27;white&#x27;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#x27;blue&#x27;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#x27;red&#x27;</span><br></pre></td></tr></table></figure><p>从无限的序列中生成有限序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import islice</span><br><span class="line">&gt;&gt;&gt; colors = cycle([&#x27;red&#x27;, &#x27;white&#x27;, &#x27;blue&#x27;])  # infinite</span><br><span class="line">&gt;&gt;&gt; limited = islice(colors, 0, 4)            # finite</span><br><span class="line">&gt;&gt;&gt; for x in limited:                         </span><br><span class="line">...     print(x)</span><br><span class="line">red</span><br><span class="line">white</span><br><span class="line">blue</span><br><span class="line">red</span><br></pre></td></tr></table></figure><p>自定义一个迭代器，以斐波那契数列为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Fib:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.prev = 0</span><br><span class="line">        self.curr = 1</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        value = self.curr</span><br><span class="line">        self.curr += self.prev</span><br><span class="line">        self.prev = value</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = Fib()</span><br><span class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure><p>Fib既是一个可迭代对象（因为它实现了 __iter__方法），又是一个迭代器（因为实现了 __next__方法）。<br>实例变量 prev和 curr用户维护迭代器内部的状态。每次调用 next()方法的时候做两件事：</p><ul><li>为下一次调用 next()方法修改状态</li><li>为当前这次调用生成返回结果</li></ul><p>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</p><h4 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器(generator)"></a>生成器(generator)</h4><p>生成器算得上是Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。</p><p>它不需要再像上面的类一样写 __iter__()和 __next__()方法了，只需要一个 yiled关键字。</p><p>生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。</p><p>用生成器来实现斐波那契数列的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fib():</span><br><span class="line">    prev, curr = 0, 1</span><br><span class="line">    while True:</span><br><span class="line">        yield curr</span><br><span class="line">        prev, curr = curr, curr + prev</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = fib()</span><br><span class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure><p>fib就是一个普通的python函数，它特需的地方在于函数体中没有 return关键字，函数的返回值是一个生成器对象。<br>当执行 f&#x3D;fib()返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。</p><p>生成器在Python中是一个非常强大的编程结构，可以用更少地中间变量写流式代码，此外，相比其它容器对象它更能节省内存和CPU，当然它可以用更少的代码来实现相似的功能。</p><p>但凡看到类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def something():</span><br><span class="line">    result = []</span><br><span class="line">    for ... in ...:</span><br><span class="line">        result.append(x)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure><p>都可以用生成器函数来替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def iter_something():</span><br><span class="line">    for ... in ...:</span><br><span class="line">        yield x</span><br></pre></td></tr></table></figure><h4 id="生成器表达式-generator-expression"><a href="#生成器表达式-generator-expression" class="headerlink" title="生成器表达式(generator expression)"></a>生成器表达式(generator expression)</h4><p>生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = (x*x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x401f08&gt;</span><br><span class="line">&gt;&gt;&gt; sum(a)</span><br><span class="line">285</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数</title>
      <link href="/2018/06/14/Python%E5%87%BD%E6%95%B0/"/>
      <url>/2018/06/14/Python%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>在 C&#x2F;C++ 中，传值和传引用是函数参数传递的两种方式，学 Python 时，有人喜欢生搬硬套地问类似的问题：“Python 函数中，参数是传值，还是传引用？”。<br>为了把这个问题弄清楚，先了解 Python 中变量与对象之间的关系。</p><span id="more"></span><h4 id="变量与对象"><a href="#变量与对象" class="headerlink" title="变量与对象"></a>变量与对象</h4><p>Python 中一切皆为对象，数字是对象，列表是对象，函数也是对象，任何东西都是对象。</p><p>而变量是对象的一个引用（又称为名字或者标签），对象的操作都是通过引用来完成的。例如，[]是一个空列表对象，变量 a 是该对象的一个引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">a.append(1)</span><br></pre></td></tr></table></figure><p>在 Python 中，「变量」更准确叫法是「名字」，赋值操作 &#x3D; 就是把一个名字绑定到一个对象上。就像给对象添加一个标签。<br>a &#x3D; 1<br>整数 1 赋值给变量 a 就相当于是在整数1上绑定了一个 a 标签。<br>a &#x3D; 2<br>整数 2 赋值给变量 a，相当于把原来整数 1 身上的 a 标签撕掉，贴到整数 2 身上。<br>b &#x3D; a<br>把变量 a 赋值给另外一个变量 b，相当于在对象 2 上贴了 a，b 两个标签，通过这两个变量都可以对对象 2 进行操作。<br>变量本身没有类型信息，类型信息存储在对象中，这和C&#x2F;C++中的变量有非常大的出入（C中的变量是一段内存区域）</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>Python 函数中，参数的传递本质上是一种赋值操作，而赋值操作是一种名字到对象的绑定过程，清楚了赋值和参数传递的本质之后，现在再来分析两段代码。</p><p>代码段一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo(arg):</span><br><span class="line">    arg = 2</span><br><span class="line">    print(arg)</span><br><span class="line">a = 1</span><br><span class="line">foo(a)  # 输出：2</span><br><span class="line">print(a) # 输出：1</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/9169686-2690f89ee269c5c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码段一"><br>在代码段1中，变量 a 绑定了 1，调用函数 foo(a) 时，相当于给参数 arg 赋值 arg&#x3D;1，这时两个变量都绑定了 1。在函数里面 arg 重新赋值为 2 之后，相当于把 1 上的 arg 标签撕掉，贴到 2 身上，而 1 上的另外一个标签 a 一直存在。因此 print(a) 还是 1。</p><p>代码段二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def bar(args):</span><br><span class="line">    args.append(1)</span><br><span class="line"></span><br><span class="line">b = []</span><br><span class="line">print(b)#　输出：[]</span><br><span class="line">print(id(b)) # 输出：4324106952</span><br><span class="line">bar(b)</span><br><span class="line">print(b) ＃　输出：[1]</span><br><span class="line">print(id(b))  # 输出：4324106952</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/9169686-f5c8bf1aa374f25f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码段二"><br>执行 append 方法前 b 和 arg 都指向（绑定）同一个对象，执行 append 方法时，并没有重新赋值操作，也就没有新的绑定过程，append 方法只是对列表对象插入一个元素，对象还是那个对象，只是对象里面的内容变了。</p><p>因为 b 和 arg 都是绑定在同一个对象上，执行 b.append 或者 arg.append 方法本质上都是对同一个对象进行操作，因此 b 的内容在调用函数后发生了变化（但id没有变，还是原来那个对象）</p><p>最后，回到问题本身，究竟是是传值还是传引用呢？说传值或者传引用都不准确。非要安一个确切的叫法的话，叫传对象（call by object）。如果作为面试官，非要考察候选人对 Python 函数参数传递掌握与否，与其讨论字面上的意思，还不如来点实际代码。</p><p>代码段三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def bad_append(new_item, a_list=[]):</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    return a_list</span><br></pre></td></tr></table></figure><p>这段代码是初学者最容易犯的错误，用可变(mutable)对象作为参数的默认值。</p><p>函数定义好之后，默认参数 a_list 就会指向（绑定）到一个空列表对象，每次调用函数时，都是对同一个对象进行 append 操作。因此这样写就会有潜在的bug，同样的调用方式返回了不一样的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(bad_append(&#x27;one&#x27;))</span><br><span class="line">[&#x27;one&#x27;]</span><br><span class="line">&gt;&gt;&gt; print(bad_append(&#x27;one&#x27;))</span><br><span class="line">[&#x27;one&#x27;, &#x27;one&#x27;]</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/9169686-739fde1ae32c8488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码段三"></p><p>而正确的方式是，把参数默认值指定为None</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def good_append(new_item, a_list=None):</span><br><span class="line">    if a_list is None:</span><br><span class="line">        a_list = []</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    return a_list</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/9169686-2f0e14d7ad5aca39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码段三正确的方式"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>Python内置了很多有用的函数，我们可以直接调用。<br>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。<br>可以直接从Python的官方网站查看文档。<br>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</p><p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(1, 2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: abs() takes exactly one argument (2 given)</span><br></pre></td></tr></table></figure><p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(&#x27;a&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &#x27;str&#x27;</span><br></pre></td></tr></table></figure><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数。</p><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</span><br><span class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p><strong>定义函数</strong><br>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p><p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p><p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</p><p>在Python交互环境中定义函数时，注意Python会出现…的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def my_abs(x):                                      </span><br><span class="line">...     if x &gt;= 0:                                      </span><br><span class="line">...         return x                                    </span><br><span class="line">...     else:                                           </span><br><span class="line">...         return -x                                   </span><br><span class="line">...                                                     </span><br><span class="line">&gt;&gt;&gt; my_abs(-9)                                          </span><br><span class="line">9                                                       </span><br><span class="line">&gt;&gt;&gt; _   </span><br></pre></td></tr></table></figure><p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from abstest import my_abs                          </span><br><span class="line">&gt;&gt;&gt; my_abs(-9)                                          </span><br><span class="line">9                                                       </span><br><span class="line">&gt;&gt;&gt; _      </span><br></pre></td></tr></table></figure><p><strong>空函数</strong><br>如果想定义一个什么事也不做的空函数，可以用pass语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。<br>pass还可以用在其他语句里，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>缺少了pass，代码运行就会有语法错误。</p><p><strong>参数检查</strong><br>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError。但是如果参数类型不对，Python解释器就无法帮我们检查。</p><p>数据类型检查可以用内置函数isinstance()实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&#x27;bad operand type&#x27;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&#x27;A&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</span><br><span class="line">TypeError: bad operand type</span><br></pre></td></tr></table></figure><p><strong>返回多个值</strong><br>返回值是一个tuple（元组）！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><h4 id="函数的参数-1"><a href="#函数的参数-1" class="headerlink" title="函数的参数"></a>函数的参数</h4><p><strong>位置参数</strong><br>对于power(x)函数，参数x就是一个位置参数。当我们调用power函数时，必须传入有且仅有的一个参数x。<br>power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。</p><p><strong>默认参数</strong><br>新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用。<br>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：def power(x, n&#x3D;2):<br>这样，当我们调用power(5)时，相当于调用power(5, 2)</p><p>设置默认参数时，有几点要注意：</p><ul><li>一是必选参数在前，默认参数在后，否则Python的解释器会报错</li><li>二是如何设置默认参数。函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li></ul><p>默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p><p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=[]):</span><br><span class="line">    L.append(&#x27;END&#x27;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(&#x27;END&#x27;)</span><br><span class="line">    return L</span><br><span class="line"></span><br><span class="line">#无论调用多少次，都不会有问题</span><br></pre></td></tr></table></figure><p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><p><strong>可变参数</strong><br>可变参数就是传入的参数个数是可变的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。</span><br><span class="line"></span><br><span class="line">要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</span><br><span class="line"></span><br><span class="line">def calc(numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">但是调用的时候，需要先组装出一个list或tuple：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br><span class="line"></span><br><span class="line">我们把函数的参数改为可变参数：</span><br><span class="line">def calc(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">调用函数的方式可以简化成这样：</span><br><span class="line">&gt;&gt;&gt; calc(1, 2, 3)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc(1, 3, 5, 7)</span><br><span class="line">84</span><br></pre></td></tr></table></figure><p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。</p><p>如果已经有一个list或者tuple，要调用一个可变参数，在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br><span class="line"></span><br><span class="line"># *nums表示把nums这个list的所有元素作为可变参数传进去。</span><br></pre></td></tr></table></figure><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。</p><p><strong>关键字参数</strong><br>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)</span><br><span class="line"></span><br><span class="line">函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Michael&#x27;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line"></span><br><span class="line">也可以传入任意个数的关键字参数：</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Bob&#x27;, 35, city=&#x27;Beijing&#x27;)</span><br><span class="line">name: Bob age: 35 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;)</span><br><span class="line">name: Adam age: 45 other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure><p>关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p><p>**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=extra[&#x27;city&#x27;], job=extra[&#x27;job&#x27;])</span><br><span class="line">name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure><p><strong>命名关键字参数</strong><br>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p><p>仍以person()函数为例，我们希望检查是否有city和job参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    if &#x27;city&#x27; in kw:</span><br><span class="line">        # 有city参数</span><br><span class="line">        pass</span><br><span class="line">    if &#x27;job&#x27; in kw:</span><br><span class="line">        # 有job参数</span><br><span class="line">        pass</span><br><span class="line">    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)</span><br></pre></td></tr></table></figure><p>但是调用者仍可以传入不受限制的关键字参数。<br>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。<br>调用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, city=&#x27;Beijing&#x27;, job=&#x27;Engineer&#x27;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, &#x27;Beijing&#x27;, &#x27;Engineer&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() takes 2 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p><p>命名关键字参数可以有缺省值，从而简化调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city=&#x27;Beijing&#x27;, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; person(&#x27;Jack&#x27;, 24, job=&#x27;Engineer&#x27;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数。</p><p><strong>参数组合</strong><br>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。<br><strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></p><p>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。<br>对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络爬虫</title>
      <link href="/2018/06/10/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
      <url>/2018/06/10/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="通用爬虫"><a href="#通用爬虫" class="headerlink" title="通用爬虫"></a>通用爬虫</h3><p>搜索引擎用的爬虫系统，目标就是尽可能把互联网上所有的网页下载下来，放到本地服务器里形成备份，再对这些网页做相关处理（提取关键字、去掉广告），最后提供一个用户检索接口。</p><span id="more"></span><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><strong>第一步：抓取网页</strong><br>首先选取一部分的种子URL，将这些URL放入待抓取URL队列；</p><p>取出待抓取URL，解析DNS得到主机的IP，并将URL对应的网页下载下来，存储进已下载网页库中，并且将这些URL放进已抓取URL队列。</p><p>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环….</p><p>搜索引擎如何获取一个新网站的URL：</p><ul><li><ol><li>新网站向搜索引擎主动提交网址</li></ol></li><li>2.在其他网站上设置新网站外链（尽可能处于搜索引擎爬虫爬取范围）</li><li><ol start="3"><li>搜索引擎和DNS解析服务商(如DNSPod等）合作，新网站域名将被迅速抓取。</li></ol></li><li>搜索引擎蜘蛛的爬行是被输入了一定的规则的，它需要遵从一些命令或文件的内容，如标注为nofollow的链接，或者是Robots协议。</li></ul><p><strong>第二步：数据存储</strong><br>搜索引擎通过爬虫爬取到的网页，将数据存入原始页面数据库。其中的页面数据与用户浏览器得到的HTML是完全一样的。</p><p>除了HTML文件外，搜索引擎通常还能抓取和索引以文字为基础的多种文件类型。</p><p>搜索引擎蜘蛛在抓取页面时，也做一定的重复内容检测，一旦遇到访问权重很低的网站上有大量抄袭、采集或者复制的内容，很可能就不再爬行。</p><p><strong>第三步：预处理</strong><br>搜索引擎将爬虫抓取回来的页面，进行各种步骤的预处理。</p><ul><li>提取文字</li><li>中文分词</li><li>消除噪音（比如版权声明文字、导航条、广告等……）</li><li>索引处理</li><li>链接关系计算</li><li>特殊文件处理</li></ul><p><strong>第四步：提供检索服务，网站排名</strong><br>搜索引擎在对信息进行组织和处理后，为用户提供关键字检索服务，将用户检索相关的信息展示给用户。</p><p>同时会根据页面的PageRank值（链接的访问量排名）来进行网站排名，这样Rank值高的网站在搜索结果中会排名较前，当然也可以直接使用 Money 购买搜索引擎网站排名，简单粗暴。</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>通用搜索引擎所返回的结果都是网页，而大多情况下，网页里90%的内容对用户来说都是无用的。</p><p>不同领域、不同背景的用户往往具有不同的检索目的和需求，搜索引擎无法提供针对具体某个用户的搜索结果。</p><p>万维网数据形式的丰富和网络技术的不断发展，图片、数据库、音频、视频多媒体等不同数据大量出现，通用搜索引擎对这些文件无能为力，不能很好地发现和获取。</p><p>通用搜索引擎大多提供基于关键字的检索，难以支持根据语义信息提出的查询，无法准确理解用户的具体需求。</p><p>针对这些情况，聚焦爬虫技术得以广泛使用。</p><h3 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h3><p>爬虫程序员写的针对某种内容爬虫，是”面向特定主题需求”的一种网络爬虫程序。</p><p>与通用搜索引擎爬虫的区别在于： 聚焦爬虫在实施网页抓取时会对内容进行处理筛选，尽量保证只抓取与需求相关的网页信息。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pythonic</title>
      <link href="/2018/06/08/Pythonic/"/>
      <url>/2018/06/08/Pythonic/</url>
      
        <content type="html"><![CDATA[<h4 id="链式比较操作"><a href="#链式比较操作" class="headerlink" title="链式比较操作"></a>链式比较操作</h4><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; False == False == True </span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 18 &lt; age &lt; 60:</span><br><span class="line">    print(&quot;yong man&quot;)</span><br></pre></td></tr></table></figure><h4 id="if-else-三目运算"><a href="#if-else-三目运算" class="headerlink" title="if&#x2F;else 三目运算"></a>if&#x2F;else 三目运算</h4><p>text &#x3D; ‘男’ if gender &#x3D;&#x3D; ‘male’ else ‘女’<br>在类C的语言中都支持三目运算 b?x:y<br>但在python能够用 if&#x2F;else 清晰表达逻辑时，就没必要再额外新增一种方式来实现。</p><h4 id="真值判断"><a href="#真值判断" class="headerlink" title="真值判断"></a>真值判断</h4><p>检查某个对象是否为真值时，还显示地与 True 和 False 做比较就显得多此一举，不专业。<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if attr == True:</span><br><span class="line">    do_something()</span><br><span class="line">if len(values) != 0: # 判断列表是否为空</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if attr:</span><br><span class="line">    do_something()</span><br><span class="line">if values:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/9169686-440e8c887e6246c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="真假值对照表"></p><h4 id="for-else语句"><a href="#for-else语句" class="headerlink" title="for&#x2F;else语句"></a>for&#x2F;else语句</h4><p>for else 是 Python 中特有的语法格式，else 中的代码在 for 循环遍历完所有元素之后执行。<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flagfound = False</span><br><span class="line">for i in mylist:</span><br><span class="line">    if i == theflag:</span><br><span class="line">        flagfound = True</span><br><span class="line">        break</span><br><span class="line">    process(i)</span><br><span class="line">if not flagfound:</span><br><span class="line">    raise ValueError(&quot;List argument missing terminal flag.&quot;)</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in mylist:</span><br><span class="line">    if i == theflag:</span><br><span class="line">        break</span><br><span class="line">    process(i)</span><br><span class="line">else:</span><br><span class="line">    raise ValueError(&quot;List argument missing terminal flag.&quot;)</span><br></pre></td></tr></table></figure><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 = &quot;foofish.net&quot;</span><br><span class="line">s2 = &quot;vttalk&quot;</span><br><span class="line">s3 = &quot;welcome to %s and following %s&quot; % (s1, s2)</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s3 = &quot;welcome to &#123;blog&#125; and following &#123;wechat&#125;&quot;.format(blog=&quot;foofish.net&quot;, wechat=&quot;vttalk&quot;)</span><br></pre></td></tr></table></figure><p>很难说用 format 比用 %s 的代码量少，但是 format 更易于理解。</p><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><p>获取列表中的部分元素最先想到的就是用 for 循环根据条件提取元素，这也是其它语言中惯用的手段，而在 Python 中还有强大的切片功能。<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">items = range(10)</span><br><span class="line"># 奇数</span><br><span class="line">odd_items = []</span><br><span class="line">for i in items:</span><br><span class="line">    if i % 2 != 0:</span><br><span class="line">        odd_items.append(i)</span><br><span class="line"># 拷贝</span><br><span class="line">copy_items = []</span><br><span class="line">for i in items:</span><br><span class="line">    copy_items.append(i)</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第1到第4个元素的范围区间</span><br><span class="line">sub_items = items[1:4]</span><br><span class="line"># 奇数</span><br><span class="line">odd_items = items[1::2]</span><br><span class="line">#拷贝</span><br><span class="line">copy_items = items[::] 或者 items[:]</span><br></pre></td></tr></table></figure><p>列表元素的下标不仅可以用正数表示，还是用负数表示，最后一个元素的位置是 -1，从右往左，依次递减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------------------------</span><br><span class="line"> | P | y | t | h | o | n |</span><br><span class="line">--------------------------</span><br><span class="line">   0   1   2   3   4   5 </span><br><span class="line">  -6  -5  -4  -3  -2  -1</span><br><span class="line">-------------------------- </span><br></pre></td></tr></table></figure><h4 id="善用生成器"><a href="#善用生成器" class="headerlink" title="善用生成器"></a>善用生成器</h4><p>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    result = []</span><br><span class="line">    while b &lt; n:</span><br><span class="line">        result.append(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    while a &lt; n:</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br></pre></td></tr></table></figure><p>上面是用生成器生成费波那契数列。生成器的好处就是无需一次性把所有元素加载到内存，只有迭代获取元素时才返回该元素，而列表是预先一次性把全部元素加载到了内存。此外用 yield 代码看起来更清晰。</p><h4 id="获取字典元素"><a href="#获取字典元素" class="headerlink" title="获取字典元素"></a>获取字典元素</h4><p>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#x27;name&#x27;: &#x27;foo&#x27;&#125;</span><br><span class="line">if d.has_key(&#x27;name&#x27;):</span><br><span class="line">    print(d[&#x27;name&#x27;])</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;unkonw&#x27;)</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.get(&quot;name&quot;, &quot;unknow&quot;)</span><br></pre></td></tr></table></figure><h4 id="预设字典默认值"><a href="#预设字典默认值" class="headerlink" title="预设字典默认值"></a>预设字典默认值</h4><p>通过 key 分组的时候，不得不每次检查 key 是否已经存在于字典中。<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = [(&#x27;foo&#x27;, 10), (&#x27;bar&#x27;, 20), (&#x27;foo&#x27;, 39), (&#x27;bar&#x27;, 49)]</span><br><span class="line">groups = &#123;&#125;</span><br><span class="line">for (key, value) in data:</span><br><span class="line">    if key in groups:</span><br><span class="line">        groups[key].append(value)</span><br><span class="line">    else:</span><br><span class="line">        groups[key] = [value]</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#　第一种方式</span><br><span class="line">groups = &#123;&#125;</span><br><span class="line">for (key, value) in data:</span><br><span class="line">    groups.setdefault(key, []).append(value) </span><br><span class="line"></span><br><span class="line"># 第二种方式</span><br><span class="line">from collections import defaultdict</span><br><span class="line">groups = defaultdict(list)</span><br><span class="line">for (key, value) in data:</span><br><span class="line">    groups[key].append(value)</span><br></pre></td></tr></table></figure><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numbers = [1, 2, 3]</span><br><span class="line">my_dict = &#123;number: number * 2 for number in numbers&#125;</span><br><span class="line">print(my_dict)  # &#123;1: 2, 2: 4, 3: 6&#125;</span><br><span class="line"></span><br><span class="line"># 还可以指定过滤条件</span><br><span class="line">my_dict = &#123;number: number * 2 for number in numbers if number &gt; 1&#125;</span><br><span class="line">print(my_dict)  # &#123;2: 4, 3: 6&#125;</span><br></pre></td></tr></table></figure><h4 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h4><p>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line">&gt;&gt;&gt; b = 2</span><br><span class="line">&gt;&gt;&gt; tmp = a</span><br><span class="line">&gt;&gt;&gt; a = b</span><br><span class="line">&gt;&gt;&gt; b = tmp</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b = b, a</span><br></pre></td></tr></table></figure><h4 id="带有索引位置的集合遍历"><a href="#带有索引位置的集合遍历" class="headerlink" title="带有索引位置的集合遍历"></a>带有索引位置的集合遍历</h4><p>遍历集合时如果需要使用到集合的索引位置时，直接对集合迭代是没有索引信息的。<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;]</span><br><span class="line">for i in range(len(colors)):</span><br><span class="line">    print i, &#x27;---&gt;&#x27;, colors[i]</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, color in enumerate(colors):</span><br><span class="line">    print i, &#x27;---&gt;&#x27;, color</span><br></pre></td></tr></table></figure><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;raymond&#x27;, &#x27;rachel&#x27;, &#x27;matthew&#x27;, &#x27;roger&#x27;, &#x27;betty&#x27;, &#x27;melissa&#x27;, &#x27;judith&#x27;, &#x27;charlie&#x27;]</span><br><span class="line">s = names[0]</span><br><span class="line">for name in names[1:]:</span><br><span class="line">    s += &#x27;, &#x27; + name</span><br><span class="line">print s</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &#x27;, &#x27;.join(names)</span><br></pre></td></tr></table></figure><p>join 是一种更加高效的字符串连接方式，使用 + 操作时，每执行一次+操作就会导致在内存中生成一个新的字符串对象，遍历8次有8个字符串生成，造成无谓的内存浪费。而用 join 方法整个过程只会产生一个字符串对象。</p><h4 id="打开-关闭文件"><a href="#打开-关闭文件" class="headerlink" title="打开&#x2F;关闭文件"></a>打开&#x2F;关闭文件</h4><p>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(&#x27;data.txt&#x27;)</span><br><span class="line">try:</span><br><span class="line">    data = f.read()</span><br><span class="line">finally:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;data.txt&#x27;) as f:</span><br><span class="line">    data = f.read()</span><br></pre></td></tr></table></figure><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>能够用一行代码简明扼要地解决问题时，绝不要用两行<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">for i in range(10):</span><br><span class="line">    result.append(i)</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i for i in range(10)]</span><br></pre></td></tr></table></figure><h4 id="善用装饰器"><a href="#善用装饰器" class="headerlink" title="善用装饰器"></a>善用装饰器</h4><p>装饰器可以把与业务逻辑无关的代码抽离出来，让代码保持干净清爽，而且装饰器还能被多个地方重复利用。比如一个爬虫网页的函数，如果该 URL 曾经被爬过就直接从缓存中获取，否则爬下来之后加入到缓存，防止后续重复爬取。<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def web_lookup(url, saved=&#123;&#125;):</span><br><span class="line">    if url in saved:</span><br><span class="line">        return saved[url]</span><br><span class="line">    page = urllib.urlopen(url).read()</span><br><span class="line">    saved[url] = page</span><br><span class="line">    return page</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request as urllib</span><br><span class="line"></span><br><span class="line">def cache(func):</span><br><span class="line">    saved = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def wrapper(url):</span><br><span class="line">        if url in saved:</span><br><span class="line">            return saved[url]</span><br><span class="line">        else:</span><br><span class="line">            page = func(url)</span><br><span class="line">            saved[url] = page</span><br><span class="line">            return page</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@cache</span><br><span class="line">def web_lookup(url):</span><br><span class="line">    return urllib.urlopen(url).read()</span><br></pre></td></tr></table></figure><p>用装饰器写代码表面上感觉代码量更多，但是它把缓存相关的逻辑抽离出来了，可以给更多的函数调用，这样总的代码量就会少很多，而且业务方法看起来简洁了。</p><h4 id="合理使用列表"><a href="#合理使用列表" class="headerlink" title="合理使用列表"></a>合理使用列表</h4><p>列表对象（list）是一个查询效率高于更新操作的数据结构，比如删除一个元素和插入一个元素时执行效率就非常低，因为还要对剩下的元素进行移动。<br>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;raymond&#x27;, &#x27;rachel&#x27;, &#x27;matthew&#x27;, &#x27;roger&#x27;, &#x27;betty&#x27;, &#x27;melissa&#x27;, &#x27;judith&#x27;, &#x27;charlie&#x27;]</span><br><span class="line">names.pop(0)</span><br><span class="line">names.insert(0, &#x27;mark&#x27;)</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">names = deque([&#x27;raymond&#x27;, &#x27;rachel&#x27;, &#x27;matthew&#x27;, &#x27;roger&#x27;, &#x27;betty&#x27;, &#x27;melissa&#x27;, &#x27;judith&#x27;, &#x27;charlie&#x27;])</span><br><span class="line">names.popleft()</span><br><span class="line">names.appendleft(&#x27;mark&#x27;)</span><br></pre></td></tr></table></figure><p>deque 是一个双向队列的数据结构，删除元素和插入元素会很快</p><h4 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h4><p>一般：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = &#x27;vttalk&#x27;, &#x27;female&#x27;, 30, &#x27;python@qq.com&#x27;</span><br><span class="line">name = p[0]</span><br><span class="line">gender = p[1]</span><br><span class="line">age = p[2]</span><br><span class="line">email = p[3]</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name, gender, age, email = p</span><br></pre></td></tr></table></figure><h4 id="遍历字典的-key-和-value"><a href="#遍历字典的-key-和-value" class="headerlink" title="遍历字典的 key 和 value"></a>遍历字典的 key 和 value</h4><p>方法一速度没那么快，因为每次迭代的时候还要重新进行hash查找 key 对应的 value。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 方法一</span><br><span class="line">for k in d:</span><br><span class="line">    print k, &#x27;---&gt;&#x27;, d[k]</span><br></pre></td></tr></table></figure><p>方法二遇到字典非常大的时候，会导致内存的消耗增加一倍以上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 方法二</span><br><span class="line">for k, v in d.items():</span><br><span class="line">    print k, &#x27;---&gt;&#x27;, v</span><br></pre></td></tr></table></figure><p>pythonic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for k, v in d.iteritems():</span><br><span class="line">    print k, &#x27;---&gt;&#x27;, v</span><br></pre></td></tr></table></figure><p>iteritems 返回迭代器对象，可节省更多的内存，不过在 python3 中没有该方法了，只有 items 方法，等值于 iteritems。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu开启BBR加速</title>
      <link href="/2018/06/07/ubuntu%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/"/>
      <url>/2018/06/07/ubuntu%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<p>BBR是google的TCP阻塞控制算法，可以最大程度的利用带宽，提升网络传输速率。</p><p>Linux kernel 4.9 及以上已支持 tcp_bbr</p><span id="more"></span><h4 id="查看系统内核版本："><a href="#查看系统内核版本：" class="headerlink" title="查看系统内核版本："></a>查看系统内核版本：</h4><p>uname -r</p><p>看内核版本是否大于等于4.9，否则要升级内核，或者安装bbr。</p><h4 id="开启BBR："><a href="#开启BBR：" class="headerlink" title="开启BBR："></a>开启BBR：</h4><p>echo “net.core.default_qdisc&#x3D;fq” &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</p><p>echo “net.ipv4.tcp_congestion_control&#x3D;bbr” &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</p><h4 id="保存生效："><a href="#保存生效：" class="headerlink" title="保存生效："></a>保存生效：</h4><p>sysctl -p</p><h4 id="检查BBR是否启用："><a href="#检查BBR是否启用：" class="headerlink" title="检查BBR是否启用："></a>检查BBR是否启用：</h4><p>sysctl net.ipv4.tcp_available_congestion_control</p><p>返回值一般为：net.ipv4.tcp_available_congestion_control &#x3D; reno cubic bbr</p><p>sysctl net.ipv4.tcp_congestion_control</p><p>返回值一般为：net.ipv4.tcp_congestion_control &#x3D; bbr</p><p>sysctl net.core.default_qdisc</p><p>返回值一般为：net.core.default_qdisc &#x3D; fq</p><p>lsmod | grep bbr</p><p>返回值有 tcp_bbr 模块则BBR已启动：</p><p>tcp_bbr 20480 10</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装nginx启用HTTPS并端口重定向</title>
      <link href="/2018/06/07/ubuntu%E5%AE%89%E8%A3%85nginx%E5%90%AF%E7%94%A8HTTPS%E5%B9%B6%E7%AB%AF%E5%8F%A3%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2018/06/07/ubuntu%E5%AE%89%E8%A3%85nginx%E5%90%AF%E7%94%A8HTTPS%E5%B9%B6%E7%AB%AF%E5%8F%A3%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强。</p><span id="more"></span><h4 id="ubuntu安装nginx"><a href="#ubuntu安装nginx" class="headerlink" title="ubuntu安装nginx:"></a>ubuntu安装nginx:</h4><p>sudo apt-get update</p><p>sudo apt-get install nginx</p><pre><code>    Let’s Encrypt 是 一个叫 ISRG （ Internet Security Research Group ，互联网安全研究小组）的组织推出的免费安全证书计划。    Certbot是EFF的自动部署Let’s Encrypt证书的工具，使用简单。</code></pre><h4 id="ubuntu安装Certbot"><a href="#ubuntu安装Certbot" class="headerlink" title="ubuntu安装Certbot:"></a>ubuntu安装Certbot:</h4><p>sudo apt-get install certbot python-certbot-nginx</p><h4 id="部署证书"><a href="#部署证书" class="headerlink" title="部署证书:"></a>部署证书:</h4><p>sudo certbot certonly –webroot -w &#x2F;var&#x2F;www&#x2F;html&#x2F; -d your.site.com</p><p>中间过程要同意协议以及填写邮箱，部署成功返回：</p><p>IMPORTANT NOTES:</p><ul><li><p>Congratulations! Your certificate and chain have been saved at:</p><p>&#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your.site.com&#x2F;fullchain.pem</p><p>Your key file has been saved at:</p><p>&#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your.site.com&#x2F;privkey.pem</p><p>Your cert will expire on 2018-09-04. To obtain a new or tweaked</p><p>version of this certificate in the future, simply run certbot</p><p>again. To non-interactively renew <em>all</em> of your certificates, run</p><p>“certbot renew”</p></li><li><p>Your account credentials have been saved in your Certbot</p><p>configuration directory at &#x2F;etc&#x2F;letsencrypt. You should make a</p><p>secure backup of this folder now. This configuration directory will</p><p>also contain certificates and private keys obtained by Certbot so</p><p>making regular backups of this folder is ideal.</p></li><li><p>If you like Certbot, please consider supporting our work by:</p><p>Donating to ISRG &#x2F; Let’s Encrypt:  <a href="https://letsencrypt.org/donate">https://letsencrypt.org/donate</a></p><p>Donating to EFF:                    <a href="https://eff.org/donate-le">https://eff.org/donate-le</a></p></li></ul><h4 id="修改Nginx的虚拟主机配置文件，新建一个443端口的server配置："><a href="#修改Nginx的虚拟主机配置文件，新建一个443端口的server配置：" class="headerlink" title="修改Nginx的虚拟主机配置文件，新建一个443端口的server配置："></a>修改Nginx的虚拟主机配置文件，新建一个443端口的server配置：</h4><p>配置文件:&#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</p><p>新增内容：</p><p>server {</p><pre><code>    listen 443 ssl;    listen [::]:443 ssl ipv6only=on;    ssl_certificate /etc/letsencrypt/live/your.site.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/your.site.com/privkey.pem;    ssl_trusted_certificate /etc/letsencrypt/live/your.site.com/chain.pem;    root /var/www/html;    index index.html index.htm index.nginx-debian.html index.php;    server_name your.site.com;</code></pre><p>}</p><h4 id="重启nginx："><a href="#重启nginx：" class="headerlink" title="重启nginx："></a>重启nginx：</h4><p>sudo service nginx reload</p><p>此时，访问<a href="https://your.site.com已经可以显示安全标记./">https://your.site.com已经可以显示安全标记。</a></p><h4 id="nginx-80端口重定向到443端口："><a href="#nginx-80端口重定向到443端口：" class="headerlink" title="nginx 80端口重定向到443端口："></a>nginx 80端口重定向到443端口：</h4><p>server {</p><pre><code>    listen 80;    server_name your.site.com;    rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;</code></pre><p>}</p><h4 id="Let’s-Encrypt-生成的免费证书为3个月时间，到期要更新证书："><a href="#Let’s-Encrypt-生成的免费证书为3个月时间，到期要更新证书：" class="headerlink" title="Let’s Encrypt 生成的免费证书为3个月时间，到期要更新证书："></a>Let’s Encrypt 生成的免费证书为3个月时间，到期要更新证书：</h4><p>sudo certbot renew –dry-run</p><p>成功更新返回：</p><p>Saving debug log to &#x2F;var&#x2F;log&#x2F;letsencrypt&#x2F;letsencrypt.log</p><hr><p>Processing &#x2F;etc&#x2F;letsencrypt&#x2F;renewal&#x2F;your.site.com.conf</p><hr><p>Cert not due for renewal, but simulating renewal for dry run</p><p>Plugins selected: Authenticator webroot, Installer None</p><p>Renewing an existing certificate</p><p>Performing the following challenges:</p><p>http-01 challenge for your.site.com</p><p>Waiting for verification…</p><p>Cleaning up challenges</p><hr><p>new certificate deployed without reload, fullchain is</p><p>&#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your.site.com&#x2F;fullchain.pem</p><hr><hr><p>** DRY RUN: simulating ‘certbot renew’ close to cert expiry</p><p>**          (The test certificates below have not been saved.)</p><p>Congratulations, all renewals succeeded. The following certs have been renewed:</p><p>  &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;your.site.com&#x2F;fullchain.pem (success)</p><p>** DRY RUN: simulating ‘certbot renew’ close to cert expiry</p><p>**          (The test certificates above have not been saved.)</p><hr><p>IMPORTANT NOTES:</p><ul><li><p>Your account credentials have been saved in your Certbot</p><p>configuration directory at &#x2F;etc&#x2F;letsencrypt. You should make a</p><p>secure backup of this folder now. This configuration directory will</p><p>also contain certificates and private keys obtained by Certbot so</p><p>making regular backups of this folder is ideal.</p></li></ul><h4 id="使用crontab-e的命令来启用自动更新证书任务："><a href="#使用crontab-e的命令来启用自动更新证书任务：" class="headerlink" title="使用crontab -e的命令来启用自动更新证书任务："></a>使用crontab -e的命令来启用自动更新证书任务：</h4><p>sudo crontab -e</p><p>添加配置：</p><p>30 2 * * 1 &#x2F;usr&#x2F;bin&#x2F;certbot renew  &gt;&gt; &#x2F;var&#x2F;log&#x2F;le-renew.log</p><p>上面的执行时间为：每周一半夜2点30分执行renew任务。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字符编码</title>
      <link href="/2018/06/04/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2018/06/04/Python%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p>UnicodeEncodeError<br>UnicodeDecodeError</p><span id="more"></span><h4 id="字节与字符"><a href="#字节与字符" class="headerlink" title="字节与字符"></a>字节与字符</h4><p>计算机存储的一切数据，文本字符、图片、视频、音频、软件都是由一串01的字节序列构成的，一个字节等于8个比特位。</p><p>而字符就是一个符号，比如一个汉字、一个英文字母、一个数字、一个标点都可以称为一个字符。</p><p>字节方便存储和网络传输，而字符用于显示，方便阅读。字符 “p” 保存到硬盘就是一串二进制数据 01110000，占用一个字节的长度。</p><h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><p>我们用编辑器打开的文本，看到的一个个字符，最终保存在磁盘的时候都是以二进制字节序列形式存起来的。</p><p>那么从字符到字节的转换过程就叫做编码（encode），反过来叫做解码（decode）</p><p>两者是一个可逆的过程。编码是为了存储传输，解码是为了方便显示阅读。<br>例如字符 “p” 保存到硬盘是一串二进制 01110000 ，占用一个字节的长度。<br>Python 使用 ASCII 字符编码作为默认编码方式，而 ASCII 不能处理中文。</p><p>Python2 把字符串分为 unicode 和 str 两种类型。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-1e7ccd9825dffaa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unicode 和 str"><br>str 本质上其实是一串二进制数据，而 unicode 是字符（符号），编码（encode）就是把字符（符号）转换为 二进制数据的过程，因此 unicode 到 str 的转换要用 encode 方法，反过来就是用 decode 方法。</p><h4 id="UnicodeEncodeError"><a href="#UnicodeEncodeError" class="headerlink" title="UnicodeEncodeError"></a>UnicodeEncodeError</h4><p>UnicodeEncodeError 发生在 unicode 字符串转换成 str 字节序列的时候。</p><p>调用 write 方法时，Python 会先判断字符串是什么类型，如果是 str，就直接写入文件，不需要编码，因为 str 类型的字符串本身就是一串二进制的字节序列了。</p><p>如果字符串是 unicode 类型，那么它会先调用 encode 方法把 unicode 字符串转换成二进制形式的 str 类型，才保存到文件，而 encode 方法会使用 python 默认的 ascii 码来编码。</p><p> ASCII 字符集中只包含了128个拉丁字母，不包括中文字符，因此 出现了 ‘ascii’ codec can’t encode characters 的错误。要正确地使用 encode ，就必须指定一个包含了中文字符的字符集，比如：UTF-8、GBK。</p><h4 id="UnicodeDecodeError"><a href="#UnicodeDecodeError" class="headerlink" title="UnicodeDecodeError"></a>UnicodeDecodeError</h4><p>1.UnicodeDecodeError 发生在 str 类型的字节序列解码成 unicode 类型的字符串时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = a.encode(&quot;utf-8&quot;)</span><br><span class="line">b.decode(&quot;gbk&quot;)</span><br><span class="line"></span><br><span class="line">UnicodeDecodeError: &#x27;gbk&#x27; codec can&#x27;t decode byte 0x85 in position 2</span><br></pre></td></tr></table></figure><p>把一个经过 UTF-8 编码后生成的字节序列 ‘\xe7\xa6\x85’ 再用 GBK 解码转换成 unicode 字符串时，出现 UnicodeDecodeError，因为 （对于中文字符）GBK 编码只占用两个字节，而 UTF-8 占用3个字节，用 GBK 转换时，还多出一个字节，因此它没法解析。避免 UnicodeDecodeError 的关键是保持 编码和解码时用的编码类型一致。</p><p>2.str 与 unicode 字符串 执行 + 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x + y</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  UnicodeDecodeError: &#x27;ascii&#x27; codec can&#x27;t decode byte 0xe4 in position 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>str 与 unicode 字符串 执行 + 操作时，Python 会把 str 类型的字节序列隐式地转换成（解码）成 和 x 一样的 unicode 类型，但Python是使用默认的 ascii 编码来转换的，而 ASCII 中不包含中文，所以会报错。</p><p>正确地方式应该是显示地把 y 用 UTF-8 或者 GBK 进行解码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = y.decode(&quot;utf-8&quot;)</span><br><span class="line">x + y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之禅</title>
      <link href="/2018/05/16/Python%E4%B9%8B%E7%A6%85/"/>
      <url>/2018/05/16/Python%E4%B9%8B%E7%A6%85/</url>
      
        <content type="html"><![CDATA[<h4 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h4><p>The Zen of Python,by Tim Peters </p><span id="more"></span><p>Beautiful is better than ugly.<br>优美胜于丑陋（Python以编写优美的代码为目标）</p><p>Explicit is better than implicit.<br>明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） </p><p>Simple is better than complex.<br>简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） </p><p>Complex is better than complicated.<br>复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</p><p>Flat is better than nested.<br>扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） </p><p>Sparse is better than dense.<br>间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</p><p>Readability counts.<br>可读性很重要（优美的代码是可读的） </p><p>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） </p><p>Errors should never pass silently.<br>Unless explicitly silenced.<br>不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）</p><p>In the face of ambiguity, refuse the temptation to guess.<br>当存在多种可能，不要尝试去猜测<br>There should be one– and preferably only one –obvious way to do it.<br>而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）<br>Although that way may not be obvious at first unless you’re Dutch.<br>虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）</p><p>Now is better than never.<br>Although never is often better than right now.<br>做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</p><p>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） </p><p>Namespaces are one honking great idea — let’s do more of those!<br>命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求与响应详解</title>
      <link href="/2018/04/25/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/25/HTTP%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）。<br>是一种发布和接收 HTML页面的方法。HTTP的端口号为80。</p><span id="more"></span><p>浏览器发送HTTP请求的过程：</p><ul><li>1.当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。</li><li>2.当我们在浏览器输入URL <a href="http://www.baidu.com/">http://www.baidu.com</a> 的时候，浏览器发送一个Request请求去获取 <a href="http://www.baidu.com/">http://www.baidu.com</a> 的html文件，服务器把Response文件对象发送回给浏览器。</li><li>3.浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</li><li>4.当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。</li></ul><p><strong>URL（Uniform &#x2F; Universal Resource Locator）</strong><br>统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。<br>基本格式：scheme:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;…&#x2F;[?query-string][#anchor]</p><ul><li>scheme：协议(例如：http, https, ftp)</li><li>host：服务器的IP地址或者域名</li><li>port#：服务器的端口（如果是走协议默认端口，缺省端口80）</li><li>path：访问资源的路径</li><li>query-string：参数，发送给http服务器的数据</li><li>anchor：锚（跳转到网页的指定锚点位置）</li></ul><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>URL只是标识资源的位置，而HTTP是用来提交和获取资源。<br>客户端发送一个HTTP请求到服务器的请求消息，包括以下格式：<br><strong>请求行、请求头部、空行、请求数据</strong><br><img src="https://upload-images.jianshu.io/upload_images/9169686-8ed3c177220f54b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP请求格式"><br>一个典型的HTTP请求示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET https://www.baidu.com/ HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Referer: http://www.baidu.com/</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">Cookie: BAIDUID=04E4001F34EA74AD4601512DD3C41A7B:FG=1; BIDUPSID=04E4001F34EA74AD4601512DD3C41A7B;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP 0.9：只有基本的文本 GET 功能。<br>HTTP 1.0：完善的请求&#x2F;响应模型，并将协议补充完整，定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP 1.1：在 1.0 基础上进行更新，新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<br>HTTP 2.0（未普及）：请求&#x2F;响应首部的定义基本没有改变，只是所有首部键必须全部小写，而且请求行要独立为 :method、:scheme、:host、:path这些键值对。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-0b21aaeaa35315fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP请求方法"><br>HTTP请求主要分为Get和Post两种方法：<br>GET是从服务器上获取数据，POST是向服务器传送数据。</p><p>GET请求参数显示，都显示在浏览器网址上，HTTP服务器根据该请求所包含URL中的参数来产生响应内容，即“Get”请求的参数是URL的一部分。 例如： <a href="http://www.baidu.com/s?wd=Chinese">http://www.baidu.com/s?wd=Chinese</a></p><p>POST请求参数在请求体当中，消息长度没有限制而且以隐式的方式进行发送，通常用来向HTTP服务器提交量比较大的数据（比如请求中包含许多参数或者文件上传操作等），请求的参数包含在“Content-Type”消息头里，指明该消息体的媒体类型和编码。</p><p>避免使用Get方式提交表单，因为有可能会导致安全问题。 比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。</p><h4 id="常用的请求报头"><a href="#常用的请求报头" class="headerlink" title="常用的请求报头"></a>常用的请求报头</h4><ol><li><p>Host (主机和端口号)<br>Host：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。</p></li><li><p>Connection (链接类型)<br>Connection：表示客户端与服务连接类型</p></li></ol><ul><li>1.Client 发起一个包含 Connection:keep-alive 的请求，HTTP&#x2F;1.1使用 keep-alive 为默认值。</li><li>2.Server收到请求后：如果 Server 支持 keep-alive，回复一个包含 Connection:keep-alive 的响应，不关闭连接；如果 Server 不支持 keep-alive，回复一个包含 Connection:close 的响应，关闭连接。</li><li>3.如果client收到包含 Connection:keep-alive 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。<br>keep-alive在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。</li></ul><ol start="3"><li><p>Upgrade-Insecure-Requests (升级为HTTPS请求)<br>升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。<br>HTTPS 是以安全为目标的 HTTP 通道，所以在 HTTPS 承载的页面上不允许出现 HTTP 请求，一旦出现就是提示或报错。</p></li><li><p>User-Agent (浏览器名称)</p></li><li><p>Accept (传输文件类型)<br>指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions（多用途互联网邮件扩展））文件类型<br>服务器可以根据它判断并返回适当的文件格式。</p></li></ol><ul><li>Accept: *&#x2F;*：表示什么都可以接收。</li><li>Accept：image&#x2F;gif：表明客户端希望接受GIF图像格式的资源</li><li>Accept：text&#x2F;html：表明客户端希望接受html文本。</li><li>Accept: text&#x2F;html, application&#x2F;xhtml+xml;q&#x3D;0.9, image&#x2F;*;q&#x3D;0.8 ：<br>表示浏览器支持的 MIME 类型分别是 html文本、xhtml和xml文档，所有的图像格式资源。<br>q是权重系数，范围 0 &#x3D;&lt; q &lt;&#x3D; 1，q 值越大，请求越倾向于获得其“;”之前的类型表示的内容。<br>若没有指定q值，则默认为1，按从左到右排序顺序，若被赋值为0，则用于表示浏览器不接受此内容类型。Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的。Application：用于传输应用程序数据或者二进制数据。</li></ul><ol start="6"><li><p>Referer (页面跳转处)<br>表明产生请求的网页来自于哪个URL，用户是从该 Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。有时候遇到下载某网站图片，需要对应的referer，否则无法下载图片，那是因为人家做了防盗链，原理就是根据referer去判断是否是本网站的地址，如果不是，则拒绝，如果是，就可以下载。</p></li><li><p>Accept-Encoding（文件编解码格式）<br>指出浏览器可以接受的编码方式。<br>编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。<br>举例：Accept-Encoding:gzip;q&#x3D;1.0, identity; q&#x3D;0.5, *;q&#x3D;0<br>如果有多个Encoding同时匹配, 按照q值顺序排列,本例中按顺序支持 gzip, identity压缩编码，支持gzip的浏览器会返回经过gzip编码的HTML页面。<br>如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</p></li><li><p>Accept-Language（语言种类）<br>指出浏览器可以接受的语言种类。<br>如en或en-us指英语，zh或者zh-cn指中文<br>当服务器能够提供一种以上的语言版本时要用到。</p></li><li><p>Accept-Charset（字符编码）<br>指出浏览器可以接受的字符编码。<br>举例：Accept-Charset:iso-8859-1,gb2312,utf-8<br>ISO8859-1：通常叫做Latin-1。Latin-1包括了书写所有西方欧洲语言不可缺少的附加字符，英文浏览器的默认值是ISO-8859-1.<br>gb2312：标准简体中文字符集;<br>utf-8：UNICODE 的一种变长字符编码，可以解决多种语言文本显示问题，从而实现应用国际化和本地化。<br>如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</p></li><li><p>Cookie （Cookie）<br>浏览器用这个属性向服务器发送Cookie。<br>Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能</p></li><li><p>Content-Type (POST数据类型)<br>POST请求里用来表示的内容类型。<br>举例：Content-Type &#x3D; Text&#x2F;XML; charset&#x3D;gb2312：<br>指明该请求的消息体中包含的是纯文本的XML类型的数据，字符编码采用“gb2312”。</p></li></ol><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>HTTP响应也由四个部分组成，分别是： 状态行、消息报头、空行、响应正文<br><img src="https://upload-images.jianshu.io/upload_images/9169686-857f650b6bd326d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP响应"><br>一个典型的HTTP响应示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Wed, 30 Nov 2016 07:58:21 GMT</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Keep-Alive: timeout=20</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Pragma: no-cache</span><br><span class="line">X-NWS-LOG-UUID: bd27210a-24e5-4740-8f6c-25dbafa9c395</span><br><span class="line">Content-Length: 180945</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; ....</span><br></pre></td></tr></table></figure><h4 id="常用的响应报头"><a href="#常用的响应报头" class="headerlink" title="常用的响应报头"></a>常用的响应报头</h4><p>理论上所有的响应头信息都应该是回应请求头的。但是服务端为了效率，安全，还有其他方面的考虑，会添加相对应的响应头信息</p><ol><li>Cache-Control：must-revalidate, no-cache, private。<br>这个值告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要从新请求服务器，不能从缓存副本中获取资源。</li></ol><p>Cache-Control是响应头中很重要的信息，当客户端请求头中包含Cache-Control:max-age&#x3D;0请求，明确表示不会缓存服务器资源时,Cache-Control作为作为回应信息，通常会返回no-cache，意思就是说，”那就不缓存呗”。</p><p>当客户端在请求头中没有包含Cache-Control时，服务端往往会定,不同的资源不同的缓存策略，比如说oschina在缓存图片资源的策略就是Cache-Control：max-age&#x3D;86400,这个意思是，从当前时间开始，在86400秒的时间内，客户端可以直接从缓存副本中读取资源，而不需要向服务器请求。</p><ol start="2"><li><p>Connection：keep-alive<br>这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。</p></li><li><p>Content-Encoding:gzip<br>告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。</p></li><li><p>Content-Type：text&#x2F;html;charset&#x3D;UTF-8<br>告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。</p></li><li><p>Date：Sun, 21 Sep 2016 06:18:21 GMT<br>这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。<br>http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。</p></li><li><p>Expires:Sun, 1 Jan 2000 01:00:00 GMT<br>这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本。<br>很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。<br>所以这个响应头是没有Cache-Control：max-age&#x3D;*这个响应头准确的，因为max-age&#x3D;date中的date是个相对时间，不仅更好理解，也更准确。</p></li><li><p>Pragma:no-cache<br>这个含义与Cache-Control等同。</p></li></ol><p>8.Server：Tengine&#x2F;1.4.6<br>这个是服务器和相对应的版本，只是告诉客户端服务器的信息。</p><ol start="9"><li><p>Transfer-Encoding：chunked<br>这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。<br>一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</p></li><li><p>Vary: Accept-Encoding<br>告诉缓存服务器，缓存压缩文件和非压缩文件两个版本。<br>现在这个字段用处并不大，因为现在的浏览器都是支持压缩的。</p></li></ol><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p>响应状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。<br>100~199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。</p><p>200~299：表示服务器成功接收请求并已完成整个处理过程。常用200（OK 请求成功）。</p><p>300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用302（所请求的页面已经临时转移至新的url）、307和304（使用缓存资源）。</p><p>400~499：客户端的请求有错误，常用404（服务器无法找到被请求的页面）、403（服务器拒绝访问，权限不够）。</p><p>500~599：服务器端出现错误，常用500（请求未完成。服务器遇到不可预知的情况）。</p><hr><p><strong>1xx:信息</strong><br>100 Continue<br>服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</p><p>101 Switching Protocols<br>服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</p><hr><p><strong>2xx:成功</strong><br>200 OK<br>请求成功（其后是对GET和POST请求的应答文档）</p><p>201 Created<br>请求被创建完成，同时新的资源被创建。</p><p>202 Accepted<br>供处理的请求已被接受，但是处理未完成。</p><p>203 Non-authoritative Information<br>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</p><p>204 No Content<br>没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</p><p>205 Reset Content<br>没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</p><p>206 Partial Content<br>客户发送了一个带有Range头的GET请求，服务器完成了它。</p><hr><p><strong>3xx:重定向</strong><br>300 Multiple Choices<br>多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</p><p>301 Moved Permanently<br>所请求的页面已经转移至新的url。</p><p>302 Moved Temporarily<br>所请求的页面已经临时转移至新的url。</p><p>303 See Other<br>所请求的页面可在别的url下被找到。</p><p>304 Not Modified<br>未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p><p>305 Use Proxy<br>客户请求的文档应该通过Location头所指明的代理服务器提取。</p><p>306 Unused<br>此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</p><p>307 Temporary Redirect<br>被请求的页面已经临时移至新的url。</p><hr><p><strong>4xx:客户端错误</strong><br>400 Bad Request<br>服务器未能理解请求。</p><p>401 Unauthorized<br>被请求的页面需要用户名和密码。<br>401.1 登录失败。<br>401.2 服务器配置导致登录失败。<br>401.3 由于 ACL 对资源的限制而未获得授权。<br>401.4 筛选器授权失败。<br>401.5 ISAPI&#x2F;CGI 应用程序授权失败。<br>401.7 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</p><p>402 Payment Required<br>此代码尚无法使用。</p><p>403 Forbidden<br>对被请求页面的访问被禁止。<br>403.1 执行访问被禁止。<br>403.2 读访问被禁止。<br>403.3 写访问被禁止。<br>403.4 要求 SSL。<br>403.5 要求 SSL 128。<br>403.6 IP 地址被拒绝。<br>403.7 要求客户端证书。<br>403.8 站点访问被拒绝。<br>403.9 用户数过多。<br>403.10 配置无效。<br>403.11 密码更改。<br>403.12 拒绝访问映射表。<br>403.13 客户端证书被吊销。<br>403.14 拒绝目录列表。<br>403.15 超出客户端访问许可。<br>403.16 客户端证书不受信任或无效。<br>403.17 客户端证书已过期或尚未生效。<br>403.18 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。<br>403.19 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。<br>403.20 Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</p><p>404 Not Found<br>服务器无法找到被请求的页面。<br>404.0 没有找到文件或目录。<br>404.1 无法在所请求的端口上访问 Web 站点。<br>404.2 Web 服务扩展锁定策略阻止本请求。<br>404.3 MIME 映射策略阻止本请求。</p><p>405 Method Not Allowed<br>请求中指定的方法不被允许。</p><p>406 Not Acceptable<br>服务器生成的响应无法被客户端所接受。</p><p>407 Proxy Authentication Required<br>用户必须首先使用代理服务器进行验证，这样请求才会被处理。</p><p>408 Request Timeout<br>请求超出了服务器的等待时间。</p><p>409 Conflict<br>由于冲突，请求无法被完成。</p><p>410 Gone<br>被请求的页面不可用。</p><p>411 Length Required<br>“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</p><p>412 Precondition Failed<br>请求中的前提条件被服务器评估为失败。</p><p>413 Request Entity Too Large<br>由于所请求的实体的太大，服务器不会接受请求。</p><p>414 Request-url Too Long<br>由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</p><p>415 Unsupported Media Type<br>由于媒介类型不被支持，服务器不会接受请求。</p><p>416 Requested Range Not Satisfiable<br>服务器不能满足客户在请求中指定的Range头。</p><p>417 Expectation Failed<br>执行失败。</p><p>423<br>锁定的错误。</p><hr><p><strong>5xx:服务器错误</strong><br>500 Internal Server Error<br>请求未完成。服务器遇到不可预知的情况。<br>500.12 应用程序正忙于在 Web 服务器上重新启动。<br>500.13 Web 服务器太忙。<br>500.15 不允许直接请求 Global.asa。<br>500.16 UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。<br>500.18 URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。<br>500.100 内部 ASP 错误。</p><p>501 Not Implemented<br>请求未完成。服务器不支持所请求的功能。</p><p>502 Bad Gateway<br>请求未完成。服务器从上游服务器收到一个无效的响应。<br>502.1 CGI 应用程序超时。　<br>502.2 CGI 应用程序出错。</p><p>503 Service Unavailable<br>请求未完成。服务器临时过载或当机。</p><p>504 Gateway Timeout<br>网关超时。</p><p>505 HTTP Version Not Supported<br>服务器不支持请求中指明的HTTP协议版本</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解HTTPS</title>
      <link href="/2018/04/22/%E7%90%86%E8%A7%A3HTTPS/"/>
      <url>/2018/04/22/%E7%90%86%E8%A7%A3HTTPS/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>本文尝试一步步还原HTTPS的设计过程，以理解为什么HTTPS最终会是这副模样。但是这并不代表HTTPS的真实设计过程。在阅读本文时，你可以尝试放下已有的对HTTPS的理解，这样更利于“还原”过程。</p><span id="more"></span><p>我们先不了聊HTTP，HTTPS，我们先从一个聊天软件说起，我们要实现A能发一个hello消息给B：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-c5f34f878314bba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A发一个hello消息给B"><br>如果我们要实现这个聊天软件，本文只考虑安全性问题，要实现：A发给B的hello消息包，即使被中间人拦截到了，也无法得知消息的内容。</p><h4 id="如何做到真正的安全"><a href="#如何做到真正的安全" class="headerlink" title="如何做到真正的安全"></a>如何做到真正的安全</h4><p>这个问题，很多人马上就想到了各种加密算法，什么对称加密、非对称加密、DES、RSA、XX、噼里啪啦~而我想说，加密算法只是解决方案，我们首先要做的是理解我们的问题域——什么是安全？我个人的理解是：A与B通信的内容，有且只有A和B有能力看到通信的真正内容。好，问题域已经定义好了（现实中当然不止这一种定义）。对于解决方案，很容易就想到了对消息进行加密。对于A与B这样的简单通信模型，我们很容易做出选择：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-200457c8697e1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对称加密"><br>这就是对称加密算法，其中图中的密钥S同时扮演加密和解密的角色。具体细节不是本文范畴。</p><p>只要这个密钥S不公开给第三者，同时密钥S足够安全，我们就解决了我们一开始所定问题域了。因为世界上有且只有A与B知道如何加密和解密他们之间的消息。但是，在WWW环境下，我们的Web服务器的通信模型没有这么简单：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-8ca1601e215d30ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Web服务器的通信模型"><br>如果服务器端对所有的客户端通信都使用同样的对称加密算法，无异于没有加密。那怎么办呢？即能使用对称加密算法，又不公开密钥？答案是：Web服务器与每个客户端使用不同的对称加密算法：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-9e85e50bab3540f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Web服务器与每个客户端使用不同的对称加密算法"></p><h4 id="如何确定对称加密算法"><a href="#如何确定对称加密算法" class="headerlink" title="如何确定对称加密算法"></a>如何确定对称加密算法</h4><p>另一个问题来了：我们的服务器端怎么告诉客户端该使用哪种对称加密算法？当然是通过协商。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-28562b87f2165b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协商使用哪种对称加密算法"><br>但是，你协商的过程是没有加密的，还是会被中间人拦截。那我们再对这个协商过程进行对称加密就好了，那你对协商过程加密的加密还是没有加密，怎么办？再加密不就好了……好吧，进行鸡生蛋蛋生鸡的问题了。</p><h4 id="如何对协商过程进行加密"><a href="#如何对协商过程进行加密" class="headerlink" title="如何对协商过程进行加密"></a>如何对协商过程进行加密</h4><p>新问题来了，如何对协商过程进行加密？密码学领域中，有一种称为“非对称加密”的加密算法，特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-7a8db8fa3f2b65b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非对称加密"><br>虽然服务器端向A、B……的方向还是不安全的，但是至少A、B向服务器端方向是安全的。好了，如何协商加密算法的问题，我们解决了：使用非对称加密算法进行对称加密算法协商过程。这下，你明白为什么HTTPS同时需要对称加密算法和非对称加密算法了吧？</p><h4 id="协商什么加密算法"><a href="#协商什么加密算法" class="headerlink" title="协商什么加密算法"></a>协商什么加密算法</h4><p>要达到Web服务器针对每个客户端使用不同的对称加密算法，同时，我们也不能让第三者知道这个对称加密算法是什么，怎么办？</p><p>使用随机数，就是使用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一刻才确定加密算法。这下，你明白为什么HTTPS协议握手阶段会有这么多的随机数了吧。</p><h4 id="如何得到公钥"><a href="#如何得到公钥" class="headerlink" title="如何得到公钥"></a>如何得到公钥</h4><p>细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。这下，我们又遇到新问题了：如何让A、B客户端安全地得到公钥？我能想到的方案只有这些：</p><ul><li>1：服务器端将公钥发送给每一个客户端</li><li>2：服务器端将公钥放到一个远程服务器，客户端可以请求得到</li></ul><p>我们选择方案1，因为方案2又多了一次请求，还要另外处理公钥的放置问题。公钥被调包了怎么办？又是一个鸡生蛋蛋生鸡问题？</p><p>但是方案1有个问题：如果服务器端发送公钥给客户端时，被中间人调包了，怎么办？<br><img src="https://upload-images.jianshu.io/upload_images/9169686-ef7cd2a16c2df7cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务器端发送公钥给客户端时，被中间人调包"></p><h4 id="使用第三方机构的公钥解决鸡生蛋蛋生鸡问题"><a href="#使用第三方机构的公钥解决鸡生蛋蛋生鸡问题" class="headerlink" title="使用第三方机构的公钥解决鸡生蛋蛋生鸡问题"></a>使用第三方机构的公钥解决鸡生蛋蛋生鸡问题</h4><p>公钥被调包的问题出现，是因为我们的客户端无法分辨返回公钥的人到底是中间人，还是真的服务器。这其实就是密码学中提的身份验证问题。</p><p>如果你了解过HTTPS，会知道使用数字证书来解决。但是你想过证书的本质是什么么？请放下你对HTTPS已有的知识，自己尝试找到解决方案。</p><p>我是这样解决的。既然服务器需要将公钥传给客户端，这个过程本身是不安全，那么我们为什么不对这个过程本身再加密一次？可是，你是使用对称加密，还是非对称加密？这下好了，我感觉又进了鸡生蛋蛋生鸡问题了。问题的难点是如果我们选择直接将公钥传递给客户端的方案，我们始终无法解决公钥传递被中间人调包的问题。</p><p>所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。</p><p>下图就是我们设计的第一版“数字证书”，证书中只有服务器交给第三方机构的公钥，而且这个公钥被第三方机构的私钥加密了：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-53fa384e715532ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数字证书"><br>如果能解密，就说明这个公钥没有被中间人调包。因为如果中间人使用自己的私钥加密后的东西传给客户端，客户端是无法使用第三方的公钥进行解密的。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-43fe0084265699a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数字证书"><br>话到此，我以为解决问题了。但是现实中HTTPS，还有一个数字签名的概念，我没法理解它的设计理由。</p><p>原来，我漏掉了一个场景：第三方机构不可能只给你一家公司制作证书，它也可能会给中间人这样有坏心思的公司发放证书。这样的，中间人就有机会对你的证书进行调包，客户端在这种情况下是无法分辨出是接收的是你的证书，还是中间人的。因为不论中间人，还是你的证书，都能使用第三方机构的公钥进行解密。像下面这样：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-9d3cbcee0da77e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中间人对你的证书进行调包"><br>客户端能解密同一家第三机构颁发的所有证书：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-0c83f8ba7492c053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端能解密同一家第三机构颁发的所有证书"><br>最终导致其它持有同一家第三方机构证书的中间人可以进行调包：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-aada17a3e282b82d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="持有同一家第三方机构证书的中间人可以进行调包"></p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>要解决这个问题，我们首先要想清楚一个问题，辨别同一机构下不同证书的这个职责，我们应该放在哪？</p><p>只能放到客户端了。意思是，客户端在拿到证书后，自己就有能力分辨证书是否被篡改了。如何才能有这个能力呢？</p><p>我们从现实中找灵感。比如你是HR，你手上拿到候选人的学历证书，证书上写了持证人，颁发机构，颁发时间等等，同时证书上，还写有一个最重要的：证书编号！我们怎么鉴别这张证书是的真伪呢？只要拿着这个证书编号上相关机构去查，如果证书上的持证人与现实的这个候选人一致，同时证书编号也能对应上，那么就说明这个证书是真实的。</p><p>我们的客户端能不能采用这个机制呢？像这样：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-401565cffb08141b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分辨证书是否被篡改"><br>可是，这个“第三方机构”到底是在哪呢？是一个远端服务？不可能吧？如果是个远端服务，整个交互都会慢了。所以，这个第三方机构的验证功能只能放在客户端的本地了。</p><h4 id="客户端本地怎么验证证书呢"><a href="#客户端本地怎么验证证书呢" class="headerlink" title="客户端本地怎么验证证书呢"></a>客户端本地怎么验证证书呢</h4><p>客户端本地怎么验证证书呢？答案是证书本身就已经告诉客户端怎么验证证书的真伪。</p><p>也就是证书上写着如何根据证书的内容生成证书编号。客户端拿到证书后根据证书上的方法自己生成一个证书编号，如果生成的证书编号与证书上的证书编号相同，那么说明这个证书是真实的。</p><p>同时，为避免证书编号本身又被调包，所以使用第三方的私钥进行加密。这地方有些抽象，我们来个图帮助理解：证书的制作如图所示。证书中的“编号生成方法MD5”就是告诉客户端：你使用MD5对证书的内容求值就可以得到一个证书编号。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-703487f8551884e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地验证证书"><br>当客户端拿到证书后，开始对证书中的内容进行验证，如果客户端计算出来的证书编号与证书中的证书编号相同，则验证通过：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-caca124134ea68c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证通过"><br>但是第三方机构的公钥怎么跑到了客户端的机器中呢？世界上这么多机器。</p><p>其实呢，现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。</p><p>说到这里，想必大家已经知道上文所说的，证书就是HTTPS中数字证书，证书编号就是数字签名，而第三方机构就是指数字证书签发机构（CA）。</p><h4 id="CA如何颁发数字证书给服务器端的"><a href="#CA如何颁发数字证书给服务器端的" class="headerlink" title="CA如何颁发数字证书给服务器端的"></a>CA如何颁发数字证书给服务器端的</h4><p>问题应该是CA如何颁发给我们的网站管理员，而我们的管理员又如何将这个数字证书放到我们的服务器上。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-40944b4f5a3c1787.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CA如何颁发数字证书给服务器端的"><br>拿到证书后，我们就可以将证书配置到自己的服务器上了。</p><h4 id="也许我们需要整理下思路"><a href="#也许我们需要整理下思路" class="headerlink" title="也许我们需要整理下思路"></a>也许我们需要整理下思路</h4><p>我们通过推算的方式尝试还原HTTPS的设计过程。这样，我们也就明白了为什么HTTPS比HTTP多那么多次的交互，为什么HTTPS的性能会差，以及找到HTTPS的性能优化点。</p><p>而上面一大堆工作都是为了让客户端与服务器端安全地协商出一个对称加密算法。这就是HTTPS中的SSL&#x2F;TLS协议主要干的活。剩下的就是通信时双方使用这个对称加密算法进行加密解密。</p><p>以下是一张HTTPS协议的真实交互图：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-b2b9a82eb84838ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS协议交互图"><br>HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS详解</title>
      <link href="/2018/04/20/DNS%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/04/20/DNS%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="DNS源起"><a href="#DNS源起" class="headerlink" title="DNS源起"></a>DNS源起</h4><p>要想访问网络上的一台计算机，我们必须要知道它的IP地址，但是这些地址（比如243.185.187.39）只是一串数字，没有规律，因此我们很难记住。并且如果一台计算机变更IP后，它必须通知所有的人。</p><span id="more"></span><p>显然，直接使用IP地址是一个愚蠢的方案。于是人们想出了一个替代的方法，即为每一台计算机起一个名字，然后建立计算机名字到地址的一个映射关系。我们访问计算机的名字，剩下的名字到地址的转换过程则由计算机自动完成。</p><p>早期，名字到地址的转换过程十分简单。每台计算机保存一个hosts文件，里面列出所有计算机名字和对应的IP地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接。</p><p>早期的ARPANET就是这样做的，但是随着网络规模的扩大，这种方法渐渐吃不消了。主要有以下三个原因：</p><ul><li>1：hosts文件变得非常大；</li><li>2：主机名字会冲突；</li><li>3：集中的维护站点会不堪重负（需要给几百万机器提供hosts文件，想想就可怕）。</li></ul><p>为了解决上面的问题，1983年Paul Mockapetris提出了域名系统（DNS, Domain Name System)，这是一种层次的、基于域的命名方案，并且用一个分布式数据库系统加以实现。当我们需要访问一个域名（其实就是前面说的计算机的名字）时，应用程序会向DNS服务器发起一个DNS请求，DNS服务器返回该域名对应的IP地址。通过下面三种手段解决了上面的问题：</p><ul><li>1：用户计算机上并没有存储所有的名字到IP的映射，这样避免了hosts文件过于庞大（现在各操作系统中hosts文件默认都是空的）。</li><li>2：规定了域名的命名规则，保证主机名字不会重复。</li><li>3：DNS服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群。</li></ul><h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>那么如何具体实现这个所谓的域名系统呢，要知道管理一个超大型并且不断变化的域名到IP的映射集合可不是一个简单的事，况且还要去应付成千上万的DNS查询请求。人们最终想出了一套不错的协议，规定如何来实现这个系统，下面我们一起来看看吧。</p><p>首先我们需要制定一套命名规则，防止域名出现重复。DNS关于域名的规则和我们生活中的快递系统类似，使用层次的地址结构。快递系统中要给某人邮寄物品，地址可能是这样：中国、广东省、广州市、番禺区、中山西路12号 XXX。而一个域名看起来则是这样的groups.google.com。</p><p>对于Internet来说，域名层次结构的顶级（相当于国际快递地址中的国家部分）由ICANN（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推。所有这些域名可以组织成一棵树，如下图所示<br><img src="https://upload-images.jianshu.io/upload_images/9169686-955d06af201121af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名树"><br>DNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：<br>Domain_name 、Time_to_live 、Class 、Type 、Value</p><ul><li>Domain_name：指出这条记录适用于哪个域名；</li><li>Time_to_live：用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；</li><li>Class：一般总是IN；</li><li>Type：记录的类型；</li><li>Value：记录的值，如果是A记录，则value是一个IPv4地址。</li></ul><p>我们看到域名资源记录有一个Type字段，用来表明记录的类型。这是为什么呢？因为对于一个域名来说，通常并非只记录其IP地址，还可能需要一些其他种类的记录，一些常见的记录类型如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-b35334d576819fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见的记录类型"><br>我们知道不能只用一台域名服务器来响应所有的DNS查询，因为没有一台机器能够给全球的用户提供查询服务，计算能力、存储、带宽都不允许。只能合理组织一个域名服务器集群，使他们协同工作，共同提供域名解析服务。接下来首先要面对的一个问题是如何合理地将所有的域名资源记录存储到不同的域名服务器上。</p><p>前面说过域名的名字空间可以组织为一棵树，这里我们可以进一步将其划分为不重叠的区域（DNS zone），针对上图的域名空间，一种可能的域名划分如下图：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-24cc406ebdd74dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名划分"><br>然后将每个区域与多个域名服务器（其中一个是master，其他slave服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的权威域名服务器(Authoritative Name Servers )，它保存两类域名资源记录：</p><ul><li>1：该区域内所有域名的域名资源记录。</li><li>2：父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。</li></ul><p>这样，所有的域名资源记录都保存在多个域名服务器中，并且所有的域名服务器也组成了一个层次的索引结构，便于我们后面进行域名解析。下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-189fe57a2345b123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简化的域名空间例子"><br>图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器，这些域名服务器里面保存了许多域名解析记录。对于上图的NDS区域E来说，它的权威域名服务器里面保存的记录如图中表格所示。</p><p>仔细观察上图你可能会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起。这将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。认识到这一点后，你可能会想出一个很自然的解决方案，就是在A中记录B域名服务器的地址，同时在B中记录A的，这样它们两个就联系起来了。但是考虑到我们有超过250个顶级域名，这样做并不是很恰当。</p><p>而我们使用的域名系统则采用了一种更加聪明的方法，那就是引入根域名服务器，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。下图为全球根域名服务器的分布图，可以在这里找到。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-620fac5ff105b0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全球根域名服务器的分布图"><br>现在为止，我们的权威域名服务器和根域名服务器其实组成了一个树，树根为根域名服务器，下面每个节点都是一个区域的权威域名服务器，对于图a中各个DNS区域的权威域名服务器，它们组成了下面这棵树（实际中，一个权威域名服务器可能保存有多个DNS区域的记录，因此权威域名服务器之间的联系并不构成一棵树。这部分的详细内容可以参考RFC 1034: 4. NAME SERVERS。下面为了容易理解，将其简化为一棵树）：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-e7be0abae62fa844.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名服务器之间的联系"></p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>我们已经有了一个域名服务器集群，该集群合理地保存了域名空间和域名资源记录的对应关系。现在我们要做的就是发送一个DNS请求给域名服务器，然后坐等它返回正确的域名资源记录，这个过程叫作域名解析。</p><p>严格来说，域名解析的过程最早要追溯到建立网络连接。因为每当连接上网络之后，计算机会自动获得一个默认的DNS服务器，当然你也可以用自己信任的DNS服务器，比如8.8.8.8（DNS服务器也有信任不信任之分，是的，实践篇会讲到），我们把这个域名服务器也叫作本地域名服务器。接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。</p><p>如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是本地域名服务器如何找到根域名服务器在哪里呢？其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录（要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找啦。</p><p>仍然以我们的图为例，现在假设区域E内的某个用户想访问math.sysu.edu.cn，那么请求的过程如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-c59e733796e6eaaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求的过程"></p><ul><li>1：用户：喂，本地域名服务器，告诉我math.sysu.edu.cn的地址；</li><li>2：本地域名服务器：哎呀，我不知道啊，不在我的辖区，容我去问问老大哥吧。root老大，能告诉我math.sysu.edu.cn的地址吗；</li><li>3：根域名服务器：忙着呢，你去问B（.cn）；</li><li>4：本地域名服务器：喂，B，告诉我math.sysu.edu.cn的地址；</li><li>5：B：你去问D（.edu.cn）；</li><li>6：本地域名服务器：喂，D，告诉我math.sysu.edu.cn的地址；</li><li>7：D：你去问F（sysu.edu.cn）；</li><li>8：本地域名服务器：喂，F，告诉我math.sysu.edu.cn的地址；</li><li>9：F：容老衲看看，哎呀，找到了，是X.X.X.X；</li><li>10：本地域名服务器：踏破铁鞋终于找到啦，喂用户，出来啊，我找到了，是X.X.X.X</li></ul><p>我们都知道一个域名的解析过程中，可能会有多台域名服务器给我们帮助，那么我们怎么能看到这些背后的功臣呢？先介绍两个常用的关于DNS的命令。dig(Domain Information Groper), 是 UNIX&#x2F;BSD 系统自带的 DNS 诊断工具，使用十分灵活、方便。</p><p>查询 selfboot.cn 的A记录，并返回简短的结果：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-241aa410bfe36dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="返回简短的结果"><br>用 dig 还可以查询某一 ip 对应的域名，如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-9a9712b967d6f257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询某一 ip 对应的域名"><br>这里返回的是pages.github.com，因为当你访问博客地址 selfboot.cn 时，其实是Github的pages 服务器（域名是：pages.github.com）在后台返回该博客内容的（根据 CNAME 确定返回哪个博客）。</p><p>nslookup 也是一个 DNS 诊断工具，几乎所有平台都自带该工具，使用也很简答，可以用 man 查询手册。</p><p>接下来用 dig 命令查看从根域名到指定域名中间可能经过的所有域名服务器，使用 +trace 选项即可。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-06e2a4543a22617d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="经过的所有域名服务器"><br>可以看到最开始是13台顶级域名服务器的NS记录（中间省去一些记录减少行数，方便观察更清楚），接下来是顶级域名 cn. 的权威域名服务器（省略一些输出），然后是 selfboot.cn 的 NS 记录，即 DNSpod 的两条 NS 记录，最后从 f1g1ns2.dnspod.net 找到 selfboot.cn 的 A 记录。</p><p>seveas 提供了一个可视化的路径查询工具：dnsgraph，可以在线绘制跟域名到指定域名的所有可能路径。</p><p>当然，实际查询过程中，大多时候我们在本地缓存或者本地域名服务器缓存就能直接找到需要的域名记录，不需要每次都向根域名服务器发起请求，然后重复迭代或者递归查询过程。</p><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>现在整个域名系统已经可以为我们提供域名解析服务了，当我们输入域名，计算机发送DNS请求，然后DNS服务器返回给我们解析的结果，一切看起来很完美。然而是不是可以更完美呢？<br>回顾一下平时浏览网站的情况，我们会发现两个比较有意思的结论：</p><ul><li>1：80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的80&#x2F;20 Rule；</li><li>2：我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。</li></ul><p>这两条结论很容易让我们联想到缓存机制。如果我们将已经访问过的那些域名的解析结果缓存在自己的计算机上，那么下次访问的时候可以直接读取结果，不用再次重复DNS查询过程，给自己和域名服务器都节省了麻烦。</p><p>当然，这样做的一个前提是要缓存的解析结果不会频繁更改，也就是说我十分钟后解析一个域名的结果和现在解析的结果是一样的。对大多数域名来说，这都是一个不争的事实。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，我们在域名资源记录里面添加一个Time_ti_live字段，表明这条记录最多可以缓存多久。对于那些“稳如泰山”的域名，给一个比较大的值，而那些“朝三暮四”的域名，则可以给定一个小的值。</p><p>我们既然可以在本机利用缓存，那么可不可以在域名服务器上也利用缓存机制呢，答案当然是可以的。因为对于域名服务器来说，上面的两条有意思的结论仍然有效。所以，域名服务器可以将那些访问过的域名资源记录缓存，用户再次发起请求时，可以直接返回缓存结果，不用去迭代或者递归解析。</p><h4 id="DNS缺陷"><a href="#DNS缺陷" class="headerlink" title="DNS缺陷"></a>DNS缺陷</h4><p>域名系统设计的很理想很美好，然而仍有一些小的瑕疵，可能会给我们带来些许困扰，首先，有些域名对注册人没有限制，而另外一些域名则对谁可以得到一个域名空间中名字有限制。比如pro域名是分配给合适的专业人员，但问题是谁才是专业的呢？显然医生、工程师是专业人员，但理发师、管道工呢？</p><p>此外，域名也可以被倒卖。黄牛们会批量注册大量域名（据说com域名下几乎每一个普通词都被人尝试注册了域名），然后转身就以高价转卖给那些对该域名感兴趣的人，这就是所谓的域名抢注。所以，现在你想注册一个符合自己网站特点的域名是很难的。</p><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>我们知道一个域名服务器对其区域内的用户解析请求负责，但是并没有一个机制去监督它有没有真地负责。也就是说域名服务器的权力并没有被关在笼子里，所以它既可以认真地“为人民服务”，也可以指鹿为马。于是有些流氓的域名服务器故意更改一些域名的解析结果，将用户引向一个错误的目标地址。这就叫作 DNS 劫持，主要用来阻止用户访问某些特定的网站，或者是将用户引导到广告页面。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-6cd6cbd0d14533a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS劫持"><br>下面验证下我所用的域名服务器有没有干这种坏事，只需要一条简单的命令即可：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-68ede3d8feb5b189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="检查DNS劫持"><br>我的DNS服务器地址为10.8.4.4，他告诉我google.com的地址是120.196.0.5，我才不信呢。于是用whois 120.196.0.5一看，果真不是Google的地址。针对DNS劫持，我们可以简单地更换域名服务器，比较靠谱的一个是Google提供的8.8.8.8。下面用 8.8.8.8 来解析一下 <a href="http://www.google.com/">www.google.com</a> 就能看到正确的地址了。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-0cf6cb8af74dcbea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="检查DNS劫持"></p><h4 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h4><p>DNS 劫持通过简单的切换域名服务器就可以绕过，不过一旦你遇上了 DNS 欺骗，就无法简单地绕过了。下面我们用不同的域名服务器来查看 fb 的 IP 地址，结果都返回了同一个地址，看起来好像是真的一样，不过也仅仅是看起来而已。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-726fdda5780d79dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS欺骗"><br>这个地址并不是 fb 的服务器地址（可以在 ViewDNS 查询所有域名真实的域名资源记录，ViewDNS是个很好玩的网站，里面有许多有意思的工具）。</p><p>DNS 欺骗简单来说就是用一个假的 DNS 应答来欺骗用户计算机，让其相信这个假的地址，并且抛弃真正的 DNS 应答。在一台主机发出 DNS 请求后，它就开始等待应答，如果此时有一个看起来正确（拥有和DNS请求一样的序列号）的应答包，它就会信以为真，并且丢弃稍晚一点到达的应答。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-0a3b9db06b0e1c4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS欺骗"><br>实施 DNS 欺骗的关键在于伪造一个有特定序列号的应答包，并且让其抢先一步到达发起请求的主机。这对于个人来说还有点难度，但是对于拥有骨干网节点的组织来说，实在是易如反掌，所以这么多网站都已沦陷。不过使用网上流传的那些 hosts文件，就可以在本机缓存许多网站的ip地址，进而可以和部分网站通信。但是通过hosts文件并不能完全 Cross the Great FireWall，因为人家还有很多其他手段。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议的细节——TCP重新发送</title>
      <link href="/2018/04/19/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94TCP%E9%87%8D%E6%96%B0%E5%8F%91%E9%80%81/"/>
      <url>/2018/04/19/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94TCP%E9%87%8D%E6%96%B0%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h4 id="TCP片段丢失"><a href="#TCP片段丢失" class="headerlink" title="TCP片段丢失"></a>TCP片段丢失</h4><p>接收方可以通过校验TCP头部中checksum区域来检验TCP片段是否出错。我们已经接触过了IP协议详解的checksum算法。TCP片段的checksum算法与之类似。IP协议的checksum只校验头部，TCP片段头部的checksum会校验包括IP头部、TCP头部和TCP数据在内的整个序列，确保IP地址、端口号和其他相关信息正确。如果TCP片段出错，接收方可以简单的丢弃该TCP片段，也就相当于TCP片段丢失。</p><span id="more"></span><p>TCP片段包裹在一个IP包中传输。IP包可能在网络中丢失。导致IP包丢失的原因可能有很多，比如IP包经过太多的路由器接力，达到hop limit；比如路由器太过拥挤，导致一些IP包被丢弃；再比如路由表(routing table)没有及时更新，导致IP包无法送达目的地。</p><h4 id="超时重新发送"><a href="#超时重新发送" class="headerlink" title="超时重新发送"></a>超时重新发送</h4><p>我们之前已经简单介绍过重新发送的机制：当发送方送出一个TCP片段后，将开始计时，等待该TCP片段的ACK回复。如果接收方正确接收到符合次序的片段，接收方会利用ACK片段回复发送方。发送方得到ACK回复后，继续移动窗口，发送接下来的TCP片段。如果直到计时完成，发送方还是没有收到ACK回复，那么发送方推断之前发送的TCP片段丢失，因此重新发送之前的TCP片段。这个计时等待的时间叫做重新发送超时时间(RTO, retransmission timeout)。</p><p>发送方应该在等待多长时间之后重新发送呢？这是重新发送的核心问题。上述过程实际上有往返两个方向：1. 发送片段从发送方到接收方的传输，2. ACK片段从接收方到发送方的传输。整个过程实际耗费的时间称做往返时间(RTT, round trip time)。如果RTT是固定的，比如1秒，那么我们可以让RTO等于RTT。</p><p>但实际上，RTT的上下浮动很大。比如某个时刻，网络中有许多交通，那么RTT就增加。在RTT浮动的情况下，如果我们设置了过小的RTO，那么TCP会等待很短的时间之后重新发送，而实际上之前发送的片段并没有丢失，只是传输速度比较慢而已，这样，网络中就被重复注入TCP片段，从而浪费网络传输资源。</p><p>另一方面，如果RTO时间过长，那么当TCP片段已经实际丢失的情况下，发送方不能及时重新发送，会造成网络资源的闲置。所以，RTO必须符合当前网络的使用状况。网络状况越好，RTO应该越短；网络状况越差，RTO应该越长。</p><p>TCP协议通过统计RTT，来决定合理的RTO。发送方可以测量每一次TCP传输的RTT (从发送出数据片段开始，到接收到ACK片段为止)，这样的每次测量得到的往返时间，叫做采样RTT(srtt, sampling round trip time)。建立连接之后，每次的srtt作为采样样本，计算平均值(mean)和标准差(standard deviation)，并让RTO等于srtt平均值加上四倍的srtt标准差，即：RTO &#x3D; mean + 4 std。需要注意的是该算法有多个变种，根据平台不同有所变化</p><p>平均值反映了平均意义上的RTT，平均往返时间越大，RTO越大。另一方面，标准差越大也会影响RTO。标准差代表了RTT样本的离散程度。如果RTT上下剧烈浮动，标准差比较大。RTT浮动大，说明当前网络状况相对不稳定。因此要设置更长的RTO，以应对不稳定的网络状况。</p><h4 id="快速重新发送"><a href="#快速重新发送" class="headerlink" title="快速重新发送"></a>快速重新发送</h4><p>我们刚才介绍了超时重新发送的机制：发送方送出一个TCP片段，然后开始等待并计时，如果RTO时间之后还没有收到ACK回复，发送方则重新发送。TCP协议有可能在计时完成之前启动重新发送，也就是利用快速重新发送(fast-retransmission)。快速发送机制如果被启动，将打断计时器的等待，直接重新发送TCP片段。</p><p>由于IP包的传输是无序的，所以接收方有可能先收到后发出的片段，也就是乱序(out-of-order)片段。乱序片段的序号并不等于最近发出的ACK回复号。已接收的文本流和乱序片段之间将出现空洞(hole)，也就是等待接收的空位。比如已经接收了正常片段5,6,7，此时又接收乱序片段9。这时片段8依然空缺，片段8的位置就是一个空洞。</p><p>TCP协议规定，当接收方收到乱序片段的时候，需要重复发送ACK。比如接收到乱序片段9的时候，接收方需要回复ACK。回复号为8 (7+1)。此后接收方如果继续收到乱序片段(序号不是8的片段)，将再次重复发送ACK&#x3D;8。当发送方收到3个ACK&#x3D;8的回复时，发送方推断片段8丢失。即使此时片段8的计时器还没有超时，发送方会打断计时，直接重新发送片段8，这就是快速重新发送机制(fast-retransmission)。</p><p>快速重新发送机制利用重复的ACK来提示空洞的存在。当重复次数达到阈值时，认为空洞对应的片段在网络中丢失。快速重新发送机制提高了检测丢失片段的效率，往往可以在超时之前探测到丢失片段，并重复发送丢失的片段。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议的细节——TCP滑窗管理</title>
      <link href="/2018/04/19/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94TCP%E6%BB%91%E7%AA%97%E7%AE%A1%E7%90%86/"/>
      <url>/2018/04/19/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94TCP%E6%BB%91%E7%AA%97%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="累计ACK"><a href="#累计ACK" class="headerlink" title="累计ACK"></a>累计ACK</h4><p>在TCP连接中讲到，我们通过将ACK回复“附着”在其他数据片段的方式，减少了ACK回复所消耗的流量。但这并不是全部的故事。TCP协议并不是对每个片段都发送ACK回复。TCP协议实际采用的是累计ACK回复。接收方往往利用一个ACK回复来知会连续多个片段的成功接收。通过累计ACK，所需要的ACK回复通常可以降到50%。</p><span id="more"></span><p>如下图所示，橙色为已经接收的片段。方框为滑窗，滑窗可容纳3个片段。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-79879bd7bde10f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑窗"><br>滑窗还没接收到片段7时，已接收到片段8，9。这样就在滑窗中制造了一个“空穴”(hole)。当滑窗最终接收到片段7时，滑窗送出一个回复号为10的ACK回复。发送方收到该回复，会意识到，片段10之前的片段已经按照次序被成功接收。整个过程中节约了片段7和片段8所需的两个ACK回复。</p><p>此外，接收方在接收到片断，并应该回复ACK的时候，会故意延迟一些时间。如果在延迟的时间里，有后续的片段到达，就可以利用累计ACK来一起回复了。</p><p><strong>累计ACK减少了TCP传输过程中所需的ACK流量。</strong></p><h4 id="滑窗结构"><a href="#滑窗结构" class="headerlink" title="滑窗结构"></a>滑窗结构</h4><p>在之前的讨论中，我们以片段为单位，来衡量滑窗的大小的。真实的滑窗是以byte为单位表示大小，但这并不会对我们之前的讨论造成太大的影响。</p><p>发送方滑窗可以分为下面两个部分。offered window为整个滑窗的大小。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-1392b8acb431826b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送方滑窗"><br>接收方滑窗可分为三个部分：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-12c533e755e37320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="接收方滑窗"><br>可以看到，接收方的滑窗相对于发送方的滑窗多了一个”Received; ACKed; Not Sent to Proc”的部分。接收方接收到的文本流必须等待进程来读取。如果进程正忙于做别的事情，那么这些文本流即使已经正确接收，还是需要暂时占用接收缓存。</p><p>当出现上述占用时，滑窗的可用部分(也就是图中advertised window)就会缩水。这意味着接收方的处理能力下降。如果这个时候发送方依然按照之前的速率发送数据给接收方，接收方将无力接收这些数据。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP协议会根据情况自动改变滑窗大小，以实现流量控制。流量控制(flow control)是指接收方将advertised window的大小通知给发送方，从而指导发送方修改offered window的大小。接收方将该信息放在TCP头部的window size区域。</p><p>发送方在收到window size的通知时，会调整自己滑窗的大小，让offered window和advertised window相符。这样，发送窗口变小，文本流发送速率降低，从而减少了接收方的负担。</p><p><strong>通过流量管理，TCP连接两端的工作能力可以匹配，从而减少不不要的传输浪费。</strong></p><h4 id="零窗口"><a href="#零窗口" class="headerlink" title="零窗口"></a>零窗口</h4><p>advertised window大小有可能变为0，这意味着接收方的接收能力降为0。发送方收到大小为0的advertised window通知时，停止发送。</p><p>当接收方经过处理，再次产生可用的advertised window时，接收方会通过纯粹的ACK回复来通知发送方，让发送方恢复发送。然而，ACK回复的传送并不是可靠的。如果该ACK回复丢失，那么TCP传输将陷入死锁(deadlock)状态。</p><p>为此，发送方会在零窗口后，不断探测接收方的窗口。窗口探测(window probe)时，发送方会向接收方发送包含1 byte文本流的TCP片段，并等待ACK回复(该ACK回复包含有window size)。由于有1 byte的数据存在，所以该传输是可靠的，而不用担心ACK回复丢失的问题。如果探测结果显示窗口依然为0，发送方会等待更长的时间，然后再次进行窗口探测，直到TCP传输恢复。</p><h4 id="白痴窗口综合征"><a href="#白痴窗口综合征" class="headerlink" title="白痴窗口综合征"></a>白痴窗口综合征</h4><p>滑窗机制有可能犯病，比如白痴窗口综合症 (Silly Window Syndrome)。假设这样一种情形：接收方宣布(advertise)一个小的窗口，发送方根据advertised window，发送一个小的片段。接收方的小窗口被填满，经过处理，接收方再宣布一个小的窗口…… 这就是“白痴窗口综合症”：TCP通信的片段中包含的数据量很小。</p><p>在这样的情况下，TCP通信的片段所含的信息都很小，网络流量主要是TCP片段的头部，从而造成流量的浪费 (由于TCP头部很大，我们希望每个TCP片段中含有比较多的数据)。</p><p>如果发送方不断发送小的片段，也会造成“白痴窗口”。为了解决这个问题，需要从两方面入手。TCP中有相关的规定，要求：</p><ul><li><ol><li>接收方宣告的窗口必须达到一定的尺寸，否则等待。</li></ol></li><li><ol start="2"><li>除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的TCP应用(比如命令行互动)。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议的细节——TCP三次握手过程</title>
      <link href="/2018/04/19/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/04/19/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%86%E8%8A%82%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>TCP三次握手过程:</p><span id="more"></span><p><img src="https://upload-images.jianshu.io/upload_images/9169686-b6c60c23ab0415fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP三次握手过程"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>第一次握手：client首先发送SYN（Synchronization）报文给server，此时，client进入SYN_SENT状态，等待server端确认；注：SYN报文的特点：SYN标识位置1，随机产生一个值seq&#x3D;X，占用一个序列号。</p><p>第二次握手：server收到client发过来的SYN包后知道client请求建立连接，将产生一个SYN+ACK包发送给client以确认连接请求，此时server进入SYN_RCVD状态；注：SYN+ACK包的特点：SYN和ACK标识位都为1，ack&#x3D;X+1,随机产生的seq&#x3D;Y。</p><p>第三次握手：client收到server的SYN+ACK包，向server发送确认包ACK(ack&#x3D;Y+1），此包发送完毕，client和server进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p>完成三次握手，客户端与服务器开始传送数据，其实在第三次握手的同时，client就可以向sever发送数据了。</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>关于三次握手的目的，谢希仁的《计算机网络》中这么说“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。</p><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</p><p>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。</p><p>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列（内核会为每个这样的连接分配资源的），导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理和反向代理概述</title>
      <link href="/2018/04/18/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/18/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理类似一个跳板机，代理访问外部资源。</p><span id="more"></span><p><img src="https://upload-images.jianshu.io/upload_images/9169686-bb57332cf6d127b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正向代理"><br>举个栗子：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><p>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p><p>例如之前使用过这类软件例如CCproxy，**<a href="http://www.ccproxy.com/**%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82">http://www.ccproxy.com/**需要在浏览器中配置代理的地址。</a><br><img src="https://upload-images.jianshu.io/upload_images/9169686-de85a55f29932660.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置代理的地址"><br>总结来说：正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><p>正向代理的用途：</p><ul><li>（1）访问原来无法访问的资源，如google</li><li>（2） 可以做缓存，加速访问资源</li><li>（3）对客户端访问授权，上网进行认证</li><li>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li></ul><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>初次接触方向代理的感觉是，客户端是无感知代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。</p><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>反向代理的作用：</p><ul><li>（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击：大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-e315af51c321d10c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="保证内网的安全"></li><li>（2）负载均衡，通过反向代理服务器来优化网站的负载<br><img src="https://upload-images.jianshu.io/upload_images/9169686-830d6bfe5380d509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="负载均衡"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓存机制概述</title>
      <link href="/2018/04/16/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/16/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Http 缓存机制作为 web 性能优化的重要手段。</p><span id="more"></span><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p>HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。</p><p>浏览器向服务器请求数据时，发送请求(request)报文；服务器向浏览器返回数据时，返回响应(response)报文。</p><p>报文信息主要分为两部分：</p><ul><li>1.首部(header)——附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中。</li><li>2.主体部分(body)—–HTTP请求真正想要传输的部分</li></ul><h4 id="缓存规则解析"><a href="#缓存规则解析" class="headerlink" title="缓存规则解析"></a>缓存规则解析</h4><p>为方便理解，我们认为浏览器存在一个缓存数据库,用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-e04e90ce36c54b9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一次请求数据"><br>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。</p><p>已存在缓存数据时，仅基于强制缓存，请求数据的流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-d951d09bbee6d75b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="已存在缓存数据时，仅基于强制缓存"><br>已存在缓存数据时，仅基于对比缓存，请求数据的流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-5a9ee2cd73e07b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="已存在缓存数据时，仅基于对比缓存"><br>对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。</p><p>我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。</p><p>两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？</p><p>在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。</p><p>对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires&#x2F;Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-ea1b2c82c3cc02ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="强制缓存生效时，网络请求的情况"><br>Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。</p><p>另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。</p><p>Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。</p><ul><li>private: 客户端可以缓存</li><li>public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）</li><li>max-age&#x3D;xxx: 缓存的内容将在 xxx 秒后失效</li><li>no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）</li><li>no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好）</li></ul><p>举例：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-ca0eddc365cb86c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="举例"></p><p>图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。</p><h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。 </p><p>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。</p><p>在对比缓存生效时，状态码为304，并且报文大小和请求时间大大减少。原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。</p><p><strong>缓存标识的传递：</strong><br>对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，</p><p><strong>Last-Modified</strong><br>服务器在响应请求时，告诉浏览器资源的最后修改时间。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-753e24a00f17a310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Last-Modified"><br><strong>If-Modified-Since</strong><br>再次请求服务器时，那么浏览器将在请求中添加参数 If-Modified-Since（值为上次响应里面的Last-Modified值），服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。</p><p>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-11e9ccb9938455a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="If-Modified-Since"><br><strong>Etag</strong><br>服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-f67965d0075f7fbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Etag"><br><strong>If-None-Match</strong><br>再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p><p>对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-a3a2f830a7acb322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无缓存"><br><img src="https://upload-images.jianshu.io/upload_images/9169686-d6ede9bbb514e5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有缓存"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL/TSL协议概述</title>
      <link href="/2018/04/15/SSL-TSL%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/15/SSL-TSL%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>TLS名为传输层安全协议(Transport Layer Protocol)，这个协议是一套加密的通信协议。它的前身是SSL协议(安全套接层协议，Secure Sockets Layer)。这两个协议的工作方式类似，但TLS协议针对SSL协议进行了一些改善。SSL&#x2F;TLS协议利用加密的方式，在开放的互联网环境中实现了加密通信，让通信的双方可以安心的说悄悄话。</p><span id="more"></span><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p><p>SSL协议位于TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密中，给所有人用的锁被称为公钥(public key)，总部自己保留的钥匙被称为私钥(private key)。这样一种钥匙和锁分离的加密算法就叫做非对称加密(asymmetric encryption)。</p><p>实现了非对称加密的经典算法是RSA算法。</p><h4 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h4><p>非对称加密从安全性上要强过对称加密。但天下没有免费的午餐。非对称加密的运算成本同样也比较高。为了兼顾效率和安全，SSL协议同时使用了非对称和对称加密。它用对称加密算法来加密信息本身。但对于安全性比较脆弱的对称加密密钥，则采用非对称加密的方式来传输。</p><p>SSL协议分为客户端和服务器端。通信的核心步骤很简单：</p><ul><li>（1）双方利用明文通信的方式确立使用的加密算法。</li><li>（2）利用非对称算法通信，交换一个密钥。</li><li>（3）该密钥用于对称加密算法，加密接下来的通信正文。</li></ul><p>可以看到，SSL协议的关键是用一个非常安全的方式来交换一个对称密钥。交换的过程会比上面的描述更加复杂一些。</p><ul><li>（1）客户发起请求时，除了说明自己支持的非对称加密算法，还会附加一个客户端随机数(client random)。</li><li>（2）服务器回复请求时，会确定非对称加密算法和哈希函数，并附上公钥。此外，服务器端还会在此次通信中附加一个服务器端随机数(server random)。</li><li>（3）客户端会产生第三个随机数(Premaster secret)，然后利用服务器确定的非对称加密算法和公钥来加密这个随机数，再发送给服务器端。</li><li>（4）客户端用自己的私钥解密第三个随机数。</li><li>（5）这样，客户端和服务器端都知道了三个随机数。双方各自用商量好的哈希函数从三个随机数获得对称加密的密钥。</li></ul><p>即使明文通信的时候，某些信息被窃听，但第三步的非对称加密通信部分可以保证窃听者无法完整的获得三个随机数。这样，窃听者还是不知道对称加密的密钥是什么。这样，对称加密的密钥就在一个安全的环境中获得了。为了进一步安全，服务器的公钥会包含在一个数字证书中发送给客户。这样，客户还可以通过数字证书来验证服务器的身份，以免服务器本身出现问题。 </p><p>使用越来越广泛的HTTPS协议就是在SSL&#x2F;TLS协议的基础上进行通信。HTTP协议在通信过程中要经过多重路由，很容易被窃听。经过SSL协议加密的信息就算被窃听，也只能被通信目的地的人解读，从而保证了信息的安全。所以，如果所访问的网站没有使用HTTPS协议，那么在输入银行账号和密码之类的敏感信息时，就要三思而后行了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层（application layer）协议概述</title>
      <link href="/2018/04/14/%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88application-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/14/%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88application-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>TCP协议实现了数据流的可靠传输。然而，人们更加习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档(hypertext document)。</p><span id="more"></span><p>超文本文档中包含有超链接，指向其他的资源。超文本文档是万维网(World Wide Web，即www)的基础。HTTP协议解决文件传输的问题。HTTP是应用层协议，主要建立在TCP协议之上(偶尔也可以UDP为底层)。它随着万维网的发展而流行。HTTP协议目的是，如何在万维网的网络环境下，更好的利用TCP协议，以实现文件，特别是超文本文件的传输。</p><p>早期的HTTP协议主要传输静态文件，即真实存储在服务器上的文件。随着万维网的发展，HTTP协议被用于传输“动态文件”，服务器上的程序根据HTTP请求即时生成的动态文件。我们将HTTP的传输对象统称为资源(resource)。</p><p>HTTP实现了资源的订购和传送。其工作方式类似于快餐点单。</p><ul><li>1：请求(request): 顾客向服务员提出请求：“来个鸡腿汉堡”。</li><li>2：回复(response):服务员根据情况，回应顾客的请求<br>根据情况的不同，服务员的回应可能有很多，比如:</li><li>服务员准备鸡腿汉堡，将鸡腿汉堡交给顾客。（一切OK）</li><li>服务员发现自己只是个甜品站。他让顾客前往正式柜台点单。（重新定向）</li><li>服务员告诉顾客鸡腿汉堡没有了。(无法找到)</li><li>交易结束后，服务员就将刚才的交易抛到脑后，准备服务下一位顾客。</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>HTTP协议的通信是一次request-responce交流。客户端(guest)向服务器发出请求(request)，服务器(server)回复(response)客户端。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-8fe94d45e22e0d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通信过程"><br>HTTP协议规定了请求和回复的格式:</p><ul><li>起始行 (start line)</li><li>头信息 (headers)</li><li>主体(entity body)</li></ul><p>起始行只有一行。它包含了请求&#x2F;回复最重要的信息。请求的起始行表示(顾客)“想要什么”。回复的起始行表示(后厨)“发生什么”。</p><p>头信息可以有多行。每一行是一对键值对(key-value pair)，比如:Content-type: text&#x2F;plain<br>它表示，包含有一个名为Content-type的参数，该参数的值为text&#x2F;plain。头信息是对起始行的补充。请求的头信息对服务器有指导意义 (好像在菜单上注明: 鸡腿不要辣)。回复的头信息则是提示客户端（比如，在盒子上注明: 小心烫）</p><p>主体部分包含了具体的资源。上图的请求中并没有主体，因为我们只是在下单，而不用管后厨送什么东西 (请求是可以有主体内容的)。回复中包含的主体是一段文本文字(Hello World!)。这段文本文字正是顾客所期待的，鸡腿汉堡。</p><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>先来看一下请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><p>在起始行中，有三段信息:</p><ul><li>GET ：用于说明想要服务器执行的操作，此外还有PUT、POST等操作</li><li>&#x2F;index.html ：资源的路径。这里指向服务器上的index.html文件。</li><li>HTTP&#x2F;1.1： 协议的版本。HTTP第一个广泛使用的版本是1.0，当前版本为1.1。</li></ul><p>早期的HTTP协议只有GET方法。遵从HTTP协议，服务器接收到GET请求后，会将特定资源传送给客户。这类似于客户点单，并获得汉堡的过程。使用GET方法时，是客户向服务器索取资源，所以请求往往没有主体部分。</p><p>GET方法也可以用于传输一些不重要的数据。它是通过改写URL的方式实现的。GET的数据利用URL?变量名＝变量值的方法传输。比如向<strong><a href="http://127.0.0.1/">http://127.0.0.1</a></strong>发送一个变量“q”，它的值为“a”。那么，实际的URL为<strong><a href="http://127.0.0.1/?q=a">http://127.0.0.1?q=a</a></strong>。服务器收到请求后，就可以知道”q”的值为”a”。</p><p>GET方法之外，最常用的是POST方法。它用于从客户端向服务器提交数据。使用POST方法时，URL不再被改写。数据位于http请求的主体。POST方法最用于提交HTML的form数据。服务器往往会对POST方法提交的数据进行一定的处理，比如存入服务器数据库。</p><p>样例请求中有一行头信息。该头信息的名字是Host。HTTP的请求必须有Host头信息，用于说明服务器的地址和端口。HTTP协议的默认端口是80，如果在HOST中没有说明端口，那么将默认采取该端口。在该例子中，服务器的域名为<strong><a href="http://www.example.com/">www.example.com</a></strong>，端口为80。域名将通过DNS服务器转换为IP地址，从而确定服务器在互联网上的地址。</p><h4 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h4><p>服务器在接收到请求之后，会根据程序，生成对应于该请求的回复，比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/plain</span><br><span class="line">Content-length: 12</span><br><span class="line"></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>回复的起始行同样包含三段信息</p><ul><li>HTTP&#x2F;1.1 协议版本</li><li>200 状态码(status code)</li><li>OK 状态描述</li></ul><p>OK是对状态码200的文字描述，它只是为了便于人类的阅读。电脑只关心三位的状态码(status code)，即这里的200。200表示一切OK，资源正常返回。状态码代表了服务器回应动作的类型。<br>其它常见的状态码还有:</p><ul><li>302，重定向(redirect): 我这里没有你想要的资源，但我知道另一个地方xxx有，你可以去那里找。</li><li>404，无法找到(not found): 我找不到你想要的资源，无能为力。</li></ul><p>Content-type说明了主体所包含的资源的类型。根据类型的不同，客户端可以启动不同的处理程序(比如显示图像文件，播放声音文件等等)。下面是一些常见的资源：</p><ul><li>text&#x2F;plain 普通文本</li><li>text&#x2F;html HTML文本</li><li>image&#x2F;jpeg jpeg图片</li><li>image&#x2F;gif gif图片</li></ul><p>Content-length说明了主体部分的长度，以字节(byte)为单位。<br>回应的主体部分为一段普通文本，即Hello World!</p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>根据早期的HTTP协议，每次request-reponse时，都要重新建立TCP连接。TCP连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，HTTP通信是无状态(stateless)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。</p><p>随着HTTP协议的发展，HTTP协议允许TCP连接复用，以节省建立连接所耗费的时间。但HTTP协议依然保持无状态的特性。</p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>域名(domain name)是IP地址的代号。域名通常是由字符构成的，比如<strong><a href="http://www.yahoo.com/">www.yahoo.com</a></strong>，要比纯粹数字构成的IP地址(106.10.170.118)容易记忆。</p><p>域名解析系统(DNS, domain name system)就负责将域名翻译为对应的IP地址。在DNS的帮助下，我们可以在浏览器的地址栏输入域名，而不是IP地址。这大大减轻了用户的记忆负担。此外，出于维护和运营的原因，一些网站可能会变更IP地址。这些网站可以更改DNS中的对应关系，从而保持域名不变，而IP地址更新。由于大部分用户记录的都是域名，这样就可以降低IP变更带来的影响。</p><p>从机器和技术的角度上来说，域名并不是必须的。但Internet是由机器和用户共同构成的。鉴于DNS对用户的巨大帮助，DNS已经被当作TCP&#x2F;IP套装不可或缺的一个组成部分。</p><h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><p>域名和IP地址的对应关系存储在DNS服务器中。所谓的DNS服务器，是指在网络中进行域名解析的一些服务器(计算机)。这些服务器都有自己的IP地址，并使用DNS协议(DNS protocol)进行通信。DNS协议主要基于UDP，是应用层协议。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-e658e1fb19e7aa03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS分级树"><br>DNS服务器构成一个分级(hierarchical)的树状体系。上图中，每个节点(node)为一个DNS服务器，每个节点都有自己的IP地址。树的顶端为用户电脑出口处的DNS服务器。在Linux下，可以使用cat &#x2F;etc&#x2F;resolv.conf，来查询出口DNS服务器。树的末端是真正的域名&#x2F;IP对应关系记录。一次DNS查询就是从树的顶端节点出发，最终找到相应末端记录的过程。</p><p>中间节点根据域名的构成，将DNS查询引导向下一级的服务器。比如说一个域名cs.berkeley.edu，DNS解析会将域名分割为cs, berkeley, edu，然后按照相反的顺序查询(edu, berkeley, cs)。出口DNS首先根据edu，将查询指向下一层的edu节点。然后edu节点根据berkeley，将查询指向下一层的berkeley节点。这台berkeley服务器上存储有cs.berkeley.edu的IP地址。所以，中间节点不断重新定向，并将我们引导到正确的记录。</p><p>在整个DNS查询过程中，无论是重新定向还是最终取得对应关系，都是用户计算机和DNS服务器使用DNS协议通信。用户计算机根据DNS服务器的反馈，依次与下一层的DNS服务器建立通信。用户计算机经过递归查询，最终和末端节点通信，并获得IP地址。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-c5998aa4c537900d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS查询过程"></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>用户计算机的操作系统中的域名解析模块(DNS Resolver)负责域名解析的相关工作。任何一个应用程序(邮件，浏览器)都可以通过调用该模块来进行域名解析。</p><p>并不是每次域名解析都要完整的经历解析过程。DNS Resolver通常有DNS缓存(cache)，用来记录最近使用和查询的域名&#x2F;IP关系。在进行DNS查询之前，计算机会先查询cache中是否有相关记录。这样，重复使用的域名就不用总要经过整个递归查询过程。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-7fabef83de63f04a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS缓存"></p><h4 id="反向DNS"><a href="#反向DNS" class="headerlink" title="反向DNS"></a>反向DNS</h4><p>上面的DNS查询均为正向DNS查询：已经知道域名，想要查询对应IP。而反向DNS(reverse DNS)是已经知道IP的前提下，想要查询域名。反向DNS也是采用分层查询方式，对于一个IP地址(比如106.10.170.118)，依次查询in-addr.arpa节点(如果是IPv6，则为ip6.arpa节点)，106节点，10节点，170节点，并在该节点获得106.10.170.118对应的域名。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层（transport layer）协议概述</title>
      <link href="/2018/04/13/%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88transport-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/13/%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%88transport-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>传输层最重要的协议为TCP协议和UDP协议。这两者走了两个极端，TCP协议复杂，但传输可靠。UDP协议简单，但传输不可靠。其他的各个传输层协议在某种程度上都是这两个协议的折中。</p><span id="more"></span><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>UDP(User Datagram Protocol)传输与IP传输非常类似。你可以将UDP协议看作IP协议暴露在传输层的一个接口。UDP协议同样以数据包(datagram)的方式传输，它的传输方式也是”Best Effort”的，所以UDP协议也是不可靠的(unreliable)。那么，我们为什么不直接使用IP协议而要额外增加一个UDP协议呢？ </p><p>一个重要的原因是IP协议中并没有端口(port)的概念。IP协议进行的是IP地址到IP地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个进程同时运行，当前到底和哪一个进程通信了？端口就是用来区分这个的。一个端口就代表了一个进程。UDP协议实现了端口，从而让数据包可以在送到IP地址的基础上，进一步可以送到某个端口。</p><p>尽管UDP协议非常简单，但它的产生晚于更加复杂的TCP协议。早期的网络开发者开发出的IP协议和TCP协议分别位于网络层和传输层，所有的通信都要先经过TCP封装，再经过IP封装(应用层-&gt;TCP-&gt;IP)。开发者将TCP&#x2F;IP视为相互合作的套装。</p><p>但很快，网络开发者发现，IP协议的功能和TCP协议的功能是相互独立的。对于一些简单的通信，我们只需要“Best Effort”式的IP传输就可以了，而不需要TCP协议复杂的建立连接的方式(特别是在早期网络环境中，如果过多的建立TCP连接，会造成很大的网络负担，而UDP协议可以相对快速的处理这些简单通信)。UDP协议随之被开发出来，作为IP协议在传输层的”傀儡”。</p><p>这样，网络通信可以通过应用层-&gt;UDP-&gt;IP的封装方式，绕过TCP协议。由于UDP协议本身异常简单，实际上只为IP传输起到了桥梁的作用。</p><h4 id="UDP协议头部"><a href="#UDP协议头部" class="headerlink" title="UDP协议头部"></a>UDP协议头部</h4><p><img src="https://upload-images.jianshu.io/upload_images/9169686-cc6b3d4340f8266f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP协议头部"><br>上面的source port和destination port分别为UDP包的出发端口和目的地端口。Length为整个UDP包的长度。</p><p>checksum的算法与IP协议的header checksum算法相类似。不同的是，UDP的checksum所校验的序列包括了整个UDP数据包，以及封装的IP头部的一些信息(主要为出发地IP和目的地IP)。这样，checksum就可以校验IP：端口的正确性了。在IPv4中，checksum可以为0，意味着不使用checksum。IPv6要求必须进行checksum校验。</p><h4 id="端口与socket"><a href="#端口与socket" class="headerlink" title="端口与socket"></a>端口与socket</h4><p>端口(port)是伴随着传输层诞生的概念。它可以将网络层的IP通信分送到各个通信通道。UDP协议和TCP协议尽管在工作方式上有很大的不同，但它们都建立了从一个端口到另一个端口的通信。</p><p>随着我们进入传输层，我们也可以调用操作系统中的API，来构建socket。Socket是操作系统提供的一个编程接口，它用来代表某个网络通信。应用程序通过socket来调用系统内核中处理网络协议的模块，而这些内核模块会负责具体的网络协议的实施。</p><p>这样，我们可以让内核来接收网络协议的细节，而我们只需要提供所要传输的内容就可以了，内核会帮我们控制格式，并进一步向底层封装。因此，在实际应用中，我们并不需要知道具体怎么构成一个UDP包，而只需要提供相关信息(比如IP地址，比如端口号，比如所要传输的信息)，操作系统内核会在传输之前会根据我们提供的相关信息构成一个合格的UDP包(以及下层的包和帧)。</p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>TCP(Transportation Control Protocol)协议与IP协议是一同产生的。事实上，两者最初是一个协议，后来才被分拆成网络层的IP和传输层的TCP。TCP协议则实现了“流”形式的通信。TCP协议是很复杂的，这里先简单列出TCP的一些重点内容：</p><ul><li>1、“流”通信的意义与实现方式——使用编号和分段实现了TCP传输的有序</li><li>2、如何实现可靠传输——使用重复发送来实现TCP传输的可靠性。</li><li>3、使用滑窗提高效率——使用滑窗来实现了发送方和接收方处理能力的匹配</li><li>4、TCP连接概念——使用连接记录TCP两端的状态</li><li>5、TCP头部格式</li><li>6、TCP建立连接</li><li>7、TCP终止连接</li><li>8、TCP堵塞控制</li></ul><h4 id="流通信"><a href="#流通信" class="headerlink" title="流通信"></a>流通信</h4><p>TCP协议是传输层协议，实现的是端口到端口(port)的通信。我们知道，计算机数据的本质是有序的0&#x2F;1序列(如果以byte为单位，就叫做文本流)，计算机的功能就是储存和处理文本流。CPU + memory + 存储设备实现了文本流在同一台计算机内部的加工处理。通过一些IO，比如屏幕和键盘，文本流实现了人机交互。而进一步，如果网络通信可在不同计算机之间进行文本流的交互，那么我们就和整个计算机系统的数据处理方式实现了对接。</p><p>IP协议和UDP协议采用的是数据包的方式传送，后发出的数据包可能早到，我们并不能保证数据到达的次序。TCP协议确保了数据到达的顺序与文本流顺序相符。当计算机从TCP协议的接口读取数据时，这些数据已经是排列好顺序的“流”了。</p><p>“流”的要点是次序(order)，然而实现这一点并不简单。TCP协议是基于IP协议的，所以最终数据传送还是以IP数据包为单位进行的。如果一个文本流很长的话，我们不可能将整个文本流放入到一个IP数据包中，那样有可能会超过MTU。</p><p>TCP协议封装到IP包的不是整个文本流，而是TCP协议所规定的片段(segment)。与之前的一个IP或者UDP数据包类似，一个TCP片段同样分为头部(header)和数据(payload)两部分。整个文本流按照次序被分成小段，而每一段被放入TCP片段的数据部分。一个TCP片段封装成的IP包不超过整个IP接力路径上的最小MTU，从而避免令人痛苦的碎片化(fragmentation)。(给文本流分段是在发送主机完成的，而碎片化是在网络中的路由器完成的。路由器要处理许多路的通信，所以相当繁忙。文本流提前在发送主机分好段，可以避免在路由器上执行碎片化，可大大减小网络负担)</p><p>TCP片段的头部(header)会存有该片段的序号(sequence number)。这样，接收的计算机就可以知道接收到的片段在原文本流中的顺序了，也可以知道自己下一步需要接收哪个片段以形成流。比如已经接收到了片段1，片段2，片段3，那么接收主机就开始期待片段4。如果接收到不符合顺序的数据包(比如片段8)，接收方的TCP模块可以拒绝接收，从而保证呈现给接收主机的信息是符合次序的“流”。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>片段编号这个初步的想法并不能解决我们所有的问题。IP协议是不可靠的，所以IP数据包可能在传输过程中发生错误或者丢失。而IP传输是”Best Effort” 式的，如果发生异常情况，我们的IP数据包就会被轻易的丢弃掉。另一方面，如果乱序(out-of-order)片段到达，根据我们上面说的，接收主机不会接收。这样，错误片段、丢失片段和被拒片段的联手破坏之下，接收主机只可能收到一个充满“漏洞”的文本流。</p><p>TCP的补救方法是，在每收到一个正确的、符合次序的片段之后，就向发送方(也就是连接的另一段)发送一个特殊的TCP片段，用来知会(ACK，acknowledge)发送方：我已经收到那个片段了。这个特殊的TCP片段叫做ACK回复。如果一个片段序号为L，对应ACK回复有回复号L+1，也就是接收方期待接收的下一个发送片段的序号。</p><p>如果发送方在一定时间等待之后，还是没有收到ACK回复，那么它推断之前发送的片段一定发生了异常。发送方会重复发送(retransmit)那个出现异常的片段，等待ACK回复，如果还没有收到，那么再重复发送原片段… 直到收到该片段对应的ACK回复(回复号为L+1的ACK)。</p><p>当发送方收到ACK回复时，它看到里面的回复号为L+1，也就是发送方下一个应该发送的TCP片段序号。发送方推断出之前的片段已经被正确的接收，随后发出L+1号片段。ACK回复也有可能丢失。对于发送方来说，这和接收方拒绝发送ACK回复是一样的。发送方会重复发送，而接收方接收到已知会过的片段，推断出ACK回复丢失，会重新发送ACK回复。</p><p>通过ACK回复和重新发送机制，TCP协议将片段传输变得可靠。尽管底盘是不可靠的IP协议，但TCP协议以一种“不放弃的精神”，不断尝试，最终成功。</p><h4 id="滑窗"><a href="#滑窗" class="headerlink" title="滑窗"></a>滑窗</h4><p>上面的工作方式中，发送方保持发送-&gt;等待ACK-&gt;发送-&gt;等待ACK…的单线工作方式，这样的工作方式叫做stop-and-wait。stop-and-wait虽然实现了TCP通信的可靠性，但同时牺牲了网络通信的效率。</p><p>在等待ACK的时间段内，我们的网络都处于闲置(idle)状态。我们希望有一种方式，可以同时发送出多个片段。然而如果同时发出多个片段，那么由于IP包传送是无次序的，有可能会生成乱序片段(out-of-order)，也就是后发出的片段先到达。</p><p>在stop-and-wait的工作方式下，乱序片段完全被拒绝，这也很不效率。毕竟，乱序片段只是提前到达的片段。我们可以在缓存中先存放它，等到它之前的片段补充完毕，再将它缀在后面。然而，如果一个乱序片段实在是太过提前(太“乱”了)，该片段将长时间占用缓存。我们需要一种折中的方法来解决该问题：利用缓存保留一些“不那么乱”的片段，期望能在段时间内补充上之前的片段(暂不处理，但发送相应的ACK)；对于“乱”的比较厉害的片段，则将它们拒绝(不处理，也不发送对应的ACK)。</p><p>滑窗(sliding window)被同时应用于接收方和发送方，以解决以上问题。发送方和接收方各有一个滑窗。当片段位于滑窗中时，表示TCP正在处理该片段。滑窗中可以有多个片段，也就是可以同时处理多个片段。滑窗越大，越大的滑窗同时处理的片段数目越多(当然，计算机也必须分配出更多的缓存供滑窗使用)。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-8c7a45d52d7240a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑窗"><br>假设一个可以容纳三个片段的滑窗，并假设片段从左向右排列。对于发送方来说，滑窗的左侧为已发送并已ACK过的片段序列，滑窗右侧是尚未发送的片段序列。滑窗中的片段(比如片段5，6，7)被发送出去，并等待相应的ACK。如果收到片段5的ACK，滑窗将向右移动。这样，新的片段从右侧进入滑窗内，被发送出去，并进入等待状态。在接收到片段5的ACK之前，滑窗不会移动，即使已经收到了片段6和7的ACK。这样，就保证了滑窗左侧的序列是已经发送的、接收到ACK的、符合顺序的片段序列。</p><p>对于接收方来说，滑窗的左侧是已经正确收到并ACK回复过的片段(比如片段1，2，3，4)，也就是正确接收到的文本流。滑窗中是期望接收的片段(比如片段5, 6, 7)。同样，如果片段6，7先到达，那么滑窗不会移动。如果片段5先到达，那么滑窗会向右移动，以等待接收新的片段。如果出现滑窗之外的片段，比如片段9，那么滑窗将拒绝接收。</p><h4 id="TCP连接概念"><a href="#TCP连接概念" class="headerlink" title="TCP连接概念"></a>TCP连接概念</h4><p>传输层在逻辑上提供了端口区分同一主机的不同进程。一个IP地址可以有多个端口。一个具体的端口需要IP地址和端口号共同确定(我们记为IP:port的形式)。一个连接为两个IP:port之间建立TCP通信。(一个常用的比喻为：TCP连接就像两个人打电话， IP为总机号码，port为分机号码)</p><p>参与连接的如果是两台电脑，那么两台电脑操作系统的TCP模块负责建立连接。每个连接有四个参数(两个IP，两个端口)，来表明“谁在和谁通话”。每台电脑都会记录有这四个参数，以确定是哪一个连接。如果这四个参数完全相同，则为同一连接；如果这四个参数有一个不同，即为不同的连接。这意味着，同一个端口上可以有多个连接。内核中的TCP模块生成连接之后，将连接分配给进程使用。</p><p>TCP连接是双向(duplex)的。在TCP协议与”流”通信中，我们所展示的TCP传输是单向的。双向连接实际上就是建立两个方向的TCP传输，所以概念上并不复杂。这时，连接的每一方都需要两个滑窗，以分别处理发送的文本流和接收的文本流。由于连接的双向性，我们也要为两个方向的文本流编号。这两个文本流的编号相互独立。为文本流分段和编号由发送方来处理，回复ACK则由接收的一方进行。</p><h4 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h4><p><img src="https://upload-images.jianshu.io/upload_images/9169686-c8c1656e08043fb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP头部格式"></p><ul><li><ol><li>一个TCP头部需要包含出发端口(source port)和目的地端口(destination port)。这些与IP头中的两个IP地址共同确定了连接。</li></ol></li><li><ol start="2"><li>每个TCP片段都有序号(sequence number)。这些序号最终将数据部分的文本片段整理成为文本流。</li></ol></li><li><ol start="3"><li>ACK是一位(bit)。只有ACK位设定的时候，回复号(Acknowledgement number)才有效。ACK回复号说明了接收方期待接收的下一个片段，所以ACK回复号为最后接收到的片段序号加1。<br>很多时候，ACK回复“附着”在发送的数据片段中。TCP协议是双向的。比如A和B两个电脑。ACK回复是接收方回复给发送方 (比如A发送给B， B回复A)。但同时，B也可以是发送方，B有可能有数据发送给A，所以B就把ACK回复附着在它要发送给A的数据片段的头部。这样可以减少ACK所占用的交通流量。<br>一个片段可以也只单纯包含ACK回复。一个纯粹的ACK回复片段不传送文本流，所以不消耗序列号。如果有下一个正常的数据片段，它的序号将与纯粹ACK回复片段的序号相同。</li></ol></li><li><ol start="4"><li>ACK后面还有SYN和FIN，它们也各占据一位(bit)。</li></ol></li></ul><h4 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h4><p>TCP传输需要一个前提：TCP连接已经建立。然而，TCP连接从无到有需要一个建立连接的过程。建立连接的最重要目是让连接的双方交换初始序号(ISN, Initial Sequence Number)。</p><p>根据TCP协议的规定，文本流的第一个片段的序号不能是确定的数字(比如说1)。连接的双方各自随机生成自己的ISN，然后再利用的一定方式让对方了解。这样的规定是出于TCP连接安全考虑：如果以一个确定的数字作为初始的TCP序号，那么其他人很容易猜出接下来的序列号，并按照正确的序号发送“伪装”的TCP片段，以插入到文本流中。</p><p>ISN交换是通过SYN片段实现的。SYN片段由头部的SYN位表明，它的序号为发送方的ISN。该片段由连接的一方首先发给给另一方，我们将发送SYN的一方称为客户(client)，而接收SYN的一方称为服务器(server)。我们使用ISN(c)表示client一方的ISN，使用ISN(s)表示server一方的ISN。随后，接收到SYN的server需要回复ACK，并发送出包含有server的ISN的SYN片段。</p><p>下图为建立连接的过程，也就是经典的TCP三次握手(three-way handshaking)。两条竖直线分别为client和server的时间轴。每个箭头代表了一次TCP片段的单向传输。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-3b4816ae27f81373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP三次握手"><br>青色为纯粹的ACK片段。整个过程的本质是双方互发含有自己的ISN的SYN片段。根据TCP传输的规则，接收到ISN的一方需要回复ACK，所以共计四片信息在建立连接过程中传输。之所以是三次握手 (而不是四次)，是因为server将发送SYN和回复ACK合并到一个TCP片段中。</p><p>我们以client方为例。client知道自己的ISN(也就是ISN(c))。建立连接之后，它也知道了对方的ISN(s)。此后，如果需要发送文本流片段，则编号为ISN(c) + 1, ISN(c) + 2 …。如果接收文本流片段，则期待接收ISN(s) + 1, ISN(s) + 2 …。</p><p>连接建立之后，连接的双方就可以按照TCP传输的方式相互发送文本流了。</p><h4 id="TCP终止连接"><a href="#TCP终止连接" class="headerlink" title="TCP终止连接"></a>TCP终止连接</h4><p>一个连接建立之后，连接两端的进程可以利用该连接进行通信。当连接的一方觉得“我讲完了”，它可以终结连接中发送到对方方向的通信。连接最终通过四次握手(four-way handshaking)的方式终结，连接终结使用的是特殊片段FIN(FIN位为1的片段)。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-1fd01e8240922bd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四次挥手"><br>我们可以看到，连接终结的过程中，连接双方也交换了四片信息(两个FIN和两个ACK)。在终结连接的过程中，TCP并没有合并FIN与ACK片段。原因是TCP连接允许单向关闭(half-close)。</p><p>也就是说，TCP连接关闭了一个方向的传输，成为一个单向连接(half-duplex)。第二个箭头和第三个箭头传递必须分开，才能有空隙在开放的方向上继续传输。如果第二个箭头和第三个箭头合并在一起，那么，随着一方关闭，另一方也要被迫关闭。</p><p>第二和第三次握手之间，server可以继续单向的发送片段给client，但client不能发送数据片段给server。</p><p>(上面的终结从client先发起，TCP连接终结也可以从server先发起。)</p><p>在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到著名的TIME_WAIT状态。</p><p>Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h4 id="TCP堵塞控制"><a href="#TCP堵塞控制" class="headerlink" title="TCP堵塞控制"></a>TCP堵塞控制</h4><p><strong>概述</strong><br>堵塞类似于现实中的堵车。网络被称为“信息高速公路”。许多汽车(IP包)在网络中行驶，并经过一个一个路口 (路由器)，直到到达目的地。</p><p>一个路由器如果过度繁忙，会丢弃一些IP包。UDP协议不保证传输的可靠性，所以丢失就丢失了。而TCP协议需要保证传输的可靠性，当包含有TCP片段的IP包丢失时，TCP协议会重复发送TCP片段。于是，更多的“汽车”进入到公路中，原本繁忙的路由器变得更加繁忙，更多的IP包丢失。这样就构成了一个恶性循环。</p><p>这样的情况被称为堵塞崩溃(congestion collapse)。每个发送方为了保证自己的发送质量，而不顾及公共领域现状，是造成堵塞崩溃的主要原因。当时的网络中高达90%的传输资源可能被堵塞崩溃所浪费。</p><p>为了解决这一缺陷，从八十年代开始，TCP协议中开始加入堵塞控制(congestion control)的功能，以避免堵塞崩溃的出现。多个算法被提出并实施，大大改善了网络的交通状况。直到今天，堵塞控制依然是互联网研究的一个活跃领域。</p><p>现实中，当我们遇到堵车，可能就会希望兴建立交桥和高架，或者希望有一位交警来疏导交通。而TCP协议的堵塞控制是通过约束自己实现的。当TCP的发送方探测到网络交通拥堵时，会控制自己发送片段的速率，以缓解网络的交通状况，避免堵塞崩溃。简言之，TCP协议规定了发送方需要遵守的“公德”。</p><p><strong>过程</strong><br>我们先来说明堵塞是如何探测的。在TCP重新发送中，我们已经总结了两种推测TCP片段丢失的方法：ACK超时和重复ACK。一旦发送方认为TCP片段丢失，则认为网络中出现堵塞。</p><p>另一方面，TCP发送方是如何控制发送速率呢？TCP协议通过控制滑窗(sliding window)大小来控制发送速率。在TCP滑窗管理中，我们已经见到了一个窗口限制，就是advertised window size，以实现TCP流量控制。TCP还会维护一个congestion window size，以根据网络状况来调整滑窗大小。真实滑窗大小取这两个滑窗限制的最小值，从而同时满足两个限制 (流量控制和堵塞控制)。</p><p><strong>Congestion Window</strong><br>congestion window总是处于两种状态的一个。这两种状态是: 慢起动(slow start)和堵塞避免(congestion avoidance)。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-7916e6bd327daf17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="congestion window"><br>上图是概念性的。实际的实施要比上图复杂，而且根据算法不同会有不同的版本。cwnd代表congestion window size。我们以片段的个数为单位，来表示cwnd的大小 (同样是概念性的)。</p><p>Congestion window从slow start的状态开始。Slow start的特点是初始速率低，但速率不断倍增。每次进入到slow start状态时，cwnd都需要重置为初始值1。发送方每接收到一个正确的ACK，就会将congestion window增加1，从而实现速率的倍增(由于累计ACK，速率增长可能会小于倍增)。</p><p>当congestion window的大小达到某个阈值ssthresh时，congestion进入到congestion avoidance状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，将窗口尺寸增加1(实际上就是每个RTT增加1)。所以在congestion avoidance下，cwnd线性增长，增长速率慢。</p><p>如果在congestion avoidance下有片段丢失，重新回到slow start状态，并将ssthresh更新为cwnd的一半。</p><p>我们看到，sshthresh是slow start到congestion avoidance的切换点。而片段丢失是congestion avoidance到slow start的切换点。一开始sshthresh的值一般比较大，所以slow start可能在切换成congestion avoidance之前就丢失片段。这种情况下，slow start会重新开始，而ssthresh更新为cwnd的一半。</p><p>总的来说，发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长快，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。</p><p>阻塞控制有效的提高了互联网的利用率。阻塞控制的算法多种多样，并且依然不完善。一个常见的问题是cwnd在接近饱和时线性增长，因此对新增的网络带宽不敏感。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层（network layer）协议概述</title>
      <link href="/2018/04/11/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88network-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/11/%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88network-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>网络层(network layer)是实现互联网的最重要的一层。正是在网络层面上，各个局域网根据IP协议相互连接，最终构成覆盖全球的Internet。更高层的协议，无论是TCP还是UDP，必须通过网络层的IP数据包(datagram)来传递信息。操作系统也会提供该层的socket，从而允许用户直接操作IP包。</p><span id="more"></span><p>IP数据包是符合IP协议的信息(也就是0&#x2F;1序列)，我们后面简称IP数据包为IP包。IP包分为头部(header)和数据(Data)两部分。</p><p>IP协议认为自己所处的环境是不可靠(unreliable)的，所以IP协议提供的传送只能是“我尽力” (best effort)。所谓的“我尽力”，其潜台词是，如果事情出错不要怪我，我只是答应了尽力，可没保证什么。所以，如果IP包传输过程中出现错误(比如checksum对不上，比如交通太繁忙，比如超过Time to Live)，根据IP协议，你的IP包会直接被丢掉。Game Over, 不会再有进一步的努力来修正错误。Best effort让IP协议保持很简单的形态。更多的质量控制交给高层协议处理，IP协议只负责有效率的传输。</p><p>“效率优先”也体现在IP包的顺序(order)上。IP协议也不保证IP包到达的先后顺序。IP接力是根据routing table决定接力路线的。如果在连续的IP包发送过程中，routing table更新(比如有一条新建的捷径出现)，那么后发出的IP包选择走不一样的接力路线。如果新的路径传输速度更快，那么后发出的IP包有可能先到。</p><h3 id="IP包格式"><a href="#IP包格式" class="headerlink" title="IP包格式"></a>IP包格式</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP地址是IP协议的重要组成部分，它可以识别接入互联网中的任意一台设备。</p><p>IPv4和IPv6是先后出现的两个IP协议版本。IPv4将32位0&#x2F;1分成4段8位序列，并用10进制来表示每一段(这样，一段的范围就是0到255)，段与段之间以.分隔。比如上面的地址可以表示成为192.0.0.3。IPv6地址是128位0&#x2F;1序列，它也按照8位分割，以16进制来记录每一段(使用16进制而不是10进制，这能让写出来的IPv6地址短一些)，段与段之间以:分隔。</p><p>IP地址的分配是一个政策性的问题。ICANN(the Internet Corporation for Assigned Names and Numbers)是Internet的中心管理机构。ICANN的IANA(Internet Assigned Numbers Authourity)部门负责将IP地址分配给5个区域性的互联网注册机构(RIR，Reginal Internet Registry)，比如APNIC，它负责亚太地区的IP分配。</p><p>然后RIR将地址进一步分配给当地的ISP(Internet Service Provider)，比如中国电信和中国网通。ISP再根据自己的情况，将IP地址分配给机构或者直接分配给用户，比如将A类地址分配给一个超大型机构，而将C类地址分配给一个网吧。机构可以进一步在局域网内部分配IP地址给各个主机。</p><p>并不是所有的地址都会被分配。一些地址被预留，用于广播、测试、私有网络使用等。这些地址被称为专用地址(special-use address)。你可以查询RFC5735来了解哪些地址是专用地址。</p><p>(RFC，Request For Comments。RFC是一系列的技术文档，用于记录Internet相关的技术和协议规定。每一个RFC文件都有一个固定的编号。它们是互联网的一个重要财产。你可以通过 <a href="http://www.rfc-editor.org/">http://www.rfc-editor.org/</a> 来查找RFC文件)</p><p>IP协议可以分为IPv4和IPv6两种。IPv6是改进版本，用于取代IPv4协议。</p><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p><img src="https://upload-images.jianshu.io/upload_images/9169686-fad361f428269f87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IPv4帧格式"><br>与帧类似，IP包的头部也有多个区域。我们将注意力放在红色的发出地(source address)和目的地(destination address)。它们都是IP地址。IPv4的地址为4 bytes的长度(也就是32位)。我们通常将IPv4的地址分为四个十进制的数，每个数的范围为0-255，段与段之间以.分隔。比如192.0.0.1就是一个IP地址。填写在IP包头部的是该地址的二进制形式。</p><p>IP地址是全球地址，它可以识别”社区”(局域网)和”房子”(主机)。这是通过将IP地址分类实现的。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-94ccf59ce843fee7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址分类"><br>每个IP地址的32位分为前后两部分，第一部分用来区分局域网，第二个部分用来区分该局域网的主机。子网掩码(Subnet Mask)告诉我们这两部分的分界线，比如255.0.0.0(也就是8个1和24个0)表示前8位用于区分局域网，后24位用于区分主机。由于A、B、C分类是已经规定好的，所以当一个IP地址属于B类范围时，我们就知道它的前16位和后16位分别表示局域网和主机。</p><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p><img src="https://upload-images.jianshu.io/upload_images/9169686-f9e95f677bc7a088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IPv4和IPv6帧头对比"><br><strong>黄色区域 (同名区域)：</strong><br>我们看到，上图中三个黄色区域跨越了IPv4和IPv6。字段Version(4位)表明IP协议版本，是IPv4还是IPv6(IPv4, Version&#x3D;0100; IPv6, Version&#x3D;0110)。Source Adrresss和Destination Address分别为发出地和目的地的IP地址。</p><p><strong>蓝色区域 （名字发生变动的区域）：</strong><br>Time to Live 存活时间(Hop Limit in IPv6)。表示一个IP包的最大存活时间，IPv4的这个区域记录一个整数(比如30)，IP包在传输过程中每经过一个路由器就给Time to Live减一。当一个路由器发现Time to Live为0时，那么IP包就作废，就不再发送该IP包。IPv6中的Hop Limit区域记录的也是最大路由接力数，与IPv4的功能相同。Time to Live&#x2F;Hop Limit避免了IP包在互联网中无限接力。</p><p>Type of Service 服务类型(Traffic Class in IPv6)。Type of Service最初是用来给IP包分优先级，比如语音通话需要实时性，所以它的IP包应该比Web服务的IP包有更高的优先级。后来，Type of Service被实际分为两部分：Differentiated Service Field (DS, 前6位)和Explicit Congestion Notification (ECN, 后2位)，前者依然用来区分服务类型，而后者用于表明IP包途径路由的交通状况。IPv6的Traffic Class也被如此分成两部分。通过IP包提供不同服务。</p><p>Protocol 协议(Next Header in IPv6)。Protocol用来说明IP包Payload部分所遵循的协议，也就是IP包之上的协议是什么。它说明了IP包封装的是一个怎样的高层协议包(TCP? UDP?)。</p><p>Total Length, 以及IPv6中Payload Length的讨论要和IHL区域放在一起，我们即将讨论。</p><p><strong>红色区域 (IPv6中删除的区域)：</strong><br>我们看一下IPv4和IPv6的长度信息。IPv4头部的长度。头部的最后，是options。每个options有32位，是选填性质的区域。一个IPv4头部可以完全没有options区域。不考虑options的话，整个IPv4头部有20 bytes(上面每行为4 bytes)。但由于有options的存在，整个头部的总长度是变动的。我们用IHL(Internet Header Length)来记录头部的总长度，用Total Length记录整个IP包的长度。IPv6没有options，它的头部是固定的长度40 bytes，所以IPv6中并不需要IHL区域。Payload Length用来表示IPv6的数据部分的长度。整个IP包为40 bytes + Payload Length。</p><p>IPv4中还有一个Header Checksum区域。这个checksum用于校验IP包的头部信息。Checksum与之前在小喇叭中提到的CRC算法并不相同。IPv6则没有checksum区域。IPv6包的校验依赖高层的协议来完成，这样的好处是免去了执行checksum校验所需要的时间，减小了网络延迟 (latency)。</p><p>Identification, flags和fragment offset，这三个包都是为分片重组服务的。分片是指一个路由器将接收到的IP包分拆成多个IP包传送，而接收这些“碎片”的路由器或者主机需要将“碎片”重组(reassembly)成一个IP包。不同的局域网所支持的最大传输单元(MTU, Maximum Transportation Unit)不同。如果一个IP包的大小超过了局域网支持的MTU，就需要在进入该局域网时分片传输。分片重组会给路由器和网络带来很大的负担。最好在IP包发出之前探测整个路径上的最小MTU，IP包的大小不超过该最小MTU，就可以避免碎片化。IPv6在设计上避免碎片化。每一个IPv6局域网的MTU都必须大于等于1280 bytes。IPv6的默认发送IP包大小为1280 bytes。</p><p><strong>绿色区域 (IPv6新增区域)：</strong><br>Flow Label是IPv6中新增的区域。它被用来提醒路由器来重复使用之前的接力路径。这样IP包可以自动保持出发时的顺序。这对于流媒体之类的应用有帮助。Flow Label可以建议路由器将一些IP包保持一样的接力路径。但这只是“建议”，路由器可能会忽略该建议。</p><h4 id="Header-Checksum算法"><a href="#Header-Checksum算法" class="headerlink" title="Header Checksum算法"></a>Header Checksum算法</h4><p>Header Checksum区域有16位。它是这样获得的，从header取得除checksum之外的0&#x2F;1序列，如：9194 8073 0000 4000 4011 C0A8 0001 C0A8 00C7 (十六进制hex, 这是一个为演示运算过程而设计的header)</p><p>按照十六位(也就是4位hex)分割整个序列。将分割后的各个4位hex累积相加。如果有超过16位的进位出现，则将进位加到后16位结果的最后一位：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-8934419b778525e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"><br>上面的计算叫做one’s complement sum。求得所有十六位数的和<br>one’s complement sum(4500, 0073, 0000, 4000, 4011, C0A8, 0001, C0A8, 00C7) &#x3D; 1433</p><p>然后，将1433的每一位取反(0-&gt;1, 1-&gt;0)， 就得到checksum：EBCC这样，我们的header就是:9194 8073 0000 4000 4011 EBCC C0A8 0001 C0A8 00C7</p><p>IP包的接收方在收到IP包后，可以求上面各个16位数的one’s complement sum，应该得到FFFF。如果不是FFFF，那么header是不正确的，整个IP包会被丢弃。</p><h3 id="网卡与路由器"><a href="#网卡与路由器" class="headerlink" title="网卡与路由器"></a>网卡与路由器</h3><p>邮差与邮局中说，IP地址是分配给每个房子(计算机)的”邮编”。但这个说法并不精确。IP地址实际上识别的是网卡(NIC, Network Interface Card)。网卡是计算机的一个硬件，它在接收到网路信息之后，将信息交给计算机(处理器&#x2F;内存)。当计算机需要发送信息的时候，也要通过网卡发送。一台计算机可以有不只一个网卡，比如笔记本就有一个以太网卡和一个WiFi网卡。计算机在接收或者发送信息的时候，要先决定想要通过哪个网卡。</p><p>路由器(router)实际上就是一台配备有多个网卡的专用电脑。它让网卡接入到不同的网络中，这样，就构成在邮差与邮局中所说的邮局。比如下图中位于中间位置的路由器有两个网卡，地址分别为199.165.145.17和199.165.146.3。它们分别接入到两个网络：199.165.145和199.165.146。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-61bd964e4cb49f12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由器(router)"></p><h3 id="IP包接力"><a href="#IP包接力" class="headerlink" title="IP包接力"></a>IP包接力</h3><h4 id="接力过程"><a href="#接力过程" class="headerlink" title="接力过程"></a>接力过程</h4><p>比如我们从主机145.22生成发送到146.21的IP包：铺开信纸，写好信的开头(剩下数据部分可以是TCP包，可以是UDP包，也可以是任意乱写的字，我们暂时不关心)，注明目的地IP地址(199.165.146.21)和发出地IP地址(199.165.145.22)。主机145.22随后参照自己的routing table，里面有三行：这里有两行记录。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-9daabda510a0984e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="routing table记录"><br>第一行表示，如果IP目的地是199.165.145.0这个网络的主机，那么只需要自己在eth0上的网卡直接传送(“本地社区”：直接送达)，不需要前往router(Gateway 0.0.0.0 &#x3D; “本地送信”)。</p><p>第二行表示所有不符合第一行的IP目的地，都应送往Gateway 199.165.145.17，也就是中间router接入在eth0的网卡IP地址(邮局在eth0的分支)。</p><p>我们的IP包目的地为199.165.146.21，不符合第一行，所以按照第二行，发送到中间的router。主机145.22会将IP包放入帧的payload，并在帧的头部写上199.165.145.22对应的MAC地址，这样，就可以在局域网中传送了。</p><p>中间的router在收到IP包之后(实际上是收到以太协议的帧，然后从帧中的payload读取IP包)，提取目的地IP地址，然后对照自己的routing table：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-9dc10e0e03b91ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="routing table"><br>从前两行我们看到，由于router横跨eth0和eth1两个网络，它可以直接通过eth0和eth1上的网卡直接传送IP包。</p><p>第三行表示，如果是前面两行之外的IP地址，则需要通过eth1，送往199.165.146.8(右边的router)。</p><p>我们的目的地符合第二行，所以将IP放入一个新的帧中，在帧的头部写上199.165.146.21的MAC地址，直接发往主机146.21。(在Linux下，可以使用$route -n来查看routing table)</p><p>IP包可以进一步接力，到达更远的主机。IP包从主机出发，根据沿途路由器的routing table指导，在router间接力。IP包最终到达某个router，这个router与目标主机位于一个局域网中，可以直接建立连接层的通信。最后，IP包被送到目标主机。这样一个过程叫做routing(我们就叫IP包接力好了，路由这个词实在是混合了太多的意思)。</p><p>整个过程中，IP包不断被主机和路由封装入帧(信封)并拆开，然后借助连接层，在局域网的各个NIC之间传送帧。整个过程中，我们的IP包的内容保持完整，没有发生变化。最终的效果是一个IP包从一个主机传送到另一个主机。利用IP包，我们不需要去操心底层(比如链路层)发生了什么。</p><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>在上面的过程中，我们实际上假设了，每一台主机和路由都能了解局域网内的IP地址和MAC地址的对应关系，这是实现IP包封装(encapsulation)到帧的基本条件。IP地址与MAC地址的对应是通过ARP协议传播到局域网的每个主机和路由。每一台主机或路由中都有一个ARP cache，用以存储局域网内IP地址和MAC地址如何对应。</p><p>ARP协议(ARP介于链路层和网络层之间，ARP包需要包裹在一个帧中，它的工作方式如下：主机会发出一个ARP包，该ARP包中包含有自己的IP地址和MAC地址。通过ARP包，主机以广播的形式询问局域网上所有的主机和路由：我是IP地址xxxx，我的MAC地址是xxxx，有人知道199.165.146.4的MAC地址吗？拥有该IP地址的主机会回复发出请求的主机：哦，我知道，这个IP地址属于我的一个NIC，它的MAC地址是xxxxxx。由于发送ARP请求的主机采取的是广播形式，并附带有自己的IP地址和MAC地址，其他的主机和路由会同时检查自己的ARP cache，如果不符合，则更新自己的ARP cache。</p><p>这样，经过几次ARP请求之后，ARP cache会达到稳定。如果局域网上设备发生变动，ARP重复上面过程。</p><p>(在Linux下，可以使用$arp命令来查看ARP的过程。ARP协议只用于IPv4。IPv6使用Neighbor Discovery Protocol来替代ARP的功能)</p><p><strong>ARP协议总结：ARP让每台电脑和路由器知道自己局域网内IP地址和MAC地址的对应关系，从而顺利实现IP包到帧的封装。</strong></p><h4 id="Routing-Table的生成"><a href="#Routing-Table的生成" class="headerlink" title="Routing Table的生成"></a>Routing Table的生成</h4><p>我们还有另一个假设，就是每个主机和路由上都已经有了合理的routing table。这个routint table描述了网络的拓扑(topology)结构。如果你了解自己的网络连接，可以手写自己主机的routing table。但是，一个路由器可能有多个出口，所以routing table可能会很长。更重要的是，周围连接的其他路由器可能发生变动(比如新增路由器或者路由器坏掉)，我们就需要routing table能及时将交通导向其他的出口。我们需要一种更加智能的探测周围的网络拓扑结构，并自动生成routing table。</p><p><strong>RIP(Routing Information Protocol)协议：</strong><br>用来生成routing table，它通过距离来决定routing table，所以属于distance-vector protocol。</p><p>对于RIP来说，所谓的距离是从出发地到目的地途径的路由器数目(hop number)。途径两个路由器，则距离为2。我们最初可以手动生成routing table。</p><p>随后，根据RIP协议，主机A向周围的路由器和主机广播自己前往各个IP的距离(比如到B&#x3D;1，C&#x3D;0)。收到RIP包的路由器和主机根据RIP包和自己到发送RIP包的主机的距离，算出自己前往各个IP的距离。A与B的距离为1。A收到C的RIP包(到C的距离为0)，那么B途径A前往C的距离为1+0&#x3D;1。如果B自己的RIP记录都比这个远，那么B更改自己的routing table：前往C的交通都发往A。如果B自身的RIP记录并不差，那么B保持routing table不变。</p><p>上述过程在各个点不断重复RIP广播&#x2F;计算距离&#x2F;更新routing table的过程，最终所有的主机和路由器都能生成最合理的路径(merge)。</p><p>RIP出于技术上的原因(looping hops)，认为距离超过15的IP不可到达。所以RIP更多用于互联网的一部分(比如整个中国电信的网络)。这样一个互联网的部分往往属于同一个ISP或者有同一个管理机构，所以叫做自治系统(AS,autonomous system)。</p><p><strong>RIP协议总结：RIP协议可以生成自治系统内部合理的routing table。</strong></p><p><strong>BGP(Border Gateway Protocol)协议:</strong><br>自治系统内部的主机和路由根据通向外部的边界路由器来和其它的自治系统通信。各个边界路由器之间通过BGP(Border Gateway Protocol)来生成自己前往其它AS的routing table，而自治系统内部则参照边界路由器，使用RIP来决定routing table。BGP的基本工作过程与RIP类似，但在考虑距离的同时，也权衡比如政策、连接性能等其他因素，再决定交通的走向(routing table)。</p><p><strong>BGP协议总结:BGP协议可以生成自治系统外部的routing table。</strong></p><h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>可以缓解IPv4的稀缺状态。CIDR(Classless Inter Domain Routing)改进了传统的IPv4地址分类。传统的IP分类将IP地址直接对应为默认的分类，从而将Internet分割为网络。CIDR在路由表中增加了子网掩码(subnet masking)，从而可以更细分网络。利用CIDR，我们可以灵活的将某个范围的IP地址分配给某个网络。</p><h4 id="传统路由表"><a href="#传统路由表" class="headerlink" title="传统路由表"></a>传统路由表</h4><p>IP分类的方便了IP包的接力。IP包到达某个路由器后，会根据该路由器的路由表(routing table)，来决定接力的下一站。一个传统的路由表看起来是这样的：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-759f60fec0070638.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统的路由表"><br>该路由表代表的网络拓扑如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-65f9d832407c107c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络拓扑"><br>由于IP分类，我们不需要记录subnet mask。当我们要前往199.165.146.17时，我们已经知道这台主机位于一个C类地址，所以它的子网掩码是255.255.255.0，也就是说199.165.146代表了网络，17代表了主机。</p><h4 id="CIDR路由表"><a href="#CIDR路由表" class="headerlink" title="CIDR路由表"></a>CIDR路由表</h4><p>然而，由于默认分类，造成了网络只能按照A、B、C的方式存在。假设一个网络(比如MIT的网络)分配了一个A类地址，那么该网络将容许16777216个主机。如果该网络无法用完这些IP地址，这些IP地址将无法被其他网络使用。再比如上面的网络，199.165.145必须作为一个整个的网络存在。如果我们只有10台主机，那么将会有200多个IP地址被浪费。CIDR的本质是在路由表中加入子网掩码，并根据该列信息对网络进行分割，而不是根据默认的A，B，C进行分割。比如：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-fd1f4a2f9db1bf5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CIDR路由表"><br>根据路由表的第一条记录：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-d218651fd0d69b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一条记录"><br>通过子网掩码可以知道，前31位表示网络，最后一位表示主机。子网掩码总是有连续多个1组成，比如上面的31个1。所以也可记为199.165.145.254&#x2F;31，来同时表示IP地址和子网掩码。</p><p>路由器将原来的199.165.145网络中的一部分分割出来。这一网络可以容纳两台电脑，也就是199.165.145.254和199.165.145.255。这个网络对应网卡是eth2。当有IP包通向这两个IP地址时，会前往eth2，而不是eth0。</p><p>网络拓扑如下：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-7b6d17e9a68efa8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络拓扑"><br>利用CIDR，我们可以将IP地址根据需要进行分割，从而不浪费IP地址。</p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>CIDR虽然可以更加节约IP地址，但它并不能创造新的IP地址。IP地址的耗尽危机并不能因此得到解决。我们来看IPv4的第二袭，NAT(Network Address Translation)。</p><p>理论上，每个IP地址代表了Internet上的一个设备。但有一些IP地址被保留，用于一些特殊用途。下面三段IP地址被保留用作私有IP地址：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-4305282719f511a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="私有IP地址"><br>私有IP地址只用于局域网内部。理论上，我们不应该在互联网上看到来自或者发往私有IP地址的IP包。与私有IP地址对应的是全球IP地址(global IP address)。</p><p>NAT是为私有网络(private network)服务的。该网络中的主机使用私有IP地址。当私有网络内部主机和外部Internet通信时，网关(gateway)路由器负责将私有IP地址转换为全球IP地址，这个地址转换过程就是Network Address Translation。网关路由器的NAT功能。最极端情况下，我们可以只分配一个全球IP地址给网关路由器，而私有网络中的设备都使用私有IP地址。由于私有IP地址可以在不同私有网络中重复使用，所以就大大减小了设备对IP地址的需求。</p><h4 id="基础NAT"><a href="#基础NAT" class="headerlink" title="基础NAT"></a>基础NAT</h4><p>NAT的一种为基础NAT，也成为一对一(one-to-one)NAT。在基础NAT下，网关路由器一一转换一个外部IP地址和一个私有IP地址。网关路由器保存有IP的NAT对应关系，比如：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-083178dbe0c12eef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP的NAT对应关系"><br>上面网络中，当有IP包要前往199.165.145.1时，网关路由器会将目的地改写为10.0.0.1，并接力给私有网络中的10.0.0.1的电脑。同样，当10.0.0.1的电脑向Internet发送IP包时，它的发送地为10.0.0.1。在到达网关路由器时，会将发送地更改为199.165.145.1。此外，IP头部的checksum，以及更高层协议(比如UDP和TCP)中的校验IP的checksum也会更改。</p><p>基础NAT尽管是一对一转换IP地址，它还是可以减小内部网络对IP地址的需求。通常来说，一个局域网中只有少数的设备处于开机状态，并不需要给每个设备对应一个全球IP地址。NAT可以动态的管理全球IP地址，并将全球IP地址对应到开机设备，从而减小内部网络对IP地址的需求。</p><h4 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h4><p>NAT还有一种，被成为NAPT (Network Address and Port Translation)。在基础NAT中，高层协议的端口号并不会改动。NAPT下，IP地址和端口号可能同时改动。</p><p>我们在UDP和TCP中提到端口(port)的概念。在建立UDP或者TCP通信时，我们实际上是用IP:Port来代表通信的一端(正如打电话时主机:分机号一样)。NAPT就是在网关路由器处建立两个通信通道，一个通往内部网络，一个通往外部网络，然后将网关处的通道端口连接，从而让内部和外部通信。比如：<br><img src="https://upload-images.jianshu.io/upload_images/9169686-d9256a4c066d7ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个通信通道"><br>我们看到，通往IP 199.165.145.1建立了三个端口的连接：8888, 8889和8080。它们分别在NAPT处改为通往10.0.0.1:80, 10.0.0.1:8080和10.0.0.3:6000。NAPT记录有外部IP:端口和内部IP:端口的一一对应关系。在IP包经过时，网关路由器会更改IP地址，端口号以及相关的checksum。</p><p>利用NAPT我们可以使用一个(或者多个但少量的)外部IP和大量的端口号，来对应多个内部IP以及相应的端口号，从而大大减小了对全球IP地址的需求。</p><p>无论是基础NAT还是NAPT，它们的设置都比较复杂，并且从本质上违背了互联网最初的设计理念。但由于IPv4的使用惯性，NAT还是被广泛推广。由于NAT所处的网关服务器是理想的设置防火墙的位置，NAT还往往和防火墙共同建设，以提高私有网络的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链路层（link layer）协议概述</title>
      <link href="/2018/04/10/%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%88link-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/10/%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%88link-layer%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>链路层（link layer）协议主要有以太网协议和WIFI协议等。</p><h2 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h2><span id="more"></span><h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>帧本身是一段有限的0&#x2F;1序列。它可以分为头部、数据(Payload)和尾部三部分。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-593575c1c79b260d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="以太网帧格式"></p><h4 id="帧头部"><a href="#帧头部" class="headerlink" title="帧头部"></a>帧头部</h4><p>帧的最初7个byte被称为序言(preamble)。它每个byte都是0xAA(这里是十六进制，也就是二进制的10101010)。通常，我们都会预定好以一定的频率发送0&#x2F;1序列(比如每秒10bit)。如果接收设备以其他频率接收(比如每秒5bit)，那么就会错漏掉应该接收的0&#x2F;1信息。但是，由于网卡的不同，发送方和接收方即使预订的频率相同，两者也可能由于物理原因发生偏差。这就好像两个人约好的10点见，结果一个人表快，一个人表慢一样。序言是为了让接收设备调整接收频率，以便与发送设备的频率一致，这个过程就叫做时钟复原(recover the clock)。</p><p>时钟调整好之后，我们等待帧的起始信号(SFD, start frame delimiter)。SFD是固定的值0xAB。这个0xAB就好像“小喇叭开始广播啦”一样，提醒我们好节目就要上演了。</p><p>SFD之后是6 byte的目的地址(DST, destination)和6 byte的源地址(SRC,source)。这就是我们在邮差和邮局中的介绍一样，为信封写上目的地和发出地。要注意，这里写在信封上的是对地址的“本地描述”，也就是MAC地址。MAC地址是物理设备自带的序号，只能在同一个以太网中被识别 (正如邮差只熟悉自己的社区一样)。</p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用6个十六进制数表示。前3个十六进制数是厂商编号，后3个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p>头部的最后一个区域是Type，用以说明数据部分的类型。(比如0x0800为IPv4，0x0806为ARP)</p><h4 id="帧数据部分"><a href="#帧数据部分" class="headerlink" title="帧数据部分"></a>帧数据部分</h4><p>数据一般包含有符合更高层协议的数据，比如IP包。连接层协议本身并不在乎数据是什么，它只负责传输。注意，数据尾部可能填充有一串0(PAD区域)。原因是数据需要超过一定的最小长度，不同的协议要求的数据最小长度是不一样的，例如：以太网(IEEE 802.3)要求帧的数据部分长度是46-1500个byte。如果数据部分不够46byte，则在数据尾部填充0以达到指定的最小长度。</p><h4 id="帧尾部"><a href="#帧尾部" class="headerlink" title="帧尾部"></a>帧尾部</h4><p>跟随在数据之后的是校验序列(FCS, Frame Check Sequence)。校验序列是为了检验数据的传输是否发生错误。</p><p>FCS采用了CRC(Cyclic Redundancy Check)算法。</p><p>n位CRC算法取一个n bit的因子，比如下面的1011。数据序列结尾增加n-1个0。因子与数据序列的不断进行XOR运算，直到得到n-1位的余数，也就是100。该余数各位取反(011)，然后存储在FCS的位置。<br><img src="https://upload-images.jianshu.io/upload_images/9169686-6ef42125ffac8271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4位CRC算法"><br>上面例子用的是4位CRC。在Ethernet中使用的因子为32位的，以达到更好的检测效果。</p><h3 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h3><p>以太网使用集线器或者交换器将帧从发出地传送到目的地。一台集线器或交换器上有多个端口，每个端口都可以连接一台计算机(或其他设备)。</p><p>集线器像一个广播电台。一台电脑将帧发送到集线器，集线器会将帧转发到所有其他的端口。每台计算机检查自己的MAC地址是不是符合DST。如果不是，则保持沉默。集线器是比较早期的以太网设备。它有明显的缺陷：</p><ol><li><p>任意两台电脑的通信在同一个以太网上是公开的。所有连接在同一个集线器上的设备都能收听到别人在传输什么，这样很不安全。可以通过对信息加密提高安全性。</p></li><li><p>不允许多路同时通信。如果两台电脑同时向集线器发信，集线器会向所有设备发出“冲突”信息，提醒发生冲突。可以在设备上增加冲突检测算法(collision detection)：一旦设备发现有冲突，则随机等待一段时间再重新发送。</p></li></ol><h3 id="交换器（Switch）"><a href="#交换器（Switch）" class="headerlink" title="交换器（Switch）"></a>交换器（Switch）</h3><p>交换器克服集线器的缺陷。交换器记录有各个设备的MAC地址。当帧发送到交换器时，交换器会检查DST，然后将帧只发送到对应端口。交换器允许多路同时通信。由于交换器的优越性，交换器基本上取代了集线器。但比较老的以太网还有可能在使用集线器。</p><h3 id="WIFI协议"><a href="#WIFI协议" class="headerlink" title="WIFI协议"></a>WIFI协议</h3><p>WiFi的工作方式与集线器连接下的以太网类似。一个WiFi设备会向所有的WiFi设备发送帧，其它的WiFi设备检查自己是否符合DST。由于WiFi采取无线电信号，所以很难像交换器一样定向发送，所以WiFi的安全性很值得关注。WiFi采用加密的方法来实现信息的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议概述</title>
      <link href="/2018/04/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>网络协议这块也是以前学习记录的一些笔记，现在逐渐的要搬到自己的博客上来。因为之前一些笔记都是用思维导图的软件记录的，现在发现这些笔记查看和分享不如网页方便。在此之前的笔记简单，但是不够深入，后续也会继续学习并作一个补充。闲话不多说，下面是有关网络协议整理的笔记内容。内容非原创，是经过学习他人的文章整理而来的，已经记不清出处在哪里了，后续会找一找，并附上原创文章链接。</p><p>网络协议这块主要是按网络5层协议栈来分层描述。</p><h3 id="物理层（physical-layer）"><a href="#物理层（physical-layer）" class="headerlink" title="物理层（physical layer）"></a>物理层（physical layer）</h3><p>所谓的物理层，是指光纤、电缆或者电磁波等真实存在的物理媒介。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为0&#x2F;1序列。</p><h3 id="链路层（link-layer）"><a href="#链路层（link-layer）" class="headerlink" title="链路层（link layer）"></a>链路层（link layer）</h3><p>在链路层，信息以帧(frame)为单位传输。所谓的帧，是一段有限的0&#x2F;1序列。链路层协议的功能就是识别0&#x2F;1序列中所包含的帧。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。帧中最重要的最重要是所要传输的数据 (payload)。这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(Type)信息。链路层协议不关心数据中到底包含什么。</p><p>以太网(Ethernet)和WiFi是现在最常见的链路层协议。通过链路层协议，我们可以建立局域的以太网或者WiFi局域网，并让位于同一局域网络中的两台计算机通信。链路层就像是一个社区的邮差，他认识社区中的每一户人。社区中的每个人都可以将一封信(帧)交给他，让他送给同一社区的另一户人家。<br><strong>相关协议：以太网协议、WIFI协议</strong></p><p><strong>介于网络层和链路层之间相关协议：ARP协议</strong></p><h3 id="网络层（network-layer）"><a href="#网络层（network-layer）" class="headerlink" title="网络层（network layer）"></a>网络层（network layer）</h3><p>不同的社区之间通信。如何让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人”。这个“中间人”必须有以下功能: 1. 能从物理层上在两个网络的接收和发送0&#x2F;1序列，2. 能同时理解两种网络的帧格式。</p><p>路由器(router)就是为此而产生的“翻译”。一个路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。所以路由器就像是在两个社区都有分支的邮局。一个社区的邮差将信送到本社区的邮局分支，而邮局会通过自己在另一个地区的分支将信转交给另一个社区的邮差手中，并由另一个社区的邮差最终送到目的地。</p><p>在链路层，我们的一个帧中只能记录SRC和DST两个地址。而上面的过程需要经过四个地址 (计算机1，WiFi接口，以太网接口，计算机2)。显然，仅仅靠链路层协议无法满足我们的需要。由于链路层协议开发在先，我们无法改动链路层协议，只能在链路层的数据(payload)，也就是信纸内部下功夫了。IP协议应运而生。</p><p>计算机1，路由器和计算机2都要懂得IP协议。当计算机1写信的时候，会在信纸的开头写上这封信的出发地址和最终到达地址 (而不是在信封上)，而在信封上写上要送往邮局。WiFi网的邮差将信送往邮局。在邮局，信被打开，邮局工作人员看到最终地址，于是将信包装在一个新的信封中，写上出发地为邮局，到达地为计算机2，并交给以太网的邮差，由以太网的邮差送往计算机2。(IP协议还要求写如诸如校验等信息，交通状况等信息，以保护通信的稳定性。)</p><p>在链路层，邮差只负责在本社区送信，所以信封上的地址总是“第一条街第三座房子”或者说“中心十字路口拐角的小房子”这样一些本地人才了解的地址描述，这给邮局的工作带来不便。所以邮局要求，信纸上写的地址必须是一个符合官方规定的“邮编”，也就是IP地址。这个地址为世界上的每一个房子编号(邮编)。当信件送到邮局的时候，邮局根据邮编，就能查到对应的地址描述，从而能顺利改写信封上的信息。</p><p>每个邮局一般连接多个社区，而一个社区也可以有多个邮局，分别通往不同的社区。有时候一封信要通过多个邮局转交，才能最终到达目的地，这个过程叫做route。邮局将分离的局域网络连接成了internet，并最终构成了覆盖全球的互联网。<br><strong>相关协议：IP协议、CIDR协议、NAT</strong></p><h3 id="传输层（transport-layer）"><a href="#传输层（transport-layer）" class="headerlink" title="传输层（transport layer）"></a>传输层（transport layer）</h3><p>上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求。这就好像一所房子里住了好几个人(进程)，如何让信精确的送到某个人手里呢？遵照之前相同的逻辑，我们需要在信纸上写上新的信息，比如收信人的姓名，才可能让信送到。所以，传输层就是在信纸的空白上写上新的“收信人”信息。每一所房子会配备一个管理员(传输层协议)。管理员从邮差手中接过信，会根据“收信人”，将信送给房子中的某个人。</p><p>传输层协议，比如TCP和UDP，使用端口号(port number)来识别收信人(某个进程)。在写信的时候，我们写上目的地的端口。当信到达目的地的管理员手中，他会根据传输层协议，识别端口号，将信送给不同的人。</p><p>TCP和UDP协议是两种不同的传输层协议。UDP协议类似于我们的信件交流过程。TCP协议则好像两个情人间的频繁通信。一个小情人要表达的感情太多，以致于连续写了好几封信。而另一方必须将这些信按顺序排列起来，才能看明白全部的意思。TCP协议还有控制网络交通等功能。<br><strong>相关协议：TCP协议、UDP协议、SCTP协议</strong></p><p><strong>介于传输层与应用层之间相关协议:SSL&#x2F;TLS协议</strong></p><h3 id="应用层（application-layer）"><a href="#应用层（application-layer）" class="headerlink" title="应用层（application layer）"></a>应用层（application layer）</h3><p>通过上面的几层协议，我们已经可以在任意两个人(进程)之间进行通信。然而每个人实际上从事的是不同的行业。有的人是律师，有的人外交官。比如说律师之间的通信，会用严格的律师术语，以免产生纠纷。再比如外交官之间的通信，必须符合一定的外交格式，以免发生外交误会。再比如间谍通过暗号来传递加密信息。应用层协议是对信件内容进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。<br><strong>相关协议：HTTP协议、DNS协议</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记——网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
