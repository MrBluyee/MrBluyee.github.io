<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>无线模块休眠与激活机制 | Mr Bluyee's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '3dbaf3043b34b1c894c4cd063629b6a9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">无线模块休眠与激活机制</h1><a id="logo" href="/.">Mr Bluyee's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">无线模块休眠与激活机制</h1><div class="post-meta">2019-02-18<span> | </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%8E%E5%8A%9F%E8%80%97%E6%8A%80%E6%9C%AF/">学习笔记——低功耗技术</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 15</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BC%91%E7%9C%A0%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">无线模块的休眠模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BC%91%E7%9C%A0"><span class="toc-number">1.1.</span> <span class="toc-text">同步休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BC%91%E7%9C%A0"><span class="toc-number">1.2.</span> <span class="toc-text">异步休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E4%BC%91%E7%9C%A0"><span class="toc-number">1.3.</span> <span class="toc-text">混合休眠</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E7%9A%84%E5%94%A4%E9%86%92%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">无线模块的唤醒方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%92"><span class="toc-number">2.1.</span> <span class="toc-text">定时唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E5%94%A4%E9%86%92"><span class="toc-number">2.2.</span> <span class="toc-text">信号强度唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E6%95%B0%E6%8D%AE%E5%8C%85%E5%94%A4%E9%86%92"><span class="toc-number">2.3.</span> <span class="toc-text">最短数据包唤醒</span></a></li></ol></li></ol></div></div><div class="post-content"><p>如何降低无线模块的总体功耗？</p>
<span id="more"></span>

<p>显然，只降低发射机的发射功率，或者只降低接收机的电流消耗是不现实的。这种方法的效果不但不明显，而且会带来通信质量下降的恶劣后果。</p>
<p>只有采用空闲时无线模块休眠的方式，才能大大的降低通信设备的平均功耗。对于由两个以上无线收发设备组成的任何结构、任何协议的半双工无线通信系统，其中的某一个设备真正工作于发射或接收状态的时间是很少的。当通信设备不工作于发射和接收状态时，使其进入休眠状态，可大大降低平均功耗。因为休眠状态的模块电流只有微安级。而无线通信设备发射时的电流是数十毫安以上，接收电流也在十几到数十毫安之间。因此，引入休眠机制的通信系统，休眠时间越长，则平均能耗越低。</p>
<h3 id="无线模块的休眠模式"><a href="#无线模块的休眠模式" class="headerlink" title="无线模块的休眠模式"></a>无线模块的休眠模式</h3><p>无线模块休眠一般有同步休眠模式、异步休眠模式和混合休眠模式。</p>
<p>同步休眠模式不需要休眠唤醒过程，最大限度的节省了电量的消耗。<br>混合休眠模式可以提高网络的健壮性，有些节点在受到干扰情况下不能进行同步休眠时，会自动进入异步休眠模式，最大限度的减小无谓的功耗消耗。</p>
<h4 id="同步休眠"><a href="#同步休眠" class="headerlink" title="同步休眠"></a>同步休眠</h4><p>同步模式下节点的休眠时间片和工作时间片由休眠广播报文实现同步，相邻节点之间的时间片误差小于1ms。同步休眠广播报文由网关在每个工作时间片的结束时刻向全网逐级广播，该报文指定本次同步休眠时间片的长度。</p>
<p>工作时间片的长度没有限制，可以根据数据传输需要自动动态调整，网络在没有数据传输时可以立即休眠而不需要等待某个预定的工作时间片结束，在有数据传输时会自动等待数据传输结束再进行休眠。</p>
<p>同步休眠模式下相邻节点间的时间片的误差很小，可以在工作时间片起始时刻立即进行数据传输，不需要进行无线唤醒或其他同步操作。</p>
<p>同步休眠示意图如下所示：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E5%90%8C%E6%AD%A5%E4%BC%91%E7%9C%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="同步休眠示意图"></p>
<p>工作时间片（work time slice）和休眠时间片（sleep time slice）根据需要由网关自动动态调整，在上图中，工作时间片和休眠时间片的时间长度是不同的。</p>
<p>在某工作时间片内网关模块有数据传出时，会在数据传输结束后等到信道静默超时后自动向网络发送同步休眠广播报文；在某工作时间片内网关模块没有数据传输时，会在工作时间片的开始时刻立即向网络发送同步休眠广播报文。</p>
<p>对于传感网络来说，数据传输就是对传感节点的数据采集，整个工作时间片的工作过程大致描述如下：</p>
<ul>
<li>网关模块在工作时间片的开始时刻向网络中的传感器节点发送读数据的指令，根据目的地址可以采用广播、多播和单播的方式。</li>
<li>传感节点模块在收到读数据指令后，如果地址匹配则唤醒传感器&#x2F;外设，同时还会向远处的传感器节点中继转发收到的读数据命令，转发次数可以设置。</li>
<li>为了保证传感器&#x2F;外设数据的有效性，传感节点模块在唤醒传感器&#x2F;外设后会等待一段时间才向传感器&#x2F;外设发送读数据的指令，然后等待传感器&#x2F;外设的响应。</li>
<li>在收到传感器&#x2F;外设的响应数据报文或等待超时后，传感节点模块通知传感器&#x2F;外设进行休眠。</li>
<li>如果收到传感器&#x2F;外设的响应数据报文，传感节点模块会将该数据报文向网关发送。</li>
<li>传感节点模块在上行数据报文缓冲区空闲时可以向网关方向中继转发远处传感节点的数据。</li>
<li>对于网关来说，在向网络发送读数据指令后，就可以陆续接收到网络中传感节点的响应数据报文，可以对网络中所有、部分、和指定传感节点进行数据采集。</li>
<li>网关模块在一定时间内不再收到传感节点的数据，认为数据采集过程已经完成，会向网络广播同步休眠报文，该报文指定当前休眠时间片的长度。</li>
<li>传感节点模块接收到广播同步休眠报文后，会向网络中继广播发送同步休眠报文，为了提高该报文的接收成功率，会多次重复发送。</li>
<li>传感节点模块完成同步休眠报文的发送次数后会进入休眠状态，直到休眠时间片结束为止。一次完整的同步数据采集过程结束。</li>
</ul>
<h4 id="异步休眠"><a href="#异步休眠" class="headerlink" title="异步休眠"></a>异步休眠</h4><p>异步休眠模式下无线节点模块会在网络空闲后主动按照预设的“睡醒比”进行间歇式休眠，睡醒比是“监听时间片”和“异步休眠时间片“长度的比值。睡醒比越大，模块的待机功耗就越小，但同样意味着异步唤醒休眠需要的时间更长、模块的响应速度越慢、每个报文的平均发送时间越长。因此”睡醒比“参数的设置需要综合考虑实际网络的工作情况，使得实际使用平均功耗最低。</p>
<p>“监听时间片”和RF的速率有关，一般只有毫秒级。如果无线节点在”监听时间片”内监听到网络中有数据需要收发就会自动进入正常工作模式。“睡醒比”可以灵活设置，该参数决定了无线节点待机电流的大小。假设无线节点模块的休眠电流为0.5uA，接收电流为22mA，异步休眠模式周期电流如下图所示：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E5%BC%82%E6%AD%A5%E4%BC%91%E7%9C%A0%E5%8A%9F%E8%80%97%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="异步休眠功耗示意图"></p>
<p>在没有外界干扰的情况下，异步唤醒的成功率为100%。</p>
<h4 id="混合休眠"><a href="#混合休眠" class="headerlink" title="混合休眠"></a>混合休眠</h4><p>采用同步休眠模式的低功耗无线网络，在同步休眠报文受到干扰或网关节点掉电时，节点模块由于得不到正确的休眠命令，并不会主动进入休眠状态，会造成节点功耗的上升，从而缩短电池的使用寿命。</p>
<p>为了克服上述情况，增强网络的抗干扰能力，可以采用以同步休眠为主、异步休眠为辅的混合休眠模式。混合休眠模式下，没有收到同步休眠命令的节点可以自动进入异步休眠模式，以保持较低的功耗。混合休眠模式可以看作在异步休眠模式的基础上叠加了同步休眠模式。</p>
<p>相对于同步休眠模式，混合休眠模式在工作时间片的一开始并不能立即进行数据传输，需要先进行全网或路由节点唤醒。在唤醒过程结束后，基本可以保证所有相邻的节点都可以被可靠唤醒。在唤醒阶段被遗漏的节点也会被后续的数据传输节点继续唤醒。</p>
<p>混合模式相对于同步休眠模式在工作时间片内增加了全网唤醒的处理过程，导致每个工作时间片的时间变长，也就增加了无线节点模块的功耗。</p>
<p>混合休眠示意图如下：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E6%B7%B7%E5%90%88%E4%BC%91%E7%9C%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="混合休眠示意图"></p>
<h3 id="无线模块的唤醒方式"><a href="#无线模块的唤醒方式" class="headerlink" title="无线模块的唤醒方式"></a>无线模块的唤醒方式</h3><p>当某个无线模块处于休眠状态时，其不接收也不发射数据，处于非工作状态，当其他模块需要与其进行通信时，通信是不会成功的。因此，就需要一套流程，把处于休眠状态的无线通信设备唤醒。</p>
<h4 id="定时唤醒"><a href="#定时唤醒" class="headerlink" title="定时唤醒"></a>定时唤醒</h4><p>定时唤醒通信中，参与通信的所有无线通信设备，按照一定的定时周期，或每次通信时约定下次通信的定时时间，定时时间一到参与通信的多个设备同时从休眠状态进入工作状态，完成通信后再进入休眠状态。其工作时序图如下图所示：</p>
<p><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%92.jpg" alt="定时唤醒"></p>
<p>上图中的T可以是常数，也可以是变量。当T是变量时，每次通信，所有参与通信的设备必须约定下次通信的时间间隔T。t是工作时间，在这个工作时间内的某一时刻，只能有一个设备处于发射状态，其他设备处于接收状态。很显然，T&#x2F;t的比值越大，平均功耗就越小。</p>
<p>定时唤醒通信的缺点有：</p>
<ul>
<li>参与通信的所有无线通信设备必须在时间上同步，则对时钟的要求较高。</li>
<li>初始同步需要较长的时间和复杂的流程。</li>
<li>不同无线通信设备的时钟，由于存在误差，会产生漂移，需要一套校准机制进行校准。</li>
<li>休眠时间越长，时钟漂移越大，一旦漂移过大或其他原因导致设备脱离同步，重新同步需要花费很大的代价。</li>
<li>通信实时性和灵活性不强，如果某设备有突发的通信需要，而其他设备仍在休眠，则不能在短时间内完成通信，只能等待定时时间到。</li>
</ul>
<h4 id="信号强度唤醒"><a href="#信号强度唤醒" class="headerlink" title="信号强度唤醒"></a>信号强度唤醒</h4><p>信号强度唤醒是利用接收机在某一时刻收到的信号强度RSSI，通过设定的门限，判断系统在某一时间段内是否产生通信需求，如果是，则设备从休眠状态进入工作状态。</p>
<p>使用信号强度唤醒法的系统中，设备有主从之分，发起通信的设备是主设备（只能有一个），其他设备是从设备（一个或多个）。在大部分应用中，主从设备是固定的。但在一些比较复杂的系统中，主从设备可以是动态的，某个设备在某一时刻，可能是主设备，也可能是从设备。</p>
<p>主设备工作流程如下：</p>
<p>主设备在有通信需求时，首先发送持续时间为Ts的唤醒信号，该信号可以是载波，也可以是调制信号。Ts&gt;&#x3D;T+t。主设备发送完唤醒信号后，其他从设备都被唤醒，马上进入正常通信状态，和从设备进行数据交换，持续时间为Tc。数据交换完毕，从设备进入休眠状态。对于通信失败的从设备，主设备需要启动差错处理机制进行处理。</p>
<p>从设备工作流程如下：</p>
<p>按照固定的周期T+t，交替工作于休眠&#x2F;接收状态。在时间T内，从设备是休眠的。在时间t内，从设备处于接收状态，但不接收数据，只测量RSSI的值。t是信号强度唤醒的监听窗口，不同的设备由于没有同步，其窗口的相位是不同的。</p>
<p>如果RSSI测量值低于预置的门限，则表示没有任何通信请求，从设备进入休眠状态。如果RSSI测量值高于或等于预置的门限值，则表示有主设备发出通信请求，从设备暂时不进入休眠状态，继续处于接收状态，等待时间为Tw。不同从设备的Tw值是不一样的。在Tw期间，从设备处于接收状态，但不能正常通信，这期间的能量是浪费掉的。</p>
<p>Tw等待期过后，从设备收到主设备的命令或数据并完成既定的收发流程TA后，又进入休眠状态。如果因为干扰等原因没有收到主设备发来的命令或数据，则表示本次通信失败，从设备在等待时间Tout后又进入休眠。</p>
<p>信号强度唤醒方法时序图：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E4%BF%A1%E5%8F%B7%E5%BC%BA%E5%BA%A6%E5%94%A4%E9%86%92.jpg" alt="信号强度唤醒"></p>
<p>信号强度唤醒法的优点是t可以取比较小的值，但其缺点很多，主要有：</p>
<ul>
<li>抗干扰能力差，尤其是同频和邻频干扰对其影响是致命的，持续的干扰会对从设备产生连续的误唤醒，从而导致能量的消耗。</li>
<li>不能区分信号发送者的身份，所以会轻易的被其他系统无意或恶意唤醒，导致能量消耗，系统的可靠性下降。</li>
<li>缩短通信距离，当RSSI信号比较弱时，从设备的接收机测试RSSI信号时，干扰和噪声能量会占比较大的比重，导致RSSI测量值的可信度下降，所以必须设置较高的门限才能减少误唤醒，提高可靠性。设置高门限则会导致通信距离缩短，如接收机的灵敏度为-120dBm，但门限必须设置为-112dBm，则通信距离相应缩短。突发干扰和噪声产生的误唤醒随环境不同而不同，随时间不同也不同，从而找到一个合理的门限值比较困难，计算和评估误唤醒消耗的能量也非常困难。</li>
</ul>
<h4 id="最短数据包唤醒"><a href="#最短数据包唤醒" class="headerlink" title="最短数据包唤醒"></a>最短数据包唤醒</h4><p>系统中某无线收发设备有通信要求时，先重复发送若干个最短数据包，接收机在定时探测时，只有正确收到其中一包数据，才认为此时有通信请求，暂时不进入休眠状态，等待进入下一步的通信流程，这种方法就是最短数据包唤醒法。</p>
<p>该方法中的通信设备也有主从之分，反复发送最短数据包的是主设备，被最短数据包唤醒的是从设备。</p>
<p>通常，无线数据通信中，数据包一般由位同步、帧同步、数据和结束符四部分组成。</p>
<p>在NRZ编码系统中，位同步码取值为10101010…，其作用主要是让接收机的位同步提取电路能可靠锁定，然后对后续的码元产生同步。</p>
<p>帧同步的作用是，让接收机通过扫描比较帧同步，找到数据部分的起始位置。接收机有一个若干位的移位寄存器，每收到1比特的数据就移位一次，并将新收到的数据放到最低位，然后与一个固定的帧同步常数比较，相等则表示已经同步上，否则继续接收下一个比特并比较。</p>
<p>数据是通信传输的有效部分，由多字节数据组成，数据中还包含数据长度、CRC校验等信息，如果采取FEC纠错算法，数据中还包含FEC的冗余部分。</p>
<p>结束符代表一包数据的结束。</p>
<p>最短数据包唤醒方法时序图：<br><img src="/images/%E4%BD%8E%E5%8A%9F%E8%80%97/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/%E6%9C%80%E7%9F%AD%E6%95%B0%E6%8D%AE%E5%8C%85%E5%94%A4%E9%86%92.jpg" alt="最短数据包唤醒"></p>
<p>最短数据包就是在保证可靠通信的情况下总长度最短的数据包。其中位同步的长度是由硬件决定的，不同的硬件电路或不同的集成电路要求发送的位同步个数也不同，一般在4<del>16字节之间，这里假设8字节。帧同步一般为16、24、32比特，越长则误同步的概率越低，一般取32比特。数据部分可以是0字节，也可以是1</del>3字节。如果没有数据（0字节），则无法分组唤醒或携带一些唤醒参数或命令，一般情况下，数据部分最好有1字节。结束符在最短数据包中可以不存在，也可以取1字节或2字节。</p>
<p>采用最短数据包唤醒法的系统，工作流程和信号强度唤醒法基本一致，从设备也工作于休眠&#x2F;接收的交替状态，但其接收的持续时间必须两倍于最短数据包的发送时间，即大于等于2t。2t是最短数据包唤醒法的窗口。休眠时间T越长平均功耗越小。  </p>
<p>最短数据包唤醒法已经克服了信号强度唤醒法的大部分缺点。如果最短数据包中再携带一定的信息，则也可以在Tw期间让从设备处于休眠状态，从而更进一步降低功耗。</p>
<p>最短数据包唤醒法的缺点是，窗口时长必须在2t以上才能保证设备被可靠唤醒。</p>
<p>针对上述参与通信的所有无线通信设备必须在时间上同步、抗干扰能力差、接收窗口时间长从而使功耗大的缺陷，CC1101提供了检测同步字的方案。CC1101的一帧数据包由前导码、同步字、地址、数据和校验构成。当CC1101从休眠状态切换到监听状态时，在监听时间片内，若收到匹配的同步字，则进行正常的接收状态，接收完一帧数据；若在监听时间片内没有收到匹配的同步字，则重新回到休眠模式。对于这种方式，不仅可以设置不同的同步字对多个模块进行区分，避免误唤醒，此外唤醒监听的窗口也可以设置的很短，从而进一步降低平均功耗。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>无线模块休眠与激活机制</p><p><span>文章作者：</span>Mr Bluyee</p><p><span>发布时间：</span>2019-02-18</p><p><span>最后更新：</span>2019-07-15</p><p><span>原始链接：</span><a href="/2019/02/18/无线模块休眠与激活机制/">https://www.mrbluyee.com/2019/02/18/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://www.mrbluyee.com/2019/02/18/%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E4%BC%91%E7%9C%A0%E4%B8%8E%E6%BF%80%E6%B4%BB%E6%9C%BA%E5%88%B6/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/02/19/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E7%BD%91WSN%E6%A6%82%E8%BF%B0/">无线传感网WSN概述</a><a class="next" href="/2019/02/16/SOC%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/">SOC的低功耗设计</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zOTYxNS8xNjE0Mg"><script>(function(d, s) {
  var j, e = d.getElementsByTagName(s)[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Enjoy life / Hope for future</p><a class="info-icon" href="mr.bluyee@hotmail.com" title="mr.bluyee@hotmail.com" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/MrBluyee" title="https://github.com/MrBluyee" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94AI/">学习笔记——AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C-%E7%AE%97%E6%B3%95/">学习笔记——C 算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">学习笔记——C数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Python/">学习笔记——Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94android/">学习笔记——android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94data-compression/">学习笔记——data compression</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94expert-c-programming/">学习笔记——expert c programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94linux/">学习笔记——linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94opencv/">学习笔记——opencv</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/">学习笔记——代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%8E%E5%8A%9F%E8%80%97%E6%8A%80%E6%9C%AF/">学习笔记——低功耗技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">学习笔记——嵌入式开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">学习笔记——机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%89%A9%E8%81%94%E7%BD%91/">学习笔记——物联网</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">学习笔记——网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">学习笔记——计算机系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">计算机系统</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 15px;">网络协议</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" style="font-size: 15px;">嵌入式开发</a> <a href="/tags/AI/" style="font-size: 15px;">AI</a> <a href="/tags/data-compression/" style="font-size: 15px;">data compression</a> <a href="/tags/opencv/" style="font-size: 15px;">opencv</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/04/02/anything-LLM-with-ollama-a-private-document-chatbot/">anything LLM with ollama - a private document chatbot</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/02/open-webui-with-ollama-ChatGPT-like-interface/">open-webui with ollama - ChatGPT like interface</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/02/ollama-run-large-language-models-locally/">ollama - run large language models locally</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/28/huffman-coding-in-deflate/">huffman coding in deflate</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/25/zlib-and-gzip-format/">zlib and gzip format</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/23/deflate%20format/">deflate format</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/23/IPsec/">IPsec</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/%E6%95%B0%E7%9A%84%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/">数的素性测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/20/%E6%89%A9%E5%B1%95%E7%9A%84%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/">扩展的欧几里得算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0/">欧几里得算法-求最大公因数</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Mr Bluyee's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>