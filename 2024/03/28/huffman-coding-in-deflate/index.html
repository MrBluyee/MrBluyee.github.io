<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>huffman coding in deflate | Mr Bluyee's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + '3dbaf3043b34b1c894c4cd063629b6a9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">huffman coding in deflate</h1><a id="logo" href="/.">Mr Bluyee's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">huffman coding in deflate</h1><div class="post-meta">2024-03-28<span> | </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94data-compression/">学习笔记——data compression</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 22</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Canonical-Huffman-code"><span class="toc-number">1.</span> <span class="toc-text">Canonical Huffman code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Translate-a-normal-huffman-coding-to-the-canonical-huffman-code"><span class="toc-number">1.1.</span> <span class="toc-text">Translate a normal huffman coding to the canonical huffman code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store-canonical-huffman-code-efficiently"><span class="toc-number">1.2.</span> <span class="toc-text">store canonical huffman code efficiently</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-the-canonical-huffman-code-from-the-stored-info"><span class="toc-number">1.3.</span> <span class="toc-text">get the canonical huffman code from the stored info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decompression-with-the-canonical-huffman-code"><span class="toc-number">1.4.</span> <span class="toc-text">decompression with the canonical huffman code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generate-the-dynamic-huffman-code"><span class="toc-number">1.5.</span> <span class="toc-text">generate the dynamic huffman code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reference"><span class="toc-number">1.6.</span> <span class="toc-text">reference</span></a></li></ol></li></ol></div></div><div class="post-content"><p>In deflate dynamic huffman blocks, the huffman tree is stored with the canonical type.</p>
<h2 id="Canonical-Huffman-code"><a href="#Canonical-Huffman-code" class="headerlink" title="Canonical Huffman code"></a>Canonical Huffman code</h2><p>a canonical Huffman code is a particular type of Huffman code with unique properties which allow it to be described in a very compact manner. Rather than storing the structure of the code tree explicitly, canonical Huffman codes are ordered in such a way that it suffices to only store the lengths of the codewords, which reduces the overhead of the codebook.</p>
<h3 id="Translate-a-normal-huffman-coding-to-the-canonical-huffman-code"><a href="#Translate-a-normal-huffman-coding-to-the-canonical-huffman-code" class="headerlink" title="Translate a normal huffman coding to the canonical huffman code"></a>Translate a normal huffman coding to the canonical huffman code</h3><p>Suppose we have the following non-canonical codebook:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = 11</span><br><span class="line">B = 0</span><br><span class="line">C = 101</span><br><span class="line">D = 100</span><br></pre></td></tr></table></figure>
<p>Here the letter A has been assigned 2 bits, B has 1 bit, and C and D both have 3 bits. To make the code a canonical Huffman code, the codes are renumbered. The bit lengths stay the same with the code book being sorted first by codeword length and secondly by alphabetical value of the letter:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B = 0</span><br><span class="line">A = 11</span><br><span class="line">C = 101</span><br><span class="line">D = 100</span><br></pre></td></tr></table></figure>
<p>Each of the existing codes are replaced with a new one of the same length, using the following algorithm:</p>
<ul>
<li>The first symbol in the list gets assigned a codeword which is the same length as the symbol’s original codeword but all zeros. This will often be a single zero (‘0’).</li>
<li>Each subsequent symbol is assigned the next binary number in sequence, ensuring that following codes are always higher in value.</li>
<li>When you reach a longer codeword, then after incrementing, append zeros until the length of the new codeword is equal to the length of the old codeword. This can be thought of as a left shift.</li>
</ul>
<p>By following these three rules, the canonical version of the code book produced will be:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B = 0</span><br><span class="line">A = 10</span><br><span class="line">C = 110</span><br><span class="line">D = 111</span><br></pre></td></tr></table></figure>

<h3 id="store-canonical-huffman-code-efficiently"><a href="#store-canonical-huffman-code-efficiently" class="headerlink" title="store canonical huffman code efficiently"></a>store canonical huffman code efficiently</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = 10    (code value: 2 decimal, bits: 2)</span><br><span class="line">B = 0     (code value: 0 decimal, bits: 1)</span><br><span class="line">C = 110   (code value: 6 decimal, bits: 3)</span><br><span class="line">D = 111   (code value: 7 decimal, bits: 3)</span><br></pre></td></tr></table></figure>

<p>Assume the alphabets are start from A,B,C,D, …<br>This alphabets should be the predefined, and be known from both compression and decompression side. Thus, only the below info need to be stored:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Used symbol length： 4</span><br><span class="line">Number of bits for each symbol: 2, 1, 3, 3</span><br></pre></td></tr></table></figure>

<h3 id="get-the-canonical-huffman-code-from-the-stored-info"><a href="#get-the-canonical-huffman-code-from-the-stored-info" class="headerlink" title="get the canonical huffman code from the stored info"></a>get the canonical huffman code from the stored info</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Used symbol length： 4</span><br><span class="line">Number of bits for each symbol: 2, 1, 3, 3</span><br><span class="line"></span><br><span class="line">Get the used symbol info and the correspond bit length:</span><br><span class="line">(&#x27;A&#x27;,2), (&#x27;B&#x27;,1), (&#x27;C&#x27;,3), (&#x27;D&#x27;,3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Sort it with bit length:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bit length: [1, 2, 3, 3]</span><br><span class="line">used symbol: [B, A, C, D]</span><br></pre></td></tr></table></figure>
<p>Pseudocode to get the canonical huffman code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">code := 0</span><br><span class="line">while more symbols do</span><br><span class="line">    print symbol = code</span><br><span class="line">    code := (code + 1) &lt;&lt; ((bit length of the next symbol) − (current bit length))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">B = 0</span><br><span class="line">A = 10</span><br><span class="line">C = 110</span><br><span class="line">D = 111</span><br></pre></td></tr></table></figure>

<h3 id="decompression-with-the-canonical-huffman-code"><a href="#decompression-with-the-canonical-huffman-code" class="headerlink" title="decompression with the canonical huffman code"></a>decompression with the canonical huffman code</h3><p>For the decompression, we do not need to create the codes or the tree in order to decode canonical codes. All we need is the list of symbols in order and the count of symbols in each code length.</p>
<p>Since the canonical codes within a code length are sequential binary integers, you can simply do integer comparisons to see if the bits you have fall within that code range, and if it is, an integer subtraction to determine which symbol it is.</p>
<p>example code from <a target="_blank" rel="noopener" href="https://github.com/madler/zlib/blob/master/contrib/puff/puff.c">https://github.com/madler/zlib/blob/master/contrib/puff/puff.c</a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#define MAXBITS 15              /* maximum bits in a code */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of</span><br><span class="line"> * each length, which for a canonical code are stepped through in order.</span><br><span class="line"> * symbol[] are the symbol values in canonical order, where the number of</span><br><span class="line"> * entries is the sum of the counts in count[].  The decoding process can be</span><br><span class="line"> * seen in the function decode() below.</span><br><span class="line"> */</span><br><span class="line">struct huffman &#123;</span><br><span class="line">    short *count;       /* number of symbols of each length */</span><br><span class="line">    short *symbol;      /* canonically ordered symbols */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Decode a code from the stream s using huffman table h.  Return the symbol or</span><br><span class="line"> * a negative value if there is an error.  If all of the lengths are zero, i.e.</span><br><span class="line"> * an empty code, or if the code is incomplete and an invalid code is received,</span><br><span class="line"> * then -10 is returned after reading MAXBITS bits.</span><br><span class="line"> *</span><br><span class="line"> * Format notes:</span><br><span class="line"> *</span><br><span class="line"> * - The codes as stored in the compressed data are bit-reversed relative to</span><br><span class="line"> *   a simple integer ordering of codes of the same lengths.  Hence below the</span><br><span class="line"> *   bits are pulled from the compressed data one at a time and used to</span><br><span class="line"> *   build the code value reversed from what is in the stream in order to</span><br><span class="line"> *   permit simple integer comparisons for decoding.  A table-based decoding</span><br><span class="line"> *   scheme (as used in zlib) does not need to do this reversal.</span><br><span class="line"> *</span><br><span class="line"> * - The first code for the shortest length is all zeros.  Subsequent codes of</span><br><span class="line"> *   the same length are simply integer increments of the previous code.  When</span><br><span class="line"> *   moving up a length, a zero bit is appended to the code.  For a complete</span><br><span class="line"> *   code, the last code of the longest length will be all ones.</span><br><span class="line"> *</span><br><span class="line"> * - Incomplete codes are handled by this decoder, since they are permitted</span><br><span class="line"> *   in the deflate format.  See the format notes for fixed() and dynamic().</span><br><span class="line"> */</span><br><span class="line">local int decode(struct state *s, const struct huffman *h)</span><br><span class="line">&#123;</span><br><span class="line">    int len;            /* current number of bits in code */</span><br><span class="line">    int code;           /* len bits being decoded */</span><br><span class="line">    int first;          /* first code of length len */</span><br><span class="line">    int count;          /* number of codes of length len */</span><br><span class="line">    int index;          /* index of first code of length len in symbol table */</span><br><span class="line"></span><br><span class="line">    code = first = index = 0;</span><br><span class="line">    for (len = 1; len &lt;= MAXBITS; len++) &#123;</span><br><span class="line">        code |= bits(s, 1);             /* get next bit */</span><br><span class="line">        count = h-&gt;count[len];</span><br><span class="line">        if (code - count &lt; first)       /* if length len, return symbol */</span><br><span class="line">            return h-&gt;symbol[index + (code - first)];</span><br><span class="line">        index += count;                 /* else update for next length */</span><br><span class="line">        first += count;</span><br><span class="line">        first &lt;&lt;= 1;</span><br><span class="line">        code &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -10;                         /* ran out of codes */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follow with the previous example, we will have:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">B = 0</span><br><span class="line">A = 10</span><br><span class="line">C = 110</span><br><span class="line">D = 111</span><br><span class="line"></span><br><span class="line">bit length: [1, 2, 3, 3]</span><br><span class="line">used symbol: [B, A, C, D]</span><br><span class="line"></span><br><span class="line">MAXBITS = 3</span><br><span class="line">h-&gt;count[MAXBITS + 1] = [0, 1, 1, 2]  (number of symbols of each length)</span><br><span class="line">h-&gt;symbol = [B, A, C, D]</span><br><span class="line"></span><br><span class="line">Assume the bit stream is:</span><br><span class="line"></span><br><span class="line">A    B   C     D</span><br><span class="line">b&#x27;10 b&#x27;0 b&#x27;110 b&#x27;111</span><br><span class="line"></span><br><span class="line">code = first = index = 0</span><br><span class="line">loop 1:</span><br><span class="line">code = 0 | bits(s, 1) //code = 1</span><br><span class="line">count = h-&gt;count[1] //count = 1</span><br><span class="line">code - count = 0 // code - count == first</span><br><span class="line">index += count //index = 1</span><br><span class="line">first += count //first = 1</span><br><span class="line">first &lt;&lt;= 1 //first = b&#x27;10</span><br><span class="line">code &lt;&lt;= 1 //code = b&#x27;10</span><br><span class="line"></span><br><span class="line">loop 2:</span><br><span class="line">code = b&#x27;10 | bits(s, 1) //code = b&#x27;10</span><br><span class="line">count = h-&gt;count[2] //count = 1</span><br><span class="line">code - count = 1 //code - count &lt; first</span><br><span class="line">index + (code - first) //1 + 2 - 2 = 1</span><br><span class="line">return h-&gt;symbol[1] //return A</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="generate-the-dynamic-huffman-code"><a href="#generate-the-dynamic-huffman-code" class="headerlink" title="generate the dynamic huffman code"></a>generate the dynamic huffman code</h3><p>analysis code from:<br><a target="_blank" rel="noopener" href="https://github.com/madler/zlib/blob/master/trees.c#L1093">https://github.com/madler/zlib/blob/master/trees.c#L1093</a><br><a target="_blank" rel="noopener" href="https://github.com/madler/zlib/blob/develop/deflate.h#L333">https://github.com/madler/zlib/blob/develop/deflate.h#L333</a> </p>
<p>There are 2 huffman table for the deflate dynamic huffman blocks,<br>one is the literal&#x2F;length table, another is the distance table.</p>
<p>And we know that the LZ77 processed data will have the below format:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">literal symbol (0-255),</span><br><span class="line">.. , </span><br><span class="line">length (3-258), distance (1-32768),</span><br><span class="line">.. ,</span><br><span class="line">end of block symbol (256).</span><br></pre></td></tr></table></figure>
<p>So, there has 2 kind of tally functions to calculate the symbol frequency when parsing each symbol within the block.</p>
<p>Related data structures and define:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#define LENGTH_CODES 29</span><br><span class="line">/* number of length codes, not counting the special END_BLOCK code */</span><br><span class="line"></span><br><span class="line">#define LITERALS  256</span><br><span class="line">/* number of literal bytes 0..255 */</span><br><span class="line"></span><br><span class="line">#define L_CODES (LITERALS+1+LENGTH_CODES)</span><br><span class="line">/* number of Literal or Length codes, including the END_BLOCK code */</span><br><span class="line"></span><br><span class="line">#define D_CODES   30</span><br><span class="line">/* number of distance codes */</span><br><span class="line"></span><br><span class="line">#define BL_CODES  19</span><br><span class="line">/* number of codes used to transfer the bit lengths */</span><br><span class="line"></span><br><span class="line">#define HEAP_SIZE (2*L_CODES+1)</span><br><span class="line">/* maximum heap size */</span><br><span class="line"></span><br><span class="line">/* Data structure describing a single value and its code string. */</span><br><span class="line">typedef struct ct_data_s &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        ush  freq;       /* frequency count */</span><br><span class="line">        ush  code;       /* bit string */</span><br><span class="line">    &#125; fc;</span><br><span class="line">    union &#123;</span><br><span class="line">        ush  dad;        /* father node in Huffman tree */</span><br><span class="line">        ush  len;        /* length of bit string */</span><br><span class="line">    &#125; dl;</span><br><span class="line">&#125; FAR ct_data;</span><br><span class="line"></span><br><span class="line">#define Freq fc.freq</span><br><span class="line">#define Code fc.code</span><br><span class="line">#define Dad  dl.dad</span><br><span class="line">#define Len  dl.len</span><br><span class="line"></span><br><span class="line">struct static_tree_desc_s &#123;</span><br><span class="line">    const ct_data *static_tree;  /* static tree or NULL */</span><br><span class="line">    const intf *extra_bits;      /* extra bits for each code or NULL */</span><br><span class="line">    int     extra_base;          /* base index for extra_bits */</span><br><span class="line">    int     elems;               /* max number of elements in the tree */</span><br><span class="line">    int     max_length;          /* max bit length for the codes */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct tree_desc_s &#123;</span><br><span class="line">    ct_data *dyn_tree;           /* the dynamic tree */</span><br><span class="line">    int     max_code;            /* largest code with non zero frequency */</span><br><span class="line">    const static_tree_desc *stat_desc;  /* the corresponding static tree */</span><br><span class="line">&#125; FAR tree_desc;</span><br><span class="line"></span><br><span class="line">typedef struct internal_state &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */</span><br><span class="line">    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */</span><br><span class="line">    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */</span><br><span class="line">    /* dyn_ltree is used for store the generated literal and length tree,</span><br><span class="line">    * The elements in dyn_ltree[:L_CODES] are leaves, middle nodes get stored</span><br><span class="line">    * after it. same as the dyn_dtree and bl_tree.</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    struct tree_desc_s l_desc;               /* desc. for literal tree */</span><br><span class="line">    struct tree_desc_s d_desc;               /* desc. for distance tree */</span><br><span class="line">    struct tree_desc_s bl_desc;              /* desc. for bit length tree */</span><br><span class="line"></span><br><span class="line">    ush bl_count[MAX_BITS+1];</span><br><span class="line">    /* number of codes at each bit length for an optimal tree */</span><br><span class="line"></span><br><span class="line">    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */</span><br><span class="line">    int heap_len;               /* number of elements in the heap */</span><br><span class="line">    int heap_max;               /* element of largest frequency */</span><br><span class="line">    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.</span><br><span class="line">     * The same heap array is used to build all trees.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    uch depth[2*L_CODES+1];</span><br><span class="line">    /* Depth of each subtree used as tie breaker for trees of equal frequency</span><br><span class="line">     */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2 tally functions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//if it is a literal symbol (0-255, 256):</span><br><span class="line"></span><br><span class="line">_tr_tally_lit(s, c, flush)</span><br><span class="line">     s-&gt;dyn_ltree[cc].Freq++;</span><br><span class="line"></span><br><span class="line">//if it is a length &amp; distance pair:</span><br><span class="line"></span><br><span class="line">_tr_tally_dist(s, distance, length, flush)</span><br><span class="line">    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++;</span><br><span class="line">    s-&gt;dyn_dtree[d_code(dist)].Freq++; </span><br></pre></td></tr></table></figure>

<p>Assume, we have A,B,C,D four symbols, and the frequency shown as below:</p>
<table>
<thead>
<tr>
<th>symbol index</th>
<th>symbol</th>
<th>frequency</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>2</td>
</tr>
</tbody></table>
<p>The huffman table is created by the build_tree() function：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* ===========================================================================</span><br><span class="line"> * Construct one Huffman tree and assigns the code bit strings and lengths.</span><br><span class="line"> * Update the total bit length for the current block.</span><br><span class="line"> * IN assertion: the field freq is set for all tree elements.</span><br><span class="line"> * OUT assertions: the fields len and code are set to the optimal bit length</span><br><span class="line"> *     and corresponding code. The length opt_len is updated; static_len is</span><br><span class="line"> *     also updated if stree is not null. The field max_code is set.</span><br><span class="line"> */</span><br><span class="line">local void build_tree(deflate_state *s, tree_desc *desc)</span><br><span class="line"></span><br><span class="line">    ct_data *tree         = desc-&gt;dyn_tree;</span><br><span class="line">    const ct_data *stree  = desc-&gt;stat_desc-&gt;static_tree;</span><br><span class="line">    int elems             = desc-&gt;stat_desc-&gt;elems;</span><br><span class="line">    int n, m;          /* iterate over heap elements */</span><br><span class="line">    int max_code = -1; /* largest code with non zero frequency */</span><br><span class="line">    int node;          /* new node being created */</span><br><span class="line"></span><br><span class="line">    /* Construct the initial heap, with least frequent element in heap[SMALLEST].</span><br><span class="line">     * The sons of heap[n] are heap[2*n] and heap[2*n + 1].</span><br><span class="line">     * heap[0] is not used.</span><br><span class="line">     * HEAP_SIZE = (2*L_CODES+1)</span><br><span class="line">     */</span><br><span class="line">    s-&gt;heap_len = 0, s-&gt;heap_max = HEAP_SIZE;</span><br><span class="line"></span><br><span class="line">    /* Initial the heap, put all the elems which Freq is not 0 to the heap.</span><br><span class="line">    * The elems with 0 Freq will be set the 0 to the Len.</span><br><span class="line">    * The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree.</span><br><span class="line">    * for l_tree, elems = L_CODES = (256 + 1 + 29) = 286</span><br><span class="line">    * for d_tree, elems = D_CODES = 30</span><br><span class="line">    * for bl_tree, elems = BL_CODES = 19</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    for (n = 0; n &lt; elems; n++) &#123;</span><br><span class="line">        if (tree[n].Freq != 0) &#123;</span><br><span class="line">            s-&gt;heap[++(s-&gt;heap_len)] = max_code = n;</span><br><span class="line">            s-&gt;depth[n] = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tree[n].Len = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>For the A, B, C, D four symbols, the heap size should be 2 * 4 + 1 &#x3D; 9, elems &#x3D; 4.<br>So, at the initial heap stage, we will get:</p>
<table>
<thead>
<tr>
<th>heap index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol depth</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>not used</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>A</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>C</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>D</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<p>heap_len &#x3D; 4<br>max_code &#x3D; 3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,</span><br><span class="line"> * establish sub-heaps of increasing lengths:</span><br><span class="line"> */</span><br><span class="line">for (n = s-&gt;heap_len/2; n &gt;= 1; n--) pqdownheap(s, tree, n);</span><br><span class="line"></span><br><span class="line">/* pqdownheap(deflate_state *s, ct_data *tree, int k) is used to </span><br><span class="line"> * restore the heap property by moving down the tree starting at node k,</span><br><span class="line"> * exchanging a node with the smallest of its two sons if necessary, stopping</span><br><span class="line"> * when the heap property is re-established (each father smaller than its</span><br><span class="line"> * two sons).</span><br></pre></td></tr></table></figure>


<p>We can build a tree with the initial heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C(1)<br>&nbsp;&nbsp;&#x2F;<br>D(2)</p>
<p>So, the elements heap[3 (4 &#x2F; 2 + 1)] &#x3D; C, heap[4] &#x3D; D are leaves of the tree.<br>And the for loop will do pqdownheap() for the heap[2] &#x3D; B, heap[1] &#x3D; A:</p>
<p><em>loop 1:</em><br>pqdownheap(s, tree, B):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;D(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C(1)<br>&nbsp;&nbsp;&#x2F;<br>B(5)</p>
<p><em>loop 2:</em><br>pqdownheap(s, tree, A):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;D(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&#x2F;<br>B(5)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* Construct the Huffman tree by repeatedly combining the least two</span><br><span class="line"> * frequent nodes.</span><br><span class="line"> */</span><br><span class="line">node = elems;              /* next internal node of the tree */</span><br><span class="line">do &#123;</span><br><span class="line">    pqremove(s, tree, n);  /* n = node of least frequency */</span><br><span class="line">    /*</span><br><span class="line">     * Remove the smallest element from the heap and recreate the heap with</span><br><span class="line">     * one less element. Updates heap and heap_len.         </span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    m = s-&gt;heap[SMALLEST]; /* m = node of next least frequency (SMALLEST = 1) */</span><br><span class="line"></span><br><span class="line">    s-&gt;heap[--(s-&gt;heap_max)] = n; /* keep the nodes sorted by frequency */</span><br><span class="line">    s-&gt;heap[--(s-&gt;heap_max)] = m;</span><br><span class="line"></span><br><span class="line">    /* Create a new node father of n and m */</span><br><span class="line">    tree[node].Freq = tree[n].Freq + tree[m].Freq;</span><br><span class="line">    s-&gt;depth[node] = (uch)((s-&gt;depth[n] &gt;= s-&gt;depth[m] ?</span><br><span class="line">                            s-&gt;depth[n] : s-&gt;depth[m]) + 1);</span><br><span class="line">    tree[n].Dad = tree[m].Dad = (ush)node;</span><br><span class="line"></span><br><span class="line">    /* and insert the new node in the heap */</span><br><span class="line">    s-&gt;heap[SMALLEST] = node++;</span><br><span class="line">    pqdownheap(s, tree, SMALLEST);</span><br><span class="line"></span><br><span class="line">&#125; while (s-&gt;heap_len &gt;= 2);</span><br></pre></td></tr></table></figure>
<p>heap_len &#x3D; 4<br>SMALLEST &#x3D; 1<br>node &#x3D; elems &#x3D; 4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define pqremove(s, tree, top) \</span><br><span class="line">&#123;\</span><br><span class="line">    top = s-&gt;heap[SMALLEST]; \</span><br><span class="line">    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \</span><br><span class="line">    pqdownheap(s, tree, SMALLEST); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>loop 1:</em><br>pqremove() step 1:<br>n &#x3D; C</p>
<p>pqremove() step 2:<br>s-&gt;heap_len &#x3D; 3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B(5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;D(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p>
<p>pqremove() step 3:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D(2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p>
<p>m &#x3D; D<br>heap[8] &#x3D; C<br>heap[7] &#x3D; D</p>
<p>Create a new node father of n and m:<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[4] &#x3D; C.freq + D.freq &#x3D; 1 + 2 &#x3D; 3</p>
<p>insert the new node in the heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p>
<p>pqdownheap(s, tree, SMALLEST):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)</p>
<table>
<thead>
<tr>
<th>heap index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol dad</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>not used</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>(3)</td>
<td>3</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>5</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>A</td>
<td>4</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>7</td>
<td>D</td>
<td>2</td>
<td>(3)</td>
</tr>
<tr>
<td>8</td>
<td>C</td>
<td>1</td>
<td>(3)</td>
</tr>
</tbody></table>
<p><em>loop 2:</em><br>pqremove() step 1:<br>n &#x3D; (3)</p>
<p>pqremove() step 2:<br>s-&gt;heap_len &#x3D; 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)</p>
<p>pqremove() step 3:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A(4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)</p>
<p>m &#x3D; A<br>heap[6] &#x3D; (3)<br>heap[5] &#x3D; A</p>
<p>Create a new node father of n and m:<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[5] &#x3D; (3).freq + A.freq &#x3D; 3 + 4 &#x3D; 7</p>
<p>insert the new node in the heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;B(5)</p>
<p>pqdownheap(s, tree, SMALLEST):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B(5)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2F;<br>&nbsp;&nbsp;&nbsp;&nbsp;(7)</p>
<table>
<thead>
<tr>
<th>heap index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol dad</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>not used</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>5</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>(7)</td>
<td>7</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>A</td>
<td>4</td>
<td>(7)</td>
</tr>
<tr>
<td>6</td>
<td>(3)</td>
<td>3</td>
<td>(7)</td>
</tr>
<tr>
<td>7</td>
<td>D</td>
<td>2</td>
<td>(3)</td>
</tr>
<tr>
<td>8</td>
<td>C</td>
<td>1</td>
<td>(3)</td>
</tr>
</tbody></table>
<p><em>loop 3:</em><br>pqremove() step 1:<br>n &#x3D; B</p>
<p>pqremove() step 2:<br>s-&gt;heap_len &#x3D; 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)</p>
<p>pqremove() step 3:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7)</p>
<p>m &#x3D; (7)<br>heap[4] &#x3D; B<br>heap[3] &#x3D; (7)</p>
<p>Create a new node father of n and m:<br>&nbsp;&nbsp;&nbsp;&nbsp;tree[6] &#x3D; (7).freq + B.freq &#x3D; 7 + 5 &#x3D; 12</p>
<p>insert the new node in the heap:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(12)</p>
<p>pqdownheap(s, tree, SMALLEST):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(12)</p>
<table>
<thead>
<tr>
<th>heap index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol dad</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>not used</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>(12)</td>
<td>12</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>(7)</td>
<td>7</td>
<td>(12)</td>
</tr>
<tr>
<td>4</td>
<td>B</td>
<td>5</td>
<td>(12)</td>
</tr>
<tr>
<td>5</td>
<td>A</td>
<td>4</td>
<td>(7)</td>
</tr>
<tr>
<td>6</td>
<td>(3)</td>
<td>3</td>
<td>(7)</td>
</tr>
<tr>
<td>7</td>
<td>D</td>
<td>2</td>
<td>(3)</td>
</tr>
<tr>
<td>8</td>
<td>C</td>
<td>1</td>
<td>(3)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;heap[--(s-&gt;heap_max)] = s-&gt;heap[SMALLEST];</span><br></pre></td></tr></table></figure>
<p>heap_max &#x3D; 2</p>
<p>for now, we have the elements in heap:</p>
<table>
<thead>
<tr>
<th>heap index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol dad</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>not used</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>(12)</td>
<td>12</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>(7)</td>
<td>7</td>
<td>(12)</td>
</tr>
<tr>
<td>4</td>
<td>B</td>
<td>5</td>
<td>(12)</td>
</tr>
<tr>
<td>5</td>
<td>A</td>
<td>4</td>
<td>(7)</td>
</tr>
<tr>
<td>6</td>
<td>(3)</td>
<td>3</td>
<td>(7)</td>
</tr>
<tr>
<td>7</td>
<td>D</td>
<td>2</td>
<td>(3)</td>
</tr>
<tr>
<td>8</td>
<td>C</td>
<td>1</td>
<td>(3)</td>
</tr>
</tbody></table>
<p>for now, we have the elements in tree:</p>
<table>
<thead>
<tr>
<th>tree index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol dad</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>4</td>
<td>(7)</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>5</td>
<td>(12)</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>1</td>
<td>(3)</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>2</td>
<td>(3)</td>
</tr>
<tr>
<td>4</td>
<td>(3)</td>
<td>3</td>
<td>(7)</td>
</tr>
<tr>
<td>5</td>
<td>(7)</td>
<td>7</td>
<td>(12)</td>
</tr>
<tr>
<td>6</td>
<td>(12)</td>
<td>12</td>
<td>-</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* At this point, the fields freq and dad are set. We can now</span><br><span class="line"> * generate the bit lengths.</span><br><span class="line"> */</span><br><span class="line">gen_bitlen(s, (tree_desc *)desc);</span><br></pre></td></tr></table></figure>
<p>The symbol bit length is generated by the gen_bitlen() function：<br>(below function not considered the overflow case, if overflow happened, adjust and recalculate)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* In a first pass, compute the optimal bit lengths (which may</span><br><span class="line"> * overflow in the case of the bit length tree).</span><br><span class="line"> */</span><br><span class="line">tree[s-&gt;heap[s-&gt;heap_max]].Len = 0; /* root of the heap */</span><br><span class="line"></span><br><span class="line">for (h = s-&gt;heap_max + 1; h &lt; HEAP_SIZE; h++) &#123;</span><br><span class="line">    n = s-&gt;heap[h];</span><br><span class="line">    bits = tree[tree[n].Dad].Len + 1;</span><br><span class="line">    if (bits &gt; max_length) bits = max_length, overflow++;</span><br><span class="line">    tree[n].Len = (ush)bits;</span><br><span class="line">    /* We overwrite tree[n].Dad which is no longer needed */</span><br><span class="line"></span><br><span class="line">    if (n &gt; max_code) continue; /* not a leaf node */</span><br><span class="line"></span><br><span class="line">    s-&gt;bl_count[bits]++;</span><br><span class="line">    xbits = 0;</span><br><span class="line">    if (n &gt;= base) xbits = extra[n - base];</span><br><span class="line">    f = tree[n].Freq;</span><br><span class="line">    s-&gt;opt_len += (ulg)f * (unsigned)(bits + xbits);</span><br><span class="line">    if (stree) s-&gt;static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>tree index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol dad</th>
<th>symbol len</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>4</td>
<td>(7)</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>5</td>
<td>(12)</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>1</td>
<td>(3)</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>2</td>
<td>(3)</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>(3)</td>
<td>3</td>
<td>(7)</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>(7)</td>
<td>7</td>
<td>(12)</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>(12)</td>
<td>12</td>
<td>-</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>bl_count: (only calculate the leaves)</p>
<table>
<thead>
<tr>
<th>bit length</th>
<th>symbol count</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* The field len is now set, we can generate the bit codes */</span><br><span class="line">gen_codes ((ct_data *)tree, max_code, s-&gt;bl_count):</span><br><span class="line">    unsigned code = 0;  </span><br><span class="line">    for (bits = 1; bits &lt;= MAX_BITS; bits++) &#123;</span><br><span class="line">        code = (code + bl_count[bits - 1]) &lt;&lt; 1;</span><br><span class="line">        next_code[bits] = (ush)code;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>bit length</th>
<th>symbol count</th>
<th>code</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>b’0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>b’10</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>b’110</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (n = 0;  n &lt;= max_code; n++) &#123;</span><br><span class="line">    int len = tree[n].Len;</span><br><span class="line">    if (len == 0) continue;</span><br><span class="line">    /* Now reverse the bits */</span><br><span class="line">    tree[n].Code = (ush)bi_reverse(next_code[len]++, len);</span><br><span class="line"></span><br><span class="line">    Tracecv(tree != static_ltree, (stderr,&quot;\nn %3d %c l %2d c %4x (%x) &quot;,</span><br><span class="line">        n, (isgraph(n) ? n : &#x27; &#x27;), len, tree[n].Code, next_code[len] - 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally we get:</p>
<table>
<thead>
<tr>
<th>tree index</th>
<th>symbol</th>
<th>symbol frequency</th>
<th>symbol len</th>
<th>symbol code</th>
<th>reversed code</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>4</td>
<td>2</td>
<td>b’10</td>
<td>b’01</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>5</td>
<td>1</td>
<td>b’0</td>
<td>b’0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>1</td>
<td>3</td>
<td>b’110</td>
<td>b’011</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>2</td>
<td>3</td>
<td>b’111</td>
<td>b’111</td>
</tr>
</tbody></table>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Canonical_Huffman_code">https://en.wikipedia.org/wiki/Canonical_Huffman_code</a><br><a target="_blank" rel="noopener" href="https://github.com/madler/zlib/blob/master/contrib/puff/puff.c">https://github.com/madler/zlib/blob/master/contrib/puff/puff.c</a><br><a target="_blank" rel="noopener" href="https://github.com/madler/zlib/blob/develop/trees.c">https://github.com/madler/zlib/blob/develop/trees.c</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/29575309/decoding-huffman-file-from-canonical-form">https://stackoverflow.com/questions/29575309/decoding-huffman-file-from-canonical-form</a></p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>huffman coding in deflate</p><p><span>文章作者：</span>Mr Bluyee</p><p><span>发布时间：</span>2024-03-28</p><p><span>最后更新：</span>2024-03-29</p><p><span>原始链接：</span><a href="/2024/03/28/huffman-coding-in-deflate/">https://www.mrbluyee.com/2024/03/28/huffman-coding-in-deflate/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://www.mrbluyee.com/2024/03/28/huffman-coding-in-deflate/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-compression/" rel="tag">data compression</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/04/02/ollama-run-large-language-models-locally/">ollama - run large language models locally</a><a class="next" href="/2024/03/25/zlib-and-gzip-format/">zlib and gzip format</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zOTYxNS8xNjE0Mg"><script>(function(d, s) {
  var j, e = d.getElementsByTagName(s)[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Enjoy life / Hope for future</p><a class="info-icon" href="mr.bluyee@hotmail.com" title="mr.bluyee@hotmail.com" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/MrBluyee" title="https://github.com/MrBluyee" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94AI/">学习笔记——AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C-%E7%AE%97%E6%B3%95/">学习笔记——C 算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">学习笔记——C数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Python/">学习笔记——Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94android/">学习笔记——android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94data-compression/">学习笔记——data compression</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94expert-c-programming/">学习笔记——expert c programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94linux/">学习笔记——linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94opencv/">学习笔记——opencv</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/">学习笔记——代码管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%8E%E5%8A%9F%E8%80%97%E6%8A%80%E6%9C%AF/">学习笔记——低功耗技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">学习笔记——嵌入式开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">学习笔记——机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%89%A9%E8%81%94%E7%BD%91/">学习笔记——物联网</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">学习笔记——网络协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">学习笔记——计算机系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">计算机系统</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 15px;">网络协议</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" style="font-size: 15px;">嵌入式开发</a> <a href="/tags/AI/" style="font-size: 15px;">AI</a> <a href="/tags/data-compression/" style="font-size: 15px;">data compression</a> <a href="/tags/opencv/" style="font-size: 15px;">opencv</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">机器学习</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/04/07/Retrieval-Augmented-Generation-RAG/">Retrieval Augmented Generation (RAG)</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/04/basic-concepts-about-the-LLM/">basic concepts about the LLM</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/02/anything-LLM-with-ollama-a-private-document-chatbot/">anything LLM with ollama - a private document chatbot</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/02/open-webui-with-ollama-ChatGPT-like-interface/">open-webui with ollama - ChatGPT like interface</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/02/ollama-run-large-language-models-locally/">ollama - run large language models locally</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/28/huffman-coding-in-deflate/">huffman coding in deflate</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/25/zlib-and-gzip-format/">zlib and gzip format</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/23/deflate%20format/">deflate format</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/23/IPsec/">IPsec</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/21/%E6%95%B0%E7%9A%84%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95/">数的素性测试</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Mr Bluyee's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>